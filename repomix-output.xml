This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
convex/
  _generated/
    api.d.ts
    api.js
    dataModel.d.ts
    server.d.ts
    server.js
  agents/
    analytics.ts
    financial.ts
    legal.ts
    manager.ts
    notifications.ts
    secretary.ts
  security/
    applyRateLimit.ts
    auditLogging.ts
    monitoring.ts
    rateLimitedExamples.ts
    rateLimitedWrapper.ts
    rateLimiting.ts
    rowLevelSecurity.ts
    secureContractOperations.ts
    secureWrapper.ts
  agent_schema.ts
  agent_types.ts
  analytics.ts
  auth.config.ts
  contracts.ts
  enterprises.ts
  events.ts
  monitoring.ts
  notification_schema.ts
  notifications.ts
  onboarding.ts
  presence.ts
  realtime.ts
  realtimeHelpers.ts
  schema.ts
  search.ts
  server.ts
  tsconfig.json
  types.ts
  users.ts
  vendors.ts
public/
  file.svg
  globe.svg
  next.svg
  vercel.svg
  window.svg
src/
  app/
    _components/
      agents/
        AgentCard.tsx
        AgentLogViewer.tsx
        AgentSystemStatus.tsx
        InsightCard.tsx
      analytics/
        AdvancedKPICard.tsx
        AnalyticsDashboard.tsx
        ContractAnalyticsSection.tsx
        DateRangePicker.tsx
        DepartmentPerformanceSection.tsx
        DrillDownModal.tsx
        InteractiveChart.tsx
        KPISection.tsx
        RiskAndComplianceSection.tsx
      auth/
        PermissionGate.tsx
        SessionWrapper.tsx
        UnauthorizedPage.tsx
      common/
        BulkActions.tsx
        Container.tsx
        CustomToolTip.tsx
        DocumentViewer.tsx
        DynamicCharts.tsx
        EmptyStates.tsx
        ErrorBoundary.tsx
        ExportOptions.tsx
        GlobalErrorHandler.tsx
        LoadingSpinner.tsx
        LoadingStates.tsx
        Logo.tsx
        MetricCard.tsx
        MonitoringProvider.tsx
        NotificationCenter.tsx
        SectionErrorBoundary.tsx
        ToastNotifications.tsx
      contracts/
        ContractDetails.tsx
        ContractForm.tsx
        ContractFormModal.tsx
        ContractTable.tsx
        NewContractButton.tsx
      dashboard/
        DashboardContent.tsx
        GlobalSearch.tsx
        Header.tsx
        SideNavigation.tsx
      homepage/
        Benefits.tsx
        Features.tsx
        Footer.tsx
        Hero.tsx
        Navigation.tsx
      mobile/
        MobileCard.tsx
        MobileNavigation.tsx
      onboarding/
        AccountTypeStep.tsx
        CompleteOnboardingStep.tsx
        CreateEnterpriseStep.tsx
        EnterpriseConfigStep.tsx
        FirstContractStep.tsx
        InviteTeamStep.tsx
        OnboardingFlowManager.tsx
        ProfileSetupStep.tsx
      search/
        AdvancedFilters.tsx
        GlobalSearch.tsx
        SearchResults.tsx
      vendor/
        CategoryComponent.tsx
        VendorDetails.tsx
        VendorDetailsModal.tsx
        VendorForm.tsx
        VendorTable.tsx
      workflow/
        ApprovalQueue.tsx
        WorkflowDesigner.tsx
        WorkflowStatus.tsx
    auth/
      [...clerk]/
        page.tsx
      sign-in/
        page.tsx
      sign-up/
        page.tsx
    dashboard/
      agents/
        page.tsx
      analytics/
        page.tsx
      contracts/
        [id]/
          page.tsx
        active/
          page.tsx
        archived/
          page.tsx
        drafts/
          page.tsx
        edit/
          [id]/
            page.tsx
        expired/
          page.tsx
        new/
          page.tsx
        pending/
          page.tsx
        layout.tsx
        page.tsx
      profile/
        page.tsx
      settings/
        enterprise/
          page.tsx
        users/
          page.tsx
        layout.tsx
        page.tsx
      vendors/
        [id]/
          page.tsx
        active/
          page.tsx
        inactive/
          page.tsx
        page.tsx
      layout.tsx
      page.tsx
    hooks/
      useAuthRedirect.ts
    invite/
      [token]/
        page.tsx
    ConvexClientProvider.tsx
    globals.css
    layout.tsx
    page.tsx
  components/
    compound/
      DataTable.tsx
      Form.tsx
    ui/
      alert.tsx
      avatar.tsx
      badge.tsx
      button.tsx
      calendar.tsx
      card.tsx
      command.tsx
      dialog.tsx
      dropdown-menu.tsx
      input.tsx
      label.tsx
      popover.tsx
      progress.tsx
      scroll-area.tsx
      select.tsx
      separator.tsx
      sheet.tsx
      switch.tsx
      table.tsx
      tabs.tsx
      textarea.tsx
      tooltip.tsx
  hooks/
    useConvexWithMonitoring.ts
    useDebounce.ts
    useInfiniteScroll.ts
    useLocalStorage.ts
    useMediaQuery.ts
    usePagination.ts
  lib/
    api-client.ts
    auth-session.ts
    AuthRedirectHandler.tsx
    error-handler.ts
    monitoring.ts
    utils.ts
    validation-utils.ts
    validations.ts
    zod-schemas.ts
  stores/
    contract-store.ts
    dashboard-store.ts
    vendor-store.ts
  styles/
    tokens.ts
  types/
    agents.types.ts
    auth.types.ts
    contract.types.ts
    convex.types.ts
    homedashboard.types.ts
    vendor.types.ts
  middleware.ts
.gitignore
components.json
eslint.config.mjs
instructions.md
next.config.ts
package.json
PACTWISE.md
postcss.config.mjs
README.md
ROLE_PERMISSIONS.md
sentry.client.config.ts
sentry.server.config.ts
tailwind.config.js
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Bash(npx tsc:*)",
      "Bash(npm run typecheck:*)",
      "Bash(npm run lint)",
      "Bash(npm run build:*)",
      "Bash(npm install:*)",
      "Bash(grep:*)",
      "Bash(npx convex dev:*)",
      "Bash(rg:*)",
      "Bash(mv:*)",
      "Bash(claude doctor)",
      "Bash(claude --version)",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg -n \"DocumentViewer\")",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg -n -A 3 -B 3 \"DocumentViewer\" --type tsx --type ts)",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg -n -A 3 -B 3 \"DocumentViewer\")",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg -n \"<DocumentViewer\" .)",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg -n -i \"document.*view|view.*document|file.*view|view.*file\" --glob=\"*.tsx\" --glob=\"*.ts\")",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg -n -A 5 -B 5 \"Download|View|document\" /home/dpxrk/pactwise-fork/src/app/_components/contracts/ContractDetails.tsx)",
      "Bash(find:*)",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg \":\\s*any\\b|<any>|Array<any>|any\\[\\]|\\bany\\s*=|\\bany\\s*\\||\\|\\s*any\\b\" --type ts --type tsx -n)",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg \":\\s*any\\b|<any>|Array<any>|any\\[\\]|\\bany\\s*=|\\bany\\s*\\||\\|\\s*any\\b\" -g \"*.ts\" -g \"*.tsx\" -n)",
      "Bash(/home/dpxrk/.nvm/versions/node/v20.9.0/lib/node_modules/@anthropic-ai/claude-code/vendor/ripgrep/x64-linux/rg \": any\" -g \"*.ts\" -g \"*.tsx\" -n)",
      "Bash(rm:*)",
      "Bash(npm run:*)",
      "Bash(mkdir:*)"
    ]
  },
  "enableAllProjectMcpServers": false
}
</file>

<file path="convex/security/applyRateLimit.ts">
/**
 * Rate Limiting Application Utility
 * 
 * This utility provides easy ways to apply rate limiting to existing Convex functions
 * without major refactoring.
 */

import { ConvexError } from "convex/values";
import { checkRateLimit } from "./rateLimiting";

/**
 * Apply rate limiting to any Convex function handler
 */
export async function withRateLimitCheck(
  ctx: any,
  operation: string,
  options: {
    cost?: number;
    skipForRoles?: string[];
  } = {}
): Promise<void> {
  const identity = await ctx.auth.getUserIdentity();
  
  // Get user information
  let userId;
  let userRole;
  
  if (identity) {
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q: any) => q.eq("clerkId", identity.subject))
      .first();
    
    userId = user?._id;
    userRole = user?.role;
  }
  
  // Skip rate limiting for certain roles
  if (userRole && options.skipForRoles?.includes(userRole)) {
    return;
  }
  
  // Check rate limit
  const rateLimitResult = await checkRateLimit(ctx, operation, {
    userId,
    cost: options.cost,
  });
  
  if (!rateLimitResult.allowed) {
    throw new ConvexError(
      `Rate limit exceeded for operation: ${operation}. ` +
      `Please try again in ${rateLimitResult.resetIn || 60} seconds.`
    );
  }
}

/**
 * Rate limiting decorator for function handlers
 */
export function rateLimitDecorator(
  operation: string,
  options: {
    cost?: number;
    skipForRoles?: string[];
  } = {}
) {
  return function <T extends (...args: any[]) => any>(
    target: any,
    propertyName: string,
    descriptor: TypedPropertyDescriptor<T>
  ) {
    const method = descriptor.value!;
    
    descriptor.value = (async function (this: any, ctx: any, ...args: any[]) {
      await withRateLimitCheck(ctx, operation, options);
      return method.apply(this, [ctx, ...args]);
    }) as T;
  };
}

/**
 * Common rate limit configurations for different operation types
 */
export const RATE_LIMIT_CONFIGS = {
  // Queries
  LIST_QUERY: { cost: 1, skipForRoles: ["admin", "owner"] },
  SEARCH_QUERY: { cost: 2, skipForRoles: ["admin"] },
  ANALYTICS_QUERY: { cost: 5, skipForRoles: ["admin", "owner"] },
  DETAIL_QUERY: { cost: 1, skipForRoles: [] },
  
  // Mutations
  CREATE_MUTATION: { cost: 2, skipForRoles: [] },
  UPDATE_MUTATION: { cost: 1, skipForRoles: [] },
  DELETE_MUTATION: { cost: 3, skipForRoles: ["owner"] },
  BULK_MUTATION: { cost: 5, skipForRoles: ["admin", "owner"] },
  
  // Actions
  FILE_UPLOAD_ACTION: { cost: 2, skipForRoles: [] },
  ANALYSIS_ACTION: { cost: 1, skipForRoles: [] },
  EXPORT_ACTION: { cost: 1, skipForRoles: ["admin", "owner"] },
  EMAIL_ACTION: { cost: 2, skipForRoles: [] },
  
  // Auth operations
  AUTH_OPERATION: { cost: 1, skipForRoles: [] },
};

/**
 * Helper functions for common patterns
 */
export const rateLimitHelpers = {
  /**
   * Apply rate limiting to a contract query
   */
  forContractQuery: (operation: string, type: 'list' | 'search' | 'analytics' | 'detail' = 'list') => {
    const config = {
      list: RATE_LIMIT_CONFIGS.LIST_QUERY,
      search: RATE_LIMIT_CONFIGS.SEARCH_QUERY,
      analytics: RATE_LIMIT_CONFIGS.ANALYTICS_QUERY,
      detail: RATE_LIMIT_CONFIGS.DETAIL_QUERY,
    }[type];
    
    return (ctx: any) => withRateLimitCheck(ctx, `query.contracts.${operation}`, config);
  },
  
  /**
   * Apply rate limiting to a contract mutation
   */
  forContractMutation: (operation: string, type: 'create' | 'update' | 'delete' | 'bulk' = 'update') => {
    const config = {
      create: RATE_LIMIT_CONFIGS.CREATE_MUTATION,
      update: RATE_LIMIT_CONFIGS.UPDATE_MUTATION,
      delete: RATE_LIMIT_CONFIGS.DELETE_MUTATION,
      bulk: RATE_LIMIT_CONFIGS.BULK_MUTATION,
    }[type];
    
    return (ctx: any) => withRateLimitCheck(ctx, `mutation.contracts.${operation}`, config);
  },
  
  /**
   * Apply rate limiting to a vendor query
   */
  forVendorQuery: (operation: string, type: 'list' | 'search' | 'detail' = 'list') => {
    const config = {
      list: RATE_LIMIT_CONFIGS.LIST_QUERY,
      search: RATE_LIMIT_CONFIGS.SEARCH_QUERY,
      detail: RATE_LIMIT_CONFIGS.DETAIL_QUERY,
    }[type];
    
    return (ctx: any) => withRateLimitCheck(ctx, `query.vendors.${operation}`, config);
  },
  
  /**
   * Apply rate limiting to a vendor mutation
   */
  forVendorMutation: (operation: string, type: 'create' | 'update' | 'delete' = 'update') => {
    const config = {
      create: RATE_LIMIT_CONFIGS.CREATE_MUTATION,
      update: RATE_LIMIT_CONFIGS.UPDATE_MUTATION,
      delete: RATE_LIMIT_CONFIGS.DELETE_MUTATION,
    }[type];
    
    return (ctx: any) => withRateLimitCheck(ctx, `mutation.vendors.${operation}`, config);
  },
  
  /**
   * Apply rate limiting to an action
   */
  forAction: (operation: string, type: 'fileUpload' | 'analysis' | 'export' | 'email' = 'analysis') => {
    const config = {
      fileUpload: RATE_LIMIT_CONFIGS.FILE_UPLOAD_ACTION,
      analysis: RATE_LIMIT_CONFIGS.ANALYSIS_ACTION,
      export: RATE_LIMIT_CONFIGS.EXPORT_ACTION,
      email: RATE_LIMIT_CONFIGS.EMAIL_ACTION,
    }[type];
    
    return (ctx: any) => withRateLimitCheck(ctx, `action.${operation}`, config);
  },
};

/**
 * Middleware-style rate limiting for existing functions
 * 
 * Usage:
 * const originalHandler = async (ctx, args) => { ... };
 * const rateLimitedHandler = applyRateLimit(originalHandler, 'query.contracts.list', { cost: 1 });
 */
export function applyRateLimit<T extends (ctx: any, ...args: any[]) => Promise<any>>(
  handler: T,
  operation: string,
  options: {
    cost?: number;
    skipForRoles?: string[];
  } = {}
): T {
  return (async (ctx: any, ...args: any[]) => {
    await withRateLimitCheck(ctx, operation, options);
    return handler(ctx, ...args);
  }) as T;
}

/**
 * Batch rate limiting for operations that process multiple items
 */
export async function withBatchRateLimit(
  ctx: any,
  operation: string,
  itemCount: number,
  options: {
    costPerItem?: number;
    maxBatchSize?: number;
    skipForRoles?: string[];
  } = {}
): Promise<void> {
  const { costPerItem = 1, maxBatchSize = 100, skipForRoles = [] } = options;
  
  // Check batch size limit
  if (itemCount > maxBatchSize) {
    throw new ConvexError(`Batch size ${itemCount} exceeds maximum allowed size of ${maxBatchSize}`);
  }
  
  // Apply rate limiting with cost multiplier
  await withRateLimitCheck(ctx, operation, {
    cost: itemCount * costPerItem,
    skipForRoles,
  });
}

/**
 * Rate limiting for expensive operations with progressive cost
 */
export async function withProgressiveRateLimit(
  ctx: any,
  operation: string,
  complexity: 'simple' | 'moderate' | 'complex' | 'intensive',
  options: {
    skipForRoles?: string[];
  } = {}
): Promise<void> {
  const costMap = {
    simple: 1,
    moderate: 3,
    complex: 8,
    intensive: 15,
  };
  
  await withRateLimitCheck(ctx, operation, {
    cost: costMap[complexity],
    skipForRoles: options.skipForRoles,
  });
}
</file>

<file path="convex/security/rateLimitedExamples.ts">
/**
 * Rate Limited Function Examples
 * 
 * This file demonstrates how to apply rate limiting to existing Convex functions.
 * These are examples that can be applied to actual functions in the codebase.
 */

import { query, mutation, action } from "../_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { withRateLimit, rateLimitPatterns } from "./rateLimitedWrapper";

// ============================================================================
// RATE LIMITED QUERY EXAMPLES
// ============================================================================

/**
 * Example: Rate limited contract listing
 */
export const getContractsWithRateLimit = query({
  args: {
    filters: v.optional(v.object({
      status: v.optional(v.string()),
      vendorId: v.optional(v.string()),
      search: v.optional(v.string()),
    })),
    pagination: v.optional(v.object({
      limit: v.optional(v.number()),
      offset: v.optional(v.number()),
    })),
  },
  handler: withRateLimit.query(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // Original function logic would go here
      const contracts = await ctx.db
        .query("contracts")
        .collect();

      return contracts;
    },
    rateLimitPatterns.query("contracts.list")
  ),
});

/**
 * Example: Rate limited search with higher cost
 */
export const searchContractsWithRateLimit = query({
  args: {
    searchQuery: v.string(),
    filters: v.optional(v.object({
      status: v.optional(v.string()),
      contractType: v.optional(v.string()),
    })),
  },
  handler: withRateLimit.query(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // Search logic with higher computational cost
      const results = await ctx.db
        .query("contracts")
        .collect();

      // Filter and search logic would go here
      return results.filter(contract => 
        contract.title?.toLowerCase().includes(args.searchQuery.toLowerCase())
      );
    },
    rateLimitPatterns.search("contracts")
  ),
});

/**
 * Example: Rate limited analytics query
 */
export const getAnalyticsWithRateLimit = query({
  args: {
    timeRange: v.object({
      start: v.string(),
      end: v.string(),
    }),
    metrics: v.array(v.string()),
  },
  handler: withRateLimit.query(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // Heavy analytics computation
      const contracts = await ctx.db.query("contracts").collect();
      
      // Complex analytics calculations would go here
      return {
        totalContracts: contracts.length,
        activeContracts: contracts.filter(c => c.status === "active").length,
        // More analytics...
      };
    },
    rateLimitPatterns.analytics("contracts.overview")
  ),
});

// ============================================================================
// RATE LIMITED MUTATION EXAMPLES
// ============================================================================

/**
 * Example: Rate limited contract creation
 */
export const createContractWithRateLimit = mutation({
  args: {
    title: v.string(),
    description: v.optional(v.string()),
    vendorId: v.id("vendors"),
    contractType: v.string(),
    status: v.optional(v.string()),
  },
  handler: withRateLimit.mutation(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // Get current user
      const user = await ctx.db
        .query("users")
        .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
        .first();

      if (!user) {
        throw new ConvexError("User not found");
      }

      // Create contract
      const contractId = await ctx.db.insert("contracts", {
        title: args.title,
        description: args.description,
        vendorId: args.vendorId,
        contractType: args.contractType as any,
        status: (args.status as any) || "draft",
        enterpriseId: user.enterpriseId,
        createdBy: user._id,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
      });

      return contractId;
    },
    rateLimitPatterns.create("contracts")
  ),
});

/**
 * Example: Rate limited contract update
 */
export const updateContractWithRateLimit = mutation({
  args: {
    contractId: v.id("contracts"),
    updates: v.object({
      title: v.optional(v.string()),
      description: v.optional(v.string()),
      status: v.optional(v.string()),
    }),
  },
  handler: withRateLimit.mutation(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // Check contract exists and user has permission
      const contract = await ctx.db.get(args.contractId);
      if (!contract) {
        throw new ConvexError("Contract not found");
      }

      // Update contract
      await ctx.db.patch(args.contractId, {
        ...args.updates,
        updatedAt: new Date().toISOString(),
      });

      return args.contractId;
    },
    rateLimitPatterns.update("contracts")
  ),
});

/**
 * Example: Rate limited bulk operation
 */
export const bulkUpdateContractsWithRateLimit = mutation({
  args: {
    contractIds: v.array(v.id("contracts")),
    updates: v.object({
      status: v.optional(v.string()),
    }),
  },
  handler: withRateLimit.mutation(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // Bulk update logic
      const results = [];
      for (const contractId of args.contractIds) {
        const contract = await ctx.db.get(contractId);
        if (contract) {
          await ctx.db.patch(contractId, {
            ...args.updates,
            updatedAt: new Date().toISOString(),
          });
          results.push(contractId);
        }
      }

      return results;
    },
    rateLimitPatterns.bulkOperation("contracts.update")
  ),
});

// ============================================================================
// RATE LIMITED ACTION EXAMPLES
// ============================================================================

/**
 * Example: Rate limited file upload action
 */
export const uploadContractFileWithRateLimit = action({
  args: {
    contractId: v.id("contracts"),
    fileName: v.string(),
    fileType: v.string(),
  },
  handler: withRateLimit.action(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // File upload logic would go here
      // This is a placeholder for the actual file upload implementation
      
      return {
        success: true,
        message: `File ${args.fileName} uploaded for contract ${args.contractId}`,
      };
    },
    rateLimitPatterns.fileUpload()
  ),
});

/**
 * Example: Rate limited contract analysis action
 */
export const analyzeContractWithRateLimit = action({
  args: {
    contractId: v.id("contracts"),
    analysisType: v.string(),
  },
  handler: withRateLimit.action(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // AI analysis logic would go here
      // This is computationally expensive and should be rate limited
      
      return {
        analysisId: `analysis_${Date.now()}`,
        status: "processing",
        estimatedCompletion: new Date(Date.now() + 300000).toISOString(), // 5 minutes
      };
    },
    rateLimitPatterns.analysis()
  ),
});

/**
 * Example: Rate limited export action
 */
export const exportContractsWithRateLimit = action({
  args: {
    filters: v.optional(v.object({
      status: v.optional(v.string()),
      dateRange: v.optional(v.object({
        start: v.string(),
        end: v.string(),
      })),
    })),
    format: v.string(), // "csv", "pdf", "xlsx"
  },
  handler: withRateLimit.action(
    async (ctx, args) => {
      const identity = await ctx.auth.getUserIdentity();
      if (!identity) {
        throw new ConvexError("Authentication required");
      }

      // Export generation logic would go here
      // This is resource-intensive and should be rate limited
      
      return {
        exportId: `export_${Date.now()}`,
        downloadUrl: `https://example.com/exports/export_${Date.now()}.${args.format}`,
        expiresAt: new Date(Date.now() + 3600000).toISOString(), // 1 hour
      };
    },
    rateLimitPatterns.export()
  ),
});

// ============================================================================
// RATE LIMIT MONITORING QUERIES
// ============================================================================

/**
 * Get rate limit status for current user
 */
export const getRateLimitStatus = query({
  args: {
    operations: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const operations = args.operations || [
      "query.contracts.list",
      "mutation.create.contracts",
      "action.fileUpload",
    ];

    const status: Record<string, any> = {};

    for (const operation of operations) {
      const key = `user:${user._id}:${operation}`;
      const bucket = await ctx.db
        .query("rateLimitBuckets")
        .withIndex("by_key", (q) => q.eq("key", key))
        .first();

      status[operation] = {
        tokens: bucket?.tokens || 0,
        maxTokens: 100, // Would need to get from config
        isBlocked: bucket?.blockedUntil && new Date(bucket.blockedUntil) > new Date(),
        blockedUntil: bucket?.blockedUntil,
        violations: bucket?.violations || 0,
      };
    }

    return status;
  },
});
</file>

<file path="convex/security/rateLimitedWrapper.ts">
import { QueryCtx, MutationCtx, ActionCtx } from "../_generated/server";
import { checkRateLimit } from "./rateLimiting";
import { ConvexError } from "convex/values";
import { FunctionReference, makeFunctionReference } from "convex/server";
import { Id } from "../_generated/dataModel";

/**
 * Rate Limited Function Wrapper
 * 
 * This wrapper applies rate limiting to Convex queries, mutations, and actions
 * based on user ID and operation type.
 */

interface RateLimitOptions {
  operation: string;
  cost?: number;
  skipForOwners?: boolean;
  skipForAdmins?: boolean;
}

/**
 * Get user information from context for rate limiting
 */
async function getUserInfo(ctx: any): Promise<{ userId?: Id<"users">; userRole?: string }> {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) {
    return {};
  }

  const user = await ctx.db
    .query("users")
    .withIndex("by_clerkId", (q: any) => q.eq("clerkId", identity.subject))
    .first();

  return {
    userId: user?._id,
    userRole: user?.role,
  };
}

/**
 * Extract IP address from request (for actions)
 */
function getIpAddress(ctx: any): string {
  // In Convex, we don't have direct access to IP address
  // This would need to be passed from the client or handled differently
  return "unknown";
}

/**
 * Check if user should skip rate limiting based on role
 */
function shouldSkipRateLimit(userRole: string | undefined, options: RateLimitOptions): boolean {
  if (!userRole) return false;
  
  if (options.skipForOwners && userRole === "owner") return true;
  if (options.skipForAdmins && (userRole === "admin" || userRole === "owner")) return true;
  
  return false;
}

/**
 * Rate limited query wrapper
 */
export function rateLimitedQuery<Args, Output>(
  queryFn: (ctx: QueryCtx, args: Args) => Promise<Output>,
  options: RateLimitOptions
) {
  return async (ctx: QueryCtx, args: Args): Promise<Output> => {
    const { userId, userRole } = await getUserInfo(ctx);
    
    // Skip rate limiting for certain roles if configured
    if (!shouldSkipRateLimit(userRole, options)) {
      const ipAddress = getIpAddress(ctx);
      
      const rateLimitResult = await checkRateLimit(ctx, options.operation, {
        userId,
        ipAddress,
        cost: options.cost,
      });
      
      if (!rateLimitResult.allowed) {
        throw new ConvexError(`Rate limit exceeded for operation: ${options.operation}. Please try again in ${rateLimitResult.resetIn || 60} seconds.`);
      }
    }
    
    return await queryFn(ctx, args);
  };
}

/**
 * Rate limited mutation wrapper
 */
export function rateLimitedMutation<Args, Output>(
  mutationFn: (ctx: MutationCtx, args: Args) => Promise<Output>,
  options: RateLimitOptions
) {
  return async (ctx: MutationCtx, args: Args): Promise<Output> => {
    const { userId, userRole } = await getUserInfo(ctx);
    
    // Skip rate limiting for certain roles if configured
    if (!shouldSkipRateLimit(userRole, options)) {
      const ipAddress = getIpAddress(ctx);
      
      const rateLimitResult = await checkRateLimit(ctx, options.operation, {
        userId,
        ipAddress,
        cost: options.cost,
      });
      
      if (!rateLimitResult.allowed) {
        throw new ConvexError(`Rate limit exceeded for operation: ${options.operation}. Please try again in ${rateLimitResult.resetIn || 60} seconds.`);
      }
    }
    
    return await mutationFn(ctx, args);
  };
}

/**
 * Rate limited action wrapper
 */
export function rateLimitedAction<Args, Output>(
  actionFn: (ctx: ActionCtx, args: Args) => Promise<Output>,
  options: RateLimitOptions
) {
  return async (ctx: ActionCtx, args: Args): Promise<Output> => {
    // For actions, we need to run the rate limit check as a mutation
    const rateLimitCheck = makeFunctionReference<"mutation", any, any>("security/rateLimiting:checkRateLimitAction");
    
    const identity = await ctx.auth.getUserIdentity();
    const userId = identity?.subject;
    
    try {
      await ctx.runMutation(rateLimitCheck, {
        operation: options.operation,
        cost: options.cost,
        clerkId: userId,
      });
    } catch (error) {
      if (error instanceof ConvexError && error.message.includes("Rate limit exceeded")) {
        throw error;
      }
      // If it's not a rate limit error, let the action proceed
    }
    
    return await actionFn(ctx, args);
  };
}

/**
 * Helper to create rate limited functions with common patterns
 */
export const rateLimitPatterns = {
  // Standard CRUD operations
  query: (operation: string) => ({ operation: `query.${operation}`, skipForAdmins: true }),
  search: (operation: string) => ({ operation: `query.search.${operation}`, cost: 2 }),
  analytics: (operation: string) => ({ operation: `query.analytics.${operation}`, cost: 5, skipForAdmins: true }),
  
  create: (operation: string) => ({ operation: `mutation.create.${operation}`, cost: 2 }),
  update: (operation: string) => ({ operation: `mutation.update.${operation}`, cost: 1 }),
  delete: (operation: string) => ({ operation: `mutation.delete.${operation}`, cost: 3, skipForOwners: true }),
  bulkOperation: (operation: string) => ({ operation: `mutation.bulk.${operation}`, cost: 5, skipForAdmins: true }),
  
  // Actions
  fileUpload: () => ({ operation: "action.fileUpload", cost: 2 }),
  analysis: () => ({ operation: "action.analysis", cost: 1 }),
  export: () => ({ operation: "action.export", cost: 1, skipForAdmins: true }),
  
  // Auth operations
  auth: (operation: string) => ({ operation: `auth.${operation}` }),
};

/**
 * Decorator functions for easy application
 */
export const withRateLimit = {
  query: <Args, Output>(
    queryFn: (ctx: QueryCtx, args: Args) => Promise<Output>,
    options: RateLimitOptions
  ) => rateLimitedQuery(queryFn, options),
  
  mutation: <Args, Output>(
    mutationFn: (ctx: MutationCtx, args: Args) => Promise<Output>,
    options: RateLimitOptions
  ) => rateLimitedMutation(mutationFn, options),
  
  action: <Args, Output>(
    actionFn: (ctx: ActionCtx, args: Args) => Promise<Output>,
    options: RateLimitOptions
  ) => rateLimitedAction(actionFn, options),
};
</file>

<file path="src/app/dashboard/settings/enterprise/page.tsx">
'use client';

import React, { useState } from 'react';
import { useUser } from '@clerk/nextjs';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../../convex/_generated/api';
import { Id } from '../../../../../convex/_generated/dataModel';

// UI Components
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";
import { Switch } from "@/components/ui/switch";
import { PermissionGate } from '@/app/_components/auth/PermissionGate';

// Icons
import {
  Building,
  Save,
  AlertCircle,
  CheckCircle,
  Edit,
  Globe,
  Users,
  Calendar,
  FileText,
  Shield,
  Database,
  Settings,
  Trash2,
  AlertTriangle,
  Info,
  Clock,
  TrendingUp
} from 'lucide-react';
import LoadingSpinner from '@/app/_components/common/LoadingSpinner';

const EnterpriseSettingsPage = () => {
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // Get enterpriseId from Clerk user's public metadata
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch current user context
  const { data: userContext, isLoading: isLoadingUser } = useConvexQuery(
    api.users.getUserContext,
    {}
  );

  // Mock data for enterprise settings (in real app, this would come from API)
  const [enterpriseData, setEnterpriseData] = useState({
    name: userContext?.enterprise?.name || '',
    domain: userContext?.enterprise?.domain || '',
    industry: '',
    size: '',
    contractVolume: '',
    primaryUseCase: [] as string[],
    address: '',
    phone: '',
    website: '',
    description: '',
    timezone: 'UTC',
    dateFormat: 'MM/DD/YYYY',
    currency: 'USD',
    fiscalYearStart: 'January',
  });

  React.useEffect(() => {
    if (userContext?.enterprise) {
      setEnterpriseData(prev => ({
        ...prev,
        name: userContext.enterprise?.name || '',
        domain: userContext.enterprise?.domain || '',
      }));
    }
  }, [userContext]);

  const handleSave = async () => {
    setIsSaving(true);
    try {
      // In a real implementation, this would call a mutation to update enterprise settings
      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call
      setIsEditing(false);
    } catch (error) {
      console.error('Failed to save enterprise settings:', error);
    } finally {
      setIsSaving(false);
    }
  };

  if (!isClerkLoaded || isLoadingUser) {
    return (
      <div className="p-6">
        <LoadingSpinner />
      </div>
    );
  }

  if (!userContext?.enterprise) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>
          Unable to load enterprise information. Please try refreshing the page.
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <PermissionGate requiredRole="admin">
      <div className="space-y-6">
        {/* Basic Information */}
        <Card>
          <CardHeader className="flex flex-row items-center justify-between">
            <div>
              <CardTitle className="flex items-center gap-2">
                <Building className="h-5 w-5" />
                Basic Information
              </CardTitle>
              <p className="text-sm text-muted-foreground mt-1">
                Manage your enterprise's basic information and branding
              </p>
            </div>
            <Button
              variant={isEditing ? "outline" : "default"}
              size="sm"
              onClick={() => setIsEditing(!isEditing)}
            >
              <Edit className="h-4 w-4 mr-2" />
              {isEditing ? 'Cancel' : 'Edit'}
            </Button>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="enterpriseName">Enterprise Name *</Label>
                <Input
                  id="enterpriseName"
                  value={enterpriseData.name}
                  onChange={(e) => setEnterpriseData({ ...enterpriseData, name: e.target.value })}
                  disabled={!isEditing}
                  placeholder="Your enterprise name"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="domain">Domain</Label>
                <Input
                  id="domain"
                  value={enterpriseData.domain}
                  onChange={(e) => setEnterpriseData({ ...enterpriseData, domain: e.target.value })}
                  disabled={!isEditing}
                  placeholder="company.com"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="industry">Industry</Label>
                <Select
                  value={enterpriseData.industry}
                  onValueChange={(value) => setEnterpriseData({ ...enterpriseData, industry: value })}
                  disabled={!isEditing}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select industry" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="technology">Technology</SelectItem>
                    <SelectItem value="healthcare">Healthcare</SelectItem>
                    <SelectItem value="finance">Finance</SelectItem>
                    <SelectItem value="manufacturing">Manufacturing</SelectItem>
                    <SelectItem value="retail">Retail</SelectItem>
                    <SelectItem value="education">Education</SelectItem>
                    <SelectItem value="other">Other</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="size">Enterprise Size</Label>
                <Select
                  value={enterpriseData.size}
                  onValueChange={(value) => setEnterpriseData({ ...enterpriseData, size: value })}
                  disabled={!isEditing}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select size" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="1-10">1-10 employees</SelectItem>
                    <SelectItem value="11-50">11-50 employees</SelectItem>
                    <SelectItem value="51-200">51-200 employees</SelectItem>
                    <SelectItem value="201-500">201-500 employees</SelectItem>
                    <SelectItem value="501-1000">501-1000 employees</SelectItem>
                    <SelectItem value="1000+">1000+ employees</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="website">Website</Label>
                <Input
                  id="website"
                  value={enterpriseData.website}
                  onChange={(e) => setEnterpriseData({ ...enterpriseData, website: e.target.value })}
                  disabled={!isEditing}
                  placeholder="https://company.com"
                />
              </div>
              <div className="space-y-2">
                <Label htmlFor="phone">Phone Number</Label>
                <Input
                  id="phone"
                  value={enterpriseData.phone}
                  onChange={(e) => setEnterpriseData({ ...enterpriseData, phone: e.target.value })}
                  disabled={!isEditing}
                  placeholder="+1 (555) 123-4567"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="address">Address</Label>
              <Textarea
                id="address"
                value={enterpriseData.address}
                onChange={(e) => setEnterpriseData({ ...enterpriseData, address: e.target.value })}
                disabled={!isEditing}
                placeholder="Enterprise address"
                rows={3}
              />
            </div>

            <div className="space-y-2">
              <Label htmlFor="description">Description</Label>
              <Textarea
                id="description"
                value={enterpriseData.description}
                onChange={(e) => setEnterpriseData({ ...enterpriseData, description: e.target.value })}
                disabled={!isEditing}
                placeholder="Brief description of your enterprise"
                rows={3}
              />
            </div>

            {isEditing && (
              <>
                <Separator />
                <div className="flex justify-end gap-2">
                  <Button variant="outline" onClick={() => setIsEditing(false)}>
                    Cancel
                  </Button>
                  <Button onClick={handleSave} disabled={isSaving}>
                    {isSaving ? (
                      <>
                        <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-current mr-2"></div>
                        Saving...
                      </>
                    ) : (
                      <>
                        <Save className="h-4 w-4 mr-2" />
                        Save Changes
                      </>
                    )}
                  </Button>
                </div>
              </>
            )}
          </CardContent>
        </Card>

        {/* Contract Management Settings */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <FileText className="h-5 w-5" />
              Contract Management
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              Configure contract management preferences and workflows
            </p>
          </CardHeader>
          <CardContent className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="contractVolume">Expected Contract Volume</Label>
                <Select
                  value={enterpriseData.contractVolume}
                  onValueChange={(value) => setEnterpriseData({ ...enterpriseData, contractVolume: value })}
                  disabled={!isEditing}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select volume" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="low">Low (1-50 contracts/year)</SelectItem>
                    <SelectItem value="medium">Medium (51-200 contracts/year)</SelectItem>
                    <SelectItem value="high">High (201-500 contracts/year)</SelectItem>
                    <SelectItem value="enterprise">Enterprise (500+ contracts/year)</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="fiscalYear">Fiscal Year Start</Label>
                <Select
                  value={enterpriseData.fiscalYearStart}
                  onValueChange={(value) => setEnterpriseData({ ...enterpriseData, fiscalYearStart: value })}
                  disabled={!isEditing}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select month" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="January">January</SelectItem>
                    <SelectItem value="April">April</SelectItem>
                    <SelectItem value="July">July</SelectItem>
                    <SelectItem value="October">October</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>

            <div className="space-y-4">
              <Label>Contract Workflow Settings</Label>
              <div className="space-y-3">
                <div className="flex items-center justify-between p-3 border rounded-lg">
                  <div>
                    <p className="font-medium text-sm">Auto-analysis for new contracts</p>
                    <p className="text-xs text-muted-foreground">Automatically analyze contracts when uploaded</p>
                  </div>
                  <Switch defaultChecked />
                </div>
                <div className="flex items-center justify-between p-3 border rounded-lg">
                  <div>
                    <p className="font-medium text-sm">Expiration notifications</p>
                    <p className="text-xs text-muted-foreground">Send alerts before contracts expire</p>
                  </div>
                  <Switch defaultChecked />
                </div>
                <div className="flex items-center justify-between p-3 border rounded-lg">
                  <div>
                    <p className="font-medium text-sm">Renewal reminders</p>
                    <p className="text-xs text-muted-foreground">Remind users about upcoming renewals</p>
                  </div>
                  <Switch defaultChecked />
                </div>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Regional Settings */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Globe className="h-5 w-5" />
              Regional Settings
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              Configure regional preferences for dates, currency, and timezone
            </p>
          </CardHeader>
          <CardContent className="space-y-4">
            <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
              <div className="space-y-2">
                <Label htmlFor="timezone">Timezone</Label>
                <Select
                  value={enterpriseData.timezone}
                  onValueChange={(value) => setEnterpriseData({ ...enterpriseData, timezone: value })}
                  disabled={!isEditing}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select timezone" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="UTC">UTC</SelectItem>
                    <SelectItem value="America/New_York">Eastern Time</SelectItem>
                    <SelectItem value="America/Chicago">Central Time</SelectItem>
                    <SelectItem value="America/Denver">Mountain Time</SelectItem>
                    <SelectItem value="America/Los_Angeles">Pacific Time</SelectItem>
                    <SelectItem value="Europe/London">London</SelectItem>
                    <SelectItem value="Europe/Paris">Paris</SelectItem>
                    <SelectItem value="Asia/Tokyo">Tokyo</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="dateFormat">Date Format</Label>
                <Select
                  value={enterpriseData.dateFormat}
                  onValueChange={(value) => setEnterpriseData({ ...enterpriseData, dateFormat: value })}
                  disabled={!isEditing}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select format" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="MM/DD/YYYY">MM/DD/YYYY</SelectItem>
                    <SelectItem value="DD/MM/YYYY">DD/MM/YYYY</SelectItem>
                    <SelectItem value="YYYY-MM-DD">YYYY-MM-DD</SelectItem>
                    <SelectItem value="MMM DD, YYYY">MMM DD, YYYY</SelectItem>
                  </SelectContent>
                </Select>
              </div>
              <div className="space-y-2">
                <Label htmlFor="currency">Currency</Label>
                <Select
                  value={enterpriseData.currency}
                  onValueChange={(value) => setEnterpriseData({ ...enterpriseData, currency: value })}
                  disabled={!isEditing}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select currency" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="USD">USD - US Dollar</SelectItem>
                    <SelectItem value="EUR">EUR - Euro</SelectItem>
                    <SelectItem value="GBP">GBP - British Pound</SelectItem>
                    <SelectItem value="JPY">JPY - Japanese Yen</SelectItem>
                    <SelectItem value="CAD">CAD - Canadian Dollar</SelectItem>
                    <SelectItem value="AUD">AUD - Australian Dollar</SelectItem>
                  </SelectContent>
                </Select>
              </div>
            </div>
          </CardContent>
        </Card>

        {/* Danger Zone */}
        <Card className="border-destructive">
          <CardHeader>
            <CardTitle className="flex items-center gap-2 text-destructive">
              <AlertTriangle className="h-5 w-5" />
              Danger Zone
            </CardTitle>
            <p className="text-sm text-muted-foreground">
              Irreversible and destructive actions for your enterprise
            </p>
          </CardHeader>
          <CardContent className="space-y-4">
            <Alert variant="destructive">
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>Warning</AlertTitle>
              <AlertDescription>
                These actions are permanent and cannot be undone. Please proceed with caution.
              </AlertDescription>
            </Alert>
            
            <div className="space-y-3">
              <div className="flex items-center justify-between p-4 border border-destructive rounded-lg">
                <div>
                  <h4 className="font-medium text-destructive">Export All Data</h4>
                  <p className="text-sm text-muted-foreground">Download all enterprise data before deletion</p>
                </div>
                <Button variant="outline" size="sm">
                  Export Data
                </Button>
              </div>
              
              <div className="flex items-center justify-between p-4 border border-destructive rounded-lg">
                <div>
                  <h4 className="font-medium text-destructive">Delete Enterprise</h4>
                  <p className="text-sm text-muted-foreground">Permanently delete this enterprise and all associated data</p>
                </div>
                <Button variant="destructive" size="sm">
                  <Trash2 className="h-4 w-4 mr-2" />
                  Delete Enterprise
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>
    </PermissionGate>
  );
};

export default EnterpriseSettingsPage;
</file>

<file path="src/app/dashboard/settings/users/page.tsx">
'use client';

import React, { useState } from 'react';
import { useUser } from '@clerk/nextjs';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../../convex/_generated/api';
import { Id } from '../../../../../convex/_generated/dataModel';
import { format } from 'date-fns';

// UI Components
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Separator } from "@/components/ui/separator";
import { PermissionGate } from '@/app/_components/auth/PermissionGate';

// Icons
import {
  Users,
  Search,
  Filter,
  UserPlus,
  Mail,
  Crown,
  Shield,
  User,
  Eye,
  Settings,
  AlertCircle,
  Calendar,
  Clock,
  Briefcase,
  Phone,
  MoreHorizontal,
  Edit,
  UserMinus
} from 'lucide-react';
import LoadingSpinner from '@/app/_components/common/LoadingSpinner';

const UserManagementPage = () => {
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();
  const [searchQuery, setSearchQuery] = useState('');
  const [roleFilter, setRoleFilter] = useState<string>('all');
  const [statusFilter, setStatusFilter] = useState<string>('all');

  // Get enterpriseId from Clerk user's public metadata
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch users data
  const { data: users, isLoading, error } = useConvexQuery(
    api.users.getEnterpriseUsers,
    enterpriseId ? { enterpriseId } : "skip"
  );

  // Role configuration
  const roleConfig = {
    owner: { label: 'Owner', icon: Crown, color: 'bg-purple-100 text-purple-800 dark:bg-purple-900/70 dark:text-purple-300' },
    admin: { label: 'Admin', icon: Shield, color: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300' },
    manager: { label: 'Manager', icon: Settings, color: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300' },
    user: { label: 'User', icon: User, color: 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300' },
    viewer: { label: 'Viewer', icon: Eye, color: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300' },
  };

  const formatDate = (dateString?: string): string => {
    if (!dateString) return 'Never';
    try {
      return format(new Date(dateString), 'MMM dd, yyyy');
    } catch (e) {
      return 'Invalid date';
    }
  };

  const formatLastLogin = (dateString?: string): string => {
    if (!dateString) return 'Never';
    try {
      const date = new Date(dateString);
      const now = new Date();
      const diffInDays = Math.floor((now.getTime() - date.getTime()) / (1000 * 60 * 60 * 24));
      
      if (diffInDays === 0) return 'Today';
      if (diffInDays === 1) return 'Yesterday';
      if (diffInDays < 7) return `${diffInDays} days ago`;
      return format(date, 'MMM dd, yyyy');
    } catch (e) {
      return 'Invalid date';
    }
  };

  // Filter users based on search and filters
  const filteredUsers = users?.filter(user => {
    const matchesSearch = !searchQuery || 
      user.email.toLowerCase().includes(searchQuery.toLowerCase()) ||
      `${user.firstName || ''} ${user.lastName || ''}`.toLowerCase().includes(searchQuery.toLowerCase()) ||
      user.department?.toLowerCase().includes(searchQuery.toLowerCase()) ||
      user.title?.toLowerCase().includes(searchQuery.toLowerCase());

    const matchesRole = roleFilter === 'all' || user.role === roleFilter;
    const matchesStatus = statusFilter === 'all' || 
      (statusFilter === 'active' && user.isActive) ||
      (statusFilter === 'inactive' && !user.isActive);

    return matchesSearch && matchesRole && matchesStatus;
  }) || [];

  if (!isClerkLoaded || isLoading) {
    return (
      <div className="p-6">
        <LoadingSpinner />
      </div>
    );
  }

  if (!enterpriseId) {
    return (
      <div className="p-6">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Configuration Error</AlertTitle>
          <AlertDescription>
            Enterprise information is missing for your user account. Please contact support.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  if (error) {
    return (
      <div className="p-6">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Access Denied</AlertTitle>
          <AlertDescription>
            You don't have permission to view user management. Only owners and admins can access this page.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <PermissionGate requiredRole="admin">
      <div className="p-6 space-y-6">
        {/* Header */}
        <div className="flex items-center justify-between">
          <div>
            <h1 className="text-3xl font-bold text-foreground">User Management</h1>
            <p className="text-muted-foreground">Manage users, roles, and permissions for your enterprise</p>
          </div>
          <Button className="flex items-center gap-2">
            <UserPlus className="h-4 w-4" />
            Invite User
          </Button>
        </div>

        {/* Stats Cards */}
        <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <Users className="h-8 w-8 text-blue-500" />
                <div>
                  <p className="text-2xl font-bold">{users?.length || 0}</p>
                  <p className="text-sm text-muted-foreground">Total Users</p>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <Shield className="h-8 w-8 text-green-500" />
                <div>
                  <p className="text-2xl font-bold">{users?.filter(u => u.isActive).length || 0}</p>
                  <p className="text-sm text-muted-foreground">Active Users</p>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <Crown className="h-8 w-8 text-purple-500" />
                <div>
                  <p className="text-2xl font-bold">{users?.filter(u => ['owner', 'admin'].includes(u.role)).length || 0}</p>
                  <p className="text-sm text-muted-foreground">Admins</p>
                </div>
              </div>
            </CardContent>
          </Card>
          <Card>
            <CardContent className="p-4">
              <div className="flex items-center gap-3">
                <Clock className="h-8 w-8 text-orange-500" />
                <div>
                  <p className="text-2xl font-bold">{users?.filter(u => u.lastLoginAt && new Date(u.lastLoginAt) > new Date(Date.now() - 7 * 24 * 60 * 60 * 1000)).length || 0}</p>
                  <p className="text-sm text-muted-foreground">Active This Week</p>
                </div>
              </div>
            </CardContent>
          </Card>
        </div>

        {/* Filters */}
        <Card>
          <CardContent className="p-4">
            <div className="flex flex-col md:flex-row gap-4">
              <div className="flex-1">
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Search users by name, email, department, or title..."
                    value={searchQuery}
                    onChange={(e) => setSearchQuery(e.target.value)}
                    className="pl-10"
                  />
                </div>
              </div>
              <Select value={roleFilter} onValueChange={setRoleFilter}>
                <SelectTrigger className="w-[180px]">
                  <Filter className="h-4 w-4 mr-2" />
                  <SelectValue placeholder="Filter by role" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Roles</SelectItem>
                  <SelectItem value="owner">Owner</SelectItem>
                  <SelectItem value="admin">Admin</SelectItem>
                  <SelectItem value="manager">Manager</SelectItem>
                  <SelectItem value="user">User</SelectItem>
                  <SelectItem value="viewer">Viewer</SelectItem>
                </SelectContent>
              </Select>
              <Select value={statusFilter} onValueChange={setStatusFilter}>
                <SelectTrigger className="w-[180px]">
                  <SelectValue placeholder="Filter by status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Status</SelectItem>
                  <SelectItem value="active">Active</SelectItem>
                  <SelectItem value="inactive">Inactive</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </CardContent>
        </Card>

        {/* Users Table */}
        <Card>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Users className="h-5 w-5" />
              Users ({filteredUsers.length})
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="space-y-4">
              {filteredUsers.map((user) => {
                const roleInfo = roleConfig[user.role as keyof typeof roleConfig];
                const RoleIcon = roleInfo.icon;
                
                return (
                  <div key={user._id} className="border rounded-lg p-4 hover:bg-muted/50 transition-colors">
                    <div className="flex items-center justify-between">
                      <div className="flex items-center gap-4">
                        <div className="w-12 h-12 rounded-full bg-primary/10 flex items-center justify-center">
                          <span className="text-sm font-semibold">
                            {(user.firstName?.[0] || user.email[0]).toUpperCase()}
                            {(user.lastName?.[0] || user.email[1] || '').toUpperCase()}
                          </span>
                        </div>
                        <div className="space-y-1">
                          <div className="flex items-center gap-2">
                            <h3 className="font-medium">
                              {user.firstName && user.lastName 
                                ? `${user.firstName} ${user.lastName}` 
                                : user.email}
                            </h3>
                            <Badge className={roleInfo.color}>
                              <RoleIcon className="h-3 w-3 mr-1" />
                              {roleInfo.label}
                            </Badge>
                            {user.isActive ? (
                              <Badge variant="outline" className="text-green-600 border-green-200">
                                Active
                              </Badge>
                            ) : (
                              <Badge variant="outline" className="text-red-600 border-red-200">
                                Inactive
                              </Badge>
                            )}
                          </div>
                          <div className="flex items-center gap-4 text-sm text-muted-foreground">
                            <div className="flex items-center gap-1">
                              <Mail className="h-3 w-3" />
                              {user.email}
                            </div>
                            {user.department && (
                              <div className="flex items-center gap-1">
                                <Briefcase className="h-3 w-3" />
                                {user.department}
                              </div>
                            )}
                            {user.title && (
                              <div className="flex items-center gap-1">
                                <User className="h-3 w-3" />
                                {user.title}
                              </div>
                            )}
                          </div>
                          <div className="flex items-center gap-4 text-xs text-muted-foreground">
                            <div className="flex items-center gap-1">
                              <Calendar className="h-3 w-3" />
                              Joined {formatDate(user.createdAt)}
                            </div>
                            <div className="flex items-center gap-1">
                              <Clock className="h-3 w-3" />
                              Last login {formatLastLogin(user.lastLoginAt)}
                            </div>
                          </div>
                        </div>
                      </div>
                      <div className="flex items-center gap-2">
                        <Button variant="outline" size="sm">
                          <Edit className="h-4 w-4 mr-2" />
                          Edit
                        </Button>
                        <Button variant="outline" size="sm">
                          <MoreHorizontal className="h-4 w-4" />
                        </Button>
                      </div>
                    </div>
                  </div>
                );
              })}
              
              {filteredUsers.length === 0 && (
                <div className="text-center py-8">
                  <Users className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                  <h3 className="text-lg font-medium text-muted-foreground">No users found</h3>
                  <p className="text-sm text-muted-foreground">
                    {searchQuery || roleFilter !== 'all' || statusFilter !== 'all'
                      ? 'Try adjusting your search or filters'
                      : 'No users have been added to this enterprise yet'}
                  </p>
                </div>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    </PermissionGate>
  );
};

export default UserManagementPage;
</file>

<file path="src/app/dashboard/settings/layout.tsx">
'use client';

import React from 'react';
import Link from 'next/link';
import { usePathname } from 'next/navigation';
import { cn } from '@/lib/utils';
import { Card, CardContent } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { PermissionGate } from '@/app/_components/auth/PermissionGate';

// Icons
import {
  Settings,
  Users,
  Building,
  Shield,
  Bell,
  CreditCard,
  Database,
  Key,
  Webhook,
  Activity
} from 'lucide-react';

interface SettingsLayoutProps {
  children: React.ReactNode;
}

const SettingsLayout = ({ children }: SettingsLayoutProps) => {
  const pathname = usePathname();

  const navigationItems = [
    {
      label: 'General',
      href: '/dashboard/settings',
      icon: Settings,
      description: 'Basic enterprise settings',
      permissions: ['user', 'manager', 'admin', 'owner']
    },
    {
      label: 'Users',
      href: '/dashboard/settings/users',
      icon: Users,
      description: 'User management and permissions',
      permissions: ['admin', 'owner']
    },
    {
      label: 'Enterprise',
      href: '/dashboard/settings/enterprise',
      icon: Building,
      description: 'Enterprise configuration',
      permissions: ['admin', 'owner']
    },
    {
      label: 'Security',
      href: '/dashboard/settings/security',
      icon: Shield,
      description: 'Security and authentication',
      permissions: ['admin', 'owner'],
      badge: 'Pro'
    },
    {
      label: 'Notifications',
      href: '/dashboard/settings/notifications',
      icon: Bell,
      description: 'Notification preferences',
      permissions: ['user', 'manager', 'admin', 'owner']
    },
    {
      label: 'Billing',
      href: '/dashboard/settings/billing',
      icon: CreditCard,
      description: 'Subscription and billing',
      permissions: ['admin', 'owner'],
      badge: 'Coming Soon'
    },
    {
      label: 'Data & Privacy',
      href: '/dashboard/settings/data',
      icon: Database,
      description: 'Data export and privacy',
      permissions: ['admin', 'owner'],
      badge: 'Pro'
    },
    {
      label: 'API Keys',
      href: '/dashboard/settings/api',
      icon: Key,
      description: 'API keys and integrations',
      permissions: ['admin', 'owner'],
      badge: 'Pro'
    },
    {
      label: 'Webhooks',
      href: '/dashboard/settings/webhooks',
      icon: Webhook,
      description: 'Webhook endpoints',
      permissions: ['admin', 'owner'],
      badge: 'Pro'
    },
    {
      label: 'Audit Logs',
      href: '/dashboard/settings/audit',
      icon: Activity,
      description: 'System activity logs',
      permissions: ['admin', 'owner']
    }
  ];

  return (
    <div className="p-6">
      <div className="mb-6">
        <h1 className="text-3xl font-bold text-foreground">Settings</h1>
        <p className="text-muted-foreground">Manage your enterprise configuration and preferences</p>
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-4 gap-6">
        {/* Settings Navigation */}
        <div className="lg:col-span-1">
          <Card>
            <CardContent className="p-4">
              <nav className="space-y-2">
                {navigationItems.map((item) => {
                  const Icon = item.icon;
                  const isActive = pathname === item.href;
                  const isDisabled = item.badge && item.badge !== 'Pro';

                  return (
                    <PermissionGate key={item.href} requiredRole="user" allowedRoles={item.permissions}>
                      <Link
                        href={isDisabled ? '#' : item.href}
                        className={cn(
                          "flex items-center gap-3 px-3 py-2 rounded-md text-sm transition-colors",
                          isActive
                            ? "bg-primary text-primary-foreground"
                            : "hover:bg-muted text-muted-foreground hover:text-foreground",
                          isDisabled && "opacity-50 cursor-not-allowed"
                        )}
                        onClick={isDisabled ? (e) => e.preventDefault() : undefined}
                      >
                        <Icon className="h-4 w-4 flex-shrink-0" />
                        <div className="flex-1 min-w-0">
                          <div className="flex items-center gap-2">
                            <span className="font-medium">{item.label}</span>
                            {item.badge && (
                              <Badge 
                                variant={item.badge === 'Pro' ? 'default' : 'secondary'} 
                                className={cn(
                                  "text-xs px-1.5 py-0.5",
                                  item.badge === 'Pro' && "bg-gradient-to-r from-purple-500 to-blue-500 text-white"
                                )}
                              >
                                {item.badge}
                              </Badge>
                            )}
                          </div>
                          <p className="text-xs text-muted-foreground truncate">{item.description}</p>
                        </div>
                      </Link>
                    </PermissionGate>
                  );
                })}
              </nav>
            </CardContent>
          </Card>
        </div>

        {/* Settings Content */}
        <div className="lg:col-span-3">
          {children}
        </div>
      </div>
    </div>
  );
};

export default SettingsLayout;
</file>

<file path="src/app/dashboard/settings/page.tsx">
'use client';

import React, { useState } from 'react';
import { useUser } from '@clerk/nextjs';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';

// UI Components
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Separator } from "@/components/ui/separator";
import { Badge } from "@/components/ui/badge";

// Icons
import {
  Settings,
  Building,
  User,
  Mail,
  Phone,
  MapPin,
  Globe,
  Save,
  AlertCircle,
  CheckCircle,
  Edit,
  Camera,
  Shield,
  Clock,
  Users
} from 'lucide-react';
import LoadingSpinner from '@/app/_components/common/LoadingSpinner';

const GeneralSettingsPage = () => {
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();
  const [isEditing, setIsEditing] = useState(false);
  const [isSaving, setIsSaving] = useState(false);

  // Get enterpriseId from Clerk user's public metadata
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch current user context
  const { data: userContext, isLoading: isLoadingUser } = useConvexQuery(
    api.users.getUserContext,
    {}
  );

  const [formData, setFormData] = useState({
    firstName: '',
    lastName: '',
    email: '',
    phoneNumber: '',
    department: '',
    title: '',
  });

  React.useEffect(() => {
    if (userContext?.user) {
      setFormData({
        firstName: userContext.user.firstName || '',
        lastName: userContext.user.lastName || '',
        email: userContext.user.email || '',
        phoneNumber: '', // Phone number would need to be added to the user context
        department: '', // Department would need to be added to the user context
        title: '', // Title would need to be added to the user context
      });
    }
  }, [userContext]);

  const handleSave = async () => {
    setIsSaving(true);
    try {
      // In a real implementation, this would call a mutation to update the user profile
      await new Promise(resolve => setTimeout(resolve, 1000)); // Simulate API call
      setIsEditing(false);
    } catch (error) {
      console.error('Failed to save settings:', error);
    } finally {
      setIsSaving(false);
    }
  };

  const getRoleBadgeColor = (role: string) => {
    switch (role) {
      case 'owner':
        return 'bg-purple-100 text-purple-800 dark:bg-purple-900/70 dark:text-purple-300';
      case 'admin':
        return 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300';
      case 'manager':
        return 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300';
      case 'user':
        return 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300';
      case 'viewer':
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
      default:
        return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    }
  };

  if (!isClerkLoaded || isLoadingUser) {
    return (
      <div className="p-6">
        <LoadingSpinner />
      </div>
    );
  }

  if (!userContext?.user) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>
          Unable to load user information. Please try refreshing the page.
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="space-y-6">
      {/* Profile Section */}
      <Card>
        <CardHeader className="flex flex-row items-center justify-between">
          <div>
            <CardTitle className="flex items-center gap-2">
              <User className="h-5 w-5" />
              Profile Information
            </CardTitle>
            <p className="text-sm text-muted-foreground mt-1">
              Manage your personal information and account settings
            </p>
          </div>
          <Button
            variant={isEditing ? "outline" : "default"}
            size="sm"
            onClick={() => setIsEditing(!isEditing)}
          >
            <Edit className="h-4 w-4 mr-2" />
            {isEditing ? 'Cancel' : 'Edit'}
          </Button>
        </CardHeader>
        <CardContent className="space-y-6">
          {/* Profile Picture */}
          <div className="flex items-center gap-4">
            <div className="relative">
              <div className="w-20 h-20 rounded-full bg-primary/10 flex items-center justify-center">
                <span className="text-2xl font-semibold">
                  {userContext.user.firstName?.[0] || userContext.user.email[0]}
                  {userContext.user.lastName?.[0] || userContext.user.email[1] || ''}
                </span>
              </div>
              {isEditing && (
                <Button
                  size="sm"
                  variant="outline"
                  className="absolute -bottom-2 -right-2 h-8 w-8 rounded-full p-0"
                >
                  <Camera className="h-3 w-3" />
                </Button>
              )}
            </div>
            <div>
              <h3 className="font-medium">
                {userContext.user.firstName && userContext.user.lastName
                  ? `${userContext.user.firstName} ${userContext.user.lastName}`
                  : userContext.user.email}
              </h3>
              <div className="flex items-center gap-2 mt-1">
                <Badge className={getRoleBadgeColor(userContext.user.role)}>
                  {userContext.user.role.charAt(0).toUpperCase() + userContext.user.role.slice(1)}
                </Badge>
                {userContext.user.isActive ? (
                  <Badge variant="outline" className="text-green-600 border-green-200">
                    Active
                  </Badge>
                ) : (
                  <Badge variant="outline" className="text-red-600 border-red-200">
                    Inactive
                  </Badge>
                )}
              </div>
            </div>
          </div>

          <Separator />

          {/* Personal Information */}
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <div className="space-y-2">
              <Label htmlFor="firstName">First Name</Label>
              <Input
                id="firstName"
                value={formData.firstName}
                onChange={(e) => setFormData({ ...formData, firstName: e.target.value })}
                disabled={!isEditing}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="lastName">Last Name</Label>
              <Input
                id="lastName"
                value={formData.lastName}
                onChange={(e) => setFormData({ ...formData, lastName: e.target.value })}
                disabled={!isEditing}
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="email">Email Address</Label>
              <Input
                id="email"
                type="email"
                value={formData.email}
                disabled
                className="bg-muted"
              />
              <p className="text-xs text-muted-foreground">
                Email cannot be changed here. Update it in your account settings.
              </p>
            </div>
            <div className="space-y-2">
              <Label htmlFor="phone">Phone Number</Label>
              <Input
                id="phone"
                value={formData.phoneNumber}
                onChange={(e) => setFormData({ ...formData, phoneNumber: e.target.value })}
                disabled={!isEditing}
                placeholder="Enter phone number"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="department">Department</Label>
              <Input
                id="department"
                value={formData.department}
                onChange={(e) => setFormData({ ...formData, department: e.target.value })}
                disabled={!isEditing}
                placeholder="e.g. Engineering, Sales, Marketing"
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="title">Job Title</Label>
              <Input
                id="title"
                value={formData.title}
                onChange={(e) => setFormData({ ...formData, title: e.target.value })}
                disabled={!isEditing}
                placeholder="e.g. Software Engineer, Sales Manager"
              />
            </div>
          </div>

          {isEditing && (
            <>
              <Separator />
              <div className="flex justify-end gap-2">
                <Button variant="outline" onClick={() => setIsEditing(false)}>
                  Cancel
                </Button>
                <Button onClick={handleSave} disabled={isSaving}>
                  {isSaving ? (
                    <>
                      <div className="animate-spin rounded-full h-4 w-4 border-t-2 border-b-2 border-current mr-2"></div>
                      Saving...
                    </>
                  ) : (
                    <>
                      <Save className="h-4 w-4 mr-2" />
                      Save Changes
                    </>
                  )}
                </Button>
              </div>
            </>
          )}
        </CardContent>
      </Card>

      {/* Enterprise Information */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Building className="h-5 w-5" />
            Enterprise Information
          </CardTitle>
          <p className="text-sm text-muted-foreground">
            Information about your enterprise. Contact an admin to make changes.
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          {userContext.enterprise ? (
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div>
                <Label>Enterprise Name</Label>
                <p className="text-sm font-medium mt-1">{userContext.enterprise.name}</p>
              </div>
              <div>
                <Label>Domain</Label>
                <p className="text-sm font-medium mt-1">{userContext.enterprise.domain || 'Not set'}</p>
              </div>
            </div>
          ) : (
            <Alert>
              <AlertCircle className="h-4 w-4" />
              <AlertDescription>
                Enterprise information is not available.
              </AlertDescription>
            </Alert>
          )}
        </CardContent>
      </Card>

      {/* Account Security */}
      <Card>
        <CardHeader>
          <CardTitle className="flex items-center gap-2">
            <Shield className="h-5 w-5" />
            Account Security
          </CardTitle>
          <p className="text-sm text-muted-foreground">
            Manage your account security settings
          </p>
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="flex items-center justify-between p-4 border rounded-lg">
            <div>
              <h4 className="font-medium">Two-Factor Authentication</h4>
              <p className="text-sm text-muted-foreground">Add an extra layer of security to your account</p>
            </div>
            <Button variant="outline" size="sm">
              Configure
            </Button>
          </div>
          <div className="flex items-center justify-between p-4 border rounded-lg">
            <div>
              <h4 className="font-medium">Password</h4>
              <p className="text-sm text-muted-foreground">Change your account password</p>
            </div>
            <Button variant="outline" size="sm">
              Change Password
            </Button>
          </div>
          <div className="flex items-center justify-between p-4 border rounded-lg">
            <div>
              <h4 className="font-medium">Active Sessions</h4>
              <p className="text-sm text-muted-foreground">Manage devices that are signed into your account</p>
            </div>
            <Button variant="outline" size="sm">
              View Sessions
            </Button>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

export default GeneralSettingsPage;
</file>

<file path="src/app/dashboard/vendors/[id]/page.tsx">
'use client'

import React from 'react';
import { useParams } from 'next/navigation';
import { useUser } from '@clerk/nextjs';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../../convex/_generated/api';
import { Id } from '../../../../../convex/_generated/dataModel';
import VendorDetails from '@/app/_components/vendor/VendorDetails';
import LoadingSpinner from '@/app/_components/common/LoadingSpinner';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle } from 'lucide-react';

const VendorDetailsPage = () => {
  const params = useParams();
  const vendorId = params.id as Id<"vendors">;
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();

  // Get enterpriseId from Clerk user's public metadata
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch vendor data
  const { data: vendor, isLoading, error } = useConvexQuery(
    api.vendors.getVendorById,
    (vendorId && enterpriseId) ? { vendorId, enterpriseId } : "skip"
  );

  if (!isClerkLoaded || isLoading) {
    return (
      <div className="p-6">
        <LoadingSpinner />
      </div>
    );
  }

  if (!enterpriseId) {
    return (
      <div className="p-6">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Configuration Error</AlertTitle>
          <AlertDescription>
            Enterprise information is missing for your user account. Please contact support.
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  if (error || !vendor) {
    return (
      <div className="p-6">
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>Error</AlertTitle>
          <AlertDescription>
            {error ? `Failed to load vendor: ${error.message}` : 'Vendor not found or access denied.'}
          </AlertDescription>
        </Alert>
      </div>
    );
  }

  return (
    <div className="p-6">
      <VendorDetails vendor={vendor} />
    </div>
  );
};

export default VendorDetailsPage;
</file>

<file path="convex/_generated/api.js">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import { anyApi } from "convex/server";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
export const api = anyApi;
export const internal = anyApi;
</file>

<file path="convex/_generated/server.d.ts">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  ActionBuilder,
  HttpActionBuilder,
  MutationBuilder,
  QueryBuilder,
  GenericActionCtx,
  GenericMutationCtx,
  GenericQueryCtx,
  GenericDatabaseReader,
  GenericDatabaseWriter,
} from "convex/server";
import type { DataModel } from "./dataModel.js";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const query: QueryBuilder<DataModel, "public">;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export declare const internalQuery: QueryBuilder<DataModel, "internal">;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const mutation: MutationBuilder<DataModel, "public">;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export declare const internalMutation: MutationBuilder<DataModel, "internal">;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export declare const action: ActionBuilder<DataModel, "public">;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export declare const internalAction: ActionBuilder<DataModel, "internal">;

/**
 * Define an HTTP action.
 *
 * This function will be used to respond to HTTP requests received by a Convex
 * deployment if the requests matches the path and method where this action
 * is routed. Be sure to route your action in `convex/http.js`.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Import this function from `convex/http.js` and route it to hook it up.
 */
export declare const httpAction: HttpActionBuilder;

/**
 * A set of services for use within Convex query functions.
 *
 * The query context is passed as the first argument to any Convex query
 * function run on the server.
 *
 * This differs from the {@link MutationCtx} because all of the services are
 * read-only.
 */
export type QueryCtx = GenericQueryCtx<DataModel>;

/**
 * A set of services for use within Convex mutation functions.
 *
 * The mutation context is passed as the first argument to any Convex mutation
 * function run on the server.
 */
export type MutationCtx = GenericMutationCtx<DataModel>;

/**
 * A set of services for use within Convex action functions.
 *
 * The action context is passed as the first argument to any Convex action
 * function run on the server.
 */
export type ActionCtx = GenericActionCtx<DataModel>;

/**
 * An interface to read from the database within Convex query functions.
 *
 * The two entry points are {@link DatabaseReader.get}, which fetches a single
 * document by its {@link Id}, or {@link DatabaseReader.query}, which starts
 * building a query.
 */
export type DatabaseReader = GenericDatabaseReader<DataModel>;

/**
 * An interface to read from and write to the database within Convex mutation
 * functions.
 *
 * Convex guarantees that all writes within a single mutation are
 * executed atomically, so you never have to worry about partial writes leaving
 * your data in an inconsistent state. See [the Convex Guide](https://docs.convex.dev/understanding/convex-fundamentals/functions#atomicity-and-optimistic-concurrency-control)
 * for the guarantees Convex provides your functions.
 */
export type DatabaseWriter = GenericDatabaseWriter<DataModel>;
</file>

<file path="convex/agents/legal.ts">
// convex/agents/legal.ts
import { internalMutation, internalQuery } from "../_generated/server";
import { v } from "convex/values";
import { Id } from "../_generated/dataModel";

/**
 * Legal Agent
 * 
 * Responsibilities:
 * - Analyze contracts for legal compliance and risks
 * - Review contract terms and clauses for legal issues
 * - Monitor regulatory compliance requirements
 * - Identify missing or problematic legal provisions
 * - Track contract modifications and amendments
 * - Generate legal risk assessments and recommendations
 * - Monitor legal deadlines and obligations
 * - Ensure adherence to corporate legal policies
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const LEGAL_CONFIG = {
  // Processing settings
  checkIntervalMinutes: 10,
  batchSize: 8,
  analysisTimeoutMinutes: 15,
  
  // Legal review thresholds
  thresholds: {
    highRiskValue: 50000,
    criticalReviewValue: 250000,
    longTermMonths: 24,
    highLiabilityAmount: 100000,
  },
  
  // Risk scoring weights
  riskWeights: {
    contractType: 0.25,
    liability: 0.30,
    termination: 0.20,
    compliance: 0.15,
    intellectual_property: 0.10,
  },
  
  // Required clauses by contract type
  requiredClauses: {
    saas: [
      "data_protection", "service_level", "limitation_of_liability",
      "termination", "intellectual_property", "compliance"
    ],
    nda: [
      "confidentiality", "return_of_information", "term_duration",
      "remedies", "governing_law"
    ],
    employment: [
      "compensation", "termination", "confidentiality", 
      "non_compete", "intellectual_property", "benefits"
    ],
    partnership: [
      "profit_sharing", "decision_making", "termination",
      "liability", "intellectual_property", "dispute_resolution"
    ],
    msa: [
      "scope_of_work", "payment_terms", "intellectual_property",
      "limitation_of_liability", "termination", "confidentiality"
    ],
  },
  
  // Compliance frameworks to check
  complianceFrameworks: [
    "gdpr", "ccpa", "hipaa", "sox", "pci_dss", "iso27001"
  ],
  
  // High-risk terms that require attention
  highRiskTerms: [
    "unlimited liability", "perpetual", "non-cancelable",
    "automatic renewal", "indemnification", "liquidated damages",
    "specific performance", "injunctive relief"
  ],
  
  // Legal deadline types
  deadlineTypes: {
    renewal_notice: 30, // days before expiration
    termination_notice: 60,
    compliance_review: 90,
    legal_review: 180,
  },
};

// Extended metrics for legal agent
interface LegalAgentMetrics {
  totalRuns: number;
  successfulRuns: number;
  failedRuns: number;
  averageRunTime: number;
  lastRunDuration?: number;
  dataProcessed?: number;
  insightsGenerated?: number;
  // Legal-specific metrics
  contractsReviewed?: number;
  legalRisksIdentified?: number;
  complianceIssuesFound?: number;
  clausesAnalyzed?: number;
  deadlinesTracked?: number;
  amendmentsProcessed?: number;
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

export const run = internalMutation({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const startTime = Date.now();
    
    try {
      await ctx.db.insert("agentLogs", {
        agentId: args.agentId,
        level: "info",
        message: "Legal agent starting run",
        timestamp: new Date().toISOString(),
        category: "agent_execution",
      });

      await ctx.db.patch(args.agentId, {
        status: "busy",
        lastRun: new Date().toISOString(),
      });

      // Process assigned legal review tasks
      const tasksProcessed = await processLegalTasks(ctx, args.agentId);
      
      // Review contracts for legal compliance
      const complianceReviews = await reviewContractCompliance(ctx, args.agentId);
      
      // Analyze contract clauses and terms
      const clauseAnalysis = await analyzeContractClauses(ctx, args.agentId);
      
      // Monitor legal deadlines
      const deadlineAlerts = await monitorLegalDeadlines(ctx, args.agentId);
      
      // Check for regulatory compliance
      const regulatoryChecks = await checkRegulatoryCompliance(ctx, args.agentId);
      
      // Identify high-risk contract terms
      const riskTermsFound = await identifyHighRiskTerms(ctx, args.agentId);
      
      // Generate legal trend analysis
      await generateLegalTrendAnalysis(ctx, args.agentId);

      // Update metrics
      await updateAgentMetrics(ctx, args.agentId, {
        runTime: Date.now() - startTime,
        tasksProcessed,
        complianceReviews,
        clauseAnalysis,
        deadlineAlerts,
        regulatoryChecks,
        riskTermsFound,
      });

      return { 
        success: true, 
        tasksProcessed,
        totalInsights: complianceReviews + clauseAnalysis + deadlineAlerts + regulatoryChecks + riskTermsFound,
      };

    } catch (error) {
      await handleAgentError(ctx, args.agentId, error);
      throw error;
    }
  },
});

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

async function processLegalTasks(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  const tasks = await ctx.db
    .query("agentTasks")
    .withIndex("by_assigned_agent", (q: any) => q.eq("assignedAgentId", agentId))
    .filter((q: any) => q.eq(q.field("status"), "pending"))
    .take(LEGAL_CONFIG.batchSize);

  let processed = 0;

  for (const task of tasks) {
    try {
      await ctx.db.patch(task._id, {
        status: "in_progress",
        startedAt: new Date().toISOString(),
      });

      let result;
      switch (task.taskType) {
        case "legal_review":
          result = await performLegalReview(ctx, agentId, task);
          break;
        case "compliance_check":
          result = await performComplianceCheck(ctx, agentId, task);
          break;
        case "clause_analysis":
          result = await analyzeSpecificClauses(ctx, agentId, task);
          break;
        case "risk_assessment":
          result = await assessLegalRisk(ctx, agentId, task);
          break;
        case "amendment_review":
          result = await reviewAmendment(ctx, agentId, task);
          break;
        default:
          throw new Error(`Unknown legal task type: ${task.taskType}`);
      }

      await ctx.db.patch(task._id, {
        status: "completed",
        completedAt: new Date().toISOString(),
        result,
      });

      processed++;

    } catch (error) {
      await ctx.db.patch(task._id, {
        status: "failed",
        errorMessage: error instanceof Error ? error.message : String(error),
        completedAt: new Date().toISOString(),
      });

      await ctx.db.insert("agentLogs", {
        agentId,
        level: "error",
        message: `Failed to process legal task ${task._id}`,
        data: { taskId: task._id, error: error instanceof Error ? error.message : String(error) },
        timestamp: new Date().toISOString(),
        category: "task_processing",
      });
    }
  }

  return processed;
}

async function reviewContractCompliance(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let reviewsCreated = 0;

  // Get contracts needing legal review
  const contractsToReview = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => 
      q.and(
        q.eq(q.field("status"), "active"),
        q.or(
          q.eq(q.field("analysisStatus"), "completed"),
          q.eq(q.field("analysisStatus"), undefined)
        )
      )
    )
    .take(LEGAL_CONFIG.batchSize);

  for (const contract of contractsToReview) {
    // Check if already has recent legal review
    const existingReview = await ctx.db
      .query("agentInsights")
      .withIndex("by_contract", (q: any) => q.eq("contractId", contract._id))
      .filter((q: any) => 
        q.and(
          q.eq(q.field("type"), "legal_review"),
          q.gt(q.field("createdAt"), new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString())
        )
      )
      .first();

    if (existingReview) continue;

    const legalReview = await conductLegalReview(ctx, contract);
    
    if (legalReview.issues.length > 0 || legalReview.riskScore > 50) {
      reviewsCreated++;
      
      const priority = legalReview.riskScore > 75 ? "critical" : 
                      legalReview.riskScore > 50 ? "high" : "medium";

      await ctx.db.insert("agentInsights", {
        agentId,
        type: "legal_review",
        title: `Legal Review: ${contract.title || contract._id}`,
        description: `${legalReview.issues.length} legal issue(s) identified. Risk score: ${legalReview.riskScore}/100`,
        priority,
        contractId: contract._id,
        vendorId: contract.vendorId,
        actionRequired: legalReview.issues.some((i:any) => i.severity === "high"),
        actionTaken: false,
        isRead: false,
        createdAt: new Date().toISOString(),
        data: legalReview,
      });

      // Create task for high-priority issues
      if (priority === "critical" || priority === "high") {
        await createLegalActionTask(ctx, agentId, contract, legalReview);
      }
    }
  }

  return reviewsCreated;
}

async function analyzeContractClauses(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let analysisCreated = 0;

  const contracts = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => q.eq(q.field("status"), "active"))
    .take(LEGAL_CONFIG.batchSize);

  for (const contract of contracts) {
    const contractType = contract.contractType || "other";
    const requiredClauses = LEGAL_CONFIG.requiredClauses[contractType as keyof typeof LEGAL_CONFIG.requiredClauses] || [];
    
    if (requiredClauses.length === 0) continue;

    // Simulate clause analysis (in practice, would use AI/NLP)
    const clauseAnalysis = await analyzeContractForClauses(contract, requiredClauses);
    
    if (clauseAnalysis.missingClauses.length > 0 || clauseAnalysis.problematicClauses.length > 0) {
      analysisCreated++;
      
      const priority = clauseAnalysis.criticalMissing > 0 ? "high" : "medium";

      await ctx.db.insert("agentInsights", {
        agentId,
        type: "compliance_alert",
        title: `Clause Analysis: ${contract.title || contract._id}`,
        description: `${clauseAnalysis.missingClauses.length} missing clause(s) and ${clauseAnalysis.problematicClauses.length} problematic clause(s) found`,
        priority,
        contractId: contract._id,
        vendorId: contract.vendorId,
        actionRequired: clauseAnalysis.criticalMissing > 0,
        actionTaken: false,
        isRead: false,
        createdAt: new Date().toISOString(),
        data: clauseAnalysis,
      });
    }
  }

  return analysisCreated;
}

async function monitorLegalDeadlines(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let alertsCreated = 0;

  const activeContracts = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => q.eq(q.field("status"), "active"))
    .collect();

  for (const contract of activeContracts) {
    const deadlines = calculateLegalDeadlines(contract);
    
    for (const deadline of deadlines) {
      if (deadline.daysUntil <= deadline.warningDays && deadline.daysUntil > 0) {
        // Check if alert already exists
        const existingAlert = await ctx.db
          .query("agentInsights")
          .withIndex("by_contract", (q: any) => q.eq("contractId", contract._id))
          .filter((q: any) => 
            q.and(
              q.eq(q.field("type"), "alert"),
              q.eq(q.field("actionTaken"), false),
              q.gte(q.field("createdAt"), new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString())
            )
          )
          .first();

        if (!existingAlert) {
          alertsCreated++;
          
          await ctx.db.insert("agentInsights", {
            agentId,
            type: "alert",
            title: `Legal Deadline Approaching: ${deadline.type}`,
            description: `${deadline.description} for contract "${contract.title}" is due in ${deadline.daysUntil} days`,
            priority: deadline.daysUntil <= 7 ? "critical" : "high",
            contractId: contract._id,
            vendorId: contract.vendorId,
            actionRequired: true,
            actionTaken: false,
            isRead: false,
            createdAt: new Date().toISOString(),
            data: {
              deadlineType: deadline.type,
              dueDate: deadline.dueDate,
              daysUntil: deadline.daysUntil,
              requiredAction: deadline.requiredAction,
            },
          });
        }
      }
    }
  }

  return alertsCreated;
}

async function checkRegulatoryCompliance(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let complianceIssues = 0;

  const contracts = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => q.eq(q.field("status"), "active"))
    .take(LEGAL_CONFIG.batchSize);

  for (const contract of contracts) {
    const complianceCheck = await performRegulatoryComplianceCheck(contract);
    
    if (complianceCheck.violations.length > 0) {
      complianceIssues++;
      
      const severity = complianceCheck.violations.some((v:any) => v.severity === "critical") ? "critical" :
                      complianceCheck.violations.some((v:any) => v.severity === "high") ? "high" : "medium";

      await ctx.db.insert("agentInsights", {
        agentId,
        type: "compliance_alert",
        title: `Regulatory Compliance Issues: ${contract.title || contract._id}`,
        description: `${complianceCheck.violations.length} compliance violation(s) detected`,
        priority: severity,
        contractId: contract._id,
        vendorId: contract.vendorId,
        actionRequired: true,
        actionTaken: false,
        isRead: false,
        createdAt: new Date().toISOString(),
        data: complianceCheck,
      });

      // Create compliance remediation task
      await createComplianceTask(ctx, agentId, contract, complianceCheck);
    }
  }

  return complianceIssues;
}

async function identifyHighRiskTerms(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let riskTermsFound = 0;

  const contracts = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => q.eq(q.field("status"), "active"))
    .take(LEGAL_CONFIG.batchSize);

  for (const contract of contracts) {
    const riskAnalysis = await analyzeHighRiskTerms(contract);
    
    if (riskAnalysis.highRiskTerms.length > 0) {
      riskTermsFound++;
      
      const priority = riskAnalysis.criticalTerms > 0 ? "critical" : "high";

      await ctx.db.insert("agentInsights", {
        agentId,
        type: "legal_review",
        title: `High-Risk Terms Detected: ${contract.title || contract._id}`,
        description: `${riskAnalysis.highRiskTerms.length} high-risk legal term(s) require review`,
        priority,
        contractId: contract._id,
        vendorId: contract.vendorId,
        actionRequired: true,
        actionTaken: false,
        isRead: false,
        createdAt: new Date().toISOString(),
        data: riskAnalysis,
      });
    }
  }

  return riskTermsFound;
}

async function generateLegalTrendAnalysis(
  ctx: any,
  agentId: Id<"agents">
): Promise<void> {
  const sixMonthsAgo = new Date(Date.now() - 180 * 24 * 60 * 60 * 1000).toISOString();
  
  // Get recent legal insights
  const recentInsights = await ctx.db
    .query("agentInsights")
    .filter((q: any) => 
      q.and(
        q.eq(q.field("agentId"), agentId),
        q.gt(q.field("createdAt"), sixMonthsAgo)
      )
    )
    .collect();

  if (recentInsights.length < 10) return;

  // Analyze trends
  const trendAnalysis = {
    totalIssues: recentInsights.length,
    byType: {} as Record<string, number>,
    byPriority: {} as Record<string, number>,
    topRisks: [] as string[],
    recommendations: [] as string[],
  };

  // Group by type and priority
  for (const insight of recentInsights) {
    trendAnalysis.byType[insight.type] = (trendAnalysis.byType[insight.type] || 0) + 1;
    trendAnalysis.byPriority[insight.priority] = (trendAnalysis.byPriority[insight.priority] || 0) + 1;
  }

  // Generate recommendations based on trends
  const mostCommonType = Object.entries(trendAnalysis.byType)
    .sort(([,a], [,b]) => b - a)[0];
  
  if (mostCommonType && mostCommonType[1] > recentInsights.length * 0.3) {
    trendAnalysis.recommendations.push(
      `High frequency of ${mostCommonType[0]} issues suggests need for template review and standardization`
    );
  }

  if (trendAnalysis.byPriority.critical && trendAnalysis.byPriority.critical > 5) {
    trendAnalysis.recommendations.push(
      "Multiple critical legal issues indicate need for enhanced contract review process"
    );
  }

  await ctx.db.insert("agentInsights", {
    agentId,
    type: "trend_analysis",
    title: "Legal Risk Trends (6-Month Analysis)",
    description: `Analysis of ${recentInsights.length} legal insights reveals key risk patterns and improvement opportunities`,
    priority: "low",
    actionRequired: trendAnalysis.recommendations.length > 0,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: trendAnalysis,
  });
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

async function conductLegalReview(ctx: any, contract: any): Promise<any> {
  const review = {
    riskScore: 0,
    issues: [] as any[],
    recommendations: [] as string[],
    complianceStatus: "compliant" as string,
  };

  // Check contract value risk
  const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
  if (value > LEGAL_CONFIG.thresholds.criticalReviewValue) {
    review.riskScore += 25;
    review.issues.push({
      type: "high_value_risk",
      severity: "high",
      description: "High-value contract requires enhanced legal oversight",
      recommendation: "Implement additional approval layers and legal review checkpoints"
    });
  }

  // Check contract duration
  if (contract.extractedStartDate && contract.extractedEndDate) {
    const duration = Math.ceil(
      (new Date(contract.extractedEndDate).getTime() - new Date(contract.extractedStartDate).getTime()) / 
      (1000 * 60 * 60 * 24 * 30)
    );
    
    if (duration > LEGAL_CONFIG.thresholds.longTermMonths) {
      review.riskScore += 15;
      review.issues.push({
        type: "long_term_commitment",
        severity: "medium",
        description: `Long-term contract (${duration} months) creates extended legal obligations`,
        recommendation: "Include periodic review clauses and termination options"
      });
    }
  }

  // Check for required legal elements based on contract type
  const contractType = contract.contractType || "other";
  const missingElements = await checkRequiredLegalElements(contract, contractType);
  
  if (missingElements.length > 0) {
    review.riskScore += missingElements.length * 10;
    review.issues.push({
      type: "missing_legal_elements",
      severity: "medium",
      description: `Missing required legal elements: ${missingElements.join(', ')}`,
      recommendation: "Add missing legal provisions to ensure comprehensive protection"
    });
  }

  // Set overall compliance status
  if (review.riskScore > 75) {
    review.complianceStatus = "non_compliant";
  } else if (review.riskScore > 50) {
    review.complianceStatus = "requires_attention";
  }

  return review;
}

async function analyzeContractForClauses(contract: any, requiredClauses: string[]): Promise<any> {
  const analysis = {
    missingClauses: [] as string[],
    problematicClauses: [] as any[],
    criticalMissing: 0,
    recommendations: [] as string[],
  };

  // Simulate clause detection (in practice, would use AI/NLP)
  const contractText = [
    contract.extractedScope || '',
    contract.extractedPaymentSchedule || '',
    contract.notes || ''
  ].join(' ').toLowerCase();

  // Check for required clauses
  for (const clause of requiredClauses) {
    const clauseKeywords = getClauseKeywords(clause);
    const hasClause = clauseKeywords.some(keyword => contractText.includes(keyword));
    
    if (!hasClause) {
      analysis.missingClauses.push(clause);
      if (isCriticalClause(clause)) {
        analysis.criticalMissing++;
      }
    }
  }

  // Check for problematic terms
  for (const riskTerm of LEGAL_CONFIG.highRiskTerms) {
    if (contractText.includes(riskTerm.toLowerCase())) {
      analysis.problematicClauses.push({
        term: riskTerm,
        severity: "high",
        concern: `Contains high-risk term: "${riskTerm}"`,
        recommendation: `Review and consider modifying "${riskTerm}" clause`
      });
    }
  }

  // Generate recommendations
  if (analysis.criticalMissing > 0) {
    analysis.recommendations.push("Add critical missing clauses before contract execution");
  }
  if (analysis.problematicClauses.length > 0) {
    analysis.recommendations.push("Review and modify high-risk terms to reduce legal exposure");
  }

  return analysis;
}

function calculateLegalDeadlines(contract: any): any[] {
  const deadlines = [];
  const now = new Date();

  if (contract.extractedEndDate) {
    const endDate = new Date(contract.extractedEndDate);
    
    // Renewal notice deadline
    const renewalNoticeDate = new Date(endDate);
    renewalNoticeDate.setDate(renewalNoticeDate.getDate() - LEGAL_CONFIG.deadlineTypes.renewal_notice);
    
    if (renewalNoticeDate > now) {
      deadlines.push({
        type: "renewal_notice",
        description: "Contract renewal notice",
        dueDate: renewalNoticeDate.toISOString(),
        daysUntil: Math.ceil((renewalNoticeDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)),
        warningDays: 14,
        requiredAction: "Review contract for renewal or provide termination notice"
      });
    }

    // Termination notice deadline
    const terminationNoticeDate = new Date(endDate);
    terminationNoticeDate.setDate(terminationNoticeDate.getDate() - LEGAL_CONFIG.deadlineTypes.termination_notice);
    
    if (terminationNoticeDate > now) {
      deadlines.push({
        type: "termination_notice",
        description: "Contract termination notice deadline",
        dueDate: terminationNoticeDate.toISOString(),
        daysUntil: Math.ceil((terminationNoticeDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)),
        warningDays: 21,
        requiredAction: "Decide on contract continuation or provide termination notice"
      });
    }
  }

  // Legal review deadline (periodic)
  const lastReviewDate = contract._creationTime ? new Date(contract._creationTime) : now;
  const nextReviewDate = new Date(lastReviewDate);
  nextReviewDate.setDate(nextReviewDate.getDate() + LEGAL_CONFIG.deadlineTypes.legal_review);
  
  if (nextReviewDate > now) {
    deadlines.push({
      type: "legal_review",
      description: "Periodic legal review",
      dueDate: nextReviewDate.toISOString(),
      daysUntil: Math.ceil((nextReviewDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)),
      warningDays: 30,
      requiredAction: "Conduct comprehensive legal review of contract terms"
    });
  }

  return deadlines;
}

async function performRegulatoryComplianceCheck(contract: any): Promise<any> {
  const complianceCheck = {
    violations: [] as any[],
    frameworks: [] as string[],
    recommendations: [] as string[],
  };

  const contractText = [
    contract.extractedScope || '',
    contract.notes || '',
    contract.title || ''
  ].join(' ').toLowerCase();

  // Check GDPR compliance for data processing contracts
  if (contractText.includes('data') || contractText.includes('personal') || contract.contractType === 'saas') {
    const gdprCompliant = checkGDPRCompliance(contractText);
    if (!gdprCompliant.compliant) {
      complianceCheck.violations.push({
        framework: "GDPR",
        severity: "high",
        violation: gdprCompliant.issue,
        requirement: "Data processing agreements must include GDPR-compliant terms"
      });
    }
    complianceCheck.frameworks.push("GDPR");
  }

  // Check financial compliance for high-value contracts
  const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
  if (value > 10000) {
    const financialCompliant = checkFinancialCompliance(contractText);
    if (!financialCompliant.compliant) {
      complianceCheck.violations.push({
        framework: "Financial",
        severity: "medium",
        violation: financialCompliant.issue,
        requirement: "High-value contracts require financial compliance measures"
      });
    }
  }

  // Generate recommendations
  if (complianceCheck.violations.length > 0) {
    complianceCheck.recommendations.push("Review contract against applicable regulatory frameworks");
    complianceCheck.recommendations.push("Consult legal counsel for compliance remediation");
  }

  return complianceCheck;
}

async function analyzeHighRiskTerms(contract: any): Promise<any> {
  const analysis = {
    highRiskTerms: [] as any[],
    criticalTerms: 0,
    riskScore: 0,
    recommendations: [] as string[],
  };

  const contractText = [
    contract.extractedScope || '',
    contract.extractedPaymentSchedule || '',
    contract.notes || ''
  ].join(' ').toLowerCase();

  // Check for each high-risk term
  for (const term of LEGAL_CONFIG.highRiskTerms) {
    if (contractText.includes(term.toLowerCase())) {
      const severity = assessTermSeverity(term);
      
      analysis.highRiskTerms.push({
        term,
        severity,
        context: extractTermContext(contractText, term),
        impact: getTermImpactDescription(term),
        recommendation: getTermRecommendation(term)
      });

      if (severity === "critical") {
        analysis.criticalTerms++;
        analysis.riskScore += 30;
      } else if (severity === "high") {
        analysis.riskScore += 20;
      } else {
        analysis.riskScore += 10;
      }
    }
  }

  // Generate overall recommendations
  if (analysis.criticalTerms > 0) {
    analysis.recommendations.push("Immediately review critical risk terms with legal counsel");
    analysis.recommendations.push("Consider contract renegotiation to mitigate critical risks");
  }
  
  if (analysis.riskScore > 50) {
    analysis.recommendations.push("Implement additional risk mitigation measures");
    analysis.recommendations.push("Require enhanced approval process for this contract");
  }

  return analysis;
}

// ============================================================================
// TASK PROCESSING FUNCTIONS
// ============================================================================

async function performLegalReview(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for legal review");
  }

  const review = await conductLegalReview(ctx, contract);
  
  // Create detailed legal assessment
  const legalAssessment = {
    contractId: contract._id,
    reviewDate: new Date().toISOString(),
    reviewer: "Legal Agent",
    overallRisk: review.riskScore,
    riskLevel: review.riskScore > 75 ? "high" : review.riskScore > 50 ? "medium" : "low",
    issues: review.issues,
    recommendations: review.recommendations,
    complianceStatus: review.complianceStatus,
    nextReviewDate: new Date(Date.now() + 180 * 24 * 60 * 60 * 1000).toISOString(), // 6 months
  };

  return legalAssessment;
}

async function performComplianceCheck(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for compliance check");
  }

  const complianceCheck = await performRegulatoryComplianceCheck(contract);
  
  const complianceAssessment = {
    contractId: contract._id,
    checkDate: new Date().toISOString(),
    frameworksChecked: complianceCheck.frameworks,
    violations: complianceCheck.violations,
    overallStatus: complianceCheck.violations.length === 0 ? "compliant" : "non_compliant",
    remediation: complianceCheck.recommendations,
    nextCheckDate: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(), // 3 months
  };

  return complianceAssessment;
}

async function analyzeSpecificClauses(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for clause analysis");
  }

  const contractType = contract.contractType || "other";
  const requiredClauses = LEGAL_CONFIG.requiredClauses[contractType as keyof typeof LEGAL_CONFIG.requiredClauses] || [];
  
  const clauseAnalysis = await analyzeContractForClauses(contract, requiredClauses);
  
  const analysis = {
    contractId: contract._id,
    contractType,
    analysisDate: new Date().toISOString(),
    requiredClauses,
    foundClauses: requiredClauses.filter(clause => !clauseAnalysis.missingClauses.includes(clause)),
    missingClauses: clauseAnalysis.missingClauses,
    problematicClauses: clauseAnalysis.problematicClauses,
    completenessScore: ((requiredClauses.length - clauseAnalysis.missingClauses.length) / requiredClauses.length) * 100,
    recommendations: clauseAnalysis.recommendations,
  };

  return analysis;
}

async function assessLegalRisk(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for legal risk assessment");
  }

  const riskAssessment = {
    contractId: contract._id,
    assessmentDate: new Date().toISOString(),
    riskFactors: [] as any[],
    overallRiskScore: 0,
    riskLevel: "low" as string,
    mitigationStrategies: [] as string[],
  };

  // Assess contract value risk
  const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
  if (value > 0) {
    const valueRisk = assessValueRisk(value);
    riskAssessment.riskFactors.push(valueRisk);
    riskAssessment.overallRiskScore += valueRisk.score;
  }

  // Assess duration risk
  if (contract.extractedStartDate && contract.extractedEndDate) {
    const durationRisk = assessDurationRisk(contract.extractedStartDate, contract.extractedEndDate);
    riskAssessment.riskFactors.push(durationRisk);
    riskAssessment.overallRiskScore += durationRisk.score;
  }

  // Assess contractual complexity risk
  const complexityRisk = assessContractComplexity(contract);
  riskAssessment.riskFactors.push(complexityRisk);
  riskAssessment.overallRiskScore += complexityRisk.score;

  // Determine risk level
  if (riskAssessment.overallRiskScore > 75) {
    riskAssessment.riskLevel = "critical";
  } else if (riskAssessment.overallRiskScore > 50) {
    riskAssessment.riskLevel = "high";
  } else if (riskAssessment.overallRiskScore > 25) {
    riskAssessment.riskLevel = "medium";
  }

  // Generate mitigation strategies
  riskAssessment.mitigationStrategies = generateMitigationStrategies(riskAssessment.riskFactors);

  return riskAssessment;
}

async function reviewAmendment(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for amendment review");
  }

  // Simulate amendment review (would need amendment data in practice)
  const amendmentReview = {
    contractId: contract._id,
    reviewDate: new Date().toISOString(),
    amendmentType: task.data?.amendmentType || "modification",
    changes: task.data?.changes || [],
    legalImpact: "medium",
    approvalRequired: true,
    risks: [] as string[],
    recommendations: [] as string[],
  };

  // Assess amendment impact
  if (task.data?.changes) {
    for (const change of task.data.changes) {
      if (change.type === "pricing") {
        amendmentReview.risks.push("Pricing changes may affect budget and financial commitments");
      } else if (change.type === "scope") {
        amendmentReview.risks.push("Scope changes may impact deliverables and timeline");
      } else if (change.type === "termination") {
        amendmentReview.risks.push("Termination clause changes affect contract exit strategy");
      }
    }
  }

  // Generate recommendations
  if (amendmentReview.risks.length > 0) {
    amendmentReview.recommendations.push("Review amendment impact on overall contract risk profile");
    amendmentReview.recommendations.push("Ensure amendment aligns with organizational policies");
  }

  return amendmentReview;
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

async function createLegalActionTask(ctx: any, agentId: Id<"agents">, contract: any, legalReview: any): Promise<void> {
  // Create task for legal team or workflow agent
  const workflowAgent = await ctx.db
    .query("agents")
    .withIndex("by_type", (q: any) => q.eq("type", "workflow"))
    .first();

  if (workflowAgent) {
    await ctx.db.insert("agentTasks", {
      assignedAgentId: workflowAgent._id,
      createdByAgentId: agentId,
      taskType: "legal_action_required",
      status: "pending",
      priority: legalReview.riskScore > 75 ? "critical" : "high",
      title: `Legal Action Required: ${contract.title}`,
      description: `Contract requires legal attention due to ${legalReview.issues.length} identified issues`,
      contractId: contract._id,
      vendorId: contract.vendorId,
      data: {
        actionType: "legal_review",
        issues: legalReview.issues,
        recommendations: legalReview.recommendations,
        urgency: legalReview.riskScore > 75 ? "critical" : "high",
      },
      createdAt: new Date().toISOString(),
    });
  }
}

async function createComplianceTask(ctx: any, agentId: Id<"agents">, contract: any, complianceCheck: any): Promise<void> {
  // Create task for compliance agent
  const complianceAgent = await ctx.db
    .query("agents")
    .withIndex("by_type", (q: any) => q.eq("type", "compliance"))
    .first();

  if (complianceAgent) {
    await ctx.db.insert("agentTasks", {
      assignedAgentId: complianceAgent._id,
      createdByAgentId: agentId,
      taskType: "compliance_remediation",
      status: "pending",
      priority: complianceCheck.violations.some((v: any) => v.severity === "critical") ? "critical" : "high",
      title: `Compliance Remediation: ${contract.title}`,
      description: `Address ${complianceCheck.violations.length} compliance violations`,
      contractId: contract._id,
      vendorId: contract.vendorId,
      data: {
        violations: complianceCheck.violations,
        frameworks: complianceCheck.frameworks,
        recommendations: complianceCheck.recommendations,
      },
      createdAt: new Date().toISOString(),
    });
  }
}

async function checkRequiredLegalElements(contract: any, contractType: string): Promise<string[]> {
  const missingElements = [];
  const contractText = [
    contract.extractedScope || '',
    contract.extractedPaymentSchedule || '',
    contract.notes || ''
  ].join(' ').toLowerCase();

  // Basic legal elements every contract should have
  const basicElements = [
    { name: "governing_law", keywords: ["governing law", "jurisdiction", "laws of"] },
    { name: "dispute_resolution", keywords: ["dispute", "arbitration", "mediation", "court"] },
    { name: "force_majeure", keywords: ["force majeure", "acts of god", "unforeseeable"] },
    { name: "entire_agreement", keywords: ["entire agreement", "complete agreement", "supersedes"] },
  ];

  for (const element of basicElements) {
    const hasElement = element.keywords.some(keyword => contractText.includes(keyword));
    if (!hasElement) {
      missingElements.push(element.name);
    }
  }

  return missingElements;
}

function getClauseKeywords(clause: string): string[] {
  const keywordMap: Record<string, string[]> = {
    data_protection: ["data protection", "privacy", "gdpr", "personal data"],
    service_level: ["service level", "sla", "uptime", "availability"],
    limitation_of_liability: ["limitation of liability", "liability cap", "damages"],
    termination: ["termination", "end", "expire", "cancel"],
    intellectual_property: ["intellectual property", "ip", "copyright", "trademark"],
    compliance: ["compliance", "regulatory", "standards", "certification"],
    confidentiality: ["confidentiality", "non-disclosure", "proprietary", "confidential"],
    return_of_information: ["return", "destroy", "delete", "confidential information"],
    term_duration: ["term", "duration", "period", "expires"],
    remedies: ["remedies", "damages", "injunction", "specific performance"],
    governing_law: ["governing law", "jurisdiction", "applicable law"],
    compensation: ["compensation", "salary", "wage", "payment"],
    non_compete: ["non-compete", "non-competition", "restraint of trade"],
    benefits: ["benefits", "insurance", "vacation", "health"],
    profit_sharing: ["profit sharing", "profits", "revenue sharing"],
    decision_making: ["decision making", "voting", "management", "control"],
    liability: ["liability", "responsible", "damages", "indemnification"],
    dispute_resolution: ["dispute resolution", "arbitration", "mediation"],
    scope_of_work: ["scope of work", "deliverables", "services", "work"],
    payment_terms: ["payment terms", "invoice", "billing", "payment schedule"],
  };

  return keywordMap[clause] || [clause];
}

function isCriticalClause(clause: string): boolean {
  const criticalClauses = [
    "limitation_of_liability",
    "termination",
    "intellectual_property",
    "data_protection",
    "governing_law",
    "confidentiality"
  ];
  return criticalClauses.includes(clause);
}

function checkGDPRCompliance(contractText: string): { compliant: boolean; issue?: string } {
  const gdprKeywords = ["data protection", "gdpr", "personal data", "data subject", "data controller"];
  const hasGDPRTerms = gdprKeywords.some(keyword => contractText.includes(keyword));
  
  if (contractText.includes('data') && !hasGDPRTerms) {
    return {
      compliant: false,
      issue: "Contract involves data processing but lacks GDPR compliance terms"
    };
  }
  
  return { compliant: true };
}

function checkFinancialCompliance(contractText: string): { compliant: boolean; issue?: string } {
  const financialKeywords = ["audit", "financial records", "books and records", "compliance"];
  const hasFinancialTerms = financialKeywords.some(keyword => contractText.includes(keyword));
  
  if (!hasFinancialTerms) {
    return {
      compliant: false,
      issue: "High-value contract lacks financial compliance and audit provisions"
    };
  }
  
  return { compliant: true };
}

function assessTermSeverity(term: string): "critical" | "high" | "medium" {
  const criticalTerms = ["unlimited liability", "perpetual", "non-cancelable"];
  const highTerms = ["automatic renewal", "indemnification", "liquidated damages"];
  
  if (criticalTerms.includes(term.toLowerCase())) return "critical";
  if (highTerms.includes(term.toLowerCase())) return "high";
  return "medium";
}

function extractTermContext(contractText: string, term: string): string {
  const termIndex = contractText.toLowerCase().indexOf(term.toLowerCase());
  if (termIndex === -1) return "";
  
  const start = Math.max(0, termIndex - 50);
  const end = Math.min(contractText.length, termIndex + term.length + 50);
  
  return "..." + contractText.substring(start, end) + "...";
}

function getTermImpactDescription(term: string): string {
  const impactMap: Record<string, string> = {
    "unlimited liability": "Exposes organization to unlimited financial risk",
    "perpetual": "Creates indefinite obligations with no clear end date",
    "non-cancelable": "Prevents contract termination regardless of circumstances",
    "automatic renewal": "Contract renews automatically without explicit approval",
    "indemnification": "Requires covering third-party claims and damages",
    "liquidated damages": "Specifies predetermined penalty amounts for breach",
    "specific performance": "May require completion of obligations rather than monetary damages",
    "injunctive relief": "Allows court orders to prevent certain actions",
  };
  
  return impactMap[term.toLowerCase()] || "Requires legal review for potential risks";
}

function getTermRecommendation(term: string): string {
  const recommendationMap: Record<string, string> = {
    "unlimited liability": "Negotiate liability caps and limitations",
    "perpetual": "Add termination clauses with reasonable notice periods",
    "non-cancelable": "Include termination rights for cause and convenience",
    "automatic renewal": "Require explicit approval for renewals",
    "indemnification": "Limit scope and add mutual indemnification provisions",
    "liquidated damages": "Ensure damages are reasonable and proportionate",
    "specific performance": "Limit to appropriate circumstances only",
    "injunctive relief": "Restrict to protection of confidential information",
  };
  
  return recommendationMap[term.toLowerCase()] || "Review term with legal counsel";
}

function assessValueRisk(value: number): any {
  let score = 0;
  let riskLevel = "low";
  let description = "";

  if (value > LEGAL_CONFIG.thresholds.criticalReviewValue) {
    score = 30;
    riskLevel = "critical";
    description = "Extremely high contract value requires comprehensive legal oversight";
  } else if (value > LEGAL_CONFIG.thresholds.highRiskValue) {
    score = 20;
    riskLevel = "high";
    description = "High contract value increases financial exposure";
  } else if (value > 10000) {
    score = 10;
    riskLevel = "medium";
    description = "Moderate contract value requires standard legal review";
  } else {
    score = 5;
    riskLevel = "low";
    description = "Low contract value presents minimal financial risk";
  }

  return {
    factor: "contract_value",
    score,
    riskLevel,
    description,
    value,
  };
}

function assessDurationRisk(startDate: string, endDate: string): any {
  const duration = Math.ceil(
    (new Date(endDate).getTime() - new Date(startDate).getTime()) / 
    (1000 * 60 * 60 * 24 * 30)
  );

  let score = 0;
  let riskLevel = "low";
  let description = "";

  if (duration > 60) { // 5+ years
    score = 25;
    riskLevel = "high";
    description = "Very long-term commitment creates significant legal obligations";
  } else if (duration > LEGAL_CONFIG.thresholds.longTermMonths) {
    score = 15;
    riskLevel = "medium";
    description = "Long-term contract increases legal complexity";
  } else if (duration > 12) {
    score = 10;
    riskLevel = "low";
    description = "Multi-year contract requires periodic review";
  } else {
    score = 5;
    riskLevel = "low";
    description = "Short-term contract presents minimal duration risk";
  }

  return {
    factor: "contract_duration",
    score,
    riskLevel,
    description,
    durationMonths: duration,
  };
}

function assessContractComplexity(contract: any): any {
  let complexityScore = 0;
  let description = "Standard contract complexity";

  // Check for multiple parties
  if (contract.extractedParties && contract.extractedParties.length > 2) {
    complexityScore += 10;
    description = "Multi-party contract increases legal complexity";
  }

  // Check for complex payment terms
  if (contract.extractedPaymentSchedule && contract.extractedPaymentSchedule.length > 100) {
    complexityScore += 10;
  }

  // Check for complex scope
  if (contract.extractedScope && contract.extractedScope.length > 500) {
    complexityScore += 10;
  }

  const riskLevel = complexityScore > 20 ? "high" : complexityScore > 10 ? "medium" : "low";

  return {
    factor: "contract_complexity",
    score: Math.min(complexityScore, 25), // Cap at 25
    riskLevel,
    description,
    complexityFactors: complexityScore / 10,
  };
}

function generateMitigationStrategies(riskFactors: any[]): string[] {
  const strategies = [];

  for (const factor of riskFactors) {
    switch (factor.factor) {
      case "contract_value":
        if (factor.riskLevel === "critical" || factor.riskLevel === "high") {
          strategies.push("Implement milestone-based payments to reduce financial exposure");
          strategies.push("Require performance bonds or guarantees");
          strategies.push("Add enhanced termination rights for non-performance");
        }
        break;
      
      case "contract_duration":
        if (factor.riskLevel === "high" || factor.riskLevel === "medium") {
          strategies.push("Include periodic review and adjustment clauses");
          strategies.push("Add early termination rights with reasonable notice");
          strategies.push("Implement performance benchmarks for long-term contracts");
        }
        break;
      
      case "contract_complexity":
        if (factor.riskLevel === "high") {
          strategies.push("Simplify contract structure where possible");
          strategies.push("Create detailed implementation timeline");
          strategies.push("Establish clear communication protocols");
        }
        break;
    }
  }

  // Add general strategies for high-risk contracts
  const highRiskFactors = riskFactors.filter(f => f.riskLevel === "critical" || f.riskLevel === "high");
  if (highRiskFactors.length > 0) {
    strategies.push("Require board or senior management approval");
    strategies.push("Conduct enhanced due diligence on counterparty");
    strategies.push("Consider obtaining legal opinions on key terms");
  }

  return [...new Set(strategies)]; // Remove duplicates
}

async function updateAgentMetrics(
  ctx: any,
  agentId: Id<"agents">,
  runData: {
    runTime: number;
    tasksProcessed: number;
    complianceReviews: number;
    clauseAnalysis: number;
    deadlineAlerts: number;
    regulatoryChecks: number;
    riskTermsFound: number;
  }
): Promise<void> {
  const agent = await ctx.db.get(agentId);
  if (!agent) return;

  const existingMetrics = (agent.metrics as LegalAgentMetrics) || {
    totalRuns: 0,
    successfulRuns: 0,
    failedRuns: 0,
    averageRunTime: 0,
    contractsReviewed: 0,
    legalRisksIdentified: 0,
    complianceIssuesFound: 0,
    clausesAnalyzed: 0,
    deadlinesTracked: 0,
    amendmentsProcessed: 0,
  };

  const newMetrics: LegalAgentMetrics = {
    ...existingMetrics,
    totalRuns: existingMetrics.totalRuns + 1,
    successfulRuns: existingMetrics.successfulRuns + 1,
    averageRunTime: 
      ((existingMetrics.averageRunTime * existingMetrics.totalRuns) + runData.runTime) / 
      (existingMetrics.totalRuns + 1),
    lastRunDuration: runData.runTime,
    contractsReviewed: (existingMetrics.contractsReviewed || 0) + runData.tasksProcessed,
    legalRisksIdentified: (existingMetrics.legalRisksIdentified || 0) + runData.riskTermsFound,
    complianceIssuesFound: (existingMetrics.complianceIssuesFound || 0) + runData.regulatoryChecks,
    clausesAnalyzed: (existingMetrics.clausesAnalyzed || 0) + runData.clauseAnalysis,
    deadlinesTracked: (existingMetrics.deadlinesTracked || 0) + runData.deadlineAlerts,
    insightsGenerated: (existingMetrics.insightsGenerated || 0) + 
      runData.complianceReviews + runData.clauseAnalysis + runData.deadlineAlerts + runData.regulatoryChecks + runData.riskTermsFound,
  };

  await ctx.db.patch(agentId, {
    status: "active",
    lastSuccess: new Date().toISOString(),
    runCount: (agent.runCount || 0) + 1,
    metrics: newMetrics,
  });
}

async function handleAgentError(ctx: any, agentId: Id<"agents">, error: any): Promise<void> {
  await ctx.db.insert("agentLogs", {
    agentId,
    level: "error",
    message: "Legal agent failed",
    data: { error: error instanceof Error ? error.message : String(error) },
    timestamp: new Date().toISOString(),
    category: "agent_execution",
  });

  const agent = await ctx.db.get(agentId);
  if (agent) {
    const existingMetrics = (agent.metrics as LegalAgentMetrics) || {
      totalRuns: 0,
      successfulRuns: 0,
      failedRuns: 0,
      averageRunTime: 0,
    };

    await ctx.db.patch(agentId, {
      status: "error",
      errorCount: (agent.errorCount || 0) + 1,
      lastError: error instanceof Error ? error.message : String(error),
      metrics: {
        ...existingMetrics,
        totalRuns: existingMetrics.totalRuns + 1,
        failedRuns: existingMetrics.failedRuns + 1,
      },
    });
  }
}

// ============================================================================
// QUERY FUNCTIONS
// ============================================================================

export const getLegalInsights = internalQuery({
  args: {
    contractId: v.optional(v.id("contracts")),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let query = ctx.db.query("agentInsights");
    
    if (args.contractId) {
      //@ts-ignore
      query = query.withIndex("by_contract", (q: any) => q.eq("contractId", args.contractId));
    }
    
    const insights = await query
      .filter((q: any) => 
        q.or(
          q.eq(q.field("type"), "legal_review"),
          q.eq(q.field("type"), "compliance_alert")
        )
      )
      .order("desc")
      .take(args.limit || 20);

    return insights;
  },
});

export const getLegalDeadlines = internalQuery({
  args: {
    daysAhead: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const daysAhead = args.daysAhead || 30;
    const cutoffDate = new Date(Date.now() + daysAhead * 24 * 60 * 60 * 1000).toISOString();
    
    const deadlineInsights = await ctx.db
      .query("agentInsights")
      .filter((q: any) => 
        q.and(
          q.eq(q.field("type"), "alert"),
          q.lte(q.field("createdAt"), cutoffDate),
          q.eq(q.field("actionTaken"), false)
        )
      )
      .order("desc")
      .collect();

    return deadlineInsights;
  },
});
</file>

<file path="convex/agents/notifications.ts">
// convex/agents/notifications.ts
import { internalMutation, internalQuery } from "../_generated/server";
import { v } from "convex/values";
import { Id } from "../_generated/dataModel";

/**
 * Notifications Agent
 * 
 * Responsibilities:
 * - Send notifications for important events (contract expiry, approvals needed, etc.)
 * - Manage notification preferences and delivery
 * - Track notification history and delivery status
 * - Handle notification batching and scheduling
 * - Manage notification templates
 * - Ensure users receive timely alerts
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const NOTIFICATIONS_CONFIG = {
  // Processing settings
  checkIntervalMinutes: 5,
  batchSize: 20,
  maxRetries: 3,
  
  // Notification types with their settings
  notificationTypes: {
    contract_expiration: {
      priority: "high",
      channels: ["in_app", "email"],
      template: "contract_expiration",
      batchable: true,
    },
    contract_created: {
      priority: "medium",
      channels: ["in_app"],
      template: "contract_created",
      batchable: true,
    },
    approval_required: {
      priority: "high",
      channels: ["in_app", "email"],
      template: "approval_required",
      batchable: false,
    },
    payment_reminder: {
      priority: "high",
      channels: ["in_app", "email"],
      template: "payment_reminder",
      batchable: true,
    },
    vendor_risk_alert: {
      priority: "high",
      channels: ["in_app", "email"],
      template: "vendor_risk",
      batchable: false,
    },
    compliance_issue: {
      priority: "critical",
      channels: ["in_app", "email"],
      template: "compliance_alert",
      batchable: false,
    },
    task_assigned: {
      priority: "medium",
      channels: ["in_app"],
      template: "task_assigned",
      batchable: true,
    },
    system_alert: {
      priority: "medium",
      channels: ["in_app"],
      template: "system_alert",
      batchable: true,
    },
  },
  
  // Delivery settings
  delivery: {
    maxBatchSize: 10,
    batchDelayMinutes: 15,
    quietHoursStart: 22, // 10 PM
    quietHoursEnd: 7,    // 7 AM
    workingDaysOnly: false,
  },
  
  // Retry settings
  retry: {
    delays: [5, 15, 60], // Minutes between retries
    maxAttempts: 3,
  },
};

// Extended metrics for notifications agent
interface NotificationsAgentMetrics {
  totalRuns: number;
  successfulRuns: number;
  failedRuns: number;
  averageRunTime: number;
  lastRunDuration?: number;
  dataProcessed?: number;
  insightsGenerated?: number;
  // Notification-specific metrics
  notificationsSent?: number;
  notificationsDelivered?: number;
  notificationsFailed?: number;
  notificationsBatched?: number;
  averageDeliveryTime?: number;
  channelBreakdown?: Record<string, number>;
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

export const run = internalMutation({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const startTime = Date.now();
    
    try {
      await ctx.db.insert("agentLogs", {
        agentId: args.agentId,
        level: "info",
        message: "Notifications agent starting run",
        timestamp: new Date().toISOString(),
        category: "agent_execution",
      });

      await ctx.db.patch(args.agentId, {
        status: "busy",
        lastRun: new Date().toISOString(),
      });

      // Process notification tasks
      const tasksProcessed = await processNotificationTasks(ctx, args.agentId);
      
      // Check for scheduled notifications
      const scheduledSent = await sendScheduledNotifications(ctx, args.agentId);
      
      // Process notification batches
      const batchesSent = await processBatchedNotifications(ctx, args.agentId);
      
      // Retry failed notifications
      const retriesProcessed = await retryFailedNotifications(ctx, args.agentId);
      
      // Clean up old notifications
      await cleanupOldNotifications(ctx, args.agentId);
      
      // Generate notification insights
      await generateNotificationInsights(ctx, args.agentId);

      // Update metrics
      await updateAgentMetrics(ctx, args.agentId, {
        runTime: Date.now() - startTime,
        tasksProcessed,
        scheduledSent,
        batchesSent,
        retriesProcessed,
      });

      return { 
        success: true, 
        tasksProcessed,
        notificationsSent: scheduledSent + batchesSent,
        retriesProcessed,
      };

    } catch (error) {
      await handleAgentError(ctx, args.agentId, error);
      throw error;
    }
  },
});

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

async function processNotificationTasks(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  const tasks = await ctx.db
    .query("agentTasks")
    .withIndex("by_assigned_agent", (q: any) => q.eq("assignedAgentId", agentId))
    .filter((q: any) => 
      q.and(
        q.eq(q.field("status"), "pending"),
        q.eq(q.field("taskType"), "send_notification")
      )
    )
    .take(NOTIFICATIONS_CONFIG.batchSize);

  let processed = 0;

  for (const task of tasks) {
    try {
      await ctx.db.patch(task._id, {
        status: "in_progress",
        startedAt: new Date().toISOString(),
      });

      // Create notification from task
      const notification = await createNotificationFromTask(ctx, task);
      
      // Send or schedule the notification
      if (shouldSendImmediately(notification)) {
        await sendNotification(ctx, notification);
      } else if (isBatchable(notification)) {
        await addToBatch(ctx, notification);
      } else {
        await scheduleNotification(ctx, notification);
      }

      await ctx.db.patch(task._id, {
        status: "completed",
        completedAt: new Date().toISOString(),
        result: { notificationId: notification._id },
      });

      processed++;

    } catch (error) {
      await ctx.db.patch(task._id, {
        status: "failed",
        errorMessage: error instanceof Error ? error.message : String(error),
        completedAt: new Date().toISOString(),
      });

      await ctx.db.insert("agentLogs", {
        agentId,
        level: "error",
        message: `Failed to process notification task ${task._id}`,
        data: { taskId: task._id, error: error instanceof Error ? error.message : String(error) },
        timestamp: new Date().toISOString(),
        category: "task_processing",
      });
    }
  }

  return processed;
}

async function sendScheduledNotifications(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  const now = new Date();
  
  // Get notifications that are scheduled and due
  const dueNotifications = await ctx.db
    .query("notifications")
    .filter((q: any) => 
      q.and(
        q.eq(q.field("status"), "scheduled"),
        q.lte(q.field("scheduledFor"), now.toISOString())
      )
    )
    .take(NOTIFICATIONS_CONFIG.batchSize);

  let sent = 0;

  for (const notification of dueNotifications) {
    try {
      await sendNotification(ctx, notification);
      sent++;
    } catch (error) {
      await handleNotificationError(ctx, notification, error);
    }
  }

  return sent;
}

async function processBatchedNotifications(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  // Get batched notifications older than batch delay
  const batchCutoff = new Date(Date.now() - NOTIFICATIONS_CONFIG.delivery.batchDelayMinutes * 60 * 1000);
  
  const batchedNotifications = await ctx.db
    .query("notifications")
    .filter((q: any) => 
      q.and(
        q.eq(q.field("status"), "batched"),
        q.lte(q.field("createdAt"), batchCutoff.toISOString())
      )
    )
    .collect();

  if (batchedNotifications.length === 0) return 0;

  // Group by recipient and type
  const batches = groupNotificationsForBatching(batchedNotifications);
  let totalSent = 0;

  for (const batch of batches) {
    try {
      await sendBatchedNotifications(ctx, batch);
      totalSent += batch.notifications.length;
    } catch (error) {
      await ctx.db.insert("agentLogs", {
        agentId,
        level: "error",
        message: "Failed to send notification batch",
        data: { 
          recipientId: batch.recipientId,
          notificationCount: batch.notifications.length,
          error: error instanceof Error ? error.message : String(error),
        },
        timestamp: new Date().toISOString(),
        category: "batch_delivery",
      });
    }
  }

  return totalSent;
}

async function retryFailedNotifications(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  const failedNotifications = await ctx.db
    .query("notifications")
    .filter((q: any) => 
      q.and(
        q.eq(q.field("status"), "failed"),
        q.lt(q.field("retryCount"), NOTIFICATIONS_CONFIG.maxRetries)
      )
    )
    .take(NOTIFICATIONS_CONFIG.batchSize);

  let retried = 0;

  for (const notification of failedNotifications) {
    const retryDelay = NOTIFICATIONS_CONFIG.retry.delays[notification.retryCount || 0] || 60;
    const lastAttempt = new Date(notification.lastAttemptAt || notification.createdAt);
    const nextRetryTime = new Date(lastAttempt.getTime() + retryDelay * 60 * 1000);

    if (nextRetryTime <= new Date()) {
      try {
        await sendNotification(ctx, notification);
        retried++;
      } catch (error) {
        await handleNotificationError(ctx, notification, error);
      }
    }
  }

  return retried;
}

async function cleanupOldNotifications(
  ctx: any,
  agentId: Id<"agents">
): Promise<void> {
  // Archive notifications older than 90 days
  const archiveCutoff = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
  
  const oldNotifications = await ctx.db
    .query("notifications")
    .filter((q: any) => 
      q.and(
        q.lte(q.field("createdAt"), archiveCutoff.toISOString()),
        q.neq(q.field("status"), "archived")
      )
    )
    .take(100);

  for (const notification of oldNotifications) {
    await ctx.db.patch(notification._id, {
      status: "archived",
      archivedAt: new Date().toISOString(),
    });
  }
}

async function generateNotificationInsights(
  ctx: any,
  agentId: Id<"agents">
): Promise<void> {
  const last24Hours = new Date(Date.now() - 24 * 60 * 60 * 1000);
  
  // Get notification statistics
  const recentNotifications = await ctx.db
    .query("notifications")
    .filter((q: any) => q.gte(q.field("createdAt"), last24Hours.toISOString()))
    .collect();

  if (recentNotifications.length < 10) return; // Not enough data

  const stats = {
    total: recentNotifications.length,
    byType: {} as Record<string, number>,
    byStatus: {} as Record<string, number>,
    byChannel: {} as Record<string, number>,
    deliveryRate: 0,
    averageDeliveryTime: 0,
  };

  let totalDeliveryTime = 0;
  let deliveredCount = 0;

  for (const notification of recentNotifications) {
    // Count by type
    stats.byType[notification.type] = (stats.byType[notification.type] || 0) + 1;
    
    // Count by status
    stats.byStatus[notification.status] = (stats.byStatus[notification.status] || 0) + 1;
    
    // Count by channel
    for (const channel of notification.channels) {
      stats.byChannel[channel] = (stats.byChannel[channel] || 0) + 1;
    }
    
    // Calculate delivery metrics
    if (notification.deliveredAt) {
      deliveredCount++;
      const deliveryTime = new Date(notification.deliveredAt).getTime() - 
                          new Date(notification.createdAt).getTime();
      totalDeliveryTime += deliveryTime;
    }
  }

  stats.deliveryRate = deliveredCount / stats.total;
  stats.averageDeliveryTime = deliveredCount > 0 ? totalDeliveryTime / deliveredCount : 0;

  // Create insights based on stats
  if (stats.deliveryRate < 0.9) {
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "alert",
      title: "Low Notification Delivery Rate",
      description: `Only ${(stats.deliveryRate * 100).toFixed(1)}% of notifications are being delivered successfully`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: stats,
    });
  }

  // Check for notification spikes
  const highVolumeTypes = Object.entries(stats.byType)
    .filter(([_, count]) => count > stats.total * 0.4)
    .map(([type]) => type);

  if (highVolumeTypes.length > 0) {
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "trend_analysis",
      title: "High Volume Notification Types",
      description: `${highVolumeTypes.join(', ')} notifications are unusually high`,
      priority: "medium",
      actionRequired: false,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: { highVolumeTypes, stats },
    });
  }
}

// ============================================================================
// NOTIFICATION HANDLING FUNCTIONS
// ============================================================================

async function createNotificationFromTask(ctx: any, task: any): Promise<any> {
  const notificationType = task.data?.notificationType || "system_alert";
  const config = NOTIFICATIONS_CONFIG.notificationTypes[notificationType as keyof typeof NOTIFICATIONS_CONFIG.notificationTypes];
  
  // Determine recipient
  let recipientId: Id<"users"> | null = null;
  if (task.data?.recipientUserId) {
    recipientId = task.data.recipientUserId;
  } else if (task.data?.recipient === "contract_owner_or_manager" && task.contractId) {
    // Find contract owner or assigned user
    const contract = await ctx.db.get(task.contractId);
    if (contract) {
      // For now, we'll need to implement logic to find the appropriate user
      // This is a placeholder - you'd need to add contract ownership tracking
      const contractManagers = await ctx.db
        .query("users")
        .withIndex("by_enterprise", (q: any) => q.eq("enterpriseId", contract.enterpriseId))
        .filter((q: any) => 
          q.or(
            q.eq(q.field("role"), "owner"),
            q.eq(q.field("role"), "admin"),
            q.eq(q.field("role"), "manager")
          )
        )
        .first();
      
      recipientId = contractManagers?._id || null;
    }
  }

  if (!recipientId) {
    throw new Error("Could not determine notification recipient");
  }

  // Get user preferences
  const user = await ctx.db.get(recipientId);
  const preferences = await getUserNotificationPreferences(ctx, recipientId);
  
  // Determine which channels to use
  const channels = config?.channels || ["in_app"];
  const enabledChannels = channels.filter(channel => {
    if (channel === "in_app") return preferences.inApp;
    if (channel === "email") return preferences.email;
    return false;
  });

  const notificationId = await ctx.db.insert("notifications", {
    recipientId,
    type: notificationType,
    title: task.data?.title || task.title || "New Notification",
    message: task.data?.message || "You have a new notification",
    priority: task.data?.urgency || config?.priority || "medium",
    channels: enabledChannels,
    status: "pending",
    isRead: false,
    metadata: {
      taskId: task._id,
      contractId: task.contractId,
      vendorId: task.vendorId,
      ...task.data,
    },
    createdAt: new Date().toISOString(),
    retryCount: 0,
  });

  return await ctx.db.get(notificationId);
}

async function sendNotification(ctx: any, notification: any): Promise<void> {
  try {
    await ctx.db.patch(notification._id, {
      status: "sending",
      lastAttemptAt: new Date().toISOString(),
    });

    // In-app notification is always created
    if (notification.channels.includes("in_app")) {
      // Already stored in database, just mark as delivered for in-app
    }

    // Email notification (placeholder for actual email sending)
    if (notification.channels.includes("email")) {
      await sendEmailNotification(ctx, notification);
    }

    // Mark as delivered
    await ctx.db.patch(notification._id, {
      status: "delivered",
      deliveredAt: new Date().toISOString(),
    });

  } catch (error) {
    throw error;
  }
}

async function sendEmailNotification(ctx: any, notification: any): Promise<void> {
  // This is a placeholder for actual email sending
  // In a real implementation, you would:
  // 1. Get user's email from the users table
  // 2. Use an email service (SendGrid, AWS SES, etc.)
  // 3. Apply the appropriate template
  // 4. Send the email
  
  await ctx.db.insert("agentLogs", {
    agentId: notification.agentId || "system",
    level: "info",
    message: "Email notification would be sent here",
    data: {
      notificationId: notification._id,
      recipientId: notification.recipientId,
      type: notification.type,
    },
    timestamp: new Date().toISOString(),
    category: "email_delivery",
  });
}

async function sendBatchedNotifications(ctx: any, batch: any): Promise<void> {
  // Create a digest notification
  const digestNotification = {
    recipientId: batch.recipientId,
    type: "digest",
    title: `You have ${batch.notifications.length} notifications`,
    message: createDigestMessage(batch.notifications),
    priority: "medium",
    channels: ["in_app", "email"],
    status: "sending",
    isRead: false,
    metadata: {
      batchedNotificationIds: batch.notifications.map((n: any) => n._id),
      originalTypes: [...new Set(batch.notifications.map((n: any) => n.type))],
    },
    createdAt: new Date().toISOString(),
    retryCount: 0,
  };

  const digestId = await ctx.db.insert("notifications", digestNotification);

  // Mark original notifications as part of batch
  for (const notification of batch.notifications) {
    await ctx.db.patch(notification._id, {
      status: "batched_sent",
      batchId: digestId,
      deliveredAt: new Date().toISOString(),
    });
  }

  // Send the digest
  const digest = await ctx.db.get(digestId);
  await sendNotification(ctx, digest);
}

async function handleNotificationError(ctx: any, notification: any, error: any): Promise<void> {
  const retryCount = (notification.retryCount || 0) + 1;
  
  await ctx.db.patch(notification._id, {
    status: retryCount >= NOTIFICATIONS_CONFIG.maxRetries ? "failed_permanently" : "failed",
    retryCount,
    lastError: error instanceof Error ? error.message : String(error),
    lastAttemptAt: new Date().toISOString(),
  });
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function shouldSendImmediately(notification: any): boolean {
  if (notification.priority === "critical") return true;
  
  const now = new Date();
  const hour = now.getHours();
  
  // Check quiet hours
  if (NOTIFICATIONS_CONFIG.delivery.quietHoursStart > NOTIFICATIONS_CONFIG.delivery.quietHoursEnd) {
    // Quiet hours span midnight
    if (hour >= NOTIFICATIONS_CONFIG.delivery.quietHoursStart || hour < NOTIFICATIONS_CONFIG.delivery.quietHoursEnd) {
      return false;
    }
  } else {
    // Normal quiet hours
    if (hour >= NOTIFICATIONS_CONFIG.delivery.quietHoursStart && hour < NOTIFICATIONS_CONFIG.delivery.quietHoursEnd) {
      return false;
    }
  }
  
  // Check working days
  if (NOTIFICATIONS_CONFIG.delivery.workingDaysOnly) {
    const day = now.getDay();
    if (day === 0 || day === 6) return false; // Weekend
  }
  
  return true;
}

function isBatchable(notification: any): boolean {
  const config = NOTIFICATIONS_CONFIG.notificationTypes[notification.type as keyof typeof NOTIFICATIONS_CONFIG.notificationTypes];
  return config?.batchable || false;
}

async function addToBatch(ctx: any, notification: any): Promise<void> {
  await ctx.db.patch(notification._id, {
    status: "batched",
  });
}

async function scheduleNotification(ctx: any, notification: any): Promise<void> {
  const now = new Date();
  let scheduledTime = new Date();
  
  // Schedule for next available time
  if (now.getHours() >= NOTIFICATIONS_CONFIG.delivery.quietHoursStart) {
    // Schedule for tomorrow morning
    scheduledTime.setDate(scheduledTime.getDate() + 1);
    scheduledTime.setHours(NOTIFICATIONS_CONFIG.delivery.quietHoursEnd, 0, 0, 0);
  } else if (now.getHours() < NOTIFICATIONS_CONFIG.delivery.quietHoursEnd) {
    // Schedule for this morning
    scheduledTime.setHours(NOTIFICATIONS_CONFIG.delivery.quietHoursEnd, 0, 0, 0);
  }
  
  await ctx.db.patch(notification._id, {
    status: "scheduled",
    scheduledFor: scheduledTime.toISOString(),
  });
}

function groupNotificationsForBatching(notifications: any[]): any[] {
  const groups = new Map<string, any[]>();
  
  for (const notification of notifications) {
    const key = `${notification.recipientId}`;
    if (!groups.has(key)) {
      groups.set(key, []);
    }
    groups.get(key)!.push(notification);
  }
  
  return Array.from(groups.entries()).map(([key, notifications]) => ({
    recipientId: notifications[0].recipientId,
    notifications: notifications.slice(0, NOTIFICATIONS_CONFIG.delivery.maxBatchSize),
  }));
}

function createDigestMessage(notifications: any[]): string {
  const typeCount = notifications.reduce((acc, n) => {
    acc[n.type] = (acc[n.type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
  
  const summaries = Object.entries(typeCount).map(([type, count]:[string, any]) => {
    const typeName = type.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
    return `${count} ${typeName}${count > 1 ? 's' : ''}`;
  });
  
  return `You have ${summaries.join(', ')}. Click to view details.`;
}

async function getUserNotificationPreferences(ctx: any, userId: Id<"users">): Promise<any> {
  // For now, return default preferences
  // In a real implementation, you'd fetch from a user preferences table
  return {
    inApp: true,
    email: true,
    sms: false,
    contractNotifications: true,
    approvalNotifications: true,
    signatureNotifications: true,
    analyticsNotifications: false,
  };
}

async function updateAgentMetrics(
  ctx: any,
  agentId: Id<"agents">,
  runData: {
    runTime: number;
    tasksProcessed: number;
    scheduledSent: number;
    batchesSent: number;
    retriesProcessed: number;
  }
): Promise<void> {
  const agent = await ctx.db.get(agentId);
  if (!agent) return;

  const existingMetrics = (agent.metrics as NotificationsAgentMetrics) || {
    totalRuns: 0,
    successfulRuns: 0,
    failedRuns: 0,
    averageRunTime: 0,
    notificationsSent: 0,
    notificationsDelivered: 0,
    notificationsFailed: 0,
    notificationsBatched: 0,
  };

  const newMetrics: NotificationsAgentMetrics = {
    ...existingMetrics,
    totalRuns: existingMetrics.totalRuns + 1,
    successfulRuns: existingMetrics.successfulRuns + 1,
    averageRunTime: 
      ((existingMetrics.averageRunTime * existingMetrics.totalRuns) + runData.runTime) / 
      (existingMetrics.totalRuns + 1),
    lastRunDuration: runData.runTime,
    notificationsSent: (existingMetrics.notificationsSent || 0) + runData.scheduledSent + runData.batchesSent,
    dataProcessed: (existingMetrics.dataProcessed || 0) + runData.tasksProcessed,
  };

  await ctx.db.patch(agentId, {
    status: "active",
    lastSuccess: new Date().toISOString(),
    runCount: (agent.runCount || 0) + 1,
    metrics: newMetrics,
  });
}

async function handleAgentError(ctx: any, agentId: Id<"agents">, error: any): Promise<void> {
  await ctx.db.insert("agentLogs", {
    agentId,
    level: "error",
    message: "Notifications agent failed",
    data: { error: error instanceof Error ? error.message : String(error) },
    timestamp: new Date().toISOString(),
    category: "agent_execution",
  });

  const agent = await ctx.db.get(agentId);
  if (agent) {
    const existingMetrics = (agent.metrics as NotificationsAgentMetrics) || {
      totalRuns: 0,
      successfulRuns: 0,
      failedRuns: 0,
      averageRunTime: 0,
    };

    await ctx.db.patch(agentId, {
      status: "error",
      errorCount: (agent.errorCount || 0) + 1,
      lastError: error instanceof Error ? error.message : String(error),
      metrics: {
        ...existingMetrics,
        totalRuns: existingMetrics.totalRuns + 1,
        failedRuns: existingMetrics.failedRuns + 1,
      },
    });
  }
}

// ============================================================================
// QUERY FUNCTIONS
// ============================================================================

export const getPendingNotifications = internalQuery({
  args: {
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const notifications = await ctx.db
      .query("notifications")
      .filter((q: any) => 
        q.or(
          q.eq(q.field("status"), "pending"),
          q.eq(q.field("status"), "scheduled"),
          q.eq(q.field("status"), "batched")
        )
      )
      .order("desc")
      .take(args.limit || 50);

    return notifications;
  },
});

export const getNotificationStats = internalQuery({
  args: {
    timeRange: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const cutoffDate = args.timeRange === "24h" 
      ? new Date(Date.now() - 24 * 60 * 60 * 1000)
      : new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);

    const notifications = await ctx.db
      .query("notifications")
      .filter((q: any) => q.gte(q.field("createdAt"), cutoffDate.toISOString()))
      .collect();

    const stats = {
      total: notifications.length,
      pending: notifications.filter(n => n.status === "pending").length,
      delivered: notifications.filter(n => n.status === "delivered").length,
      failed: notifications.filter(n => n.status === "failed" || n.status === "failed_permanently").length,
      batched: notifications.filter(n => n.status === "batched").length,
    };

    return stats;
  },
});
</file>

<file path="convex/security/monitoring.ts">
import { query, internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { Id } from "../_generated/dataModel";
import { getSecurityContext } from "./rowLevelSecurity";
import { ConvexError } from "convex/values";

/**
 * Security monitoring and analytics
 */

// Get security dashboard data
export const getSecurityDashboard = query({
  args: {
    timeRange: v.optional(v.union(
      v.literal("24h"),
      v.literal("7d"),
      v.literal("30d")
    ))
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Only admins and owners can view security dashboard
    if (!["owner", "admin"].includes(security.role)) {
      throw new ConvexError("Access denied");
    }
    
    const timeRange = args.timeRange || "24h";
    const cutoffs = {
      "24h": new Date(Date.now() - 24 * 60 * 60 * 1000),
      "7d": new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
      "30d": new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
    };
    const cutoff = cutoffs[timeRange].toISOString();
    
    // Get audit logs
    const auditLogs = await ctx.db
      .query("auditLogs")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .filter((q) => q.gte(q.field("timestamp"), cutoff))
      .collect();
    
    // Get rate limit violations
    const rateLimitLogs = await ctx.db
      .query("rateLimitLogs")
      .withIndex("by_timestamp", (q) => q.gte("timestamp", cutoff))
      .filter((q) => q.eq(q.field("allowed"), false))
      .collect();
    
    // Get active alerts
    const alerts = await ctx.db
      .query("auditAlerts")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .filter((q) => q.eq(q.field("resolved"), false))
      .collect();
    
    // Calculate metrics
    const metrics = {
      totalOperations: auditLogs.length,
      failedOperations: auditLogs.filter(l => l.status === "failure").length,
      uniqueUsers: new Set(auditLogs.map(l => l.userId.toString())).size,
      rateLimitViolations: rateLimitLogs.length,
      activeAlerts: alerts.length,
      criticalAlerts: alerts.filter(a => a.severity === "critical").length,
    };
    
    // Group operations by type
    const operationsByType = auditLogs.reduce((acc, log) => {
      acc[log.action] = (acc[log.action] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    // Get top users by activity
    const userActivity = auditLogs.reduce((acc, log) => {
      acc[log.userId.toString()] = (acc[log.userId.toString()] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);
    
    const topUsers = await Promise.all(
      Object.entries(userActivity)
        .sort(([, a], [, b]) => b - a)
        .slice(0, 5)
        .map(async ([userId, count]) => {
          const user = await ctx.db.get(userId as Id<"users">);
          return {
            userId,
            name: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email : 'Unknown',
            email: user?.email,
            operationCount: count
          };
        })
    );
    
    // Recent security events
    const recentEvents = auditLogs
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, 10)
      .map(log => ({
        ...log,
        timestamp: log.timestamp,
        operation: log.operation,
        resourceType: log.resourceType,
        status: log.status
      }));
    
    return {
      timeRange,
      metrics,
      operationsByType,
      topUsers,
      recentEvents,
      alerts: alerts.slice(0, 5),
      hourlyActivity: calculateHourlyActivity(auditLogs)
    };
  }
});

// Calculate hourly activity for chart
function calculateHourlyActivity(logs: any[]): any[] {
  const hourly: Record<string, number> = {};
  
  logs.forEach(log => {
    const hour = new Date(log.timestamp).toISOString().slice(0, 13);
    hourly[hour] = (hourly[hour] || 0) + 1;
  });
  
  return Object.entries(hourly)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([hour, count]) => ({
      hour: hour + ":00",
      count
    }));
}

// Automated security monitoring job
export const runSecurityMonitoring = internalMutation({
  args: {},
  handler: async (ctx) => {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
    
    // Check for suspicious patterns across all enterprises
    const enterprises = await ctx.db.query("enterprises").collect();
    
    for (const enterprise of enterprises) {
      // Check for unusual activity volume
      const recentLogs = await ctx.db
        .query("auditLogs")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", enterprise._id))
        .filter((q) => q.gte(q.field("timestamp"), oneHourAgo))
        .collect();
      
      if (recentLogs.length > 1000) {
        await ctx.db.insert("auditAlerts", {
          enterpriseId: enterprise._id,
          alertType: "suspicious_activity",
          severity: "high",
          description: `Unusually high activity: ${recentLogs.length} operations in the last hour`,
          resolved: false,
          createdAt: new Date().toISOString(),
          metadata: { operationCount: recentLogs.length }
        });
      }
      
      // Check for access from multiple IPs
      const userIPs = new Map<string, Set<string>>();
      recentLogs.forEach(log => {
        if (log.ipAddress) {
          const userId = log.userId.toString();
          if (!userIPs.has(userId)) {
            userIPs.set(userId, new Set());
          }
          userIPs.get(userId)!.add(log.ipAddress);
        }
      });
      
      for (const [userId, ips] of userIPs.entries()) {
        if (ips.size > 3) {
          await ctx.db.insert("auditAlerts", {
            enterpriseId: enterprise._id,
            alertType: "suspicious_activity",
            severity: "medium",
            description: `User accessing from ${ips.size} different IP addresses`,
            userId: userId as Id<"users">,
            resolved: false,
            createdAt: new Date().toISOString(),
            metadata: { ipAddresses: Array.from(ips) }
          });
        }
      }
    }
    
    // Note: Rate limit cleanup is handled by the rateLimiting module
  }
});

// Schedule monitoring to run every hour
export const scheduleSecurityMonitoring = internalMutation({
  args: {},
  handler: async (ctx) => {
    // Schedule next monitoring run in 1 hour
    // Note: Scheduler calls would need proper internal API setup
    console.log("Security monitoring scheduled");
  }
});
</file>

<file path="convex/security/rateLimiting.ts">
import { QueryCtx, MutationCtx, ActionCtx, internalMutation, mutation } from "../_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { defineTable } from "convex/server";
import { Id } from "../_generated/dataModel";

/**
 * Rate Limiting and DDoS Protection
 * 
 * Implements token bucket algorithm for rate limiting
 * with different limits for different operations
 */

interface RateLimitConfig {
  maxTokens: number;      // Maximum tokens in bucket
  refillRate: number;     // Tokens per minute
  costPerRequest: number; // Tokens consumed per request
}

const RATE_LIMIT_CONFIGS: Record<string, RateLimitConfig> = {
  // Queries - more lenient
  "query.default": { maxTokens: 100, refillRate: 60, costPerRequest: 1 },
  "query.search": { maxTokens: 30, refillRate: 20, costPerRequest: 2 },
  "query.analytics": { maxTokens: 20, refillRate: 10, costPerRequest: 5 },
  
  // Mutations - more restrictive
  "mutation.create": { maxTokens: 20, refillRate: 10, costPerRequest: 2 },
  "mutation.update": { maxTokens: 30, refillRate: 15, costPerRequest: 1 },
  "mutation.delete": { maxTokens: 10, refillRate: 5, costPerRequest: 3 },
  "mutation.bulk": { maxTokens: 5, refillRate: 2, costPerRequest: 5 },
  
  // Actions - most restrictive
  "action.fileUpload": { maxTokens: 5, refillRate: 2, costPerRequest: 2 },
  "action.analysis": { maxTokens: 3, refillRate: 1, costPerRequest: 1 },
  "action.export": { maxTokens: 2, refillRate: 1, costPerRequest: 1 },
  
  // Authentication - special handling
  "auth.login": { maxTokens: 10, refillRate: 5, costPerRequest: 1 },
  "auth.register": { maxTokens: 5, refillRate: 2, costPerRequest: 2 },
  "auth.passwordReset": { maxTokens: 3, refillRate: 1, costPerRequest: 1 },
};

// Rate limit buckets table schema
export const rateLimitTables = {
  rateLimitBuckets: defineTable({
    key: v.string(), // userId:operation or ip:operation
    tokens: v.number(),
    lastRefill: v.string(), // ISO timestamp
    violations: v.number(),
    blockedUntil: v.optional(v.string()), // ISO timestamp
  })
  .index("by_key", ["key"])
  .index("by_blocked", ["blockedUntil"]),
  
  rateLimitLogs: defineTable({
    userId: v.optional(v.id("users")),
    ipAddress: v.string(),
    operation: v.string(),
    allowed: v.boolean(),
    tokens: v.number(),
    timestamp: v.string(),
    userAgent: v.optional(v.string()),
    metadata: v.optional(v.any()),
  })
  .index("by_user", ["userId"])
  .index("by_ip", ["ipAddress"])
  .index("by_timestamp", ["timestamp"]),
};

/**
 * Check rate limit for an operation
 */
export async function checkRateLimit(
  ctx: any,
  operation: string,
  options: {
    userId?: Id<"users">;
    ipAddress?: string;
    cost?: number;
  } = {}
): Promise<{ allowed: boolean; tokens: number; resetIn?: number }> {
  const config = RATE_LIMIT_CONFIGS[operation] || RATE_LIMIT_CONFIGS["query.default"];
  const cost = options.cost || config.costPerRequest;
  
  // Generate rate limit key
  const key = options.userId 
    ? `user:${options.userId}:${operation}`
    : `ip:${options.ipAddress || "unknown"}:${operation}`;
  
  // Get or create bucket
  let bucket = await ctx.db
    .query("rateLimitBuckets")
    .withIndex("by_key", (q:any) => q.eq("key", key))
    .first();
  
  const now = new Date();
  
  if (!bucket) {
    // Create new bucket
    await ctx.db.insert("rateLimitBuckets", {
      key,
      tokens: config.maxTokens,
      lastRefill: now.toISOString(),
      violations: 0,
    });
    bucket = { tokens: config.maxTokens, violations: 0 };
  } else {
    // Check if blocked
    if (bucket.blockedUntil && new Date(bucket.blockedUntil) > now) {
      const resetIn = Math.ceil((new Date(bucket.blockedUntil).getTime() - now.getTime()) / 1000);
      
      await logRateLimit(ctx, {
        userId: options.userId,
        ipAddress: options.ipAddress || "unknown",
        operation,
        allowed: false,
        tokens: 0,
        metadata: { reason: "blocked", resetIn }
      });
      
      return { allowed: false, tokens: 0, resetIn };
    }
    
    // Refill tokens
    const timeSinceRefill = (now.getTime() - new Date(bucket.lastRefill).getTime()) / 60000; // minutes
    const tokensToAdd = Math.floor(timeSinceRefill * config.refillRate);
    
    if (tokensToAdd > 0) {
      bucket.tokens = Math.min(config.maxTokens, bucket.tokens + tokensToAdd);
      await ctx.db.patch(bucket._id, {
        tokens: bucket.tokens,
        lastRefill: now.toISOString(),
      });
    }
  }
  
  // Check if enough tokens
  if (bucket.tokens >= cost) {
    // Consume tokens
    await ctx.db.patch(bucket._id, {
      tokens: bucket.tokens - cost,
      violations: 0, // Reset violations on successful request
    });
    
    await logRateLimit(ctx, {
      userId: options.userId,
      ipAddress: options.ipAddress || "unknown",
      operation,
      allowed: true,
      tokens: bucket.tokens - cost,
    });
    
    return { allowed: true, tokens: bucket.tokens - cost };
  } else {
    // Not enough tokens - increment violations
    const violations = bucket.violations + 1;
    const blockDuration = calculateBlockDuration(violations);
    
    await ctx.db.patch(bucket._id, {
      violations,
      blockedUntil: blockDuration > 0 
        ? new Date(now.getTime() + blockDuration).toISOString()
        : undefined,
    });
    
    await logRateLimit(ctx, {
      userId: options.userId,
      ipAddress: options.ipAddress || "unknown",
      operation,
      allowed: false,
      tokens: bucket.tokens,
      metadata: { violations, blockDuration }
    });
    
    const resetIn = Math.ceil((config.maxTokens - bucket.tokens) / config.refillRate * 60);
    
    return { allowed: false, tokens: bucket.tokens, resetIn };
  }
}

/**
 * Calculate block duration based on violations
 */
function calculateBlockDuration(violations: number): number {
  if (violations < 5) return 0;
  if (violations < 10) return 5 * 60 * 1000; // 5 minutes
  if (violations < 20) return 15 * 60 * 1000; // 15 minutes
  if (violations < 50) return 60 * 60 * 1000; // 1 hour
  return 24 * 60 * 60 * 1000; // 24 hours
}

/**
 * Log rate limit check
 */
async function logRateLimit(
  ctx: any,
  data: {
    userId?: Id<"users">;
    ipAddress: string;
    operation: string;
    allowed: boolean;
    tokens: number;
    metadata?: any;
  }
): Promise<void> {
  await ctx.db.insert("rateLimitLogs", {
    userId: data.userId,
    ipAddress: data.ipAddress,
    operation: data.operation,
    allowed: data.allowed,
    tokens: data.tokens,
    timestamp: new Date().toISOString(),
    metadata: data.metadata,
  });
}

/**
 * Rate limit check for actions (called from action context)
 */
export const checkRateLimitAction = mutation({
  args: {
    operation: v.string(),
    cost: v.optional(v.number()),
    clerkId: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    let userId: Id<"users"> | undefined;
    
    // Get user by Clerk ID if provided
    if (args.clerkId) {
      const user = await ctx.db
        .query("users")
        .withIndex("by_clerkId", (q) => q.eq("clerkId", args.clerkId))
        .first();
      userId = user?._id;
    }
    
    const rateLimitResult = await checkRateLimit(ctx, args.operation, {
      userId,
      cost: args.cost,
    });
    
    if (!rateLimitResult.allowed) {
      throw new ConvexError(`Rate limit exceeded for operation: ${args.operation}. Please try again in ${rateLimitResult.resetIn || 60} seconds.`);
    }
    
    return rateLimitResult;
  },
});

/**
 * Clean up old rate limit data
 */
export const cleanupRateLimits = internalMutation({
  args: {},
  handler: async (ctx) => {
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).toISOString();
    
    // Clean up old logs
    const oldLogs = await ctx.db
      .query("rateLimitLogs")
      .withIndex("by_timestamp", (q) => q.lt("timestamp", thirtyDaysAgo))
      .collect();
    
    for (const log of oldLogs) {
      await ctx.db.delete(log._id);
    }
    
    // Clean up expired blocks
    const now = new Date().toISOString();
    const expiredBlocks = await ctx.db
      .query("rateLimitBuckets")
      .withIndex("by_blocked", (q) => q.lt("blockedUntil", now))
      .collect();
    
    for (const bucket of expiredBlocks) {
      await ctx.db.patch(bucket._id, {
        blockedUntil: undefined,
        violations: 0,
      });
    }
  },
});
</file>

<file path="convex/security/rowLevelSecurity.ts">
import { QueryCtx, MutationCtx, DatabaseReader, DatabaseWriter } from "../_generated/server";
import { Id, Doc } from "../_generated/dataModel";
import { ConvexError } from "convex/values";

/**
 * Row-Level Security Implementation
 * 
 * This module provides secure database access functions that automatically
 * enforce enterprise-level data isolation and role-based permissions
 */

export interface SecurityContext {
  userId: Id<"users">;
  enterpriseId: Id<"enterprises">;
  role: "owner" | "admin" | "manager" | "user" | "viewer";
  permissions: string[];
}

// Permission definitions based on roles
const ROLE_PERMISSIONS = {
  owner: ["*"], // All permissions
  admin: [
    "contracts.create", "contracts.read", "contracts.update", "contracts.delete",
    "vendors.create", "vendors.read", "vendors.update", "vendors.delete",
    "users.read", "users.update", "users.invite",
    "analytics.read", "settings.read", "settings.update"
  ],
  manager: [
    "contracts.create", "contracts.read", "contracts.update",
    "vendors.create", "vendors.read", "vendors.update",
    "users.read", "analytics.read"
  ],
  user: [
    "contracts.create", "contracts.read", "contracts.update",
    "vendors.create", "vendors.read", "vendors.update",
    "analytics.read"
  ],
  viewer: [
    "contracts.read", "vendors.read", "users.read", "analytics.read"
  ]
};

/**
 * Get security context for the current user
 */
export async function getSecurityContext(
  ctx: QueryCtx | MutationCtx
): Promise<SecurityContext> {
  const identity = await ctx.auth.getUserIdentity();
  if (!identity) {
    throw new ConvexError("Authentication required");
  }

  const user = await ctx.db
    .query("users")
    .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
    .first();

  if (!user || !user.isActive) {
    throw new ConvexError("User not found or inactive");
  }

  return {
    userId: user._id,
    enterpriseId: user.enterpriseId,
    role: user.role,
    permissions: ROLE_PERMISSIONS[user.role] || []
  };
}

/**
 * Check if user has specific permission
 */
export function hasPermission(
  context: SecurityContext,
  permission: string
): boolean {
  if (context.permissions.includes("*")) return true;
  return context.permissions.includes(permission);
}

/**
 * Secure query builder that automatically filters by enterprise
 */
export class SecureQuery<T extends keyof typeof import("../_generated/dataModel").default> {
  constructor(
    private ctx: QueryCtx | MutationCtx,
    private table: T,
    private securityContext: SecurityContext
  ) {}

  async all(): Promise<Doc<T>[]> {
    return await this.ctx.db
      .query(this.table)
      .filter((q) => q.eq(q.field("enterpriseId"), this.securityContext.enterpriseId))
      .collect();
  }

  async byId(id: Id<T>): Promise<Doc<T> | null> {
    const doc = await this.ctx.db.get(id);
    if (!doc) return null;
    
    // Verify enterprise access
    if ((doc as any).enterpriseId !== this.securityContext.enterpriseId) {
      throw new ConvexError("Access denied: Document belongs to different enterprise");
    }
    
    return doc;
  }

  async where(filter: (q: any) => any): Promise<Doc<T>[]> {
    return await this.ctx.db
      .query(this.table)
      .filter((q) => 
        q.and(
          q.eq(q.field("enterpriseId"), this.securityContext.enterpriseId),
          filter(q)
        )
      )
      .collect();
  }
}

/**
 * Secure mutation operations
 */
export class SecureMutation {
  constructor(
    private ctx: MutationCtx,
    private securityContext: SecurityContext
  ) {}

  async insert<T extends keyof typeof import("../_generated/dataModel").default>(
    table: T,
    data: Omit<Doc<T>, "_id" | "_creationTime" | "enterpriseId">,
    permission?: string
  ): Promise<Id<T>> {
    // Check permission if specified
    if (permission && !hasPermission(this.securityContext, permission)) {
      throw new ConvexError(`Permission denied: ${permission}`);
    }

    // Automatically add enterprise ID
    const secureData = {
      ...data,
      enterpriseId: this.securityContext.enterpriseId
    } as any;

    return await this.ctx.db.insert(table, secureData);
  }

  async update<T extends keyof typeof import("../_generated/dataModel").default>(
    id: Id<T>,
    data: Partial<Omit<Doc<T>, "_id" | "_creationTime" | "enterpriseId">>,
    permission?: string
  ): Promise<void> {
    // Check permission if specified
    if (permission && !hasPermission(this.securityContext, permission)) {
      throw new ConvexError(`Permission denied: ${permission}`);
    }

    // Verify document belongs to user's enterprise
    const existing = await this.ctx.db.get(id);
    if (!existing) {
      throw new ConvexError("Document not found");
    }

    if ((existing as any).enterpriseId !== this.securityContext.enterpriseId) {
      throw new ConvexError("Access denied: Cannot update document from different enterprise");
    }

    // Remove enterprise ID from updates to prevent tampering
    const { enterpriseId, ...safeData } = data as any;
    
    await this.ctx.db.patch(id, safeData);
  }

  async delete<T extends keyof typeof import("../_generated/dataModel").default>(
    id: Id<T>,
    permission?: string
  ): Promise<void> {
    // Check permission if specified
    if (permission && !hasPermission(this.securityContext, permission)) {
      throw new ConvexError(`Permission denied: ${permission}`);
    }

    // Verify document belongs to user's enterprise
    const existing = await this.ctx.db.get(id);
    if (!existing) {
      throw new ConvexError("Document not found");
    }

    if ((existing as any).enterpriseId !== this.securityContext.enterpriseId) {
      throw new ConvexError("Access denied: Cannot delete document from different enterprise");
    }

    await this.ctx.db.delete(id);
  }

  // Helper method for byId that's used in secureContractOperations.ts
  async byId<T extends keyof typeof import("../_generated/dataModel").default>(
    table: T, 
    id: Id<T>
  ): Promise<Doc<T> | null> {
    const doc = await this.ctx.db.get(id);
    if (!doc) return null;
    
    // Verify enterprise access
    if ((doc as any).enterpriseId !== this.securityContext.enterpriseId) {
      throw new ConvexError("Access denied: Document belongs to different enterprise");
    }
    
    return doc;
  }
}
</file>

<file path="convex/events.ts">
import { mutation, query, internalMutation } from "./_generated/server";
import { v } from "convex/values";
import { Id } from "./_generated/dataModel";
import { getSecurityContext } from "./security/rowLevelSecurity";

/**
 * Real-time Event System
 * 
 * Handles broadcasting events across the application for real-time updates
 * Events are enterprise-scoped for security
 */

/**
 * Broadcast a real-time event to all users in the enterprise
 */
export const broadcastEvent = mutation({
  args: {
    eventType: v.union(
      v.literal("contract_updated"),
      v.literal("contract_created"),
      v.literal("contract_deleted"),
      v.literal("vendor_updated"),
      v.literal("vendor_created"),
      v.literal("analysis_completed"),
      v.literal("notification_created"),
      v.literal("user_joined"),
      v.literal("user_left"),
      v.literal("system_alert")
    ),
    resourceId: v.optional(v.string()),
    resourceType: v.optional(v.string()),
    data: v.optional(v.any()),
    targetUsers: v.optional(v.array(v.id("users"))), // If specified, only these users receive the event
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Create the event record
    await ctx.db.insert("realtimeEvents", {
      enterpriseId: security.enterpriseId,
      userId: security.userId,
      eventType: args.eventType,
      resourceId: args.resourceId,
      resourceType: args.resourceType,
      data: args.data,
      targetUsers: args.targetUsers,
      timestamp: new Date().toISOString(),
      processed: false,
    });
  },
});

/**
 * Subscribe to real-time events for the current user
 */
export const subscribeToEvents = query({
  args: {
    since: v.optional(v.string()), // ISO timestamp
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Get events for this enterprise since the specified time
    const since = args.since || new Date(Date.now() - 5 * 60 * 1000).toISOString(); // Default: last 5 minutes
    
    let events = await ctx.db
      .query("realtimeEvents")
      .withIndex("by_enterprise_timestamp", (q) => 
        q.eq("enterpriseId", security.enterpriseId)
         .gte("timestamp", since)
      )
      .order("desc")
      .take(args.limit || 50);

    // Filter events that are either for everyone or specifically for this user
    const relevantEvents = events.filter(event => 
      !event.targetUsers || 
      event.targetUsers.includes(security.userId) ||
      event.userId === security.userId
    );

    // Enrich events with user data
    const enrichedEvents = await Promise.all(
      relevantEvents.map(async (event) => {
        const user = await ctx.db.get(event.userId);
        
        return {
          ...event,
          user: user ? {
            _id: user._id,
            name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
            email: user.email,
          } : null,
        };
      })
    );

    return enrichedEvents;
  },
});

/**
 * Subscribe to live contract analysis updates
 */
export const subscribeToAnalysisEvents = query({
  args: {
    contractId: v.optional(v.id("contracts")),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
    
    let events = await ctx.db
      .query("realtimeEvents")
      .withIndex("by_enterprise_timestamp", (q) => 
        q.eq("enterpriseId", security.enterpriseId)
         .gte("timestamp", fiveMinutesAgo)
      )
      .filter((q) => q.eq(q.field("eventType"), "analysis_completed"))
      .collect();

    // Filter to specific contract if provided
    if (args.contractId) {
      events = events.filter(event => event.resourceId === args.contractId);
    }

    return events.map(event => ({
      _id: event._id,
      contractId: event.resourceId,
      eventType: event.eventType,
      data: event.data,
      timestamp: event.timestamp,
    }));
  },
});

/**
 * Create a system-wide notification event
 */
export const createSystemAlert = mutation({
  args: {
    alertType: v.union(
      v.literal("maintenance"),
      v.literal("update"),
      v.literal("security"),
      v.literal("info")
    ),
    title: v.string(),
    message: v.string(),
    severity: v.union(
      v.literal("low"),
      v.literal("medium"), 
      v.literal("high"),
      v.literal("critical")
    ),
    targetRoles: v.optional(v.array(v.string())), // Only users with these roles see the alert
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Only admins and owners can create system alerts
    if (!["owner", "admin"].includes(security.role)) {
      throw new Error("Access denied: Only admins can create system alerts");
    }

    // Get users to target
    let targetUsers: Id<"users">[] | undefined;
    if (args.targetRoles) {
      const users = await ctx.db
        .query("users")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
        .collect();
      
      targetUsers = users
        .filter(user => args.targetRoles!.includes(user.role))
        .map(user => user._id);
    }

    // Broadcast the alert event
    await ctx.db.insert("realtimeEvents", {
      enterpriseId: security.enterpriseId,
      userId: security.userId,
      eventType: "system_alert",
      resourceType: "system",
      data: {
        alertType: args.alertType,
        title: args.title,
        message: args.message,
        severity: args.severity,
      },
      targetUsers,
      timestamp: new Date().toISOString(),
      processed: false,
    });
  },
});

/**
 * Mark events as processed (for cleanup)
 */
export const markEventsProcessed = mutation({
  args: {
    eventIds: v.array(v.id("realtimeEvents")),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    for (const eventId of args.eventIds) {
      const event = await ctx.db.get(eventId);
      if (event && event.enterpriseId === security.enterpriseId) {
        await ctx.db.patch(eventId, { processed: true });
      }
    }
  },
});

/**
 * Clean up old events
 */
export const cleanupEvents = internalMutation({
  args: {},
  handler: async (ctx) => {
    // Delete events older than 24 hours
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
    
    const oldEvents = await ctx.db
      .query("realtimeEvents")
      .filter((q) => q.lt(q.field("timestamp"), oneDayAgo))
      .collect();

    for (const event of oldEvents) {
      await ctx.db.delete(event._id);
    }
  },
});

/**
 * Subscribe to typing indicators for collaborative editing
 */
export const subscribeToTypingIndicators = query({
  args: {
    resourceId: v.string(),
    resourceType: v.string(),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    const thirtySecondsAgo = new Date(Date.now() - 30 * 1000).toISOString();
    
    const typingEvents = await ctx.db
      .query("typingIndicators")
      .withIndex("by_resource", (q) => 
        q.eq("resourceId", args.resourceId)
         .eq("resourceType", args.resourceType)
      )
      .filter((q) => 
        q.and(
          q.eq(q.field("enterpriseId"), security.enterpriseId),
          q.gte(q.field("lastTyped"), thirtySecondsAgo),
          q.neq(q.field("userId"), security.userId) // Don't show current user
        )
      )
      .collect();

    // Enrich with user data
    const enrichedIndicators = await Promise.all(
      typingEvents.map(async (indicator) => {
        const user = await ctx.db.get(indicator.userId);
        if (!user) return null;

        return {
          userId: user._id,
          name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
          lastTyped: indicator.lastTyped,
          field: indicator.field,
        };
      })
    );

    return enrichedIndicators.filter(indicator => indicator !== null);
  },
});

/**
 * Update typing indicator
 */
export const updateTypingIndicator = mutation({
  args: {
    resourceId: v.string(),
    resourceType: v.string(),
    field: v.optional(v.string()), // Which field they're typing in
    isTyping: v.boolean(),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    const existing = await ctx.db
      .query("typingIndicators")
      .withIndex("by_user_resource", (q) => 
        q.eq("userId", security.userId)
         .eq("resourceId", args.resourceId)
         .eq("resourceType", args.resourceType)
      )
      .first();

    if (args.isTyping) {
      const data = {
        userId: security.userId,
        enterpriseId: security.enterpriseId,
        resourceId: args.resourceId,
        resourceType: args.resourceType,
        field: args.field,
        lastTyped: new Date().toISOString(),
      };

      if (existing) {
        await ctx.db.patch(existing._id, data);
      } else {
        await ctx.db.insert("typingIndicators", data);
      }
    } else if (existing) {
      // Remove typing indicator when user stops typing
      await ctx.db.delete(existing._id);
    }
  },
});
</file>

<file path="convex/monitoring.ts">
import { mutation, query } from "./_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";

// Analytics event schema
const analyticsEventSchema = v.object({
  event: v.string(),
  timestamp: v.number(),
  url: v.string(),
  userId: v.optional(v.string()),
  properties: v.optional(v.object({})),
  sessionId: v.string(),
  userAgent: v.optional(v.string()),
  ip: v.optional(v.string()),
});

// Error report schema
const errorReportSchema = v.object({
  message: v.string(),
  stack: v.optional(v.string()),
  timestamp: v.number(),
  url: v.string(),
  userId: v.optional(v.string()),
  sessionId: v.string(),
  userAgent: v.string(),
  context: v.optional(v.object({})),
});

/**
 * Log analytics event
 */
export const logAnalyticsEvent = mutation({
  args: analyticsEventSchema,
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    
    // Get user for enterprise context
    const user = identity ? await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first() : null;

    // Store analytics event
    const eventId = await ctx.db.insert("analytics_events", {
      ...args,
      authenticatedUserId: user?._id,
      enterpriseId: user?.enterpriseId,
      serverTimestamp: Date.now(),
      createdAt: new Date().toISOString(),
    });

    // Log important events to console in development
    if (process.env.NODE_ENV === 'development' && 
        ['error', 'form_submit', 'feature_usage'].includes(args.event)) {
      console.log('Analytics Event:', {
        id: eventId,
        event: args.event,
        userId: user?._id,
        timestamp: new Date(args.timestamp).toISOString(),
      });
    }

    return eventId;
  },
});

/**
 * Log batch analytics events
 */
export const logAnalyticsEventBatch = mutation({
  args: {
    events: v.array(analyticsEventSchema),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    
    // Get user for enterprise context
    const user = identity ? await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first() : null;

    // Validate events
    const validEvents = args.events.filter(event => 
      event.event && event.timestamp && event.sessionId
    );

    if (validEvents.length === 0) {
      throw new ConvexError("No valid events found");
    }

    // Insert all events
    const eventIds = await Promise.all(
      validEvents.map(event => 
        ctx.db.insert("analytics_events", {
          ...event,
          authenticatedUserId: user?._id,
          enterpriseId: user?.enterpriseId,
          serverTimestamp: Date.now(),
          createdAt: new Date().toISOString(),
        })
      )
    );

    console.log(`Processed analytics batch: ${eventIds.length} events`);

    return {
      success: true,
      processed: eventIds.length,
      skipped: args.events.length - validEvents.length,
      eventIds,
    };
  },
});

/**
 * Get analytics events (for development/admin)
 */
export const getAnalyticsEvents = query({
  args: {
    limit: v.optional(v.number()),
    eventType: v.optional(v.string()),
    enterpriseId: v.optional(v.id("enterprises")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    // Get user to check permissions
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    // Only allow admin/owner roles to view analytics in development
    if (process.env.NODE_ENV === 'development' && 
        ['admin', 'owner'].includes(user.role)) {
      
      let eventsQuery = ctx.db.query("analytics_events");
      
      // Filter by enterprise if specified
      if (args.enterpriseId) {
        eventsQuery = eventsQuery.filter(q => q.eq(q.field("enterpriseId"), args.enterpriseId));
      } else if (user.enterpriseId) {
        eventsQuery = eventsQuery.filter(q => q.eq(q.field("enterpriseId"), user.enterpriseId));
      }

      // Filter by event type if specified
      if (args.eventType) {
        eventsQuery = eventsQuery.filter(q => q.eq(q.field("event"), args.eventType));
      }

      const events = await eventsQuery
        .order("desc")
        .take(args.limit || 100);

      return {
        events,
        total: events.length,
        timestamp: new Date().toISOString(),
      };
    }

    throw new ConvexError("Unauthorized");
  },
});

/**
 * Report error
 */
export const reportError = mutation({
  args: errorReportSchema,
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    
    // Get user for enterprise context
    const user = identity ? await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first() : null;

    // Store error report
    const errorId = await ctx.db.insert("error_reports", {
      ...args,
      authenticatedUserId: user?._id,
      enterpriseId: user?.enterpriseId,
      serverTimestamp: Date.now(),
      createdAt: new Date().toISOString(),
    });

    // Log error to console
    console.error('Client Error Report:', {
      id: errorId,
      message: args.message,
      stack: args.stack,
      url: args.url,
      userId: user?._id,
      timestamp: new Date(args.timestamp).toISOString(),
    });

    // In production, you could integrate with external error tracking
    // Example: Send to Sentry, DataDog, etc.

    return errorId;
  },
});

/**
 * Get error reports (for development/admin)
 */
export const getErrorReports = query({
  args: {
    limit: v.optional(v.number()),
    enterpriseId: v.optional(v.id("enterprises")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    // Get user to check permissions
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    // Only allow admin/owner roles to view errors in development
    if (process.env.NODE_ENV === 'development' && 
        ['admin', 'owner'].includes(user.role)) {
      
      let errorsQuery = ctx.db.query("error_reports");
      
      // Filter by enterprise if specified
      if (args.enterpriseId) {
        errorsQuery = errorsQuery.filter(q => q.eq(q.field("enterpriseId"), args.enterpriseId));
      } else if (user.enterpriseId) {
        errorsQuery = errorsQuery.filter(q => q.eq(q.field("enterpriseId"), user.enterpriseId));
      }

      const errors = await errorsQuery
        .order("desc")
        .take(args.limit || 50);

      return {
        errors,
        total: errors.length,
        timestamp: new Date().toISOString(),
      };
    }

    throw new ConvexError("Unauthorized");
  },
});

/**
 * Health check
 */
export const getHealthStatus = query({
  args: {},
  handler: async (ctx) => {
    try {
      // Perform basic health checks
      const now = Date.now();
      
      // Check database connectivity by counting users
      const userCount = await ctx.db.query("users").collect().then(users => users.length);
      
      // Check if we can write/read (simple test)
      const testId = await ctx.db.insert("health_checks", {
        timestamp: now,
        status: "test",
        createdAt: new Date().toISOString(),
      });
      
      const testRecord = await ctx.db.get(testId);
      
      // Clean up test record
      await ctx.db.delete(testId);

      return {
        status: "healthy",
        timestamp: new Date().toISOString(),
        checks: {
          database: testRecord ? "ok" : "error",
          userCount,
          responseTime: Date.now() - now,
        },
        version: process.env.NEXT_PUBLIC_APP_VERSION || "development",
        environment: process.env.NODE_ENV,
      };
    } catch (error) {
      return {
        status: "unhealthy",
        timestamp: new Date().toISOString(),
        error: error instanceof Error ? error.message : "Unknown error",
        version: process.env.NEXT_PUBLIC_APP_VERSION || "development",
        environment: process.env.NODE_ENV,
      };
    }
  },
});

/**
 * Get system metrics (for monitoring dashboard)
 */
export const getSystemMetrics = query({
  args: {
    timeRange: v.optional(v.union(v.literal("1h"), v.literal("1d"), v.literal("7d"))),
    enterpriseId: v.optional(v.id("enterprises")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    // Get user to check permissions
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user || !['admin', 'owner'].includes(user.role)) {
      throw new ConvexError("Unauthorized");
    }

    const enterpriseId = args.enterpriseId || user.enterpriseId;
    const timeRange = args.timeRange || "1d";
    
    // Calculate time bounds
    const now = Date.now();
    const timeRangeMs = {
      "1h": 60 * 60 * 1000,
      "1d": 24 * 60 * 60 * 1000,
      "7d": 7 * 24 * 60 * 60 * 1000,
    }[timeRange];
    
    const since = now - timeRangeMs;

    // Get metrics
    const [
      activeUsers,
      totalContracts,
      recentErrors,
      recentEvents
    ] = await Promise.all([
      // Active users (users with recent events)
      ctx.db.query("analytics_events")
        .filter(q => q.and(
          q.eq(q.field("enterpriseId"), enterpriseId),
          q.gte(q.field("timestamp"), since)
        ))
        .collect()
        .then(events => new Set(events.map(e => e.authenticatedUserId)).size),
      
      // Total contracts
      ctx.db.query("contracts")
        .withIndex("by_enterprise", q => q.eq("enterpriseId", enterpriseId))
        .collect()
        .then(contracts => contracts.length),
      
      // Recent errors
      ctx.db.query("error_reports")
        .filter(q => q.and(
          q.eq(q.field("enterpriseId"), enterpriseId),
          q.gte(q.field("timestamp"), since)
        ))
        .collect(),
      
      // Recent events count
      ctx.db.query("analytics_events")
        .filter(q => q.and(
          q.eq(q.field("enterpriseId"), enterpriseId),
          q.gte(q.field("timestamp"), since)
        ))
        .collect()
    ]);

    return {
      timeRange,
      metrics: {
        activeUsers,
        totalContracts,
        errorCount: recentErrors.length,
        eventCount: recentEvents.length,
        errorRate: recentEvents.length > 0 ? (recentErrors.length / recentEvents.length) * 100 : 0,
      },
      timestamp: new Date().toISOString(),
    };
  },
});
</file>

<file path="convex/presence.ts">
import { query, mutation, internalMutation } from "./_generated/server";
import { v } from "convex/values";
import { Id } from "./_generated/dataModel";
import { getSecurityContext } from "./security/rowLevelSecurity";

/**
 * Real-time Presence System
 * 
 * Tracks who's online, what they're working on, and enables
 * real-time collaboration features
 */

/**
 * Update user presence - call this periodically from frontend
 */
export const updatePresence = mutation({
  args: {
    activity: v.optional(v.object({
      type: v.union(
        v.literal("viewing_contract"),
        v.literal("editing_contract"), 
        v.literal("viewing_vendor"),
        v.literal("dashboard"),
        v.literal("idle")
      ),
      resourceId: v.optional(v.string()),
      resourceTitle: v.optional(v.string()),
    })),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Find existing presence record
    const existingPresence = await ctx.db
      .query("userPresence")
      .withIndex("by_user", (q) => q.eq("userId", security.userId))
      .first();

    const presenceData = {
      userId: security.userId,
      enterpriseId: security.enterpriseId,
      lastSeen: new Date().toISOString(),
      isOnline: true,
      activity: args.activity || { type: "dashboard" as const },
    };

    if (existingPresence) {
      await ctx.db.patch(existingPresence._id, presenceData);
    } else {
      await ctx.db.insert("userPresence", presenceData);
    }
  },
});

/**
 * Mark user as offline
 */
export const setOffline = mutation({
  args: {},
  handler: async (ctx) => {
    const security = await getSecurityContext(ctx);
    
    const existingPresence = await ctx.db
      .query("userPresence")
      .withIndex("by_user", (q) => q.eq("userId", security.userId))
      .first();

    if (existingPresence) {
      await ctx.db.patch(existingPresence._id, {
        isOnline: false,
        lastSeen: new Date().toISOString(),
        activity: { type: "idle" as const },
      });
    }
  },
});

/**
 * Subscribe to online users in the enterprise
 */
export const subscribeToOnlineUsers = query({
  args: {},
  handler: async (ctx) => {
    const security = await getSecurityContext(ctx);
    
    // Get all recent presence records for the enterprise
    const fiveMinutesAgo = new Date(Date.now() - 5 * 60 * 1000).toISOString();
    
    const presenceRecords = await ctx.db
      .query("userPresence")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .filter((q) => 
        q.and(
          q.gte(q.field("lastSeen"), fiveMinutesAgo),
          q.eq(q.field("isOnline"), true)
        )
      )
      .collect();

    // Enrich with user data
    const onlineUsers = await Promise.all(
      presenceRecords.map(async (presence) => {
        const user = await ctx.db.get(presence.userId);
        if (!user) return null;

        return {
          userId: user._id,
          name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
          email: user.email,
          role: user.role,
          activity: presence.activity,
          lastSeen: presence.lastSeen,
        };
      })
    );

    return onlineUsers.filter(user => user !== null);
  },
});

/**
 * Subscribe to who's viewing/editing a specific contract
 */
export const subscribeToContractViewers = query({
  args: {
    contractId: v.id("contracts"),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Verify user has access to this contract
    const contract = await ctx.db.get(args.contractId);
    if (!contract || contract.enterpriseId !== security.enterpriseId) {
      return [];
    }

    const twoMinutesAgo = new Date(Date.now() - 2 * 60 * 1000).toISOString();
    
    const viewers = await ctx.db
      .query("userPresence")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .filter((q) => 
        q.and(
          q.gte(q.field("lastSeen"), twoMinutesAgo),
          q.eq(q.field("isOnline"), true)
        )
      )
      .collect();

    // Filter to users viewing this specific contract
    const contractViewers = viewers.filter(presence => 
      presence.activity?.resourceId === args.contractId &&
      (presence.activity?.type === "viewing_contract" || presence.activity?.type === "editing_contract")
    );

    // Enrich with user data
    const enrichedViewers = await Promise.all(
      contractViewers.map(async (presence) => {
        const user = await ctx.db.get(presence.userId);
        if (!user) return null;

        return {
          userId: user._id,
          name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
          activity: presence.activity,
          lastSeen: presence.lastSeen,
          isCurrentUser: user._id === security.userId,
        };
      })
    );

    return enrichedViewers.filter(viewer => viewer !== null);
  },
});

/**
 * Subscribe to enterprise activity feed
 */
export const subscribeToActivityFeed = query({
  args: {
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Get recent presence updates and audit logs
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
    
    // Get recent user activities
    const recentPresence = await ctx.db
      .query("userPresence")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .filter((q) => q.gte(q.field("lastSeen"), oneHourAgo))
      .collect();

    // Get recent audit events
    const recentAudit = await ctx.db
      .query("auditLogs")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .filter((q) => q.gte(q.field("timestamp"), oneHourAgo))
      .order("desc")
      .take(20);

    // Combine and sort activities
    const activities: any[] = [];

    // Add significant presence activities
    for (const presence of recentPresence) {
      if (presence.activity?.type === "editing_contract" || presence.activity?.type === "viewing_contract") {
        const user = await ctx.db.get(presence.userId);
        if (user) {
          activities.push({
            type: "presence",
            timestamp: presence.lastSeen,
            user: {
              _id: user._id,
              name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
            },
            activity: presence.activity,
          });
        }
      }
    }

    // Add audit events
    for (const audit of recentAudit) {
      if (audit.status === "success" && ["create", "update", "delete"].includes(audit.action)) {
        const user = await ctx.db.get(audit.userId);
        if (user) {
          activities.push({
            type: "action",
            timestamp: audit.timestamp,
            user: {
              _id: user._id,
              name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
            },
            action: audit.action,
            resourceType: audit.resourceType,
            operation: audit.operation,
          });
        }
      }
    }

    // Sort by timestamp and limit
    return activities
      .sort((a, b) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime())
      .slice(0, args.limit || 10);
  },
});

/**
 * Clean up old presence records
 */
export const cleanupPresence = internalMutation({
  args: {},
  handler: async (ctx) => {
    const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
    
    // Mark old presence records as offline
    const oldPresence = await ctx.db
      .query("userPresence")
      .filter((q) => q.lt(q.field("lastSeen"), oneHourAgo))
      .collect();

    for (const presence of oldPresence) {
      if (presence.isOnline) {
        await ctx.db.patch(presence._id, {
          isOnline: false,
          activity: { type: "idle" as const },
        });
      }
    }

    // Delete very old presence records (older than 24 hours)
    const oneDayAgo = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
    const veryOldPresence = await ctx.db
      .query("userPresence")
      .filter((q) => q.lt(q.field("lastSeen"), oneDayAgo))
      .collect();

    for (const presence of veryOldPresence) {
      await ctx.db.delete(presence._id);
    }
  },
});
</file>

<file path="convex/realtimeHelpers.ts">
import { MutationCtx } from "./_generated/server";
import { Id } from "./_generated/dataModel";

/**
 * Helper functions to automatically broadcast real-time events
 * when data changes occur
 */

/**
 * Broadcast contract-related events
 */
export async function broadcastContractEvent(
  ctx: MutationCtx,
  eventType: "contract_created" | "contract_updated" | "contract_deleted",
  contractId: Id<"contracts">,
  userId: Id<"users">,
  enterpriseId: Id<"enterprises">,
  additionalData?: any
) {
  await ctx.db.insert("realtimeEvents", {
    enterpriseId,
    userId,
    eventType,
    resourceId: contractId,
    resourceType: "contracts",
    data: additionalData,
    timestamp: new Date().toISOString(),
    processed: false,
  });
}

/**
 * Broadcast vendor-related events
 */
export async function broadcastVendorEvent(
  ctx: MutationCtx,
  eventType: "vendor_created" | "vendor_updated",
  vendorId: Id<"vendors">,
  userId: Id<"users">,
  enterpriseId: Id<"enterprises">,
  additionalData?: any
) {
  await ctx.db.insert("realtimeEvents", {
    enterpriseId,
    userId,
    eventType,
    resourceId: vendorId,
    resourceType: "vendors",
    data: additionalData,
    timestamp: new Date().toISOString(),
    processed: false,
  });
}

/**
 * Broadcast analysis completion events
 */
export async function broadcastAnalysisEvent(
  ctx: MutationCtx,
  contractId: Id<"contracts">,
  userId: Id<"users">,
  enterpriseId: Id<"enterprises">,
  analysisResults: any
) {
  await ctx.db.insert("realtimeEvents", {
    enterpriseId,
    userId,
    eventType: "analysis_completed",
    resourceId: contractId,
    resourceType: "contracts",
    data: {
      analysisStatus: "completed",
      results: analysisResults,
      completedAt: new Date().toISOString(),
    },
    timestamp: new Date().toISOString(),
    processed: false,
  });
}

/**
 * Broadcast notification events
 */
export async function broadcastNotificationEvent(
  ctx: MutationCtx,
  notificationId: Id<"notifications">,
  targetUserId: Id<"users">,
  enterpriseId: Id<"enterprises">,
  notificationData: any
) {
  await ctx.db.insert("realtimeEvents", {
    enterpriseId,
    userId: targetUserId, // The user who created the action that caused the notification
    eventType: "notification_created",
    resourceId: notificationId,
    resourceType: "notifications",
    data: notificationData,
    targetUsers: [targetUserId], // Only the target user should receive this
    timestamp: new Date().toISOString(),
    processed: false,
  });
}

/**
 * Broadcast user presence events
 */
export async function broadcastUserEvent(
  ctx: MutationCtx,
  eventType: "user_joined" | "user_left",
  userId: Id<"users">,
  enterpriseId: Id<"enterprises">,
  userData?: any
) {
  await ctx.db.insert("realtimeEvents", {
    enterpriseId,
    userId,
    eventType,
    resourceType: "users",
    data: userData,
    timestamp: new Date().toISOString(),
    processed: false,
  });
}

/**
 * Auto-trigger events when contracts are modified
 * Add this to your existing contract mutations
 */
export async function triggerContractEvents(
  ctx: MutationCtx,
  action: "create" | "update" | "delete",
  contractId: Id<"contracts">,
  userId: Id<"users">,
  enterpriseId: Id<"enterprises">,
  changes?: any
) {
  const eventType = `contract_${action}d` as "contract_created" | "contract_updated" | "contract_deleted";
  
  await broadcastContractEvent(
    ctx,
    eventType,
    contractId,
    userId,
    enterpriseId,
    changes
  );
}

/**
 * Auto-trigger events when vendors are modified
 */
export async function triggerVendorEvents(
  ctx: MutationCtx,
  action: "create" | "update",
  vendorId: Id<"vendors">,
  userId: Id<"users">,
  enterpriseId: Id<"enterprises">,
  changes?: any
) {
  const eventType = `vendor_${action}d` as "vendor_created" | "vendor_updated";
  
  await broadcastVendorEvent(
    ctx,
    eventType,
    vendorId,
    userId,
    enterpriseId,
    changes
  );
}
</file>

<file path="convex/server.ts">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;
</file>

<file path="convex/types.ts">
// convex/types.ts
import { Id, Doc } from "./_generated/dataModel";

// ============================================================================
// DOCUMENT TYPES (Convex table types)
// ============================================================================

export type Enterprise = Doc<"enterprises">;
export type User = Doc<"users">;
export type Vendor = Doc<"vendors">;
export type Contract = Doc<"contracts">;
export type Invitation = Doc<"invitations">;
export type UserOnboarding = Doc<"userOnboarding">;
export type UserPresence = Doc<"userPresence">;
export type RealtimeEvent = Doc<"realtimeEvents">;
export type TypingIndicator = Doc<"typingIndicators">;

// ============================================================================
// ENUM TYPES (from schema)
// ============================================================================

export type ContractStatus = 
  | "draft" 
  | "pending_analysis" 
  | "active" 
  | "expired" 
  | "terminated" 
  | "archived";

export type AnalysisStatus = 
  | "pending" 
  | "processing" 
  | "completed" 
  | "failed";

export type VendorCategory = 
  | "technology"
  | "marketing"
  | "legal"
  | "finance"
  | "hr"
  | "facilities"
  | "logistics"
  | "manufacturing"
  | "consulting"
  | "other";

export type ContractType = 
  | "nda"
  | "msa"
  | "sow"
  | "saas"
  | "lease"
  | "employment"
  | "partnership"
  | "other";

export type UserRole = 
  | "owner"
  | "admin"
  | "manager"
  | "user"
  | "viewer";

export type VendorStatus = "active" | "inactive";

export type NotificationChannel = "in_app" | "email" | "sms";

export type ActivityType = 
  | "viewing_contract"
  | "editing_contract"
  | "viewing_vendor"
  | "dashboard"
  | "idle";

export type RealtimeEventType = 
  | "contract_updated"
  | "contract_created"
  | "contract_deleted"
  | "vendor_updated"
  | "vendor_created"
  | "analysis_completed"
  | "notification_created"
  | "user_joined"
  | "user_left"
  | "system_alert";

// ============================================================================
// FILTER AND QUERY TYPES
// ============================================================================

export interface ContractFilters {
  enterpriseId: Id<"enterprises">;
  status?: ContractStatus | "all";
  contractType?: ContractType | "all";
  vendorId?: Id<"vendors">;
  analysisStatus?: AnalysisStatus | "all";
  searchQuery?: string;
  startDate?: string;
  endDate?: string;
  minValue?: number;
  maxValue?: number;
  limit?: number;
  offset?: number;
  sortBy?: "title" | "createdAt" | "value" | "endDate" | "status";
  sortOrder?: "asc" | "desc";
}

export interface VendorFilters {
  enterpriseId: Id<"enterprises">;
  category?: VendorCategory | "all";
  status?: VendorStatus | "all";
  searchQuery?: string;
  limit?: number;
  offset?: number;
  sortBy?: "name" | "createdAt" | "category" | "status";
  sortOrder?: "asc" | "desc";
}

export interface UserFilters {
  enterpriseId: Id<"enterprises">;
  role?: UserRole | "all";
  isActive?: boolean;
  department?: string;
  searchQuery?: string;
  limit?: number;
  offset?: number;
  sortBy?: "firstName" | "lastName" | "email" | "createdAt" | "role";
  sortOrder?: "asc" | "desc";
}

// ============================================================================
// ANALYTICS TYPES
// ============================================================================

export interface ContractAnalytics {
  totalContracts: number;
  activeContracts: number;
  expiredContracts: number;
  draftContracts: number;
  totalValue: number;
  averageValue: number;
  contractsByType: Record<ContractType, number>;
  contractsByStatus: Record<ContractStatus, number>;
  monthlyTrends: MonthlyTrend[];
  expiringNext30Days: number;
  renewalRate: number;
  complianceScore: number;
}

export interface VendorAnalytics {
  totalVendors: number;
  activeVendors: number;
  inactiveVendors: number;
  vendorsByCategory: Record<VendorCategory, number>;
  averageContractsPerVendor: number;
  topVendorsByValue: VendorMetric[];
  vendorPerformanceScores: VendorPerformance[];
  newVendorsThisMonth: number;
}

export interface MonthlyTrend {
  month: string;
  year: number;
  contractsCreated: number;
  contractsExpired: number;
  totalValue: number;
  activeContracts: number;
}

export interface VendorMetric {
  vendorId: Id<"vendors">;
  vendorName: string;
  totalValue: number;
  contractCount: number;
  averageValue: number;
  category: VendorCategory;
}

export interface VendorPerformance {
  vendorId: Id<"vendors">;
  vendorName: string;
  performanceScore: number;
  onTimeDelivery: number;
  qualityScore: number;
  communicationScore: number;
  category: VendorCategory;
}

// ============================================================================
// SEARCH TYPES
// ============================================================================

export interface SearchResults {
  contracts: SearchResultContract[];
  vendors: SearchResultVendor[];
  users: SearchResultUser[];
  total: number;
}

export interface SearchResultContract {
  _id: Id<"contracts">;
  title: string;
  status: ContractStatus;
  vendorName: string;
  value?: number;
  highlightedContent?: string;
}

export interface SearchResultVendor {
  _id: Id<"vendors">;
  name: string;
  category?: VendorCategory;
  status?: VendorStatus;
  contractCount: number;
  highlightedContent?: string;
}

export interface SearchResultUser {
  _id: Id<"users">;
  firstName?: string;
  lastName?: string;
  email: string;
  role: UserRole;
  department?: string;
  highlightedContent?: string;
}

// ============================================================================
// NOTIFICATION TYPES
// ============================================================================

export interface NotificationPreferences {
  channels: NotificationChannel[];
  contractExpirations: boolean;
  analysisComplete: boolean;
  systemAlerts: boolean;
  teamUpdates: boolean;
}

export interface NotificationData {
  type: "contract_expiration" | "analysis_complete" | "system_alert" | "team_update";
  title: string;
  message: string;
  actionUrl?: string;
  priority: "low" | "medium" | "high" | "critical";
  metadata?: Record<string, unknown>;
}

// ============================================================================
// RESPONSE TYPES
// ============================================================================

export interface PaginatedResponse<T> {
  data: T[];
  total: number;
  hasMore: boolean;
  offset: number;
  limit: number;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  message?: string;
  error?: string;
}

// ============================================================================
// UTILITY TYPES
// ============================================================================

export type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export type CreateVendorArgs = OptionalFields<
  Omit<Vendor, "_id" | "_creationTime" | "createdAt">,
  "status" | "category" | "contactEmail" | "contactPhone" | "address" | "notes" | "website"
> & {
  createdAt: string;
};

export type UpdateVendorArgs = Partial<
  Omit<Vendor, "_id" | "_creationTime" | "enterpriseId">
>;

export type CreateContractArgs = OptionalFields<
  Omit<Contract, "_id" | "_creationTime" | "createdAt" | "analysisStatus" | "analysisError">,
  | "contractType"
  | "value"
  | "startDate"
  | "endDate"
  | "extractedParties"
  | "extractedStartDate"
  | "extractedEndDate"
  | "extractedPaymentSchedule"
  | "extractedPricing"
  | "extractedScope"
  | "notes"
> & {
  createdAt: string;
};

export type UpdateContractArgs = Partial<
  Omit<Contract, "_id" | "_creationTime" | "enterpriseId" | "storageId" | "fileName" | "fileType">
>;

// ============================================================================
// FILTER HELPER TYPES
// ============================================================================

export interface DateRange {
  start?: string;
  end?: string;
}

export interface NumericRange {
  min?: number;
  max?: number;
}

export interface SortOptions {
  field: string;
  direction: "asc" | "desc";
}

export interface PaginationOptions {
  limit?: number;
  offset?: number;
}

// ============================================================================
// VALIDATION TYPES
// ============================================================================

export interface ValidationError {
  field: string;
  message: string;
  code: string;
}

export interface ValidationResult {
  isValid: boolean;
  errors: ValidationError[];
}

// ============================================================================
// AUDIT LOG TYPES
// ============================================================================

export interface AuditLogEntry {
  userId: Id<"users">;
  enterpriseId: Id<"enterprises">;
  action: string;
  resourceType: string;
  resourceId?: string;
  details?: Record<string, unknown>;
  timestamp: string;
  ipAddress?: string;
  userAgent?: string;
}

// ============================================================================
// TYPE GUARDS
// ============================================================================

export function isContractStatus(value: string): value is ContractStatus {
  return ["draft", "pending_analysis", "active", "expired", "terminated", "archived"].includes(value);
}

export function isVendorCategory(value: string): value is VendorCategory {
  return [
    "technology", "marketing", "legal", "finance", "hr",
    "facilities", "logistics", "manufacturing", "consulting", "other"
  ].includes(value);
}

export function isUserRole(value: string): value is UserRole {
  return ["owner", "admin", "manager", "user", "viewer"].includes(value);
}

export function isNotificationChannel(value: string): value is NotificationChannel {
  return ["in_app", "email", "sms"].includes(value);
}
</file>

<file path="public/file.svg">
<svg fill="none" viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg"><path d="M14.5 13.5V5.41a1 1 0 0 0-.3-.7L9.8.29A1 1 0 0 0 9.08 0H1.5v13.5A2.5 2.5 0 0 0 4 16h8a2.5 2.5 0 0 0 2.5-2.5m-1.5 0v-7H8v-5H3v12a1 1 0 0 0 1 1h8a1 1 0 0 0 1-1M9.5 5V2.12L12.38 5zM5.13 5h-.62v1.25h2.12V5zm-.62 3h7.12v1.25H4.5zm.62 3h-.62v1.25h7.12V11z" clip-rule="evenodd" fill="#666" fill-rule="evenodd"/></svg>
</file>

<file path="public/globe.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><g clip-path="url(#a)"><path fill-rule="evenodd" clip-rule="evenodd" d="M10.27 14.1a6.5 6.5 0 0 0 3.67-3.45q-1.24.21-2.7.34-.31 1.83-.97 3.1M8 16A8 8 0 1 0 8 0a8 8 0 0 0 0 16m.48-1.52a7 7 0 0 1-.96 0H7.5a4 4 0 0 1-.84-1.32q-.38-.89-.63-2.08a40 40 0 0 0 3.92 0q-.25 1.2-.63 2.08a4 4 0 0 1-.84 1.31zm2.94-4.76q1.66-.15 2.95-.43a7 7 0 0 0 0-2.58q-1.3-.27-2.95-.43a18 18 0 0 1 0 3.44m-1.27-3.54a17 17 0 0 1 0 3.64 39 39 0 0 1-4.3 0 17 17 0 0 1 0-3.64 39 39 0 0 1 4.3 0m1.1-1.17q1.45.13 2.69.34a6.5 6.5 0 0 0-3.67-3.44q.65 1.26.98 3.1M8.48 1.5l.01.02q.41.37.84 1.31.38.89.63 2.08a40 40 0 0 0-3.92 0q.25-1.2.63-2.08a4 4 0 0 1 .85-1.32 7 7 0 0 1 .96 0m-2.75.4a6.5 6.5 0 0 0-3.67 3.44 29 29 0 0 1 2.7-.34q.31-1.83.97-3.1M4.58 6.28q-1.66.16-2.95.43a7 7 0 0 0 0 2.58q1.3.27 2.95.43a18 18 0 0 1 0-3.44m.17 4.71q-1.45-.12-2.69-.34a6.5 6.5 0 0 0 3.67 3.44q-.65-1.27-.98-3.1" fill="#666"/></g><defs><clipPath id="a"><path fill="#fff" d="M0 0h16v16H0z"/></clipPath></defs></svg>
</file>

<file path="public/next.svg">
<svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 394 80"><path fill="#000" d="M262 0h68.5v12.7h-27.2v66.6h-13.6V12.7H262V0ZM149 0v12.7H94v20.4h44.3v12.6H94v21h55v12.6H80.5V0h68.7zm34.3 0h-17.8l63.8 79.4h17.9l-32-39.7 32-39.6h-17.9l-23 28.6-23-28.6zm18.3 56.7-9-11-27.1 33.7h17.8l18.3-22.7z"/><path fill="#000" d="M81 79.3 17 0H0v79.3h13.6V17l50.2 62.3H81Zm252.6-.4c-1 0-1.8-.4-2.5-1s-1.1-1.6-1.1-2.6.3-1.8 1-2.5 1.6-1 2.6-1 1.8.3 2.5 1a3.4 3.4 0 0 1 .6 4.3 3.7 3.7 0 0 1-3 1.8zm23.2-33.5h6v23.3c0 2.1-.4 4-1.3 5.5a9.1 9.1 0 0 1-3.8 3.5c-1.6.8-3.5 1.3-5.7 1.3-2 0-3.7-.4-5.3-1s-2.8-1.8-3.7-3.2c-.9-1.3-1.4-3-1.4-5h6c.1.8.3 1.6.7 2.2s1 1.2 1.6 1.5c.7.4 1.5.5 2.4.5 1 0 1.8-.2 2.4-.6a4 4 0 0 0 1.6-1.8c.3-.8.5-1.8.5-3V45.5zm30.9 9.1a4.4 4.4 0 0 0-2-3.3 7.5 7.5 0 0 0-4.3-1.1c-1.3 0-2.4.2-3.3.5-.9.4-1.6 1-2 1.6a3.5 3.5 0 0 0-.3 4c.3.5.7.9 1.3 1.2l1.8 1 2 .5 3.2.8c1.3.3 2.5.7 3.7 1.2a13 13 0 0 1 3.2 1.8 8.1 8.1 0 0 1 3 6.5c0 2-.5 3.7-1.5 5.1a10 10 0 0 1-4.4 3.5c-1.8.8-4.1 1.2-6.8 1.2-2.6 0-4.9-.4-6.8-1.2-2-.8-3.4-2-4.5-3.5a10 10 0 0 1-1.7-5.6h6a5 5 0 0 0 3.5 4.6c1 .4 2.2.6 3.4.6 1.3 0 2.5-.2 3.5-.6 1-.4 1.8-1 2.4-1.7a4 4 0 0 0 .8-2.4c0-.9-.2-1.6-.7-2.2a11 11 0 0 0-2.1-1.4l-3.2-1-3.8-1c-2.8-.7-5-1.7-6.6-3.2a7.2 7.2 0 0 1-2.4-5.7 8 8 0 0 1 1.7-5 10 10 0 0 1 4.3-3.5c2-.8 4-1.2 6.4-1.2 2.3 0 4.4.4 6.2 1.2 1.8.8 3.2 2 4.3 3.4 1 1.4 1.5 3 1.5 5h-5.8z"/></svg>
</file>

<file path="public/vercel.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1155 1000"><path d="m577.3 0 577.4 1000H0z" fill="#fff"/></svg>
</file>

<file path="public/window.svg">
<svg fill="none" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 16 16"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.5 2.5h13v10a1 1 0 0 1-1 1h-11a1 1 0 0 1-1-1zM0 1h16v11.5a2.5 2.5 0 0 1-2.5 2.5h-11A2.5 2.5 0 0 1 0 12.5zm3.75 4.5a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5M7 4.75a.75.75 0 1 1-1.5 0 .75.75 0 0 1 1.5 0m1.75.75a.75.75 0 1 0 0-1.5.75.75 0 0 0 0 1.5" fill="#666"/></svg>
</file>

<file path="src/app/_components/agents/AgentCard.tsx">
'use client'

import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import {
  Bot,
  Activity,
  Clock,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Eye,
  EyeOff,
  Settings,
  Play,
  Pause,
  BarChart3,
} from "lucide-react";
import { Agent, AgentStatus, AGENT_TYPE_LABELS, STATUS_COLORS } from "@/types/agents.types";
import { cn } from "@/lib/utils";

interface AgentCardProps {
  agent: Agent;
  onToggleAgent?: (agentId: string, enabled: boolean) => void;
  onConfigureAgent?: (agentId: string) => void;
  onViewDetails?: (agentId: string) => void;
  loading?: boolean;
}

export const AgentCard: React.FC<AgentCardProps> = ({
  agent,
  onToggleAgent,
  onConfigureAgent,
  onViewDetails,
  loading = false,
}) => {
  const getStatusIcon = (status: AgentStatus) => {
    switch (status) {
      case 'active':
        return <CheckCircle className="h-4 w-4 text-green-600" />;
      case 'busy':
        return <Activity className="h-4 w-4 text-blue-600 animate-pulse" />;
      case 'error':
        return <XCircle className="h-4 w-4 text-red-600" />;
      case 'disabled':
        return <Pause className="h-4 w-4 text-gray-600" />;
      default:
        return <Clock className="h-4 w-4 text-gray-600" />;
    }
  };

  const getPerformanceScore = () => {
    if (agent.runCount === 0) return 0;
    const successRate = ((agent.runCount - agent.errorCount) / agent.runCount) * 100;
    return Math.round(successRate);
  };

  const getPerformanceColor = (score: number) => {
    if (score >= 90) return "text-green-600";
    if (score >= 75) return "text-yellow-600";
    if (score >= 60) return "text-orange-600";
    return "text-red-600";
  };

  const formatLastRun = (lastRun?: string) => {
    if (!lastRun) return "Never";
    const date = new Date(lastRun);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / (1000 * 60));
    
    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
    return `${Math.floor(diffMins / 1440)}d ago`;
  };

  const performanceScore = getPerformanceScore();

  return (
    <Card className={cn(
      "transition-all duration-200 hover:shadow-md",
      !agent.isEnabled && "opacity-75",
      agent.status === 'error' && "border-red-200 bg-red-50/50"
    )}>
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between">
          <div className="flex items-center space-x-3">
            <div className="relative">
              <Bot className={cn(
                "h-8 w-8",
                agent.isEnabled ? "text-primary" : "text-gray-400"
              )} />
              <div className="absolute -bottom-1 -right-1">
                {getStatusIcon(agent.status)}
              </div>
            </div>
            <div>
              <CardTitle className="text-lg font-semibold">
                {agent.name}
              </CardTitle>
              <p className="text-sm text-muted-foreground">
                {AGENT_TYPE_LABELS[agent.type]}
              </p>
            </div>
          </div>
          <Badge className={STATUS_COLORS[agent.status]}>
            {agent.status.charAt(0).toUpperCase() + agent.status.slice(1)}
          </Badge>
        </div>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Description */}
        {agent.description && (
          <p className="text-sm text-muted-foreground line-clamp-2">
            {agent.description}
          </p>
        )}

        {/* Performance Metrics */}
        <div className="space-y-3">
          <div className="flex items-center justify-between">
            <span className="text-sm font-medium">Performance</span>
            <span className={cn("text-sm font-bold", getPerformanceColor(performanceScore))}>
              {performanceScore}%
            </span>
          </div>
          <Progress 
            value={performanceScore} 
            className="h-2"
          />
        </div>

        {/* Stats Grid */}
        <div className="grid grid-cols-2 gap-3 text-sm">
          <div className="space-y-1">
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Runs:</span>
              <span className="font-medium">{agent.runCount}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Errors:</span>
              <span className={cn(
                "font-medium",
                agent.errorCount > 0 ? "text-red-600" : "text-green-600"
              )}>
                {agent.errorCount}
              </span>
            </div>
          </div>
          <div className="space-y-1">
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Type:</span>
              <span className="font-medium capitalize">{agent.type}</span>
            </div>
            <div className="flex items-center justify-between">
              <span className="text-muted-foreground">Last Run:</span>
              <span className="font-medium">{formatLastRun(agent.lastRun)}</span>
            </div>
          </div>
        </div>

        {/* Error Message */}
        {agent.lastError && agent.status === 'error' && (
          <div className="flex items-start space-x-2 p-2 bg-red-50 rounded-md border border-red-200">
            <AlertTriangle className="h-4 w-4 text-red-600 mt-0.5 flex-shrink-0" />
            <p className="text-sm text-red-700 line-clamp-2">
              {agent.lastError}
            </p>
          </div>
        )}

        {/* Agent Metrics */}
        {agent.metrics && (
          <div className="space-y-2">
            <div className="flex items-center space-x-2">
              <BarChart3 className="h-4 w-4 text-muted-foreground" />
              <span className="text-sm font-medium">Metrics</span>
            </div>
            <div className="grid grid-cols-2 gap-2 text-xs">
              {agent.metrics.insightsGenerated !== undefined && (
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Insights:</span>
                  <span className="font-medium">{agent.metrics.insightsGenerated}</span>
                </div>
              )}
              {agent.metrics.averageRunTime !== undefined && (
                <div className="flex justify-between">
                  <span className="text-muted-foreground">Avg Time:</span>
                  <span className="font-medium">{Math.round(agent.metrics.averageRunTime / 1000)}s</span>
                </div>
              )}
            </div>
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex items-center justify-between pt-2 border-t">
          <Button
            variant="outline"
            size="sm"
            onClick={() => onToggleAgent?.(agent._id, !agent.isEnabled)}
            disabled={loading}
            className="flex items-center space-x-1"
          >
            {agent.isEnabled ? (
              <EyeOff className="h-3 w-3" />
            ) : (
              <Eye className="h-3 w-3" />
            )}
            <span>{agent.isEnabled ? 'Disable' : 'Enable'}</span>
          </Button>

          <div className="flex items-center space-x-1">
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onConfigureAgent?.(agent._id)}
              disabled={loading}
            >
              <Settings className="h-3 w-3" />
            </Button>
            <Button
              variant="ghost"
              size="sm"
              onClick={() => onViewDetails?.(agent._id)}
              disabled={loading}
            >
              <BarChart3 className="h-3 w-3" />
            </Button>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

export default AgentCard;
</file>

<file path="src/app/_components/agents/AgentLogViewer.tsx">
'use client'

import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  AlertTriangle,
  Info,
  AlertCircle,
  Bug,
  Zap,
  Search,
  Filter,
  Download,
  Clock,
  Bot,
  RefreshCw,
  ChevronDown,
  ChevronRight,
} from "lucide-react";
import { LogLevel, LOG_LEVEL_COLORS } from "@/types/agents.types";
import { cn } from "@/lib/utils";

interface LogEntry {
  _id: string;
  agentId: string;
  agentName: string;
  level: LogLevel;
  message: string;
  timestamp: string;
  taskId?: string;
  category?: string;
  source?: string;
  data?: any;
}

interface AgentLogViewerProps {
  logs: LogEntry[];
  onRefresh?: () => void;
  onExportLogs?: () => void;
  loading?: boolean;
}

export const AgentLogViewer: React.FC<AgentLogViewerProps> = ({
  logs,
  onRefresh,
  onExportLogs,
  loading = false,
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [levelFilter, setLevelFilter] = useState<string>("all");
  const [agentFilter, setAgentFilter] = useState<string>("all");
  const [expandedLogs, setExpandedLogs] = useState<Set<string>>(new Set());

  const getLogIcon = (level: LogLevel) => {
    switch (level) {
      case 'error':
      case 'critical':
        return <AlertTriangle className="h-4 w-4" />;
      case 'warn':
        return <AlertCircle className="h-4 w-4" />;
      case 'info':
        return <Info className="h-4 w-4" />;
      case 'debug':
        return <Bug className="h-4 w-4" />;
      default:
        return <Info className="h-4 w-4" />;
    }
  };

  const formatTimestamp = (timestamp: string) => {
    const date = new Date(timestamp);
    return date.toLocaleString('en-US', {
      month: 'short',
      day: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
      second: '2-digit',
      hour12: false,
    });
  };

  const formatTimeAgo = (timestamp: string) => {
    const date = new Date(timestamp);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffSecs = Math.floor(diffMs / 1000);
    const diffMins = Math.floor(diffSecs / 60);
    const diffHours = Math.floor(diffMins / 60);
    
    if (diffSecs < 60) return `${diffSecs}s ago`;
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffHours < 24) return `${diffHours}h ago`;
    return date.toLocaleDateString();
  };

  const toggleLogExpansion = (logId: string) => {
    setExpandedLogs(prev => {
      const newSet = new Set(prev);
      if (newSet.has(logId)) {
        newSet.delete(logId);
      } else {
        newSet.add(logId);
      }
      return newSet;
    });
  };

  // Get unique agents for filter
  const uniqueAgents = Array.from(new Set(logs.map(log => log.agentName))).sort();

  // Filter logs
  const filteredLogs = logs.filter(log => {
    const matchesSearch = !searchTerm || 
      log.message.toLowerCase().includes(searchTerm.toLowerCase()) ||
      log.agentName.toLowerCase().includes(searchTerm.toLowerCase()) ||
      log.category?.toLowerCase().includes(searchTerm.toLowerCase());
    
    const matchesLevel = levelFilter === 'all' || log.level === levelFilter;
    const matchesAgent = agentFilter === 'all' || log.agentName === agentFilter;
    
    return matchesSearch && matchesLevel && matchesAgent;
  });

  // Group logs by level for stats
  const logStats = logs.reduce((acc, log) => {
    acc[log.level] = (acc[log.level] || 0) + 1;
    return acc;
  }, {} as Record<LogLevel, number>);

  return (
    <div className="space-y-4">
      {/* Header and Controls */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <CardTitle className="flex items-center space-x-2">
              <Bot className="h-5 w-5" />
              <span>Agent System Logs</span>
              <Badge variant="outline">
                {filteredLogs.length} of {logs.length}
              </Badge>
            </CardTitle>
            
            <div className="flex items-center space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={onRefresh}
                disabled={loading}
              >
                <RefreshCw className={cn("h-4 w-4", loading && "animate-spin")} />
              </Button>
              <Button
                variant="outline"
                size="sm"
                onClick={onExportLogs}
              >
                <Download className="h-4 w-4 mr-1" />
                Export
              </Button>
            </div>
          </div>
        </CardHeader>

        <CardContent className="space-y-4">
          {/* Log Level Stats */}
          <div className="flex items-center space-x-4">
            {Object.entries(logStats).map(([level, count]) => (
              <div
                key={level}
                className="flex items-center space-x-2"
              >
                {getLogIcon(level as LogLevel)}
                <Badge className={LOG_LEVEL_COLORS[level as LogLevel]}>
                  {level.toUpperCase()}: {count}
                </Badge>
              </div>
            ))}
          </div>

          {/* Filters */}
          <div className="flex items-center space-x-4">
            <div className="relative flex-1">
              <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input
                placeholder="Search logs..."
                value={searchTerm}
                onChange={(e) => setSearchTerm(e.target.value)}
                className="pl-8"
              />
            </div>
            
            <Select value={levelFilter} onValueChange={setLevelFilter}>
              <SelectTrigger className="w-[140px]">
                <SelectValue placeholder="Log Level" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Levels</SelectItem>
                <SelectItem value="debug">Debug</SelectItem>
                <SelectItem value="info">Info</SelectItem>
                <SelectItem value="warn">Warning</SelectItem>
                <SelectItem value="error">Error</SelectItem>
                <SelectItem value="critical">Critical</SelectItem>
              </SelectContent>
            </Select>

            <Select value={agentFilter} onValueChange={setAgentFilter}>
              <SelectTrigger className="w-[160px]">
                <SelectValue placeholder="Agent" />
              </SelectTrigger>
              <SelectContent>
                <SelectItem value="all">All Agents</SelectItem>
                {uniqueAgents.map(agent => (
                  <SelectItem key={agent} value={agent}>
                    {agent}
                  </SelectItem>
                ))}
              </SelectContent>
            </Select>
          </div>
        </CardContent>
      </Card>

      {/* Log Entries */}
      <div className="space-y-2">
        {filteredLogs.length > 0 ? (
          filteredLogs.map((log) => {
            const isExpanded = expandedLogs.has(log._id);
            const hasExtraData = log.data && Object.keys(log.data).length > 0;
            
            return (
              <Card
                key={log._id}
                className={cn(
                  "transition-all duration-200",
                  log.level === 'error' && 'border-red-200 bg-red-50/50',
                  log.level === 'critical' && 'border-red-300 bg-red-100/50',
                  log.level === 'warn' && 'border-yellow-200 bg-yellow-50/50'
                )}
              >
                <CardContent className="p-4">
                  <div className="flex items-start justify-between">
                    <div className="flex items-start space-x-3 flex-1">
                      <div className={cn(
                        "p-1.5 rounded-md",
                        LOG_LEVEL_COLORS[log.level]
                      )}>
                        {getLogIcon(log.level)}
                      </div>
                      
                      <div className="flex-1 space-y-1">
                        <div className="flex items-center space-x-2">
                          <Badge
                            variant="outline"
                            className={LOG_LEVEL_COLORS[log.level]}
                          >
                            {log.level.toUpperCase()}
                          </Badge>
                          <span className="font-medium text-sm">{log.agentName}</span>
                          {log.category && (
                            <Badge variant="outline" className="text-xs">
                              {log.category}
                            </Badge>
                          )}
                          {log.taskId && (
                            <Badge variant="outline" className="text-xs">
                              Task: {log.taskId.slice(-8)}
                            </Badge>
                          )}
                        </div>
                        
                        <p className="text-sm">
                          {log.message}
                        </p>
                        
                        {isExpanded && hasExtraData && (
                          <div className="mt-3 p-3 bg-gray-50 rounded-md border">
                            <h4 className="text-xs font-medium text-gray-700 mb-2">Additional Data:</h4>
                            <pre className="text-xs text-gray-600 overflow-x-auto">
                              {JSON.stringify(log.data, null, 2)}
                            </pre>
                          </div>
                        )}
                      </div>
                    </div>
                    
                    <div className="flex items-center space-x-2 text-xs text-muted-foreground">
                      <Clock className="h-3 w-3" />
                      <span>{formatTimestamp(log.timestamp)}</span>
                      <span className="text-gray-400">
                        ({formatTimeAgo(log.timestamp)})
                      </span>
                      
                      {hasExtraData && (
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => toggleLogExpansion(log._id)}
                          className="h-6 w-6 p-0"
                        >
                          {isExpanded ? (
                            <ChevronDown className="h-3 w-3" />
                          ) : (
                            <ChevronRight className="h-3 w-3" />
                          )}
                        </Button>
                      )}
                    </div>
                  </div>
                </CardContent>
              </Card>
            );
          })
        ) : (
          <Card>
            <CardContent className="text-center py-12">
              <Bot className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
              <p className="text-muted-foreground">
                {logs.length === 0 ? "No logs available." : "No logs match your filter criteria."}
              </p>
              {searchTerm || levelFilter !== 'all' || agentFilter !== 'all' ? (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={() => {
                    setSearchTerm("");
                    setLevelFilter("all");
                    setAgentFilter("all");
                  }}
                  className="mt-2"
                >
                  Clear Filters
                </Button>
              ) : null}
            </CardContent>
          </Card>
        )}
      </div>
    </div>
  );
};

export default AgentLogViewer;
</file>

<file path="src/app/_components/agents/AgentSystemStatus.tsx">
'use client'

import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Progress } from "@/components/ui/progress";
import {
  Bot,
  Activity,
  Clock,
  CheckCircle,
  AlertTriangle,
  Zap,
  TrendingUp,
  Users,
  Brain,
  Play,
  Square,
  Settings,
  RefreshCw,
  Loader2,
} from "lucide-react";
import { AgentSystem, AgentSystemStatusResponse } from "@/types/agents.types";
import { cn } from "@/lib/utils";

interface AgentSystemStatusProps {
  systemStatus: AgentSystemStatusResponse | null;
  onStartSystem?: () => void;
  onStopSystem?: () => void;
  onInitializeSystem?: () => void;
  onRefreshStatus?: () => void;
  loading?: boolean;
  startLoading?: boolean;
  stopLoading?: boolean;
  initLoading?: boolean;
}

export const AgentSystemStatus: React.FC<AgentSystemStatusProps> = ({
  systemStatus,
  onStartSystem,
  onStopSystem,
  onInitializeSystem,
  onRefreshStatus,
  loading = false,
  startLoading = false,
  stopLoading = false,
  initLoading = false,
}) => {
  if (!systemStatus) {
    return (
      <Card>
        <CardContent className="flex flex-col items-center justify-center py-12">
          <Bot className="h-16 w-16 text-muted-foreground mb-4" />
          <h3 className="text-lg font-semibold mb-2">Agent System Not Initialized</h3>
          <p className="text-muted-foreground text-center mb-6 max-w-md">
            The AI agent system hasn't been set up yet. Initialize it to start getting AI-powered 
            insights and automated contract analysis.
          </p>
          <Button 
            onClick={onInitializeSystem}
            disabled={initLoading}
            className="bg-blue-600 hover:bg-blue-700"
          >
            {initLoading ? (
              <Loader2 className="h-4 w-4 animate-spin mr-2" />
            ) : (
              <Settings className="h-4 w-4 mr-2" />
            )}
            Initialize Agent System
          </Button>
        </CardContent>
      </Card>
    );
  }

  const { system, stats } = systemStatus;

  const getSystemStatusColor = (status: string) => {
    switch (status) {
      case 'running':
        return 'bg-green-100 text-green-800 border-green-200';
      case 'stopped':
        return 'bg-red-100 text-red-800 border-red-200';
      case 'starting':
        return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'error':
        return 'bg-red-100 text-red-800 border-red-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  const getSystemStatusIcon = () => {
    switch (system.status) {
      case 'running':
        return <CheckCircle className="h-5 w-5 text-green-600" />;
      case 'stopped':
        return <Clock className="h-5 w-5 text-red-600" />;
      case 'starting':
        return <Loader2 className="h-5 w-5 text-yellow-600 animate-spin" />;
      case 'error':
        return <AlertTriangle className="h-5 w-5 text-red-600" />;
      default:
        return <Activity className="h-5 w-5 text-gray-600" />;
    }
  };

  const formatUptime = () => {
    if (!system.lastStarted || !system.isRunning) return "N/A";
    
    const startTime = new Date(system.lastStarted);
    const now = new Date();
    const diffMs = now.getTime() - startTime.getTime();
    
    const days = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    const hours = Math.floor((diffMs % (1000 * 60 * 60 * 24)) / (1000 * 60 * 60));
    const minutes = Math.floor((diffMs % (1000 * 60 * 60)) / (1000 * 60));
    
    if (days > 0) return `${days}d ${hours}h`;
    if (hours > 0) return `${hours}h ${minutes}m`;
    return `${minutes}m`;
  };

  const getAgentHealthPercentage = () => {
    if (stats.totalAgents === 0) return 0;
    return Math.round((stats.activeAgents / stats.totalAgents) * 100);
  };

  return (
    <div className="space-y-6">
      {/* Main System Status Card */}
      <Card>
        <CardHeader>
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-3">
              {getSystemStatusIcon()}
              <div>
                <CardTitle className="flex items-center space-x-2">
                  <span>Agent System Status</span>
                  <Badge className={getSystemStatusColor(system.status)}>
                    {system.status.charAt(0).toUpperCase() + system.status.slice(1)}
                  </Badge>
                </CardTitle>
                <p className="text-sm text-muted-foreground mt-1">
                  AI-powered contract intelligence system
                </p>
              </div>
            </div>
            
            {/* System Controls */}
            <div className="flex items-center space-x-2">
              <Button
                variant="outline"
                size="sm"
                onClick={onRefreshStatus}
                disabled={loading}
              >
                <RefreshCw className={cn("h-4 w-4", loading && "animate-spin")} />
              </Button>
              
              {system.isRunning ? (
                <Button
                  variant="destructive"
                  size="sm"
                  onClick={onStopSystem}
                  disabled={stopLoading}
                >
                  {stopLoading ? (
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                  ) : (
                    <Square className="h-4 w-4 mr-2" />
                  )}
                  Stop System
                </Button>
              ) : (
                <Button
                  size="sm"
                  onClick={onStartSystem}
                  disabled={startLoading}
                  className="bg-green-600 hover:bg-green-700"
                >
                  {startLoading ? (
                    <Loader2 className="h-4 w-4 animate-spin mr-2" />
                  ) : (
                    <Play className="h-4 w-4 mr-2" />
                  )}
                  Start System
                </Button>
              )}
            </div>
          </div>
        </CardHeader>

        <CardContent>
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-6">
            {/* System Uptime */}
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <Clock className="h-4 w-4 text-muted-foreground" />
                <span className="text-sm font-medium">System Uptime</span>
              </div>
              <p className="text-2xl font-bold">{formatUptime()}</p>
              {system.lastStarted && (
                <p className="text-xs text-muted-foreground">
                  Started: {new Date(system.lastStarted).toLocaleString()}
                </p>
              )}
            </div>

            {/* Agent Health */}
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <Users className="h-4 w-4 text-muted-foreground" />
                <span className="text-sm font-medium">Agent Health</span>
              </div>
              <p className="text-2xl font-bold">{getAgentHealthPercentage()}%</p>
              <div className="space-y-1">
                <Progress value={getAgentHealthPercentage()} className="h-2" />
                <p className="text-xs text-muted-foreground">
                  {stats.activeAgents} of {stats.totalAgents} agents active
                </p>
              </div>
            </div>

            {/* Recent Activity */}
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <Brain className="h-4 w-4 text-muted-foreground" />
                <span className="text-sm font-medium">Recent Insights</span>
              </div>
              <p className="text-2xl font-bold">{stats.recentInsights}</p>
              <p className="text-xs text-muted-foreground">
                Generated in last 24h
              </p>
            </div>

            {/* Task Queue */}
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <Zap className="h-4 w-4 text-muted-foreground" />
                <span className="text-sm font-medium">Task Queue</span>
              </div>
              <p className="text-2xl font-bold">{stats.pendingTasks}</p>
              <p className="text-xs text-muted-foreground">
                Pending tasks
              </p>
            </div>
          </div>

          {/* Error Message */}
          {system.errorMessage && (
            <div className="mt-6 p-4 bg-red-50 border border-red-200 rounded-md">
              <div className="flex items-start space-x-2">
                <AlertTriangle className="h-5 w-5 text-red-600 mt-0.5 flex-shrink-0" />
                <div>
                  <p className="font-medium text-red-800">System Error</p>
                  <p className="text-sm text-red-700 mt-1">{system.errorMessage}</p>
                </div>
              </div>
            </div>
          )}

          {/* System Metrics */}
          {system.metrics && (
            <div className="mt-6 pt-6 border-t">
              <h4 className="text-sm font-medium mb-3 flex items-center space-x-2">
                <TrendingUp className="h-4 w-4" />
                <span>System Metrics</span>
              </h4>
              <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
                <div className="space-y-1">
                  <span className="text-muted-foreground">Total Tasks Processed</span>
                  <p className="font-semibold">{system.metrics.totalTasksProcessed.toLocaleString()}</p>
                </div>
                <div className="space-y-1">
                  <span className="text-muted-foreground">Total Insights</span>
                  <p className="font-semibold">{system.metrics.totalInsightsGenerated.toLocaleString()}</p>
                </div>
                <div className="space-y-1">
                  <span className="text-muted-foreground">Avg Task Duration</span>
                  <p className="font-semibold">
                    {system.metrics.averageTaskDuration 
                      ? `${Math.round(system.metrics.averageTaskDuration / 1000)}s`
                      : 'N/A'
                    }
                  </p>
                </div>
                <div className="space-y-1">
                  <span className="text-muted-foreground">Error Rate</span>
                  <p className={cn(
                    "font-semibold",
                    (system.metrics.errorRate || 0) > 0.1 ? "text-red-600" : "text-green-600"
                  )}>
                    {system.metrics.errorRate 
                      ? `${Math.round((system.metrics.errorRate || 0) * 100)}%`
                      : '0%'
                    }
                  </p>
                </div>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default AgentSystemStatus;
</file>

<file path="src/app/_components/agents/InsightCard.tsx">
'use client'

import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import {
  AlertTriangle,
  Brain,
  CheckCircle,
  Clock,
  DollarSign,
  FileText,
  Shield,
  TrendingUp,
  Zap,
  Eye,
  ExternalLink,
  Star,
} from "lucide-react";
import { AgentInsight, InsightType, TaskPriority, INSIGHT_TYPE_LABELS, PRIORITY_COLORS } from "@/types/agents.types";
import { cn } from "@/lib/utils";

interface InsightCardProps {
  insight: any; // Using any because the actual structure might differ from types
  onMarkAsRead?: (insightId: string) => void;
  onViewDetails?: (insightId: string) => void;
  onTakeAction?: (insightId: string) => void;
  loading?: boolean;
}

export const InsightCard: React.FC<InsightCardProps> = ({
  insight,
  onMarkAsRead,
  onViewDetails,
  onTakeAction,
  loading = false,
}) => {
  const getInsightIcon = (type: string) => {
    switch (type) {
      case 'contract_analysis':
        return <FileText className="h-5 w-5" />;
      case 'financial_risk':
      case 'cost_optimization':
        return <DollarSign className="h-5 w-5" />;
      case 'expiration_warning':
      case 'renewal_opportunity':
        return <Clock className="h-5 w-5" />;
      case 'legal_review':
      case 'compliance_alert':
        return <Shield className="h-5 w-5" />;
      case 'performance_metric':
      case 'trend_analysis':
        return <TrendingUp className="h-5 w-5" />;
      case 'vendor_risk':
        return <AlertTriangle className="h-5 w-5" />;
      case 'recommendation':
        return <Brain className="h-5 w-5" />;
      case 'alert':
        return <Zap className="h-5 w-5" />;
      default:
        return <Brain className="h-5 w-5" />;
    }
  };

  const getPriorityColor = (priority: string) => {
    switch (priority) {
      case 'critical':
        return 'bg-red-100 text-red-800 border-red-200';
      case 'high':
        return 'bg-orange-100 text-orange-800 border-orange-200';
      case 'medium':
        return 'bg-yellow-100 text-yellow-800 border-yellow-200';
      case 'low':
        return 'bg-green-100 text-green-800 border-green-200';
      default:
        return 'bg-gray-100 text-gray-800 border-gray-200';
    }
  };

  const getTypeColor = (type: string) => {
    switch (type) {
      case 'contract_analysis':
        return 'bg-blue-100 text-blue-800';
      case 'financial_risk':
        return 'bg-red-100 text-red-800';
      case 'cost_optimization':
        return 'bg-green-100 text-green-800';
      case 'expiration_warning':
        return 'bg-yellow-100 text-yellow-800';
      case 'legal_review':
        return 'bg-purple-100 text-purple-800';
      case 'compliance_alert':
        return 'bg-orange-100 text-orange-800';
      case 'performance_metric':
        return 'bg-cyan-100 text-cyan-800';
      case 'vendor_risk':
        return 'bg-pink-100 text-pink-800';
      case 'recommendation':
        return 'bg-indigo-100 text-indigo-800';
      default:
        return 'bg-gray-100 text-gray-800';
    }
  };

  const formatTimeAgo = (dateString: string) => {
    const date = new Date(dateString);
    const now = new Date();
    const diffMs = now.getTime() - date.getTime();
    const diffMins = Math.floor(diffMs / (1000 * 60));
    
    if (diffMins < 1) return "Just now";
    if (diffMins < 60) return `${diffMins}m ago`;
    if (diffMins < 1440) return `${Math.floor(diffMins / 60)}h ago`;
    if (diffMins < 43200) return `${Math.floor(diffMins / 1440)}d ago`;
    return date.toLocaleDateString();
  };

  const getConfidenceColor = (confidence?: number) => {
    if (!confidence) return "text-gray-500";
    if (confidence >= 0.9) return "text-green-600";
    if (confidence >= 0.7) return "text-yellow-600";
    return "text-red-600";
  };

  return (
    <Card className={cn(
      "transition-all duration-200 hover:shadow-md",
      !insight.isRead && "border-l-4 border-l-blue-500 bg-blue-50/30",
      insight.priority === 'critical' && "border-l-4 border-l-red-500 bg-red-50/30"
    )}>
      <CardHeader className="pb-3">
        <div className="flex items-start justify-between">
          <div className="flex items-start space-x-3">
            <div className={cn(
              "p-2 rounded-md",
              getTypeColor(insight.type)
            )}>
              {getInsightIcon(insight.type)}
            </div>
            <div className="flex-1">
              <CardTitle className="text-lg font-semibold line-clamp-2">
                {insight.title}
              </CardTitle>
              <div className="flex items-center space-x-2 mt-2">
                <Badge variant="outline" className={getTypeColor(insight.type)}>
                  {INSIGHT_TYPE_LABELS[insight.type as InsightType] || insight.type}
                </Badge>
                <Badge className={getPriorityColor(insight.priority)}>
                  {insight.priority.charAt(0).toUpperCase() + insight.priority.slice(1)}
                </Badge>
                {insight.confidence && (
                  <div className="flex items-center space-x-1">
                    <Star className="h-3 w-3 text-yellow-500" />
                    <span className={cn("text-xs font-medium", getConfidenceColor(insight.confidence))}>
                      {Math.round(insight.confidence * 100)}%
                    </span>
                  </div>
                )}
              </div>
            </div>
          </div>
          
          {!insight.isRead && (
            <Button
              variant="outline"
              size="sm"
              onClick={() => onMarkAsRead?.(insight._id)}
              disabled={loading}
            >
              <Eye className="h-3 w-3 mr-1" />
              Mark Read
            </Button>
          )}
        </div>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Description */}
        <p className="text-sm text-muted-foreground line-clamp-3">
          {insight.description}
        </p>

        {/* Metadata */}
        <div className="flex items-center justify-between text-xs text-muted-foreground">
          <div className="flex items-center space-x-4">
            <span>by {insight.agentName}</span>
            <span></span>
            <span>{formatTimeAgo(insight.createdAt)}</span>
            {insight.expiresAt && (
              <>
                <span></span>
                <span className="text-yellow-600">
                  Expires {formatTimeAgo(insight.expiresAt)}
                </span>
              </>
            )}
          </div>
        </div>

        {/* Structured Data Preview */}
        {insight.data && (
          <div className="space-y-2">
            {/* Financial Impact */}
            {insight.data.financialImpact && (
              <div className="flex items-center justify-between p-2 bg-green-50 rounded-md border border-green-200">
                <span className="text-sm font-medium text-green-800">Financial Impact</span>
                <span className={cn(
                  "text-sm font-bold",
                  insight.data.financialImpact.type === 'saving' ? "text-green-600" : "text-red-600"
                )}>
                  {insight.data.financialImpact.type === 'saving' ? '+' : '-'}
                  ${insight.data.financialImpact.amount.toLocaleString()} {insight.data.financialImpact.currency}
                </span>
              </div>
            )}

            {/* Risk Score */}
            {insight.data.contractRisk && (
              <div className="flex items-center justify-between p-2 bg-red-50 rounded-md border border-red-200">
                <span className="text-sm font-medium text-red-800">Risk Score</span>
                <span className="text-sm font-bold text-red-600">
                  {insight.data.contractRisk.score}/10
                </span>
              </div>
            )}

            {/* Performance Data */}
            {insight.data.performanceData && (
              <div className="flex items-center justify-between p-2 bg-blue-50 rounded-md border border-blue-200">
                <span className="text-sm font-medium text-blue-800">
                  {insight.data.performanceData.metric}
                </span>
                <span className="text-sm font-bold text-blue-600">
                  {insight.data.performanceData.current} / {insight.data.performanceData.target}
                </span>
              </div>
            )}
          </div>
        )}

        {/* Action Required */}
        {insight.actionRequired && !insight.actionTaken && (
          <div className="flex items-center justify-between p-3 bg-yellow-50 rounded-md border border-yellow-200">
            <div className="flex items-center space-x-2">
              <AlertTriangle className="h-4 w-4 text-yellow-600" />
              <span className="text-sm font-medium text-yellow-800">Action Required</span>
            </div>
            <Button
              size="sm"
              onClick={() => onTakeAction?.(insight._id)}
              disabled={loading}
            >
              Take Action
            </Button>
          </div>
        )}

        {/* Action Taken */}
        {insight.actionTaken && insight.actionDetails && (
          <div className="flex items-start space-x-2 p-3 bg-green-50 rounded-md border border-green-200">
            <CheckCircle className="h-4 w-4 text-green-600 mt-0.5 flex-shrink-0" />
            <div>
              <p className="text-sm font-medium text-green-800">Action Taken</p>
              <p className="text-sm text-green-700 mt-1">{insight.actionDetails}</p>
            </div>
          </div>
        )}

        {/* Tags */}
        {insight.tags && insight.tags.length > 0 && (
          <div className="flex flex-wrap gap-1">
            {insight.tags.map((tag: string, index: number) => (
              <Badge key={index} variant="secondary" className="text-xs">
                {tag}
              </Badge>
            ))}
          </div>
        )}

        {/* Action Buttons */}
        <div className="flex items-center justify-between pt-2 border-t">
          <div className="flex items-center space-x-2">
            {/* Related Entity Links */}
            {insight.contractId && (
              <Button variant="ghost" size="sm">
                <FileText className="h-3 w-3 mr-1" />
                View Contract
              </Button>
            )}
            {insight.vendorId && (
              <Button variant="ghost" size="sm">
                <ExternalLink className="h-3 w-3 mr-1" />
                View Vendor
              </Button>
            )}
          </div>

          <Button
            variant="outline"
            size="sm"
            onClick={() => onViewDetails?.(insight._id)}
            disabled={loading}
          >
            View Details
          </Button>
        </div>
      </CardContent>
    </Card>
  );
};

export default InsightCard;
</file>

<file path="src/app/_components/analytics/ContractAnalyticsSection.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import DynamicChart from "@/app/_components/common/DynamicCharts"
const contractTrends = [
  { month: "Jan", active: 45, completed: 30, expired: 5, value: 150000 },
  { month: "Feb", active: 52, completed: 35, expired: 3, value: 180000 },
  { month: "Mar", active: 48, completed: 40, expired: 4, value: 165000 },
  { month: "Apr", active: 60, completed: 38, expired: 6, value: 200000 },
];

export const ContractAnalyticsSection = () => (
  <div className="grid grid-cols-1 gap-4 mb-8">
    <Card>
      <CardHeader>
        <CardTitle>Contract Trends</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-96">
          <DynamicChart
            type="area"
            data={contractTrends}
            series={[
              {
                dataKey: "active",
                name: "Active",
                color: "#4ade80",
                stackId: "1",
                fillOpacity: 0.6
              },
              {
                dataKey: "completed",
                name: "Completed",
                color: "#60a5fa",
                stackId: "1",
                fillOpacity: 0.6
              },
              {
                dataKey: "expired",
                name: "Expired",
                color: "#f87171",
                stackId: "1",
                fillOpacity: 0.6
              }
            ]}
            xAxisKey="month"
            height={340}
            stacked={true}
            showGrid={true}
            showLegend={true}
            showTooltip={true}
          />
        </div>
      </CardContent>
    </Card>
  </div>
);
</file>

<file path="src/app/_components/analytics/DateRangePicker.tsx">
'use client'

import React, { useState } from "react";
import { Button } from "@/components/ui/button";
import { Calendar } from "@/components/ui/calendar";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Badge } from "@/components/ui/badge";
import { CalendarIcon, X } from "lucide-react";
import { format } from "date-fns";
import { cn } from "@/lib/utils";

export interface DateRange {
  from: Date | undefined;
  to: Date | undefined;
}

interface DateRangePickerProps {
  value?: DateRange;
  onChange?: (range: DateRange) => void;
  presets?: boolean;
  className?: string;
}

const PRESET_RANGES = [
  {
    label: "Last 7 days",
    value: "7d",
    getRange: () => ({
      from: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
      to: new Date(),
    }),
  },
  {
    label: "Last 30 days",
    value: "30d",
    getRange: () => ({
      from: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
      to: new Date(),
    }),
  },
  {
    label: "Last 90 days",
    value: "90d",
    getRange: () => ({
      from: new Date(Date.now() - 90 * 24 * 60 * 60 * 1000),
      to: new Date(),
    }),
  },
  {
    label: "This month",
    value: "month",
    getRange: () => {
      const now = new Date();
      return {
        from: new Date(now.getFullYear(), now.getMonth(), 1),
        to: new Date(now.getFullYear(), now.getMonth() + 1, 0),
      };
    },
  },
  {
    label: "This quarter",
    value: "quarter",
    getRange: () => {
      const now = new Date();
      const quarter = Math.floor(now.getMonth() / 3);
      return {
        from: new Date(now.getFullYear(), quarter * 3, 1),
        to: new Date(now.getFullYear(), quarter * 3 + 3, 0),
      };
    },
  },
  {
    label: "This year",
    value: "year",
    getRange: () => ({
      from: new Date(new Date().getFullYear(), 0, 1),
      to: new Date(new Date().getFullYear(), 11, 31),
    }),
  },
  {
    label: "Last year",
    value: "last-year",
    getRange: () => {
      const lastYear = new Date().getFullYear() - 1;
      return {
        from: new Date(lastYear, 0, 1),
        to: new Date(lastYear, 11, 31),
      };
    },
  },
];

export const DateRangePicker: React.FC<DateRangePickerProps> = ({
  value,
  onChange,
  presets = true,
  className,
}) => {
  const [selectedPreset, setSelectedPreset] = useState<string>("");
  const [isOpen, setIsOpen] = useState(false);

  const handlePresetChange = (presetValue: string) => {
    const preset = PRESET_RANGES.find(p => p.value === presetValue);
    if (preset && onChange) {
      const range = preset.getRange();
      onChange(range);
      setSelectedPreset(presetValue);
    }
  };

  const handleDateSelect = (range: DateRange | undefined) => {
    if (range && onChange) {
      onChange(range);
      setSelectedPreset(""); // Clear preset when custom date is selected
    }
  };

  const handleClear = () => {
    if (onChange) {
      onChange({ from: undefined, to: undefined });
      setSelectedPreset("");
    }
  };

  const formatDateRange = () => {
    if (!value?.from) return "Select date range";
    
    if (value.from && !value.to) {
      return format(value.from, "MMM d, yyyy");
    }
    
    if (value.from && value.to) {
      return `${format(value.from, "MMM d, yyyy")} - ${format(value.to, "MMM d, yyyy")}`;
    }
    
    return "Select date range";
  };

  const hasSelection = value?.from || value?.to;

  return (
    <div className={cn("space-y-2", className)}>
      {presets && (
        <div className="flex items-center space-x-2">
          <Select value={selectedPreset} onValueChange={handlePresetChange}>
            <SelectTrigger className="w-[180px]">
              <SelectValue placeholder="Quick select" />
            </SelectTrigger>
            <SelectContent>
              {PRESET_RANGES.map((preset) => (
                <SelectItem key={preset.value} value={preset.value}>
                  {preset.label}
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
          
          {selectedPreset && (
            <Badge variant="secondary" className="flex items-center space-x-1">
              <span>{PRESET_RANGES.find(p => p.value === selectedPreset)?.label}</span>
              <X 
                className="h-3 w-3 cursor-pointer" 
                onClick={() => {
                  setSelectedPreset("");
                  handleClear();
                }}
              />
            </Badge>
          )}
        </div>
      )}

      <div className="flex items-center space-x-2">
        <Popover open={isOpen} onOpenChange={setIsOpen}>
          <PopoverTrigger asChild>
            <Button
              variant="outline"
              className={cn(
                "min-w-[280px] justify-start text-left font-normal",
                !hasSelection && "text-muted-foreground"
              )}
            >
              <CalendarIcon className="mr-2 h-4 w-4" />
              {formatDateRange()}
            </Button>
          </PopoverTrigger>
          <PopoverContent className="w-auto p-0" align="start">
            <Calendar
              initialFocus
              mode="range"
              defaultMonth={value?.from}
              selected={value}
              onSelect={handleDateSelect}
              numberOfMonths={2}
            />
          </PopoverContent>
        </Popover>

        {hasSelection && (
          <Button
            variant="ghost"
            size="sm"
            onClick={handleClear}
            className="h-10 px-3"
          >
            <X className="h-4 w-4" />
          </Button>
        )}
      </div>

      {hasSelection && (
        <div className="text-sm text-muted-foreground">
          {value?.from && value?.to && (
            <span>
              {Math.ceil((value.to.getTime() - value.from.getTime()) / (1000 * 60 * 60 * 24))} days selected
            </span>
          )}
        </div>
      )}
    </div>
  );
};

export default DateRangePicker;
</file>

<file path="src/app/_components/analytics/DepartmentPerformanceSection.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import DynamicChart from "@/app/_components/common/DynamicCharts"

const departmentPerformance = [
  { department: "Legal", efficiency: 92, contracts: 150, savings: 125000 },
  { department: "Sales", efficiency: 88, contracts: 200, savings: 180000 },
  { department: "Procurement", efficiency: 95, contracts: 180, savings: 150000 },
];

export const DepartmentPerformanceSection = () => (
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-8">
    <Card>
      <CardHeader>
        <CardTitle>Department Contract Volume</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-80">
          <DynamicChart
            type="bar"
            data={departmentPerformance}
            series={[{
              dataKey: "contracts",
              name: "Contracts",
              color: "#60a5fa"
            }]}
            xAxisKey="department"
            height={280}
            showGrid={true}
            showLegend={true}
            showTooltip={true}
          />
        </div>
      </CardContent>
    </Card>

    <Card>
      <CardHeader>
        <CardTitle>Department Savings</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-80">
          <DynamicChart
            type="line"
            data={departmentPerformance}
            series={[{
              dataKey: "savings",
              name: "Savings",
              color: "#4ade80",
              strokeWidth: 2,
              dot: true
            }]}
            xAxisKey="department"
            height={280}
            showGrid={true}
            showLegend={true}
            showTooltip={true}
          />
        </div>
      </CardContent>
    </Card>
  </div>
);
</file>

<file path="src/app/_components/analytics/DrillDownModal.tsx">
'use client'

import React, { useState, useMemo } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  ArrowLeft,
  Search,
  Filter,
  Download,
  ExternalLink,
  TrendingUp,
  TrendingDown,
  Calendar,
  DollarSign,
  FileText,
  Users,
} from "lucide-react";
import InteractiveChart from "./InteractiveChart";
import { cn } from "@/lib/utils";

interface DrillDownData {
  id: string;
  name: string;
  value: number;
  category: string;
  subcategory?: string;
  date: string;
  status: string;
  trend?: number;
  details?: Record<string, any>;
}

interface DrillDownModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  title: string;
  category: string;
  data: DrillDownData[];
  onNavigateToDetail?: (id: string) => void;
}

export const DrillDownModal: React.FC<DrillDownModalProps> = ({
  open,
  onOpenChange,
  title,
  category,
  data,
  onNavigateToDetail,
}) => {
  const [searchTerm, setSearchTerm] = useState("");
  const [statusFilter, setStatusFilter] = useState("all");
  const [sortBy, setSortBy] = useState("value");
  const [sortOrder, setSortOrder] = useState<"asc" | "desc">("desc");

  // Filter and sort data
  const filteredData = useMemo(() => {
    let filtered = data.filter(item => {
      const matchesSearch = !searchTerm || 
        item.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
        item.category.toLowerCase().includes(searchTerm.toLowerCase());
      
      const matchesStatus = statusFilter === "all" || item.status === statusFilter;
      
      return matchesSearch && matchesStatus;
    });

    // Sort data
    filtered.sort((a, b) => {
      let aVal = a[sortBy as keyof DrillDownData];
      let bVal = b[sortBy as keyof DrillDownData];
      
      if (typeof aVal === "string") aVal = aVal.toLowerCase();
      if (typeof bVal === "string") bVal = bVal.toLowerCase();
      
      if (sortOrder === "asc") {
        return aVal > bVal ? 1 : -1;
      } else {
        return aVal < bVal ? 1 : -1;
      }
    });

    return filtered;
  }, [data, searchTerm, statusFilter, sortBy, sortOrder]);

  // Calculate summary statistics
  const summary = useMemo(() => {
    const total = filteredData.reduce((sum, item) => sum + item.value, 0);
    const average = total / (filteredData.length || 1);
    const highest = Math.max(...filteredData.map(item => item.value));
    const lowest = Math.min(...filteredData.map(item => item.value));
    
    // Trend calculation
    const recentTrend = filteredData
      .filter(item => item.trend !== undefined)
      .reduce((sum, item, _, arr) => sum + (item.trend || 0) / arr.length, 0);

    return {
      total,
      average,
      highest,
      lowest,
      count: filteredData.length,
      trend: recentTrend,
    };
  }, [filteredData]);

  // Prepare chart data
  const chartData = useMemo(() => {
    // Group by subcategory or status for chart
    const grouped = filteredData.reduce((acc, item) => {
      const key = item.subcategory || item.status;
      if (!acc[key]) {
        acc[key] = { name: key, value: 0, count: 0 };
      }
      acc[key].value += item.value;
      acc[key].count += 1;
      return acc;
    }, {} as Record<string, { name: string; value: number; count: number }>);

    return Object.values(grouped);
  }, [filteredData]);

  const getStatusColor = (status: string) => {
    switch (status.toLowerCase()) {
      case "active":
        return "bg-green-100 text-green-800";
      case "pending":
        return "bg-yellow-100 text-yellow-800";
      case "expired":
        return "bg-red-100 text-red-800";
      case "draft":
        return "bg-gray-100 text-gray-800";
      default:
        return "bg-blue-100 text-blue-800";
    }
  };

  const formatValue = (value: number) => {
    if (category.toLowerCase().includes("cost") || category.toLowerCase().includes("value")) {
      return `$${value.toLocaleString()}`;
    }
    return value.toLocaleString();
  };

  const handleSort = (column: string) => {
    if (sortBy === column) {
      setSortOrder(sortOrder === "asc" ? "desc" : "asc");
    } else {
      setSortBy(column);
      setSortOrder("desc");
    }
  };

  const handleExport = () => {
    const csvContent = [
      ["Name", "Category", "Value", "Status", "Date", "Trend"],
      ...filteredData.map(item => [
        item.name,
        item.category,
        item.value.toString(),
        item.status,
        item.date,
        item.trend?.toString() || ""
      ])
    ].map(row => row.join(",")).join("\n");

    const blob = new Blob([csvContent], { type: "text/csv" });
    const url = URL.createObjectURL(blob);
    const link = document.createElement("a");
    link.href = url;
    link.download = `${title.toLowerCase().replace(/\s+/g, "_")}_drill_down.csv`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <div className="flex items-center justify-between">
            <div className="flex items-center space-x-2">
              <Button
                variant="ghost"
                size="sm"
                onClick={() => onOpenChange(false)}
              >
                <ArrowLeft className="h-4 w-4" />
              </Button>
              <DialogTitle>{title} - {category}</DialogTitle>
            </div>
            <Button variant="outline" size="sm" onClick={handleExport}>
              <Download className="h-4 w-4 mr-2" />
              Export
            </Button>
          </div>
        </DialogHeader>

        {/* Summary Cards */}
        <div className="grid grid-cols-2 md:grid-cols-5 gap-4 mb-6">
          <div className="space-y-1">
            <p className="text-sm font-medium text-muted-foreground">Total</p>
            <p className="text-2xl font-bold">{formatValue(summary.total)}</p>
          </div>
          <div className="space-y-1">
            <p className="text-sm font-medium text-muted-foreground">Average</p>
            <p className="text-2xl font-bold">{formatValue(summary.average)}</p>
          </div>
          <div className="space-y-1">
            <p className="text-sm font-medium text-muted-foreground">Highest</p>
            <p className="text-2xl font-bold">{formatValue(summary.highest)}</p>
          </div>
          <div className="space-y-1">
            <p className="text-sm font-medium text-muted-foreground">Count</p>
            <p className="text-2xl font-bold">{summary.count}</p>
          </div>
          <div className="space-y-1">
            <p className="text-sm font-medium text-muted-foreground">Trend</p>
            <div className="flex items-center space-x-1">
              {summary.trend > 0 ? (
                <TrendingUp className="h-4 w-4 text-green-600" />
              ) : (
                <TrendingDown className="h-4 w-4 text-red-600" />
              )}
              <span className={cn(
                "text-xl font-bold",
                summary.trend > 0 ? "text-green-600" : "text-red-600"
              )}>
                {Math.abs(summary.trend).toFixed(1)}%
              </span>
            </div>
          </div>
        </div>

        <Tabs defaultValue="chart" className="w-full">
          <TabsList>
            <TabsTrigger value="chart">Chart View</TabsTrigger>
            <TabsTrigger value="table">Table View</TabsTrigger>
          </TabsList>

          <TabsContent value="chart" className="space-y-4">
            <InteractiveChart
              title={`${category} Distribution`}
              data={chartData}
              type="bar"
              height={300}
              showTypeSelector={true}
              showExport={false}
            />
          </TabsContent>

          <TabsContent value="table" className="space-y-4">
            {/* Filters */}
            <div className="flex items-center space-x-4">
              <div className="relative flex-1">
                <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search items..."
                  value={searchTerm}
                  onChange={(e) => setSearchTerm(e.target.value)}
                  className="pl-8"
                />
              </div>
              
              <Select value={statusFilter} onValueChange={setStatusFilter}>
                <SelectTrigger className="w-[140px]">
                  <SelectValue placeholder="Status" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="all">All Status</SelectItem>
                  <SelectItem value="active">Active</SelectItem>
                  <SelectItem value="pending">Pending</SelectItem>
                  <SelectItem value="expired">Expired</SelectItem>
                  <SelectItem value="draft">Draft</SelectItem>
                </SelectContent>
              </Select>

              <Select value={sortBy} onValueChange={setSortBy}>
                <SelectTrigger className="w-[140px]">
                  <SelectValue placeholder="Sort by" />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="name">Name</SelectItem>
                  <SelectItem value="value">Value</SelectItem>
                  <SelectItem value="date">Date</SelectItem>
                  <SelectItem value="status">Status</SelectItem>
                </SelectContent>
              </Select>
            </div>

            {/* Table */}
            <div className="border rounded-md">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort("name")}
                    >
                      Name
                      {sortBy === "name" && (
                        <span className="ml-1">
                          {sortOrder === "asc" ? "" : ""}
                        </span>
                      )}
                    </TableHead>
                    <TableHead>Category</TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort("value")}
                    >
                      Value
                      {sortBy === "value" && (
                        <span className="ml-1">
                          {sortOrder === "asc" ? "" : ""}
                        </span>
                      )}
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort("status")}
                    >
                      Status
                      {sortBy === "status" && (
                        <span className="ml-1">
                          {sortOrder === "asc" ? "" : ""}
                        </span>
                      )}
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50"
                      onClick={() => handleSort("date")}
                    >
                      Date
                      {sortBy === "date" && (
                        <span className="ml-1">
                          {sortOrder === "asc" ? "" : ""}
                        </span>
                      )}
                    </TableHead>
                    <TableHead>Trend</TableHead>
                    <TableHead>Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {filteredData.map((item) => (
                    <TableRow key={item.id} className="hover:bg-muted/50">
                      <TableCell className="font-medium">{item.name}</TableCell>
                      <TableCell>{item.subcategory || item.category}</TableCell>
                      <TableCell className="font-mono">
                        {formatValue(item.value)}
                      </TableCell>
                      <TableCell>
                        <Badge className={getStatusColor(item.status)}>
                          {item.status}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        {new Date(item.date).toLocaleDateString()}
                      </TableCell>
                      <TableCell>
                        {item.trend !== undefined && (
                          <div className="flex items-center space-x-1">
                            {item.trend > 0 ? (
                              <TrendingUp className="h-3 w-3 text-green-600" />
                            ) : (
                              <TrendingDown className="h-3 w-3 text-red-600" />
                            )}
                            <span className={cn(
                              "text-sm",
                              item.trend > 0 ? "text-green-600" : "text-red-600"
                            )}>
                              {Math.abs(item.trend).toFixed(1)}%
                            </span>
                          </div>
                        )}
                      </TableCell>
                      <TableCell>
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={() => onNavigateToDetail?.(item.id)}
                        >
                          <ExternalLink className="h-3 w-3" />
                        </Button>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>

            {filteredData.length === 0 && (
              <div className="text-center py-8 text-muted-foreground">
                No items match your filter criteria.
              </div>
            )}
          </TabsContent>
        </Tabs>
      </DialogContent>
    </Dialog>
  );
};

export default DrillDownModal;
</file>

<file path="src/app/_components/analytics/InteractiveChart.tsx">
'use client'

import React, { useState, useMemo } from "react";
import {
  AreaChart,
  Area,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  ResponsiveContainer,
  BarChart,
  Bar,
  LineChart,
  Line,
  PieChart,
  Pie,
  Cell,
} from "recharts";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  TrendingUp,
  TrendingDown,
  BarChart3,
  LineChart as LineChartIcon,
  PieChart as PieChartIcon,
  AreaChart as AreaChartIcon,
  Download,
  Maximize2,
  Filter,
  Eye,
  EyeOff,
} from "lucide-react";
import { cn } from "@/lib/utils";

export type ChartType = "area" | "bar" | "line" | "pie";

export interface ChartDataPoint {
  name: string;
  value: number;
  category?: string;
  date?: string;
  [key: string]: any;
}

export interface ChartSeries {
  key: string;
  name: string;
  color: string;
  visible: boolean;
}

interface InteractiveChartProps {
  title: string;
  subtitle?: string;
  data: ChartDataPoint[];
  type?: ChartType;
  series?: ChartSeries[];
  height?: number;
  showExport?: boolean;
  showTypeSelector?: boolean;
  showSeriesToggle?: boolean;
  onDataPointClick?: (dataPoint: ChartDataPoint) => void;
  onDrillDown?: (category: string, value: any) => void;
  className?: string;
  loading?: boolean;
}

const CHART_COLORS = [
  "#8884d8", "#82ca9d", "#ffc658", "#ff7300", "#00ff00",
  "#0088fe", "#00c49f", "#ffbb28", "#ff8042", "#8dd1e1"
];

const PIE_COLORS = [
  "#0088FE", "#00C49F", "#FFBB28", "#FF8042", "#8884d8",
  "#82ca9d", "#ffc658", "#ff7300", "#00ff00", "#8dd1e1"
];

export const InteractiveChart: React.FC<InteractiveChartProps> = ({
  title,
  subtitle,
  data,
  type = "area",
  series = [],
  height = 300,
  showExport = true,
  showTypeSelector = true,
  showSeriesToggle = true,
  onDataPointClick,
  onDrillDown,
  className,
  loading = false,
}) => {
  const [chartType, setChartType] = useState<ChartType>(type);
  const [visibleSeries, setVisibleSeries] = useState<Set<string>>(
    new Set(series.map(s => s.key))
  );

  // Process data based on visible series
  const processedData = useMemo(() => {
    if (!data || data.length === 0) return [];
    
    return data.map(item => {
      const newItem = { ...item };
      series.forEach(s => {
        if (!visibleSeries.has(s.key)) {
          delete newItem[s.key];
        }
      });
      return newItem;
    });
  }, [data, series, visibleSeries]);

  // Calculate trend
  const trend = useMemo(() => {
    if (processedData.length < 2) return null;
    
    const firstValue = processedData[0].value || 0;
    const lastValue = processedData[processedData.length - 1].value || 0;
    const change = ((lastValue - firstValue) / firstValue) * 100;
    
    return {
      direction: change >= 0 ? 'up' : 'down',
      percentage: Math.abs(change).toFixed(1),
    };
  }, [processedData]);

  const toggleSeries = (seriesKey: string) => {
    setVisibleSeries(prev => {
      const newSet = new Set(prev);
      if (newSet.has(seriesKey)) {
        newSet.delete(seriesKey);
      } else {
        newSet.add(seriesKey);
      }
      return newSet;
    });
  };

  const handleExport = () => {
    // Export functionality - could integrate with CSV export, PDF, etc.
    const dataStr = JSON.stringify(processedData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `${title.toLowerCase().replace(/\s+/g, '_')}_data.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  const handleDataPointClick = (data: any) => {
    if (onDataPointClick) {
      onDataPointClick(data);
    }
    
    // Auto drill-down if category and value are available
    if (onDrillDown && data.category) {
      onDrillDown(data.category, data.value);
    }
  };

  const renderChart = () => {
    if (loading) {
      return (
        <div className="flex items-center justify-center h-full">
          <div className="animate-spin rounded-full h-8 w-8 border-b-2 border-primary"></div>
        </div>
      );
    }

    if (!processedData || processedData.length === 0) {
      return (
        <div className="flex items-center justify-center h-full text-muted-foreground">
          No data available
        </div>
      );
    }

    const commonProps = {
      data: processedData,
      height,
      onClick: handleDataPointClick,
    };

    switch (chartType) {
      case "area":
        return (
          <ResponsiveContainer width="100%" height={height}>
            <AreaChart {...commonProps}>
              <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
              <XAxis 
                dataKey="name" 
                tick={{ fontSize: 12 }}
                tickLine={{ stroke: '#e0e0e0' }}
              />
              <YAxis 
                tick={{ fontSize: 12 }}
                tickLine={{ stroke: '#e0e0e0' }}
              />
              <Tooltip 
                contentStyle={{ 
                  backgroundColor: 'white',
                  border: '1px solid #e0e0e0',
                  borderRadius: '6px',
                  boxShadow: '0 4px 6px -1px rgba(0, 0, 0, 0.1)'
                }}
              />
              {showSeriesToggle && <Legend />}
              {series.length > 0 ? (
                series.map((s, index) => (
                  visibleSeries.has(s.key) && (
                    <Area
                      key={s.key}
                      type="monotone"
                      dataKey={s.key}
                      stackId="1"
                      stroke={s.color}
                      fill={s.color}
                      fillOpacity={0.6}
                    />
                  )
                ))
              ) : (
                <Area
                  type="monotone"
                  dataKey="value"
                  stroke={CHART_COLORS[0]}
                  fill={CHART_COLORS[0]}
                  fillOpacity={0.6}
                />
              )}
            </AreaChart>
          </ResponsiveContainer>
        );

      case "bar":
        return (
          <ResponsiveContainer width="100%" height={height}>
            <BarChart {...commonProps}>
              <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
              <XAxis dataKey="name" tick={{ fontSize: 12 }} />
              <YAxis tick={{ fontSize: 12 }} />
              <Tooltip />
              {showSeriesToggle && <Legend />}
              {series.length > 0 ? (
                series.map((s, index) => (
                  visibleSeries.has(s.key) && (
                    <Bar
                      key={s.key}
                      dataKey={s.key}
                      fill={s.color}
                      radius={[2, 2, 0, 0]}
                    />
                  )
                ))
              ) : (
                <Bar
                  dataKey="value"
                  fill={CHART_COLORS[0]}
                  radius={[2, 2, 0, 0]}
                />
              )}
            </BarChart>
          </ResponsiveContainer>
        );

      case "line":
        return (
          <ResponsiveContainer width="100%" height={height}>
            <LineChart {...commonProps}>
              <CartesianGrid strokeDasharray="3 3" stroke="#f0f0f0" />
              <XAxis dataKey="name" tick={{ fontSize: 12 }} />
              <YAxis tick={{ fontSize: 12 }} />
              <Tooltip />
              {showSeriesToggle && <Legend />}
              {series.length > 0 ? (
                series.map((s) => (
                  visibleSeries.has(s.key) && (
                    <Line
                      key={s.key}
                      type="monotone"
                      dataKey={s.key}
                      stroke={s.color}
                      strokeWidth={2}
                      dot={{ r: 4 }}
                    />
                  )
                ))
              ) : (
                <Line
                  type="monotone"
                  dataKey="value"
                  stroke={CHART_COLORS[0]}
                  strokeWidth={2}
                  dot={{ r: 4 }}
                />
              )}
            </LineChart>
          </ResponsiveContainer>
        );

      case "pie":
        return (
          <ResponsiveContainer width="100%" height={height}>
            <PieChart>
              <Pie
                data={processedData}
                cx="50%"
                cy="50%"
                outerRadius={Math.min(height * 0.35, 120)}
                fill="#8884d8"
                dataKey="value"
                label={({ name, percent }) => `${name} ${(percent * 100).toFixed(0)}%`}
              >
                {processedData.map((entry, index) => (
                  <Cell key={`cell-${index}`} fill={PIE_COLORS[index % PIE_COLORS.length]} />
                ))}
              </Pie>
              <Tooltip />
            </PieChart>
          </ResponsiveContainer>
        );

      default:
        return null;
    }
  };

  return (
    <Card className={cn("w-full", className)}>
      <CardHeader>
        <div className="flex items-center justify-between">
          <div className="space-y-1">
            <CardTitle className="flex items-center space-x-2">
              <span>{title}</span>
              {trend && (
                <Badge variant="outline" className="flex items-center space-x-1">
                  {trend.direction === 'up' ? (
                    <TrendingUp className="h-3 w-3 text-green-600" />
                  ) : (
                    <TrendingDown className="h-3 w-3 text-red-600" />
                  )}
                  <span className={trend.direction === 'up' ? 'text-green-600' : 'text-red-600'}>
                    {trend.percentage}%
                  </span>
                </Badge>
              )}
            </CardTitle>
            {subtitle && (
              <p className="text-sm text-muted-foreground">{subtitle}</p>
            )}
          </div>
          
          <div className="flex items-center space-x-2">
            {showSeriesToggle && series.length > 0 && (
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="outline" size="sm">
                    <Filter className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent>
                  {series.map((s) => (
                    <DropdownMenuItem
                      key={s.key}
                      onClick={() => toggleSeries(s.key)}
                      className="flex items-center space-x-2"
                    >
                      {visibleSeries.has(s.key) ? (
                        <Eye className="h-4 w-4" />
                      ) : (
                        <EyeOff className="h-4 w-4" />
                      )}
                      <span>{s.name}</span>
                      <div
                        className="w-3 h-3 rounded-full ml-auto"
                        style={{ backgroundColor: s.color }}
                      />
                    </DropdownMenuItem>
                  ))}
                </DropdownMenuContent>
              </DropdownMenu>
            )}

            {showTypeSelector && (
              <Select value={chartType} onValueChange={(value: ChartType) => setChartType(value)}>
                <SelectTrigger className="w-32">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="area">
                    <div className="flex items-center space-x-2">
                      <AreaChartIcon className="h-4 w-4" />
                      <span>Area</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="bar">
                    <div className="flex items-center space-x-2">
                      <BarChart3 className="h-4 w-4" />
                      <span>Bar</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="line">
                    <div className="flex items-center space-x-2">
                      <LineChartIcon className="h-4 w-4" />
                      <span>Line</span>
                    </div>
                  </SelectItem>
                  <SelectItem value="pie">
                    <div className="flex items-center space-x-2">
                      <PieChartIcon className="h-4 w-4" />
                      <span>Pie</span>
                    </div>
                  </SelectItem>
                </SelectContent>
              </Select>
            )}

            {showExport && (
              <Button variant="outline" size="sm" onClick={handleExport}>
                <Download className="h-4 w-4" />
              </Button>
            )}

            <Button variant="outline" size="sm">
              <Maximize2 className="h-4 w-4" />
            </Button>
          </div>
        </div>
      </CardHeader>

      <CardContent>
        {renderChart()}
      </CardContent>
    </Card>
  );
};

export default InteractiveChart;
</file>

<file path="src/app/_components/analytics/KPISection.tsx">
import { MetricCard } from "@/app/_components/common/MetricCard"
import { Clock, DollarSign, Users, FileText } from "lucide-react";

export const KPISection = () => (
  <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
    <MetricCard
      title="Total Active Contracts"
      value="486"
      icon={FileText}
      trend={12}
      changeType="positive"
      description="Currently active contracts"
    />
    <MetricCard
      title="Total Contract Value"
      value="$2.4M"
      icon={DollarSign}
      trend={8}
      changeType="positive"
      description="Aggregate contract value"
    />
    <MetricCard
      title="Average Completion Time"
      value="4.2 days"
      icon={Clock}
      trend={-15}
      changeType="negative"
      description="Time to signature completion"
    />
    <MetricCard
      title="Active Users"
      value="234"
      icon={Users}
      trend={5}
      changeType="positive"
      description="Users engaged this month"
    />
  </div>
);
</file>

<file path="src/app/_components/analytics/RiskAndComplianceSection.tsx">
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import DynamicChart from "@/app/_components/common/DynamicCharts"

const riskDistribution = [
  { name: "Low Risk", value: 45 },
  { name: "Medium Risk", value: 35 },
  { name: "High Risk", value: 20 },
];

const departmentPerformance = [
  { department: "Legal", efficiency: 92, contracts: 150, savings: 125000 },
  { department: "Sales", efficiency: 88, contracts: 200, savings: 180000 },
  { department: "Procurement", efficiency: 95, contracts: 180, savings: 150000 },
];

export const RiskAndComplianceSection = () => (
  <div className="grid grid-cols-1 lg:grid-cols-2 gap-4 mb-8">
    <Card>
      <CardHeader>
        <CardTitle>Risk Distribution</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-80">
          <DynamicChart 
            type="pie"
            data={riskDistribution}
            series={[{ dataKey: "value" }]}
            pieConfig={{
              innerRadius: 60,
              outerRadius: 80,
              paddingAngle: 5,
              dataKey: "value",
              nameKey: "name",
            }}
            colors={["#4ade80", "#f87171", "#60a5fa"]}
            height={280}
            showLegend={true}
            showTooltip={true}
          />
        </div>
      </CardContent>
    </Card>

    <Card>
      <CardHeader>
        <CardTitle>Compliance Overview</CardTitle>
      </CardHeader>
      <CardContent>
        <div className="h-80">
          <DynamicChart 
            type="bar"
            data={departmentPerformance}
            series={[{
              dataKey: "efficiency",
              name: "Compliance Score",
              color: "#4ade80"
            }]}
            xAxisKey="department"
            height={280}
            showGrid={true}
            showLegend={true}
            showTooltip={true}
          />
        </div>
      </CardContent>
    </Card>
  </div>
);
</file>

<file path="src/app/_components/auth/PermissionGate.tsx">
'use client';

import React, { ReactNode } from 'react';
import { useUser } from '@clerk/nextjs';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';
import { EmptyPermissions } from '../common/EmptyStates';
import { LoadingSpinner } from '../common/LoadingStates';

// User roles from the permission system
export type UserRole = 'owner' | 'admin' | 'manager' | 'user' | 'viewer';

// Permission types for different operations
export type Permission = 
  // Contract permissions
  | 'contracts:view'
  | 'contracts:create'
  | 'contracts:edit:own'
  | 'contracts:edit:all'
  | 'contracts:delete'
  | 'contracts:approve'
  
  // Vendor permissions
  | 'vendors:view'
  | 'vendors:create'
  | 'vendors:edit:own'
  | 'vendors:edit:all'
  | 'vendors:delete'
  
  // User management permissions
  | 'users:view'
  | 'users:add'
  | 'users:edit'
  | 'users:remove'
  
  // Agent system permissions
  | 'agents:view'
  | 'agents:control'
  | 'agents:insights'
  | 'agents:tasks'
  
  // Analytics permissions
  | 'analytics:view'
  | 'analytics:export'
  
  // Enterprise permissions
  | 'enterprise:settings'
  | 'enterprise:delete'
  
  // System permissions
  | 'system:audit'
  | 'system:maintenance';

// Role hierarchy levels (higher number = more permissions)
const roleHierarchy: Record<UserRole, number> = {
  viewer: 1,
  user: 2,
  manager: 3,
  admin: 4,
  owner: 5,
};

// Permission matrix - defines what permissions each role has
const permissionMatrix: Record<UserRole, Permission[]> = {
  owner: [
    // All permissions
    'contracts:view', 'contracts:create', 'contracts:edit:own', 'contracts:edit:all', 'contracts:delete', 'contracts:approve',
    'vendors:view', 'vendors:create', 'vendors:edit:own', 'vendors:edit:all', 'vendors:delete',
    'users:view', 'users:add', 'users:edit', 'users:remove',
    'agents:view', 'agents:control', 'agents:insights', 'agents:tasks',
    'analytics:view', 'analytics:export',
    'enterprise:settings', 'enterprise:delete',
    'system:audit', 'system:maintenance'
  ],
  admin: [
    // Almost all permissions (cannot modify owners or delete enterprise)
    'contracts:view', 'contracts:create', 'contracts:edit:own', 'contracts:edit:all', 'contracts:delete', 'contracts:approve',
    'vendors:view', 'vendors:create', 'vendors:edit:own', 'vendors:edit:all', 'vendors:delete',
    'users:view', 'users:add', 'users:edit', 'users:remove',
    'agents:view', 'agents:control', 'agents:insights', 'agents:tasks',
    'analytics:view', 'analytics:export',
    'enterprise:settings',
    'system:audit'
  ],
  manager: [
    // Operational management
    'contracts:view', 'contracts:create', 'contracts:edit:own', 'contracts:edit:all', 'contracts:delete', 'contracts:approve',
    'vendors:view', 'vendors:create', 'vendors:edit:own', 'vendors:edit:all', 'vendors:delete',
    'users:view',
    'agents:view', 'agents:insights', 'agents:tasks',
    'analytics:view', 'analytics:export'
  ],
  user: [
    // Standard business user
    'contracts:view', 'contracts:create', 'contracts:edit:own',
    'vendors:view', 'vendors:create', 'vendors:edit:own',
    'analytics:view'
  ],
  viewer: [
    // Read-only access
    'contracts:view',
    'vendors:view',
    'analytics:view'
  ]
};

// Resource ownership check interface
export interface ResourceOwnership {
  resourceType: 'contract' | 'vendor' | 'user';
  resourceId: Id<"contracts"> | Id<"vendors"> | Id<"users">;
  createdBy?: Id<"users">;
}

// Permission gate props
export interface PermissionGateProps {
  children: ReactNode;
  permission?: Permission;
  role?: UserRole;
  minimumRole?: UserRole;
  resource?: ResourceOwnership;
  fallback?: ReactNode;
  showFallback?: boolean;
  enterprise?: Id<"enterprises">;
  onAccessDenied?: () => void;
  loading?: ReactNode;
}

// Hook to get user permissions
export const usePermissions = () => {
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Get user data from Convex
  const { data: userData, isLoading: isUserLoading } = useConvexQuery(
    api.users.getCurrentUser,
    isClerkLoaded && clerkUser ? {} : "skip"
  );

  const isLoading = !isClerkLoaded || isUserLoading;
  const userRole = userData?.role as UserRole | undefined;

  // Check if user has a specific permission
  const hasPermission = (permission: Permission, resourceOwnership?: ResourceOwnership): boolean => {
    if (!userRole) return false;

    const userPermissions = permissionMatrix[userRole] || [];

    // For ownership-based permissions, check if user owns the resource
    if (permission.includes(':own') && resourceOwnership) {
      if (resourceOwnership.createdBy === userData?._id) {
        return userPermissions.includes(permission);
      }
      // If they don't own it, check if they have 'all' permission
      const allPermission = permission.replace(':own', ':all') as Permission;
      return userPermissions.includes(allPermission);
    }

    return userPermissions.includes(permission);
  };

  // Check if user has minimum role level
  const hasMinimumRole = (minimumRole: UserRole): boolean => {
    if (!userRole) return false;
    return roleHierarchy[userRole] >= roleHierarchy[minimumRole];
  };

  // Check if user has exact role
  const hasRole = (role: UserRole): boolean => {
    return userRole === role;
  };

  // Check if user can modify another user (for user management)
  const canModifyUser = (targetUserRole: UserRole): boolean => {
    if (!userRole) return false;
    
    // Owners can modify anyone
    if (userRole === 'owner') return true;
    
    // Admins can modify anyone except owners
    if (userRole === 'admin' && targetUserRole !== 'owner') return true;
    
    return false;
  };

  return {
    isLoading,
    userRole,
    userData,
    enterpriseId,
    hasPermission,
    hasMinimumRole,
    hasRole,
    canModifyUser,
    permissions: userRole ? permissionMatrix[userRole] : [],
    hierarchyLevel: userRole ? roleHierarchy[userRole] : 0,
  };
};

// Permission check utility
export const checkPermission = (
  userRole: UserRole | undefined,
  permission: Permission,
  resourceOwnership?: ResourceOwnership,
  currentUserId?: Id<"users">
): boolean => {
  if (!userRole) return false;

  const userPermissions = permissionMatrix[userRole] || [];

  // For ownership-based permissions
  if (permission.includes(':own') && resourceOwnership) {
    if (resourceOwnership.createdBy === currentUserId) {
      return userPermissions.includes(permission);
    }
    // Check if they have 'all' permission
    const allPermission = permission.replace(':own', ':all') as Permission;
    return userPermissions.includes(allPermission);
  }

  return userPermissions.includes(permission);
};

// Main PermissionGate component
export const PermissionGate: React.FC<PermissionGateProps> = ({
  children,
  permission,
  role,
  minimumRole,
  resource,
  fallback,
  showFallback = true,
  enterprise,
  onAccessDenied,
  loading
}) => {
  const {
    isLoading,
    userRole,
    userData,
    enterpriseId,
    hasPermission,
    hasMinimumRole,
    hasRole
  } = usePermissions();

  // Show loading state
  if (isLoading) {
    return loading || <LoadingSpinner />;
  }

  // Check enterprise access if specified
  if (enterprise && enterpriseId !== enterprise) {
    if (onAccessDenied) onAccessDenied();
    return showFallback ? (
      fallback || <EmptyPermissions resource="this enterprise" />
    ) : null;
  }

  // Check role-based access
  let hasAccess = true;

  if (permission) {
    hasAccess = hasPermission(permission, resource);
  } else if (role) {
    hasAccess = hasRole(role);
  } else if (minimumRole) {
    hasAccess = hasMinimumRole(minimumRole);
  }

  // Handle access denied
  if (!hasAccess) {
    if (onAccessDenied) onAccessDenied();
    
    if (!showFallback) return null;

    if (fallback) return <>{fallback}</>;

    // Default fallback based on what was checked
    let resourceName = 'this resource';
    if (permission) {
      const [resourceType] = permission.split(':');
      resourceName = resourceType;
    }

    return <EmptyPermissions resource={resourceName} />;
  }

  return <>{children}</>;
};

// Specialized permission gates for common use cases
export const ContractPermissionGate: React.FC<{
  children: ReactNode;
  action: 'view' | 'create' | 'edit' | 'delete' | 'approve';
  contractId?: Id<"contracts">;
  createdBy?: Id<"users">;
  fallback?: ReactNode;
}> = ({ children, action, contractId, createdBy, fallback }) => {
  const permissionMap = {
    view: 'contracts:view' as Permission,
    create: 'contracts:create' as Permission,
    edit: 'contracts:edit:own' as Permission,
    delete: 'contracts:delete' as Permission,
    approve: 'contracts:approve' as Permission,
  };

  const resource = contractId ? {
    resourceType: 'contract' as const,
    resourceId: contractId,
    createdBy
  } : undefined;

  return (
    <PermissionGate
      permission={permissionMap[action]}
      resource={resource}
      fallback={fallback}
    >
      {children}
    </PermissionGate>
  );
};

export const VendorPermissionGate: React.FC<{
  children: ReactNode;
  action: 'view' | 'create' | 'edit' | 'delete';
  vendorId?: Id<"vendors">;
  createdBy?: Id<"users">;
  fallback?: ReactNode;
}> = ({ children, action, vendorId, createdBy, fallback }) => {
  const permissionMap = {
    view: 'vendors:view' as Permission,
    create: 'vendors:create' as Permission,
    edit: 'vendors:edit:own' as Permission,
    delete: 'vendors:delete' as Permission,
  };

  const resource = vendorId ? {
    resourceType: 'vendor' as const,
    resourceId: vendorId,
    createdBy
  } : undefined;

  return (
    <PermissionGate
      permission={permissionMap[action]}
      resource={resource}
      fallback={fallback}
    >
      {children}
    </PermissionGate>
  );
};

export const AdminGate: React.FC<{
  children: ReactNode;
  fallback?: ReactNode;
}> = ({ children, fallback }) => (
  <PermissionGate minimumRole="admin" fallback={fallback}>
    {children}
  </PermissionGate>
);

export const ManagerGate: React.FC<{
  children: ReactNode;
  fallback?: ReactNode;
}> = ({ children, fallback }) => (
  <PermissionGate minimumRole="manager" fallback={fallback}>
    {children}
  </PermissionGate>
);

export const UserGate: React.FC<{
  children: ReactNode;
  fallback?: ReactNode;
}> = ({ children, fallback }) => (
  <PermissionGate minimumRole="user" fallback={fallback}>
    {children}
  </PermissionGate>
);

// HOC for component-level permissions
export const withPermission = <P extends object>(
  WrappedComponent: React.ComponentType<P>,
  permission: Permission
) => {
  const WithPermissionComponent = (props: P) => (
    <PermissionGate permission={permission}>
      <WrappedComponent {...props} />
    </PermissionGate>
  );

  WithPermissionComponent.displayName = `withPermission(${WrappedComponent.displayName || WrappedComponent.name})`;

  return WithPermissionComponent;
};

export default PermissionGate;
</file>

<file path="src/app/_components/auth/SessionWrapper.tsx">
'use client';

import React, { useEffect } from 'react';
import { useAuth } from '@clerk/nextjs';
import { useSessionTimeout, logSecurityEvent } from '@/lib/auth-session';

interface SessionWrapperProps {
  children: React.ReactNode;
}

export const SessionWrapper: React.FC<SessionWrapperProps> = ({ children }) => {
  const { isSignedIn, userId } = useAuth();
  const { extendSession } = useSessionTimeout();

  useEffect(() => {
    if (isSignedIn && userId) {
      // Log session start
      logSecurityEvent('session_started', userId, {
        timestamp: new Date().toISOString(),
      });

      // Set up page visibility change handler
      const handleVisibilityChange = () => {
        if (!document.hidden && isSignedIn) {
          // User came back to tab, extend session
          extendSession();
          logSecurityEvent('session_resumed', userId, {
            timestamp: new Date().toISOString(),
          });
        }
      };

      document.addEventListener('visibilitychange', handleVisibilityChange);

      return () => {
        document.removeEventListener('visibilitychange', handleVisibilityChange);
      };
    }
  }, [isSignedIn, userId, extendSession]);

  return <>{children}</>;
};
</file>

<file path="src/app/_components/auth/UnauthorizedPage.tsx">
'use client';

import React from 'react';
import { useRouter } from 'next/navigation';
import { useUser } from '@clerk/nextjs';
import { 
  Shield, 
  ArrowLeft, 
  Mail, 
  Home, 
  Users, 
  AlertTriangle,
  Lock,
  UserX,
  Building,
  RefreshCw
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { cn } from '@/lib/utils';

// Different types of unauthorized scenarios
export type UnauthorizedReason = 
  | 'insufficient_permissions'
  | 'role_required'
  | 'enterprise_access'
  | 'resource_ownership'
  | 'feature_disabled'
  | 'maintenance_mode'
  | 'account_suspended'
  | 'subscription_required';

export interface UnauthorizedPageProps {
  reason?: UnauthorizedReason;
  requiredRole?: string;
  resource?: string;
  action?: string;
  enterprise?: string;
  customMessage?: string;
  customDescription?: string;
  showContactSupport?: boolean;
  showRequestAccess?: boolean;
  showGoBack?: boolean;
  onRequestAccess?: () => void;
  onContactSupport?: () => void;
  className?: string;
}

// Configuration for different unauthorized scenarios
const unauthorizedConfigs = {
  insufficient_permissions: {
    icon: Shield,
    title: 'Access Denied',
    defaultDescription: 'You don\'t have sufficient permissions to access this resource.',
    severity: 'error' as const,
    showRequestAccess: true,
  },
  role_required: {
    icon: Users,
    title: 'Higher Role Required',
    defaultDescription: 'This feature requires elevated permissions.',
    severity: 'warning' as const,
    showRequestAccess: true,
  },
  enterprise_access: {
    icon: Building,
    title: 'Enterprise Access Required',
    defaultDescription: 'You need to be a member of this enterprise to access this resource.',
    severity: 'error' as const,
    showContactSupport: true,
  },
  resource_ownership: {
    icon: Lock,
    title: 'Resource Access Restricted',
    defaultDescription: 'You can only access resources you created or have been granted access to.',
    severity: 'info' as const,
    showRequestAccess: true,
  },
  feature_disabled: {
    icon: AlertTriangle,
    title: 'Feature Unavailable',
    defaultDescription: 'This feature is currently disabled or not available for your account.',
    severity: 'warning' as const,
    showContactSupport: true,
  },
  maintenance_mode: {
    icon: RefreshCw,
    title: 'System Maintenance',
    defaultDescription: 'This feature is temporarily unavailable due to system maintenance.',
    severity: 'info' as const,
    showContactSupport: false,
  },
  account_suspended: {
    icon: UserX,
    title: 'Account Suspended',
    defaultDescription: 'Your account has been suspended. Please contact support for assistance.',
    severity: 'error' as const,
    showContactSupport: true,
  },
  subscription_required: {
    icon: Shield,
    title: 'Subscription Required',
    defaultDescription: 'This feature requires an active subscription or higher plan.',
    severity: 'info' as const,
    showContactSupport: true,
  },
};

export const UnauthorizedPage: React.FC<UnauthorizedPageProps> = ({
  reason = 'insufficient_permissions',
  requiredRole,
  resource,
  action = 'access',
  enterprise,
  customMessage,
  customDescription,
  showContactSupport = true,
  showRequestAccess = true,
  showGoBack = true,
  onRequestAccess,
  onContactSupport,
  className
}) => {
  const router = useRouter();
  const { user } = useUser();
  
  const config = unauthorizedConfigs[reason];
  const IconComponent = config.icon;

  // Build dynamic message
  const getTitle = () => {
    if (customMessage) return customMessage;
    
    if (reason === 'role_required' && requiredRole) {
      return `${requiredRole.charAt(0).toUpperCase() + requiredRole.slice(1)} Role Required`;
    }
    
    return config.title;
  };

  const getDescription = () => {
    if (customDescription) return customDescription;
    
    let description = config.defaultDescription;
    
    if (resource) {
      description = `You don't have permission to ${action} ${resource}.`;
    }
    
    if (requiredRole) {
      description += ` This action requires ${requiredRole} level access or higher.`;
    }
    
    if (enterprise) {
      description += ` You need to be a member of ${enterprise} enterprise.`;
    }

    return description;
  };

  // Handlers
  const handleGoBack = () => {
    if (window.history.length > 1) {
      router.back();
    } else {
      router.push('/dashboard');
    }
  };

  const handleGoHome = () => {
    router.push('/dashboard');
  };

  const handleRequestAccess = () => {
    if (onRequestAccess) {
      onRequestAccess();
    } else {
      // Default request access behavior - could open a modal or send to a form
      const subject = `Access Request: ${resource || 'Feature'}`;
      const body = `I would like to request access to ${resource || 'this feature'}.\n\nUser: ${user?.emailAddresses[0]?.emailAddress}\nRequired Action: ${action}\nRequired Role: ${requiredRole || 'N/A'}`;
      const mailtoLink = `mailto:support@pactwise.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      window.open(mailtoLink);
    }
  };

  const handleContactSupport = () => {
    if (onContactSupport) {
      onContactSupport();
    } else {
      // Default contact support behavior
      const subject = `Support Request: Access Issue`;
      const body = `I'm experiencing an access issue.\n\nUser: ${user?.emailAddresses[0]?.emailAddress}\nReason: ${reason}\nResource: ${resource || 'N/A'}\nAction: ${action}`;
      const mailtoLink = `mailto:support@pactwise.com?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(body)}`;
      window.open(mailtoLink);
    }
  };

  const severityColors = {
    error: 'text-red-600 bg-red-50 border-red-200',
    warning: 'text-yellow-600 bg-yellow-50 border-yellow-200',
    info: 'text-blue-600 bg-blue-50 border-blue-200',
  };

  return (
    <div className={cn('min-h-[60vh] flex items-center justify-center p-4', className)}>
      <Card className="w-full max-w-2xl">
        <CardHeader>
          <div className="flex items-center gap-4">
            <div className={cn(
              'w-16 h-16 rounded-full flex items-center justify-center',
              severityColors[config.severity]
            )}>
              <IconComponent className="h-8 w-8" />
            </div>
            <div className="flex-1">
              <CardTitle className="text-2xl font-semibold mb-2">
                {getTitle()}
              </CardTitle>
              <div className="flex items-center gap-2">
                <Badge variant="outline" className={cn(
                  'text-xs',
                  config.severity === 'error' && 'border-red-200 text-red-700',
                  config.severity === 'warning' && 'border-yellow-200 text-yellow-700',
                  config.severity === 'info' && 'border-blue-200 text-blue-700'
                )}>
                  {reason.replace(/_/g, ' ').toUpperCase()}
                </Badge>
                {requiredRole && (
                  <Badge variant="secondary">
                    {requiredRole.toUpperCase()} REQUIRED
                  </Badge>
                )}
              </div>
            </div>
          </div>
        </CardHeader>

        <CardContent className="space-y-6">
          {/* Main Alert */}
          <Alert className={cn(
            'border-2',
            config.severity === 'error' && 'border-red-200 bg-red-50/50',
            config.severity === 'warning' && 'border-yellow-200 bg-yellow-50/50',
            config.severity === 'info' && 'border-blue-200 bg-blue-50/50'
          )}>
            <AlertTriangle className="h-4 w-4" />
            <AlertTitle>Access Restricted</AlertTitle>
            <AlertDescription className="mt-2">
              {getDescription()}
            </AlertDescription>
          </Alert>

          {/* Additional Information */}
          {(user || enterprise || resource) && (
            <div className="bg-muted/50 p-4 rounded-lg space-y-3">
              <h4 className="font-medium text-sm">Access Details</h4>
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-3 text-sm">
                {user && (
                  <div>
                    <span className="text-muted-foreground">Current User:</span>
                    <p className="font-medium">{user.emailAddresses[0]?.emailAddress}</p>
                  </div>
                )}
                {resource && (
                  <div>
                    <span className="text-muted-foreground">Requested Resource:</span>
                    <p className="font-medium">{resource}</p>
                  </div>
                )}
                {action && (
                  <div>
                    <span className="text-muted-foreground">Requested Action:</span>
                    <p className="font-medium">{action}</p>
                  </div>
                )}
                {requiredRole && (
                  <div>
                    <span className="text-muted-foreground">Required Role:</span>
                    <p className="font-medium">{requiredRole}</p>
                  </div>
                )}
              </div>
            </div>
          )}

          {/* Help Text */}
          <div className="text-sm text-muted-foreground bg-muted/30 p-4 rounded-lg">
            <h4 className="font-medium mb-2">What can I do?</h4>
            <ul className="space-y-1 list-disc list-inside">
              {showRequestAccess && config.showRequestAccess && (
                <li>Request access from your administrator</li>
              )}
              {showContactSupport && config.showContactSupport && (
                <li>Contact support for assistance</li>
              )}
              <li>Check with your team lead about your account permissions</li>
              <li>Return to the dashboard and try a different action</li>
            </ul>
          </div>

          <Separator />

          {/* Action Buttons */}
          <div className="flex flex-col sm:flex-row gap-3 justify-between">
            <div className="flex gap-3">
              {showGoBack && (
                <Button variant="outline" onClick={handleGoBack}>
                  <ArrowLeft className="h-4 w-4 mr-2" />
                  Go Back
                </Button>
              )}
              <Button variant="outline" onClick={handleGoHome}>
                <Home className="h-4 w-4 mr-2" />
                Dashboard
              </Button>
            </div>

            <div className="flex gap-3">
              {showRequestAccess && config.showRequestAccess && (
                <Button variant="default" onClick={handleRequestAccess}>
                  <Mail className="h-4 w-4 mr-2" />
                  Request Access
                </Button>
              )}
              {showContactSupport && config.showContactSupport && (
                <Button variant="outline" onClick={handleContactSupport}>
                  <Mail className="h-4 w-4 mr-2" />
                  Contact Support
                </Button>
              )}
            </div>
          </div>

          {/* Footer Information */}
          <div className="text-xs text-muted-foreground text-center pt-4 border-t">
            <p>
              If you believe this is an error, please contact your system administrator.
              <br />
              <strong>Error Code:</strong> {reason.toUpperCase()}_{Date.now().toString().slice(-6)}
            </p>
          </div>
        </CardContent>
      </Card>
    </div>
  );
};

// Specialized unauthorized components for common scenarios
export const InsufficientPermissions: React.FC<{
  resource?: string;
  action?: string;
  requiredRole?: string;
  onRequestAccess?: () => void;
}> = ({ resource, action, requiredRole, onRequestAccess }) => (
  <UnauthorizedPage
    reason="insufficient_permissions"
    resource={resource}
    action={action}
    requiredRole={requiredRole}
    onRequestAccess={onRequestAccess}
  />
);

export const RoleRequired: React.FC<{
  requiredRole: string;
  resource?: string;
  onRequestAccess?: () => void;
}> = ({ requiredRole, resource, onRequestAccess }) => (
  <UnauthorizedPage
    reason="role_required"
    requiredRole={requiredRole}
    resource={resource}
    onRequestAccess={onRequestAccess}
  />
);

export const EnterpriseAccessRequired: React.FC<{
  enterprise: string;
  onContactSupport?: () => void;
}> = ({ enterprise, onContactSupport }) => (
  <UnauthorizedPage
    reason="enterprise_access"
    enterprise={enterprise}
    onContactSupport={onContactSupport}
    showRequestAccess={false}
  />
);

export const ResourceOwnershipRequired: React.FC<{
  resource: string;
  action?: string;
  onRequestAccess?: () => void;
}> = ({ resource, action, onRequestAccess }) => (
  <UnauthorizedPage
    reason="resource_ownership"
    resource={resource}
    action={action}
    onRequestAccess={onRequestAccess}
  />
);

export const FeatureDisabled: React.FC<{
  feature: string;
  reason?: string;
  onContactSupport?: () => void;
}> = ({ feature, reason, onContactSupport }) => (
  <UnauthorizedPage
    reason="feature_disabled"
    resource={feature}
    customDescription={reason}
    onContactSupport={onContactSupport}
    showRequestAccess={false}
  />
);

export default UnauthorizedPage;
</file>

<file path="src/app/_components/common/BulkActions.tsx">
'use client';

import React, { useState, useCallback, useMemo } from 'react';
import { 
  Check, 
  X, 
  Trash2, 
  Archive, 
  Edit, 
  Download, 
  Mail, 
  Tag, 
  Copy, 
  MoreHorizontal,
  CheckSquare,
  Square,
  MinusSquare,
  AlertTriangle,
  Loader2,
  RefreshCw
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Checkbox } from '@/components/ui/checkbox';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
} from '@/components/ui/dropdown-menu';
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from '@/components/ui/dialog';
import { cn } from '@/lib/utils';
import { showToast } from './ToastNotifications';

// Generic type for items that can be bulk selected
export interface BulkActionItem {
  id: string;
  title?: string;
  status?: string;
  type?: string;
  [key: string]: any;
}

// Bulk action definition
export interface BulkAction {
  id: string;
  label: string;
  icon?: React.ComponentType<{ className?: string }>;
  variant?: 'default' | 'destructive' | 'outline' | 'secondary';
  disabled?: boolean;
  hidden?: boolean;
  requiresConfirmation?: boolean;
  confirmationTitle?: string;
  confirmationMessage?: string;
  maxItems?: number;
  minItems?: number;
  allowedStatuses?: string[];
  allowedTypes?: string[];
  handler: (selectedItems: BulkActionItem[]) => Promise<void> | void;
}

// Bulk operation result
export interface BulkOperationResult {
  success: number;
  failed: number;
  total: number;
  errors?: string[];
}

// Selection state hook
export const useBulkSelection = <T extends BulkActionItem>(items: T[]) => {
  const [selectedIds, setSelectedIds] = useState<Set<string>>(new Set());

  const selectedItems = useMemo(() => {
    return items.filter(item => selectedIds.has(item.id));
  }, [items, selectedIds]);

  const isSelected = useCallback((id: string) => selectedIds.has(id), [selectedIds]);

  const isAllSelected = useMemo(() => {
    return items.length > 0 && items.every(item => selectedIds.has(item.id));
  }, [items, selectedIds]);

  const isPartiallySelected = useMemo(() => {
    return selectedIds.size > 0 && !isAllSelected;
  }, [selectedIds.size, isAllSelected]);

  const toggleItem = useCallback((id: string) => {
    setSelectedIds(prev => {
      const next = new Set(prev);
      if (next.has(id)) {
        next.delete(id);
      } else {
        next.add(id);
      }
      return next;
    });
  }, []);

  const toggleAll = useCallback(() => {
    if (isAllSelected) {
      setSelectedIds(new Set());
    } else {
      setSelectedIds(new Set(items.map(item => item.id)));
    }
  }, [items, isAllSelected]);

  const selectItems = useCallback((ids: string[]) => {
    setSelectedIds(new Set(ids));
  }, []);

  const clearSelection = useCallback(() => {
    setSelectedIds(new Set());
  }, []);

  const selectByCondition = useCallback((condition: (item: T) => boolean) => {
    const matchingIds = items.filter(condition).map(item => item.id);
    setSelectedIds(new Set(matchingIds));
  }, [items]);

  return {
    selectedIds,
    selectedItems,
    selectedCount: selectedIds.size,
    isSelected,
    isAllSelected,
    isPartiallySelected,
    toggleItem,
    toggleAll,
    selectItems,
    clearSelection,
    selectByCondition,
  };
};

// Bulk action bar component
export interface BulkActionBarProps {
  selectedCount: number;
  totalCount: number;
  actions: BulkAction[];
  selectedItems: BulkActionItem[];
  onClearSelection: () => void;
  className?: string;
  variant?: 'fixed' | 'inline' | 'floating';
  position?: 'top' | 'bottom';
  showProgress?: boolean;
}

export const BulkActionBar: React.FC<BulkActionBarProps> = ({
  selectedCount,
  totalCount,
  actions,
  selectedItems,
  onClearSelection,
  className,
  variant = 'fixed',
  position = 'bottom',
  showProgress = true
}) => {
  const [isProcessing, setIsProcessing] = useState(false);
  const [progress, setProgress] = useState(0);
  const [currentOperation, setCurrentOperation] = useState<string>('');
  const [confirmAction, setConfirmAction] = useState<BulkAction | null>(null);

  // Filter actions based on selection
  const availableActions = useMemo(() => {
    return actions.filter(action => {
      if (action.hidden) return false;
      if (action.disabled) return false;
      if (action.maxItems && selectedCount > action.maxItems) return false;
      if (action.minItems && selectedCount < action.minItems) return false;
      
      // Check status constraints
      if (action.allowedStatuses) {
        const hasValidStatus = selectedItems.some(item => 
          action.allowedStatuses!.includes(item.status || '')
        );
        if (!hasValidStatus) return false;
      }

      // Check type constraints
      if (action.allowedTypes) {
        const hasValidType = selectedItems.some(item => 
          action.allowedTypes!.includes(item.type || '')
        );
        if (!hasValidType) return false;
      }

      return true;
    });
  }, [actions, selectedCount, selectedItems]);

  const handleAction = async (action: BulkAction) => {
    if (action.requiresConfirmation) {
      setConfirmAction(action);
      return;
    }

    await executeAction(action);
  };

  const executeAction = async (action: BulkAction) => {
    setIsProcessing(true);
    setProgress(0);
    setCurrentOperation(action.label);

    try {
      // Simulate progress for better UX
      const progressInterval = setInterval(() => {
        setProgress(prev => Math.min(prev + 10, 90));
      }, 100);

      await action.handler(selectedItems);

      clearInterval(progressInterval);
      setProgress(100);

      showToast.success(`${action.label} completed`, {
        description: `Successfully processed ${selectedCount} items.`
      });

      onClearSelection();
    } catch (error) {
      console.error('Bulk action failed:', error);
      showToast.error(`${action.label} failed`, {
        description: error instanceof Error ? error.message : 'An unexpected error occurred.'
      });
    } finally {
      setIsProcessing(false);
      setProgress(0);
      setCurrentOperation('');
      setConfirmAction(null);
    }
  };

  const handleConfirm = async () => {
    if (confirmAction) {
      await executeAction(confirmAction);
    }
  };

  const containerClasses = cn(
    'bg-background border shadow-lg rounded-lg p-4 transition-all duration-200',
    variant === 'fixed' && 'fixed left-4 right-4 z-50',
    variant === 'fixed' && position === 'bottom' && 'bottom-4',
    variant === 'fixed' && position === 'top' && 'top-4',
    variant === 'floating' && 'fixed bottom-20 left-1/2 transform -translate-x-1/2 z-50',
    variant === 'inline' && 'relative',
    className
  );

  if (selectedCount === 0) {
    return null;
  }

  return (
    <>
      <Card className={containerClasses}>
        <CardContent className="p-0">
          {/* Progress bar during processing */}
          {isProcessing && (
            <div className="mb-4">
              <div className="flex items-center justify-between mb-2">
                <span className="text-sm font-medium">{currentOperation}...</span>
                <span className="text-sm text-muted-foreground">{progress}%</span>
              </div>
              <Progress value={progress} className="h-2" />
            </div>
          )}

          <div className="flex items-center justify-between">
            {/* Selection info */}
            <div className="flex items-center gap-3">
              <Badge variant="default" className="flex items-center gap-1">
                <CheckSquare className="h-3 w-3" />
                {selectedCount} selected
              </Badge>
              
              {showProgress && totalCount > 0 && (
                <span className="text-sm text-muted-foreground">
                  {Math.round((selectedCount / totalCount) * 100)}% of {totalCount}
                </span>
              )}

              <Button
                variant="ghost"
                size="sm"
                onClick={onClearSelection}
                disabled={isProcessing}
                className="h-7 px-2"
              >
                <X className="h-3 w-3 mr-1" />
                Clear
              </Button>
            </div>

            {/* Actions */}
            <div className="flex items-center gap-2">
              {availableActions.slice(0, 3).map(action => {
                const IconComponent = action.icon;
                return (
                  <Button
                    key={action.id}
                    variant={action.variant || 'outline'}
                    size="sm"
                    onClick={() => handleAction(action)}
                    disabled={isProcessing}
                    className="flex items-center gap-1"
                  >
                    {isProcessing ? (
                      <Loader2 className="h-3 w-3 animate-spin" />
                    ) : (
                      IconComponent && <IconComponent className="h-3 w-3" />
                    )}
                    <span className="hidden sm:inline">{action.label}</span>
                  </Button>
                );
              })}

              {/* More actions dropdown */}
              {availableActions.length > 3 && (
                <DropdownMenu>
                  <DropdownMenuTrigger asChild>
                    <Button variant="outline" size="sm" disabled={isProcessing}>
                      <MoreHorizontal className="h-3 w-3" />
                    </Button>
                  </DropdownMenuTrigger>
                  <DropdownMenuContent align="end">
                    <DropdownMenuLabel>More Actions</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    {availableActions.slice(3).map(action => {
                      const IconComponent = action.icon;
                      return (
                        <DropdownMenuItem
                          key={action.id}
                          onClick={() => handleAction(action)}
                          className={cn(
                            action.variant === 'destructive' && 'text-destructive focus:text-destructive'
                          )}
                        >
                          {IconComponent && <IconComponent className="h-4 w-4 mr-2" />}
                          {action.label}
                        </DropdownMenuItem>
                      );
                    })}
                  </DropdownMenuContent>
                </DropdownMenu>
              )}
            </div>
          </div>
        </CardContent>
      </Card>

      {/* Confirmation dialog */}
      <Dialog open={!!confirmAction} onOpenChange={() => setConfirmAction(null)}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <AlertTriangle className="h-5 w-5 text-yellow-600" />
              {confirmAction?.confirmationTitle || `Confirm ${confirmAction?.label}`}
            </DialogTitle>
            <DialogDescription>
              {confirmAction?.confirmationMessage || 
                `Are you sure you want to ${confirmAction?.label.toLowerCase()} ${selectedCount} items? This action cannot be undone.`
              }
            </DialogDescription>
          </DialogHeader>
          
          <div className="py-4">
            <Alert>
              <AlertTriangle className="h-4 w-4" />
              <AlertDescription>
                This will affect {selectedCount} selected items.
              </AlertDescription>
            </Alert>
          </div>

          <DialogFooter>
            <Button
              variant="outline"
              onClick={() => setConfirmAction(null)}
              disabled={isProcessing}
            >
              Cancel
            </Button>
            <Button
              variant={confirmAction?.variant === 'destructive' ? 'destructive' : 'default'}
              onClick={handleConfirm}
              disabled={isProcessing}
            >
              {isProcessing ? (
                <>
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                  Processing...
                </>
              ) : (
                <>Confirm {confirmAction?.label}</>
              )}
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </>
  );
};

// Select all header component
export interface SelectAllHeaderProps {
  isAllSelected: boolean;
  isPartiallySelected: boolean;
  onToggleAll: () => void;
  disabled?: boolean;
  label?: string;
  className?: string;
}

export const SelectAllHeader: React.FC<SelectAllHeaderProps> = ({
  isAllSelected,
  isPartiallySelected,
  onToggleAll,
  disabled = false,
  label = "Select all",
  className
}) => {
  const getIcon = () => {
    if (isAllSelected) return CheckSquare;
    if (isPartiallySelected) return MinusSquare;
    return Square;
  };

  const IconComponent = getIcon();

  return (
    <div className={cn('flex items-center gap-2', className)}>
      <Checkbox
        checked={isAllSelected}
        ref={(el) => {
          if (el) el.indeterminate = isPartiallySelected;
        }}
        onCheckedChange={onToggleAll}
        disabled={disabled}
        aria-label={label}
      />
      <span className="text-sm text-muted-foreground hidden sm:inline">
        {label}
      </span>
    </div>
  );
};

// Item selection checkbox component
export interface SelectItemCheckboxProps {
  isSelected: boolean;
  onToggle: () => void;
  disabled?: boolean;
  item?: BulkActionItem;
  className?: string;
}

export const SelectItemCheckbox: React.FC<SelectItemCheckboxProps> = ({
  isSelected,
  onToggle,
  disabled = false,
  item,
  className
}) => {
  return (
    <Checkbox
      checked={isSelected}
      onCheckedChange={onToggle}
      disabled={disabled}
      className={className}
      aria-label={`Select ${item?.title || 'item'}`}
    />
  );
};

// Predefined bulk actions for common operations
export const createCommonBulkActions = (
  entityType: 'contracts' | 'vendors',
  handlers: {
    onDelete?: (items: BulkActionItem[]) => Promise<void>;
    onArchive?: (items: BulkActionItem[]) => Promise<void>;
    onExport?: (items: BulkActionItem[]) => Promise<void>;
    onUpdateStatus?: (items: BulkActionItem[], status: string) => Promise<void>;
    onAssignTag?: (items: BulkActionItem[], tag: string) => Promise<void>;
    onDuplicate?: (items: BulkActionItem[]) => Promise<void>;
  }
): BulkAction[] => {
  const actions: BulkAction[] = [];

  if (handlers.onExport) {
    actions.push({
      id: 'export',
      label: 'Export',
      icon: Download,
      variant: 'outline',
      handler: handlers.onExport,
    });
  }

  if (handlers.onDuplicate) {
    actions.push({
      id: 'duplicate',
      label: 'Duplicate',
      icon: Copy,
      variant: 'outline',
      maxItems: 10, // Limit duplications
      handler: handlers.onDuplicate,
    });
  }

  if (handlers.onAssignTag) {
    actions.push({
      id: 'tag',
      label: 'Add Tag',
      icon: Tag,
      variant: 'outline',
      handler: (items) => handlers.onAssignTag!(items, 'important'), // Could open a tag selector
    });
  }

  if (handlers.onArchive) {
    actions.push({
      id: 'archive',
      label: 'Archive',
      icon: Archive,
      variant: 'outline',
      requiresConfirmation: true,
      confirmationTitle: `Archive ${entityType}`,
      confirmationMessage: `Are you sure you want to archive these ${entityType}? They will be moved to the archive and won't appear in the main list.`,
      handler: handlers.onArchive,
    });
  }

  if (handlers.onDelete) {
    actions.push({
      id: 'delete',
      label: 'Delete',
      icon: Trash2,
      variant: 'destructive',
      requiresConfirmation: true,
      confirmationTitle: `Delete ${entityType}`,
      confirmationMessage: `Are you sure you want to permanently delete these ${entityType}? This action cannot be undone.`,
      handler: handlers.onDelete,
    });
  }

  return actions;
};

export default BulkActionBar;
</file>

<file path="src/app/_components/common/Container.tsx">
import { cn } from "@/lib/utils";

interface ContainerProps extends React.HTMLAttributes<HTMLDivElement> {
  children: React.ReactNode;
}

export function Container({ children, className, ...props }: ContainerProps) {
  return (
    <div
      className={cn("mx-auto w-full max-w-7xl px-6 lg:px-8", className)}
      {...props}
    >
      {children}
    </div>
  );
}
</file>

<file path="src/app/_components/common/CustomToolTip.tsx">
import { TooltipProps } from "recharts";

interface CustomPayload {
  color: string;
  name: string;
  value: number;
  payload?: {
    [key: string]: string | number | boolean | null | undefined;
  };
}

interface CustomTooltipProps
  extends Omit<TooltipProps<number, string>, "payload"> {
  payload?: CustomPayload[];
  valuePrefix?: string;
  valueSuffix?: string;
}

export const CustomTooltip: React.FC<CustomTooltipProps> = ({
  active,
  payload,
  label,
  valuePrefix = "",
  valueSuffix = "",
}) => {
  if (!active || !payload || !payload.length) {
    return null;
  }

  return (
    <div className="bg-background p-4 border border-border rounded-lg shadow-lg">
      <p className="text-sm font-medium text-primary">{label}</p>
      {payload.map((pld, index) => (
        <p key={index} className="text-sm" style={{ color: pld.color }}>
          {pld.name}: {valuePrefix}
          {pld.value.toLocaleString()}
          {valueSuffix}
        </p>
      ))}
    </div>
  );
};

export default CustomTooltip;
</file>

<file path="src/app/_components/common/DocumentViewer.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';

// UI Components
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";

// Icons
import {
  FileText,
  Download,
  ZoomIn,
  ZoomOut,
  RotateCw,
  Maximize2,
  Minimize2,
  AlertCircle,
  Eye,
  X,
  ChevronLeft,
  ChevronRight,
  Printer
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface DocumentViewerProps {
  storageId: Id<"_storage">;
  fileName?: string;
  fileType?: string;
  className?: string;
  showHeader?: boolean;
  showControls?: boolean;
  height?: string;
  onClose?: () => void;
}

export const DocumentViewer = ({
  storageId,
  fileName = 'Document',
  fileType = 'pdf',
  className,
  showHeader = true,
  showControls = true,
  height = 'h-[600px]',
  onClose
}: DocumentViewerProps) => {
  // State
  const [scale, setScale] = useState(100);
  const [rotation, setRotation] = useState(0);
  const [isFullscreen, setIsFullscreen] = useState(false);
  const [currentPage, setCurrentPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  // Fetch file URL from Convex
  const { data: fileUrl, isLoading: isLoadingUrl, error: urlError } = useConvexQuery(
    api.contracts.getContractFileUrl,
    storageId ? { storageId } : "skip"
  );

  useEffect(() => {
    if (urlError) {
      setError(urlError.message);
      setIsLoading(false);
    } else if (fileUrl) {
      setIsLoading(false);
    }
  }, [fileUrl, urlError]);

  // File type detection and support
  const getSupportedFileTypes = () => {
    return ['pdf', 'jpg', 'jpeg', 'png', 'gif', 'webp', 'svg', 'txt', 'md'];
  };

  const isFileTypeSupported = () => {
    const supportedTypes = getSupportedFileTypes();
    const fileExt = fileType.toLowerCase().replace('.', '');
    return supportedTypes.includes(fileExt);
  };

  const isPdfFile = () => {
    return fileType.toLowerCase().includes('pdf');
  };

  const isImageFile = () => {
    const imageTypes = ['jpg', 'jpeg', 'png', 'gif', 'webp', 'svg'];
    return imageTypes.some(type => fileType.toLowerCase().includes(type));
  };

  const isTextFile = () => {
    const textTypes = ['txt', 'md', 'text'];
    return textTypes.some(type => fileType.toLowerCase().includes(type));
  };

  // Control handlers
  const handleZoomIn = () => {
    setScale(prev => Math.min(prev + 25, 300));
  };

  const handleZoomOut = () => {
    setScale(prev => Math.max(prev - 25, 25));
  };

  const handleRotate = () => {
    setRotation(prev => (prev + 90) % 360);
  };

  const handleFullscreen = () => {
    setIsFullscreen(!isFullscreen);
  };

  const handleDownload = () => {
    if (fileUrl) {
      const link = document.createElement('a');
      link.href = fileUrl;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }
  };

  const handlePrint = () => {
    if (fileUrl) {
      window.open(fileUrl, '_blank');
    }
  };

  const handlePrevPage = () => {
    setCurrentPage(prev => Math.max(prev - 1, 1));
  };

  const handleNextPage = () => {
    setCurrentPage(prev => Math.min(prev + 1, totalPages));
  };

  // Render controls
  const renderControls = () => {
    if (!showControls) return null;

    return (
      <div className="flex items-center gap-2 flex-wrap">
        {/* Zoom controls */}
        <div className="flex items-center gap-1 bg-muted rounded-md p-1">
          <Button
            variant="ghost"
            size="sm"
            onClick={handleZoomOut}
            disabled={scale <= 25}
            className="h-7 w-7 p-0"
          >
            <ZoomOut className="h-4 w-4" />
          </Button>
          <span className="text-xs px-2 min-w-[50px] text-center">{scale}%</span>
          <Button
            variant="ghost"
            size="sm"
            onClick={handleZoomIn}
            disabled={scale >= 300}
            className="h-7 w-7 p-0"
          >
            <ZoomIn className="h-4 w-4" />
          </Button>
        </div>

        {/* Page navigation for PDFs */}
        {isPdfFile() && totalPages > 1 && (
          <div className="flex items-center gap-1 bg-muted rounded-md p-1">
            <Button
              variant="ghost"
              size="sm"
              onClick={handlePrevPage}
              disabled={currentPage <= 1}
              className="h-7 w-7 p-0"
            >
              <ChevronLeft className="h-4 w-4" />
            </Button>
            <span className="text-xs px-2 min-w-[60px] text-center">
              {currentPage} / {totalPages}
            </span>
            <Button
              variant="ghost"
              size="sm"
              onClick={handleNextPage}
              disabled={currentPage >= totalPages}
              className="h-7 w-7 p-0"
            >
              <ChevronRight className="h-4 w-4" />
            </Button>
          </div>
        )}

        {/* Rotation for images */}
        {isImageFile() && (
          <Button
            variant="ghost"
            size="sm"
            onClick={handleRotate}
            className="h-7 w-7 p-0"
          >
            <RotateCw className="h-4 w-4" />
          </Button>
        )}

        {/* Fullscreen toggle */}
        <Button
          variant="ghost"
          size="sm"
          onClick={handleFullscreen}
          className="h-7 w-7 p-0"
        >
          {isFullscreen ? <Minimize2 className="h-4 w-4" /> : <Maximize2 className="h-4 w-4" />}
        </Button>

        {/* Download */}
        <Button
          variant="ghost"
          size="sm"
          onClick={handleDownload}
          className="h-7 w-7 p-0"
        >
          <Download className="h-4 w-4" />
        </Button>

        {/* Print */}
        <Button
          variant="ghost"
          size="sm"
          onClick={handlePrint}
          className="h-7 w-7 p-0"
        >
          <Printer className="h-4 w-4" />
        </Button>
      </div>
    );
  };

  // Render file content
  const renderFileContent = () => {
    if (isLoading || isLoadingUrl) {
      return (
        <div className="flex flex-col items-center justify-center h-full space-y-4">
          <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"></div>
          <div className="space-y-2 text-center">
            <p className="text-sm font-medium">Loading document...</p>
            <Progress value={33} className="w-48" />
          </div>
        </div>
      );
    }

    if (error || !fileUrl) {
      return (
        <div className="flex flex-col items-center justify-center h-full space-y-4">
          <AlertCircle className="h-16 w-16 text-muted-foreground" />
          <div className="text-center space-y-2">
            <p className="text-lg font-medium text-muted-foreground">Unable to load document</p>
            <p className="text-sm text-muted-foreground">
              {error || 'The document could not be retrieved.'}
            </p>
            <Button onClick={handleDownload} variant="outline" size="sm" disabled={!fileUrl}>
              <Download className="h-4 w-4 mr-2" />
              Download File
            </Button>
          </div>
        </div>
      );
    }

    if (!isFileTypeSupported()) {
      return (
        <div className="flex flex-col items-center justify-center h-full space-y-4">
          <FileText className="h-16 w-16 text-muted-foreground" />
          <div className="text-center space-y-2">
            <p className="text-lg font-medium text-muted-foreground">Preview not available</p>
            <p className="text-sm text-muted-foreground">
              File type .{fileType} is not supported for preview.
            </p>
            <Badge variant="outline" className="mb-2">
              Supported: {getSupportedFileTypes().join(', ')}
            </Badge>
            <Button onClick={handleDownload} variant="outline" size="sm">
              <Download className="h-4 w-4 mr-2" />
              Download {fileName}
            </Button>
          </div>
        </div>
      );
    }

    // Render based on file type
    const containerStyle = {
      transform: `scale(${scale / 100}) rotate(${rotation}deg)`,
      transformOrigin: 'center',
      transition: 'transform 0.2s ease-in-out',
    };

    if (isPdfFile()) {
      return (
        <div className="flex items-center justify-center h-full overflow-auto">
          <div style={containerStyle}>
            <iframe
              src={`${fileUrl}#page=${currentPage}&zoom=${scale}`}
              className="w-full h-full border-0"
              style={{ minHeight: '500px', minWidth: '400px' }}
              title={fileName}
              onLoad={() => {
                // Could implement PDF page counting here with a library
                setTotalPages(1); // Placeholder
              }}
            />
          </div>
        </div>
      );
    }

    if (isImageFile()) {
      return (
        <div className="flex items-center justify-center h-full overflow-auto p-4">
          <div style={containerStyle}>
            <img
              src={fileUrl}
              alt={fileName}
              className="max-w-full max-h-full object-contain"
              onError={() => setError('Failed to load image')}
            />
          </div>
        </div>
      );
    }

    if (isTextFile()) {
      return (
        <div className="h-full overflow-auto p-4">
          <div style={containerStyle}>
            <iframe
              src={fileUrl}
              className="w-full h-full border-0 bg-white"
              style={{ minHeight: '500px' }}
              title={fileName}
            />
          </div>
        </div>
      );
    }

    // Fallback for other supported types
    return (
      <div className="flex items-center justify-center h-full overflow-auto">
        <div style={containerStyle}>
          <iframe
            src={fileUrl}
            className="w-full h-full border-0"
            style={{ minHeight: '500px', minWidth: '400px' }}
            title={fileName}
          />
        </div>
      </div>
    );
  };

  // Main render
  const content = (
    <Card className={cn('w-full', className)}>
      {showHeader && (
        <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-2">
          <CardTitle className="flex items-center gap-2 text-lg">
            <FileText className="h-5 w-5" />
            <span className="truncate">{fileName}</span>
            <Badge variant="outline" className="text-xs">
              {fileType.toUpperCase()}
            </Badge>
          </CardTitle>
          
          <div className="flex items-center gap-2">
            {renderControls()}
            {onClose && (
              <Button
                variant="ghost"
                size="sm"
                onClick={onClose}
                className="h-7 w-7 p-0"
              >
                <X className="h-4 w-4" />
              </Button>
            )}
          </div>
        </CardHeader>
      )}

      <CardContent className="p-0">
        <div className={cn(height, 'relative bg-muted/20')}>
          {renderFileContent()}
        </div>
      </CardContent>
    </Card>
  );

  // Fullscreen wrapper
  if (isFullscreen) {
    return (
      <div className="fixed inset-0 z-50 bg-background">
        <div className="h-full w-full">
          {React.cloneElement(content, {
            className: cn(className, 'h-full'),
            children: React.cloneElement(content.props.children, {
              children: [
                content.props.children.props.children[0], // Header
                React.cloneElement(content.props.children.props.children[1], {
                  children: React.cloneElement(
                    content.props.children.props.children[1].props.children,
                    { className: 'h-full' }
                  )
                })
              ]
            })
          })}
        </div>
      </div>
    );
  }

  return content;
};

export default DocumentViewer;
</file>

<file path="src/app/_components/common/DynamicCharts.tsx">
//@ts-nocheck
"use client";


import React from 'react';
import {
  ResponsiveContainer,
  LineChart,
  Line,
  BarChart,
  Bar,
  AreaChart,
  Area,
  PieChart,
  Pie,
  RadarChart,
  Radar,
  RadialBarChart,
  RadialBar,
  ScatterChart,
  Scatter,
  ComposedChart,
  XAxis,
  YAxis,
  CartesianGrid,
  Tooltip,
  Legend,
  Cell,
  PolarGrid,
  PolarAngleAxis,
  PolarRadiusAxis
} from 'recharts';
import CustomTooltip from "./CustomToolTip";

// Define available chart types
type ChartType = 
  | 'line' 
  | 'bar' 
  | 'area' 
  | 'pie' 
  | 'radar' 
  | 'radialBar' 
  | 'scatter'
  | 'composed';

// Define chart series configuration
interface SeriesConfig {
  dataKey: string;
  name?: string;
  color?: string;
  type?: 'line' | 'bar' | 'area' | 'scatter'; // For composed charts
  stackId?: string;
  fill?: string;
  stroke?: string;
  strokeWidth?: number;
  dot?: boolean | object;
  activeDot?: object;
  isAnimationActive?: boolean;
  fillOpacity?: number;
}

interface DynamicChartProps {
  type: ChartType;
  data: any[];
  series: SeriesConfig[];
  width?: string | number;
  height?: number;
  layout?: 'horizontal' | 'vertical';
  stacked?: boolean;
  xAxisKey?: string;
  yAxisLabel?: string;
  xAxisLabel?: string;
  showGrid?: boolean;
  showLegend?: boolean;
  showTooltip?: boolean;
  useCustomTooltip?: boolean;
  colors?: string[];
  margin?: {
    top?: number;
    right?: number;
    bottom?: number;
    left?: number;
  };
  pieConfig?: {
    innerRadius?: number;
    outerRadius?: number;
    paddingAngle?: number;
    dataKey: string;
    nameKey?: string;
    labelLine?: boolean;
    label?: boolean | React.ReactNode | Function;
  };
  radarConfig?: {
    outerRadius?: number;
    dataKey: string;
  };
  radialBarConfig?: {
    innerRadius?: number;
    outerRadius?: number;
    dataKey: string;
    startAngle?: number;
    endAngle?: number;
  };
  syncId?: string; // For synchronized charts
}

const DynamicChart: React.FC<DynamicChartProps> = ({
  type,
  data,
  series,
  width = "100%",
  height = 400,
  layout = 'horizontal',
  stacked = false,
  xAxisKey = "name",
  yAxisLabel,
  xAxisLabel,
  showGrid = true,
  showLegend = true,
  showTooltip = true,
  useCustomTooltip = false,
  colors = ["hsl(var(--gold))", "hsl(var(--chart-1))", "hsl(var(--chart-2))", "hsl(var(--chart-3))", "hsl(var(--chart-4))"],
  margin = { top: 20, right: 30, left: 20, bottom: 20 },
  pieConfig,
  radarConfig,
  radialBarConfig,
  syncId
}) => {
  // Generate color for a series
  const getColor = (index: number) => colors[index % colors.length];

  // Add this helper function near the top of the component
  const getNumericSize = (size: string | number | undefined) => {
    return typeof size === 'string' ? 0 : size;
  };

  // Common chart components
  const renderCartesianComponents = () => (
    <>
      {showGrid && <CartesianGrid strokeDasharray="3 3" stroke="hsl(var(--border))" />}
      <XAxis 
        dataKey={xAxisKey} 
        label={xAxisLabel ? { value: xAxisLabel, position: 'insideBottom', offset: -5 } : undefined}
        tick={{ fill: 'hsl(var(--muted-foreground))' }}
        axisLine={{ stroke: 'hsl(var(--border))' }}
      />
      <YAxis 
        label={yAxisLabel ? { value: yAxisLabel, angle: -90, position: 'insideLeft' } : undefined}
        tick={{ fill: 'hsl(var(--muted-foreground))' }}
        axisLine={{ stroke: 'hsl(var(--border))' }}
      />
      {showTooltip && useCustomTooltip ? <Tooltip content={<CustomTooltip />} /> : showTooltip ? <Tooltip /> : null}
      {showLegend && <Legend wrapperStyle={{ paddingTop: 10 }} />}
    </>
  );

  // Render Line Series
  const renderLineSeries = () => (
    <>
      {series.map((item, index) => (
        <Line
          key={`line-${item.dataKey}`}
          type="monotone"
          dataKey={item.dataKey}
          name={item.name || item.dataKey}
          stroke={item.color || item.stroke || getColor(index)}
          strokeWidth={item.strokeWidth || 2}
          dot={item.dot !== undefined ? item.dot : { r: 4, fill: item.color || getColor(index) }}
          activeDot={item.activeDot || { r: 6 }}
          isAnimationActive={item.isAnimationActive !== undefined ? item.isAnimationActive : true}
          fillOpacity={item.fillOpacity || 0.3}
          
        />
      ))}
    </>
  );

  // Render Bar Series
  const renderBarSeries = () => (
    <>
      {series.map((item, index) => (
        <Bar
          key={`bar-${item.dataKey}`}
          dataKey={item.dataKey}
          name={item.name || item.dataKey}
          fill={item.color || item.fill || getColor(index)}
          stroke={item.stroke || 'none'}
          strokeWidth={item.strokeWidth || 0}
          isAnimationActive={item.isAnimationActive !== undefined ? item.isAnimationActive : true}
          stackId={stacked ? '1' : undefined}
        />
      ))}
    </>
  );

  // Render Area Series
  const renderAreaSeries = () => (
    <>
      {series.map((item, index) => (
        <Area
          key={`area-${item.dataKey}`}
          type="monotone"
          dataKey={item.dataKey}
          name={item.name || item.dataKey}
          fill={item.fill || item.color || getColor(index)}
          stroke={item.stroke || item.color || getColor(index)}
          strokeWidth={item.strokeWidth || 2}
          dot={item.dot !== undefined ? item.dot : { r: 4 }}
          activeDot={item.activeDot || { r: 6 }}
          isAnimationActive={item.isAnimationActive !== undefined ? item.isAnimationActive : true}
          fillOpacity={item.fillOpacity || 0.3}
          stackId={stacked ? '1' : undefined}
        />
      ))}
    </>
  );

  // Render Pie Series
  const renderPieChart = () => {
    if (!pieConfig) return null;
    
    return (
      <PieChart width={getNumericSize(width)} height={height} margin={margin}>
        <Pie
          data={data}
          cx="50%"
          cy="50%"
          labelLine={pieConfig.labelLine !== undefined ? pieConfig.labelLine : true}
          label={pieConfig.label !== undefined ? pieConfig.label : true}
          outerRadius={pieConfig.outerRadius || 150}
          innerRadius={pieConfig.innerRadius || 0}
          fill={colors[0]}
          dataKey={pieConfig.dataKey}
          nameKey={pieConfig.nameKey || xAxisKey}
          paddingAngle={pieConfig.paddingAngle || 0}
        >
          {data.map((entry, index) => (
            <Cell key={`cell-${index}`} fill={getColor(index)} />
          ))}
        </Pie>
        {showLegend && <Legend wrapperStyle={{ paddingTop: 20 }} />}
        {showTooltip && useCustomTooltip ? <Tooltip content={<CustomTooltip />} /> : showTooltip ? <Tooltip /> : null}
      </PieChart>
    );
  };

  // Render Radar Chart
  const renderRadarChart = () => {
    if (!radarConfig) return null;
    
    return (
      <RadarChart cx="50%" cy="50%" outerRadius={radarConfig.outerRadius || 150} width={width} height={height} data={data} margin={margin}>
        <PolarGrid stroke="hsl(var(--border))" />
        <PolarAngleAxis dataKey={xAxisKey} tick={{ fill: 'hsl(var(--muted-foreground))' }} />
        <PolarRadiusAxis tick={{ fill: 'hsl(var(--muted-foreground))' }} />
        {series.map((item, index) => (
          <Radar 
            key={`radar-${item.dataKey}`}
            name={item.name || item.dataKey}
            dataKey={item.dataKey}
            stroke={item.stroke || item.color || getColor(index)}
            fill={item.fill || item.color || getColor(index)}
            fillOpacity={item.fillOpacity || 0.3}
          />
        ))}
        {showLegend && <Legend wrapperStyle={{ paddingTop: 20 }} />}
        {showTooltip && useCustomTooltip ? <Tooltip content={<CustomTooltip />} /> : showTooltip ? <Tooltip /> : null}
      </RadarChart>
    );
  };

  // Render RadialBar Chart
  const renderRadialBarChart = () => {
    if (!radialBarConfig) return null;
    
    return (
      <RadialBarChart 
        cx="50%" 
        cy="50%" 
        innerRadius={radialBarConfig.innerRadius || 20} 
        outerRadius={radialBarConfig.outerRadius || 140} 
        startAngle={radialBarConfig.startAngle || 0} 
        endAngle={radialBarConfig.endAngle || 360} 
        width={width} 
        height={height} 
        data={data}
        margin={margin}
      >
        <RadialBar
          label={{ position: 'insideStart', fill: 'hsl(var(--foreground))' }}
          background={{ fill: 'hsl(var(--background))' }}
          dataKey={radialBarConfig.dataKey}
        >
          {data.map((entry, index) => (
            <Cell key={`cell-${index}`} fill={getColor(index)} />
          ))}
        </RadialBar>
        {showLegend && <Legend wrapperStyle={{ paddingTop: 20 }} iconSize={10} />}
        {showTooltip && useCustomTooltip ? <Tooltip content={<CustomTooltip />} /> : showTooltip ? <Tooltip /> : null}
      </RadialBarChart>
    );
  };

  // Render Scatter Chart
  const renderScatterChart = () => (
    <ScatterChart width={width} height={height} margin={margin}>
      {renderCartesianComponents()}
      {series.map((item, index) => (
        <Scatter
          key={`scatter-${item.dataKey}`}
          name={item.name || item.dataKey}
          data={data}
          fill={item.fill || item.color || getColor(index)}
          line={{ stroke: item.stroke || item.color || getColor(index) }}
          dataKey={item.dataKey}
        />
      ))}
    </ScatterChart>
  );

  // Render Composed Chart
  const renderComposedChart = () => (
    <ComposedChart width={width} height={height} data={data} layout={layout} margin={margin} syncId={syncId}>
      {renderCartesianComponents()}
      {series.map((item, index) => {
        const color = item.color || getColor(index);
        switch (item.type) {
          case 'line':
            return (
              <Line
                key={`line-${item.dataKey}`}
                type="monotone"
                dataKey={item.dataKey}
                name={item.name || item.dataKey}
                stroke={item.stroke || color}
                strokeWidth={item.strokeWidth || 2}
                dot={item.dot !== undefined ? item.dot : { r: 4 }}
                activeDot={item.activeDot || { r: 6 }}
                fill={item.fill || color}
                
              />
            );
          case 'bar':
            return (
              <Bar
                key={`bar-${item.dataKey}`}
                dataKey={item.dataKey}
                name={item.name || item.dataKey}
                fill={item.fill || color}
                stroke={item.stroke || 'none'}
                stackId={item.stackId}
              />
            );
          case 'area':
            return (
              <Area
                key={`area-${item.dataKey}`}
                type="monotone"
                dataKey={item.dataKey}
                name={item.name || item.dataKey}
                fill={item.fill || color}
                stroke={item.stroke || color}
                strokeWidth={item.strokeWidth || 2}
                fillOpacity={item.fillOpacity || 0.3}
                stackId={item.stackId}
              />
            );
          case 'scatter':
            return (
              <Scatter
                key={`scatter-${item.dataKey}`}
                name={item.name || item.dataKey}
                fill={item.fill || color}
                dataKey={item.dataKey}
              />
            );
          default:
            return null;
        }
      })}
    </ComposedChart>
  );

 
  const renderChart = () => {
    switch (type) {
      case 'line':
        return (
          <LineChart width={width} height={height} data={data} layout={layout} margin={margin} syncId={syncId}>
            {renderCartesianComponents()}
            {renderLineSeries()}
          </LineChart>
        );
      case 'bar':
        return (
          <BarChart width={width} height={height} data={data} layout={layout} margin={margin} syncId={syncId}>
            {renderCartesianComponents()}
            {renderBarSeries()}
          </BarChart>
        );
      case 'area':
        return (
          <AreaChart width={width} height={height} data={data} layout={layout} margin={margin} syncId={syncId}>
            {renderCartesianComponents()}
            {renderAreaSeries()}
          </AreaChart>
        );
      case 'pie':
        return renderPieChart();
      case 'radar':
        return renderRadarChart();
      case 'radialBar':
        return renderRadialBarChart();
      case 'scatter':
        return renderScatterChart();
      case 'composed':
        return renderComposedChart();
      default:
        return <div>Unsupported chart type</div>;
    }
  };

  return (
    <ResponsiveContainer width={width} height={height}>
      {renderChart() || <div>No chart rendered</div>}
    </ResponsiveContainer>
  );
};

export default DynamicChart;
</file>

<file path="src/app/_components/common/EmptyStates.tsx">
'use client';

import React from 'react';
import { 
  FileText, 
  Building, 
  Search, 
  Users, 
  BarChart3, 
  Bell, 
  Archive, 
  Plus, 
  Upload, 
  Filter,
  Calendar,
  AlertTriangle,
  CheckCircle,
  Clock,
  Star,
  Settings,
  ArrowRight,
  ExternalLink,
  Sparkles
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';

// Base empty state component
export interface EmptyStateProps {
  icon?: React.ComponentType<{ className?: string }>;
  title: string;
  description?: string;
  action?: {
    label: string;
    onClick: () => void;
    variant?: 'default' | 'outline' | 'secondary';
    icon?: React.ComponentType<{ className?: string }>;
  };
  secondaryAction?: {
    label: string;
    onClick: () => void;
    variant?: 'ghost' | 'outline';
  };
  image?: string;
  variant?: 'default' | 'minimal' | 'illustrated' | 'card';
  size?: 'sm' | 'md' | 'lg';
  className?: string;
  children?: React.ReactNode;
}

export const EmptyState: React.FC<EmptyStateProps> = ({
  icon: IconComponent = FileText,
  title,
  description,
  action,
  secondaryAction,
  image,
  variant = 'default',
  size = 'md',
  className,
  children
}) => {
  const sizeClasses = {
    sm: {
      container: 'py-8',
      icon: 'h-12 w-12',
      title: 'text-lg',
      description: 'text-sm',
      spacing: 'space-y-3'
    },
    md: {
      container: 'py-12',
      icon: 'h-16 w-16',
      title: 'text-xl',
      description: 'text-base',
      spacing: 'space-y-4'
    },
    lg: {
      container: 'py-16',
      icon: 'h-20 w-20',
      title: 'text-2xl',
      description: 'text-lg',
      spacing: 'space-y-6'
    }
  };

  const classes = sizeClasses[size];

  const content = (
    <div className={cn(
      'text-center flex flex-col items-center',
      classes.container,
      classes.spacing,
      className
    )}>
      {/* Icon or Image */}
      {image ? (
        <img 
          src={image} 
          alt={title}
          className={cn('object-contain', classes.icon)}
        />
      ) : (
        <div className={cn(
          'rounded-full bg-muted/50 flex items-center justify-center',
          variant === 'minimal' ? 'bg-transparent' : 'bg-muted/50',
          size === 'sm' ? 'p-3' : size === 'lg' ? 'p-5' : 'p-4'
        )}>
          <IconComponent className={cn(classes.icon, 'text-muted-foreground')} />
        </div>
      )}

      {/* Title */}
      <h3 className={cn('font-semibold text-foreground', classes.title)}>
        {title}
      </h3>

      {/* Description */}
      {description && (
        <p className={cn('text-muted-foreground max-w-md', classes.description)}>
          {description}
        </p>
      )}

      {/* Custom content */}
      {children}

      {/* Actions */}
      {(action || secondaryAction) && (
        <div className="flex flex-col sm:flex-row gap-3 mt-2">
          {action && (
            <Button
              onClick={action.onClick}
              variant={action.variant || 'default'}
              className="flex items-center gap-2"
            >
              {action.icon && <action.icon className="h-4 w-4" />}
              {action.label}
            </Button>
          )}
          {secondaryAction && (
            <Button
              onClick={secondaryAction.onClick}
              variant={secondaryAction.variant || 'outline'}
            >
              {secondaryAction.label}
            </Button>
          )}
        </div>
      )}
    </div>
  );

  if (variant === 'card') {
    return (
      <Card className={className}>
        <CardContent>
          {content}
        </CardContent>
      </Card>
    );
  }

  return content;
};

// Contract-specific empty states
export const EmptyContracts: React.FC<{
  variant?: 'all' | 'filtered' | 'draft' | 'active' | 'expired' | 'archived';
  onCreateContract?: () => void;
  onClearFilters?: () => void;
  className?: string;
}> = ({ variant = 'all', onCreateContract, onClearFilters, className }) => {
  const configs = {
    all: {
      title: 'No contracts yet',
      description: 'Get started by creating your first contract. Upload documents and let our AI analyze the key terms automatically.',
      action: onCreateContract ? {
        label: 'Create First Contract',
        onClick: onCreateContract,
        icon: Plus
      } : undefined
    },
    filtered: {
      title: 'No contracts match your filters',
      description: 'Try adjusting your search criteria or filters to find what you\'re looking for.',
      action: onClearFilters ? {
        label: 'Clear Filters',
        onClick: onClearFilters,
        variant: 'outline' as const,
        icon: Filter
      } : undefined
    },
    draft: {
      title: 'No draft contracts',
      description: 'Draft contracts will appear here as you create them.',
      action: onCreateContract ? {
        label: 'Create Draft',
        onClick: onCreateContract,
        icon: Plus
      } : undefined
    },
    active: {
      title: 'No active contracts',
      description: 'Active contracts will be displayed here once they are executed and in force.',
      icon: CheckCircle
    },
    expired: {
      title: 'No expired contracts',
      description: 'Contracts that have passed their end date will appear here.',
      icon: Calendar
    },
    archived: {
      title: 'No archived contracts',
      description: 'Archived contracts will be shown here.',
      icon: Archive
    }
  };

  const config = configs[variant];

  return (
    <EmptyState
      icon={config.icon || FileText}
      title={config.title}
      description={config.description}
      action={config.action}
      className={className}
    />
  );
};

// Vendor-specific empty states
export const EmptyVendors: React.FC<{
  variant?: 'all' | 'filtered' | 'active' | 'inactive' | 'category';
  category?: string;
  onAddVendor?: () => void;
  onClearFilters?: () => void;
  className?: string;
}> = ({ variant = 'all', category, onAddVendor, onClearFilters, className }) => {
  const configs = {
    all: {
      title: 'No vendors yet',
      description: 'Start building your vendor database by adding your first vendor. Track their performance, compliance, and contracts.',
      action: onAddVendor ? {
        label: 'Add First Vendor',
        onClick: onAddVendor,
        icon: Plus
      } : undefined
    },
    filtered: {
      title: 'No vendors match your criteria',
      description: 'Try adjusting your search or filter settings to find the vendors you\'re looking for.',
      action: onClearFilters ? {
        label: 'Clear Filters',
        onClick: onClearFilters,
        variant: 'outline' as const,
        icon: Filter
      } : undefined
    },
    active: {
      title: 'No active vendors',
      description: 'Active vendors with current contracts will appear here.',
    },
    inactive: {
      title: 'No inactive vendors',
      description: 'Vendors without active contracts will be listed here.',
    },
    category: {
      title: `No ${category} vendors`,
      description: `You haven't added any vendors in the ${category} category yet.`,
      action: onAddVendor ? {
        label: `Add ${category} Vendor`,
        onClick: onAddVendor,
        icon: Plus
      } : undefined
    }
  };

  const config = configs[variant];

  return (
    <EmptyState
      icon={Building}
      title={config.title}
      description={config.description}
      action={config.action}
      className={className}
    />
  );
};

// Search empty state
export const EmptySearchResults: React.FC<{
  query: string;
  suggestions?: string[];
  onClearSearch?: () => void;
  onSuggestionClick?: (suggestion: string) => void;
  className?: string;
}> = ({ query, suggestions = [], onClearSearch, onSuggestionClick, className }) => (
  <EmptyState
    icon={Search}
    title={`No results for "${query}"`}
    description="We couldn't find anything matching your search. Try different keywords or check your spelling."
    action={onClearSearch ? {
      label: 'Clear Search',
      onClick: onClearSearch,
      variant: 'outline'
    } : undefined}
    className={className}
  >
    {suggestions.length > 0 && (
      <div className="mt-4 space-y-2">
        <p className="text-sm text-muted-foreground">Try searching for:</p>
        <div className="flex flex-wrap gap-2 justify-center">
          {suggestions.map((suggestion, index) => (
            <Badge
              key={index}
              variant="outline"
              className="cursor-pointer hover:bg-muted"
              onClick={() => onSuggestionClick?.(suggestion)}
            >
              {suggestion}
            </Badge>
          ))}
        </div>
      </div>
    )}
  </EmptyState>
);

// Analytics empty state
export const EmptyAnalytics: React.FC<{
  type?: 'no-data' | 'loading' | 'error';
  onRefresh?: () => void;
  className?: string;
}> = ({ type = 'no-data', onRefresh, className }) => {
  const configs = {
    'no-data': {
      title: 'No data available',
      description: 'Analytics will appear here once you have contracts and vendor data to analyze.',
      icon: BarChart3
    },
    loading: {
      title: 'Generating analytics...',
      description: 'Please wait while we process your data to generate insights.',
      icon: Sparkles
    },
    error: {
      title: 'Unable to load analytics',
      description: 'There was an error loading your analytics data. Please try again.',
      icon: AlertTriangle,
      action: onRefresh ? {
        label: 'Retry',
        onClick: onRefresh,
        icon: ArrowRight
      } : undefined
    }
  };

  const config = configs[type];

  return (
    <EmptyState
      icon={config.icon}
      title={config.title}
      description={config.description}
      action={config.action}
      className={className}
    />
  );
};

// Notifications empty state
export const EmptyNotifications: React.FC<{
  variant?: 'all' | 'unread' | 'type';
  type?: string;
  className?: string;
}> = ({ variant = 'all', type, className }) => {
  const configs = {
    all: {
      title: 'No notifications',
      description: 'You\'re all caught up! Notifications about contracts, vendors, and system updates will appear here.',
      icon: CheckCircle
    },
    unread: {
      title: 'No unread notifications',
      description: 'You\'ve read all your notifications. Great job staying on top of things!',
      icon: CheckCircle
    },
    type: {
      title: `No ${type} notifications`,
      description: `You don't have any ${type} notifications at the moment.`,
      icon: Bell
    }
  };

  const config = configs[variant];

  return (
    <EmptyState
      icon={config.icon}
      title={config.title}
      description={config.description}
      size="sm"
      variant="minimal"
      className={className}
    />
  );
};

// File upload empty state
export const EmptyFileUpload: React.FC<{
  onUpload?: () => void;
  acceptedTypes?: string[];
  maxSize?: string;
  className?: string;
}> = ({ onUpload, acceptedTypes = ['PDF', 'DOC', 'DOCX'], maxSize = '10MB', className }) => (
  <EmptyState
    icon={Upload}
    title="Upload your contract"
    description={`Drag and drop your contract file here, or click to browse. Accepted formats: ${acceptedTypes.join(', ')}. Max size: ${maxSize}.`}
    action={onUpload ? {
      label: 'Choose File',
      onClick: onUpload,
      icon: Upload
    } : undefined}
    variant="card"
    className={cn('border-2 border-dashed border-muted-foreground/25 hover:border-muted-foreground/50 transition-colors', className)}
  />
);

// Permission denied empty state
export const EmptyPermissions: React.FC<{
  resource: string;
  action?: string;
  onRequestAccess?: () => void;
  className?: string;
}> = ({ resource, action = 'access', onRequestAccess, className }) => (
  <EmptyState
    icon={AlertTriangle}
    title="Access restricted"
    description={`You don't have permission to ${action} ${resource}. Contact your administrator if you need access.`}
    action={onRequestAccess ? {
      label: 'Request Access',
      onClick: onRequestAccess,
      variant: 'outline'
    } : undefined}
    className={className}
  />
);

// Coming soon empty state
export const ComingSoon: React.FC<{
  feature: string;
  description?: string;
  timeline?: string;
  onNotifyMe?: () => void;
  className?: string;
}> = ({ feature, description, timeline, onNotifyMe, className }) => (
  <EmptyState
    icon={Star}
    title={`${feature} coming soon`}
    description={description || `We're working hard to bring you ${feature}. ${timeline ? `Expected ${timeline}.` : ''}`}
    action={onNotifyMe ? {
      label: 'Notify Me',
      onClick: onNotifyMe,
      variant: 'outline',
      icon: Bell
    } : undefined}
    className={className}
  >
    {timeline && (
      <Badge variant="outline" className="mt-2">
        {timeline}
      </Badge>
    )}
  </EmptyState>
);

// Maintenance empty state
export const MaintenanceMode: React.FC<{
  title?: string;
  description?: string;
  expectedDuration?: string;
  onCheckStatus?: () => void;
  className?: string;
}> = ({ 
  title = 'System maintenance',
  description = 'We\'re performing scheduled maintenance to improve your experience.',
  expectedDuration,
  onCheckStatus,
  className 
}) => (
  <EmptyState
    icon={Settings}
    title={title}
    description={`${description} ${expectedDuration ? `Expected completion: ${expectedDuration}.` : ''}`}
    action={onCheckStatus ? {
      label: 'Check Status',
      onClick: onCheckStatus,
      variant: 'outline'
    } : undefined}
    variant="card"
    size="lg"
    className={className}
  >
    {expectedDuration && (
      <div className="flex items-center gap-2 mt-2">
        <Clock className="h-4 w-4 text-muted-foreground" />
        <span className="text-sm text-muted-foreground">
          Estimated completion: {expectedDuration}
        </span>
      </div>
    )}
  </EmptyState>
);

export default EmptyState;
</file>

<file path="src/app/_components/common/ErrorBoundary.tsx">
'use client';

import React, { Component, ErrorInfo, ReactNode } from 'react';
import { AlertTriangle, RefreshCw, Home, Bug, Copy, ExternalLink } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';

interface Props {
  children: ReactNode;
  fallback?: ReactNode;
  showErrorDetails?: boolean;
  onError?: (error: Error, errorInfo: ErrorInfo) => void;
  isolate?: boolean; // If true, only catches errors in this component tree
}

interface State {
  hasError: boolean;
  error: Error | null;
  errorInfo: ErrorInfo | null;
  eventId: string | null;
  isExpanded: boolean;
}

export class ErrorBoundary extends Component<Props, State> {
  private retryTimeoutId: NodeJS.Timeout | null = null;

  public state: State = {
    hasError: false,
    error: null,
    errorInfo: null,
    eventId: null,
    isExpanded: false,
  };

  public static getDerivedStateFromError(error: Error): Partial<State> {
    // Update state so the next render will show the fallback UI
    return {
      hasError: true,
      error,
      eventId: `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
    };
  }

  public componentDidCatch(error: Error, errorInfo: ErrorInfo) {
    // Log error details
    console.error('ErrorBoundary caught an error:', error, errorInfo);

    // Update state with error info
    this.setState({
      error,
      errorInfo,
    });

    // Call custom error handler if provided
    if (this.props.onError) {
      this.props.onError(error, errorInfo);
    }

    // Report to error tracking service (e.g., Sentry, LogRocket)
    this.reportError(error, errorInfo);
  }

  private reportError = (error: Error, errorInfo: ErrorInfo) => {
    const errorReport = {
      message: error.message,
      stack: error.stack,
      componentStack: errorInfo.componentStack,
      timestamp: new Date().toISOString(),
      userAgent: navigator.userAgent,
      url: window.location.href,
      eventId: this.state.eventId,
    };

    // Send to Sentry
    if (typeof window !== 'undefined') {
      import('../../../lib/monitoring').then(({ reportError }) => {
        reportError(error, {
          contexts: { 
            react: errorInfo,
            errorBoundary: {
              eventId: this.state.eventId,
              isolate: this.props.isolate || false,
              componentStack: errorInfo.componentStack
            }
          },
          tags: {
            errorBoundary: true,
            component: 'ErrorBoundary',
            isolate: this.props.isolate ? 'true' : 'false'
          },
          extra: errorReport
        });
      }).catch(err => {
        console.error('Failed to report error to monitoring:', err);
      });
    }
    
    // For development, also log to console
    if (process.env.NODE_ENV === 'development') {
      console.group(' Error Report');
      console.error('Error:', error);
      console.error('Error Info:', errorInfo);
      console.error('Full Report:', errorReport);
      console.groupEnd();
    }
  };

  private handleRetry = () => {
    // Clear any existing timeout
    if (this.retryTimeoutId) {
      clearTimeout(this.retryTimeoutId);
    }

    // Reset error state
    this.setState({
      hasError: false,
      error: null,
      errorInfo: null,
      eventId: null,
      isExpanded: false,
    });
  };

  private handleReload = () => {
    window.location.reload();
  };

  private handleGoHome = () => {
    window.location.href = '/dashboard';
  };

  private copyErrorDetails = () => {
    const { error, errorInfo, eventId } = this.state;
    const errorDetails = {
      eventId,
      message: error?.message,
      stack: error?.stack,
      componentStack: errorInfo?.componentStack,
      timestamp: new Date().toISOString(),
      url: window.location.href,
    };

    navigator.clipboard.writeText(JSON.stringify(errorDetails, null, 2))
      .then(() => {
        // You could show a toast here
        console.log('Error details copied to clipboard');
      })
      .catch(err => {
        console.error('Failed to copy error details:', err);
      });
  };

  private getErrorSeverity = (): 'low' | 'medium' | 'high' | 'critical' => {
    const { error } = this.state;
    if (!error) return 'medium';

    // Classify errors by type/message
    if (error.message.includes('ChunkLoadError') || error.message.includes('Loading')) {
      return 'low'; // Network/loading issues
    }
    if (error.message.includes('TypeError') || error.message.includes('ReferenceError')) {
      return 'high'; // Code errors
    }
    if (error.message.includes('SecurityError') || error.message.includes('auth')) {
      return 'critical'; // Security issues
    }
    
    return 'medium'; // Default
  };

  private getErrorCategory = (): string => {
    const { error } = this.state;
    if (!error) return 'Unknown';

    if (error.message.includes('ChunkLoadError')) return 'Network';
    if (error.message.includes('TypeError')) return 'Code';
    if (error.message.includes('auth') || error.message.includes('permission')) return 'Authentication';
    if (error.message.includes('fetch') || error.message.includes('API')) return 'API';
    
    return 'Application';
  };

  public render() {
    const { hasError, error, errorInfo, eventId, isExpanded } = this.state;
    const { children, fallback, showErrorDetails = true } = this.props;

    if (hasError) {
      // Custom fallback UI
      if (fallback) {
        return fallback;
      }

      const severity = this.getErrorSeverity();
      const category = this.getErrorCategory();

      const severityColors = {
        low: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300',
        medium: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/70 dark:text-yellow-300',
        high: 'bg-orange-100 text-orange-800 dark:bg-orange-900/70 dark:text-orange-300',
        critical: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300',
      };

      // Default error UI
      return (
        <div className="min-h-[400px] flex items-center justify-center p-4">
          <Card className="w-full max-w-2xl">
            <CardHeader>
              <div className="flex items-center gap-4">
                <div className="flex-shrink-0">
                  <div className="w-12 h-12 rounded-full bg-red-100 dark:bg-red-900/20 flex items-center justify-center">
                    <AlertTriangle className="h-6 w-6 text-red-600 dark:text-red-400" />
                  </div>
                </div>
                <div className="flex-1">
                  <CardTitle className="text-xl text-foreground">Something went wrong</CardTitle>
                  <div className="flex items-center gap-2 mt-2">
                    <Badge className={severityColors[severity]}>
                      {severity.toUpperCase()}
                    </Badge>
                    <Badge variant="outline">{category}</Badge>
                    {eventId && (
                      <Badge variant="outline" className="font-mono text-xs">
                        {eventId}
                      </Badge>
                    )}
                  </div>
                </div>
              </div>
            </CardHeader>

            <CardContent className="space-y-4">
              <Alert>
                <AlertTriangle className="h-4 w-4" />
                <AlertTitle>Error Details</AlertTitle>
                <AlertDescription className="mt-2">
                  {error?.message || 'An unexpected error occurred. Please try refreshing the page or contact support if the problem persists.'}
                </AlertDescription>
              </Alert>

              {/* Action Buttons */}
              <div className="flex flex-wrap gap-3">
                <Button onClick={this.handleRetry} className="flex items-center gap-2">
                  <RefreshCw className="h-4 w-4" />
                  Try Again
                </Button>
                <Button variant="outline" onClick={this.handleReload}>
                  Reload Page
                </Button>
                <Button variant="outline" onClick={this.handleGoHome}>
                  <Home className="h-4 w-4 mr-2" />
                  Go to Dashboard
                </Button>
              </div>

              {/* Error Details (Collapsible) */}
              {showErrorDetails && (error || errorInfo) && (
                <>
                  <Separator />
                  <Collapsible open={isExpanded} onOpenChange={setIsExpanded}>
                    <CollapsibleTrigger asChild>
                      <Button variant="ghost" className="w-full justify-between">
                        <span className="flex items-center gap-2">
                          <Bug className="h-4 w-4" />
                          Technical Details
                        </span>
                        <span className="text-xs text-muted-foreground">
                          {isExpanded ? 'Hide' : 'Show'}
                        </span>
                      </Button>
                    </CollapsibleTrigger>
                    <CollapsibleContent className="space-y-4 mt-4">
                      {error && (
                        <div className="space-y-2">
                          <h4 className="font-medium text-sm">Error Message:</h4>
                          <pre className="text-xs bg-muted p-3 rounded-md overflow-auto max-h-32">
                            {error.message}
                          </pre>
                        </div>
                      )}

                      {error?.stack && (
                        <div className="space-y-2">
                          <h4 className="font-medium text-sm">Stack Trace:</h4>
                          <pre className="text-xs bg-muted p-3 rounded-md overflow-auto max-h-40">
                            {error.stack}
                          </pre>
                        </div>
                      )}

                      {errorInfo?.componentStack && (
                        <div className="space-y-2">
                          <h4 className="font-medium text-sm">Component Stack:</h4>
                          <pre className="text-xs bg-muted p-3 rounded-md overflow-auto max-h-32">
                            {errorInfo.componentStack}
                          </pre>
                        </div>
                      )}

                      <div className="flex gap-2">
                        <Button
                          variant="outline"
                          size="sm"
                          onClick={this.copyErrorDetails}
                          className="flex items-center gap-2"
                        >
                          <Copy className="h-3 w-3" />
                          Copy Details
                        </Button>
                        {process.env.NODE_ENV === 'development' && (
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => console.error('Error:', error, 'ErrorInfo:', errorInfo)}
                            className="flex items-center gap-2"
                          >
                            <Bug className="h-3 w-3" />
                            Log to Console
                          </Button>
                        )}
                      </div>
                    </CollapsibleContent>
                  </Collapsible>
                </>
              )}

              {/* Help Text */}
              <div className="text-sm text-muted-foreground bg-muted/50 p-3 rounded-md">
                <p className="font-medium mb-1">Need help?</p>
                <p>
                  If this error persists, please contact our support team with the error ID above.
                  We're here to help resolve any issues you encounter.
                </p>
              </div>
            </CardContent>
          </Card>
        </div>
      );
    }

    return children;
  }
}

// HOC wrapper for functional components
export function withErrorBoundary<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  errorBoundaryConfig?: Omit<Props, 'children'>
) {
  const WithErrorBoundaryComponent = (props: P) => (
    <ErrorBoundary {...errorBoundaryConfig}>
      <WrappedComponent {...props} />
    </ErrorBoundary>
  );

  WithErrorBoundaryComponent.displayName = `withErrorBoundary(${WrappedComponent.displayName || WrappedComponent.name})`;

  return WithErrorBoundaryComponent;
}

// Simple error boundary for specific use cases
export const SimpleErrorBoundary: React.FC<{ children: ReactNode; message?: string }> = ({ 
  children, 
  message = "Something went wrong with this component." 
}) => (
  <ErrorBoundary 
    fallback={
      <Alert variant="destructive" className="m-4">
        <AlertTriangle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>{message}</AlertDescription>
      </Alert>
    }
    showErrorDetails={false}
  >
    {children}
  </ErrorBoundary>
);

export default ErrorBoundary;
</file>

<file path="src/app/_components/common/ExportOptions.tsx">
'use client';

import React, { useState } from 'react';
import { format } from 'date-fns';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';
import { useUser } from '@clerk/nextjs';

// UI Components
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
  DropdownMenuSeparator,
  DropdownMenuLabel,
  DropdownMenuGroup,
} from "@/components/ui/dropdown-menu";
import { Button } from "@/components/ui/button";
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from "@/components/ui/dialog";
import { Label } from "@/components/ui/label";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Checkbox } from "@/components/ui/checkbox";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Progress } from "@/components/ui/progress";
import { Badge } from "@/components/ui/badge";

// Icons
import {
  Download,
  FileSpreadsheet,
  FileText,
  Printer,
  Mail,
  Calendar,
  Settings,
  Filter,
  CheckCircle,
  AlertCircle,
  Clock,
  Building,
  FileBarChart
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface ExportOptionsProps {
  data?: 'contracts' | 'vendors' | 'analytics' | 'custom';
  entityIds?: Id<"contracts">[] | Id<"vendors">[];
  variant?: 'dropdown' | 'button' | 'inline';
  className?: string;
  onExportComplete?: (result: ExportResult) => void;
}

interface ExportConfig {
  format: 'csv' | 'excel' | 'pdf' | 'json';
  includeFields: string[];
  dateRange?: {
    start: string;
    end: string;
  };
  filters?: Record<string, any>;
  template?: string;
  includeRelatedData?: boolean;
}

interface ExportResult {
  success: boolean;
  downloadUrl?: string;
  fileName?: string;
  error?: string;
}

// Export format configurations
const exportFormats = {
  csv: {
    label: 'CSV (Comma Separated)',
    icon: FileSpreadsheet,
    description: 'Best for spreadsheets and data analysis',
    extension: '.csv',
    maxRows: 50000,
  },
  excel: {
    label: 'Excel Workbook',
    icon: FileSpreadsheet,
    description: 'Full-featured spreadsheet with formatting',
    extension: '.xlsx',
    maxRows: 100000,
  },
  pdf: {
    label: 'PDF Report',
    icon: FileText,
    description: 'Professional formatted document',
    extension: '.pdf',
    maxRows: 10000,
  },
  json: {
    label: 'JSON Data',
    icon: FileBarChart,
    description: 'Raw data for developers',
    extension: '.json',
    maxRows: 100000,
  },
};

// Field configurations for different data types
const fieldConfigs = {
  contracts: {
    basic: ['title', 'status', 'vendor', 'createdAt'],
    financial: ['extractedPricing', 'extractedPaymentSchedule'],
    dates: ['extractedStartDate', 'extractedEndDate'],
    details: ['contractType', 'extractedParties', 'extractedScope'],
    metadata: ['analysisStatus', 'fileName', 'fileType', 'notes'],
  },
  vendors: {
    basic: ['name', 'category', 'status', 'createdAt'],
    contact: ['contactEmail', 'contactPhone', 'website', 'address'],
    performance: ['total_spend', 'compliance_score', 'risk_level'],
    metadata: ['notes', 'active_contracts', 'vendor_number'],
  },
  analytics: {
    summary: ['totalContracts', 'totalVendors', 'totalValue'],
    performance: ['completionRate', 'averageProcessingTime'],
    compliance: ['complianceScore', 'riskDistribution'],
    trends: ['monthlyTrends', 'categoryBreakdown'],
  },
};

export const ExportOptions = ({
  data = 'contracts',
  entityIds = [],
  variant = 'dropdown',
  className,
  onExportComplete
}: ExportOptionsProps) => {
  // State
  const [isDialogOpen, setIsDialogOpen] = useState(false);
  const [isExporting, setIsExporting] = useState(false);
  const [exportProgress, setExportProgress] = useState(0);
  const [exportConfig, setExportConfig] = useState<ExportConfig>({
    format: 'csv',
    includeFields: fieldConfigs[data]?.basic || [],
    includeRelatedData: true,
  });

  const { user: clerkUser } = useUser();
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch data for export preview
  const { data: contractsData } = useConvexQuery(
    api.contracts.getContracts,
    data === 'contracts' && enterpriseId ? { enterpriseId } : "skip"
  );

  const { data: vendorsData } = useConvexQuery(
    api.vendors.getVendors,
    data === 'vendors' && enterpriseId ? { enterpriseId } : "skip"
  );

  // Get available fields based on data type
  const getAvailableFields = () => {
    const fields = fieldConfigs[data] || {};
    return Object.entries(fields).flatMap(([category, fieldList]) =>
      fieldList.map(field => ({ field, category, label: formatFieldLabel(field) }))
    );
  };

  const formatFieldLabel = (field: string): string => {
    return field
      .replace(/([A-Z])/g, ' $1')
      .replace(/^./, str => str.toUpperCase())
      .replace(/([a-z])([A-Z])/g, '$1 $2');
  };

  // Generate filename
  const generateFileName = (): string => {
    const timestamp = format(new Date(), 'yyyy-MM-dd-HHmm');
    const dataLabel = data.charAt(0).toUpperCase() + data.slice(1);
    const formatExt = exportFormats[exportConfig.format].extension;
    
    if (entityIds.length > 0) {
      return `${dataLabel}-Selection-${timestamp}${formatExt}`;
    }
    
    return `${dataLabel}-Export-${timestamp}${formatExt}`;
  };

  // Prepare export data
  const prepareExportData = () => {
    let sourceData: any[] = [];
    
    switch (data) {
      case 'contracts':
        sourceData = contractsData || [];
        break;
      case 'vendors':
        sourceData = vendorsData || [];
        break;
      default:
        sourceData = [];
    }

    // Filter by entityIds if provided
    if (entityIds.length > 0) {
      sourceData = sourceData.filter(item => entityIds.includes(item._id));
    }

    // Apply date range filter if specified
    if (exportConfig.dateRange) {
      const startDate = new Date(exportConfig.dateRange.start);
      const endDate = new Date(exportConfig.dateRange.end);
      
      sourceData = sourceData.filter(item => {
        const itemDate = new Date(item._creationTime || item.createdAt);
        return itemDate >= startDate && itemDate <= endDate;
      });
    }

    // Select only requested fields
    return sourceData.map(item => {
      const exportItem: any = {};
      
      exportConfig.includeFields.forEach(field => {
        if (field === 'vendor' && item.vendor) {
          exportItem.vendor = item.vendor.name;
        } else if (field === 'createdAt' && item._creationTime) {
          exportItem.createdAt = format(new Date(item._creationTime), 'yyyy-MM-dd HH:mm:ss');
        } else if (field.includes('Date') && item[field]) {
          exportItem[field] = format(new Date(item[field]), 'yyyy-MM-dd');
        } else {
          exportItem[field] = item[field] || '';
        }
      });
      
      return exportItem;
    });
  };

  // Convert data to format
  const convertToFormat = (data: any[]): string => {
    switch (exportConfig.format) {
      case 'csv':
        return convertToCSV(data);
      case 'json':
        return JSON.stringify(data, null, 2);
      case 'excel':
        return convertToExcel(data);
      case 'pdf':
        return convertToPDF(data);
      default:
        return JSON.stringify(data);
    }
  };

  const convertToCSV = (data: any[]): string => {
    if (data.length === 0) return '';
    
    const headers = Object.keys(data[0]);
    const csvContent = [
      headers.join(','),
      ...data.map(row => 
        headers.map(header => {
          const value = row[header];
          // Escape CSV values that contain commas or quotes
          if (typeof value === 'string' && (value.includes(',') || value.includes('"'))) {
            return `"${value.replace(/"/g, '""')}"`;
          }
          return value;
        }).join(',')
      )
    ].join('\n');
    
    return csvContent;
  };

  const convertToExcel = (data: any[]): string => {
    // In a real implementation, you'd use a library like xlsx
    // For now, return CSV format as placeholder
    return convertToCSV(data);
  };

  const convertToPDF = (data: any[]): string => {
    // In a real implementation, you'd use a library like jsPDF
    // For now, return a simple text format
    return data.map(item => Object.values(item).join(' | ')).join('\n');
  };

  // Handle export
  const handleExport = async () => {
    setIsExporting(true);
    setExportProgress(0);

    try {
      // Simulate progress
      setExportProgress(25);
      
      const exportData = prepareExportData();
      setExportProgress(50);
      
      const content = convertToFormat(exportData);
      setExportProgress(75);
      
      // Create download
      const fileName = generateFileName();
      const mimeType = {
        csv: 'text/csv',
        excel: 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
        pdf: 'application/pdf',
        json: 'application/json',
      }[exportConfig.format];
      
      const blob = new Blob([content], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      // Download file
      const link = document.createElement('a');
      link.href = url;
      link.download = fileName;
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
      URL.revokeObjectURL(url);
      
      setExportProgress(100);
      
      const result: ExportResult = {
        success: true,
        fileName,
        downloadUrl: url,
      };
      
      onExportComplete?.(result);
      setIsDialogOpen(false);
      
    } catch (error) {
      console.error('Export failed:', error);
      const result: ExportResult = {
        success: false,
        error: error instanceof Error ? error.message : 'Export failed',
      };
      onExportComplete?.(result);
    } finally {
      setIsExporting(false);
      setExportProgress(0);
    }
  };

  // Quick export handlers
  const handleQuickExport = (format: keyof typeof exportFormats) => {
    setExportConfig(prev => ({
      ...prev,
      format,
      includeFields: fieldConfigs[data]?.basic || [],
    }));
    
    // Perform export immediately
    setTimeout(() => {
      handleExport();
    }, 100);
  };

  // Render export dialog
  const renderExportDialog = () => (
    <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
      <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Download className="h-5 w-5" />
            Export {data.charAt(0).toUpperCase() + data.slice(1)}
          </DialogTitle>
        </DialogHeader>

        <div className="space-y-6">
          {/* Export Format Selection */}
          <div className="space-y-3">
            <Label className="text-base font-medium">Export Format</Label>
            <div className="grid grid-cols-2 gap-3">
              {Object.entries(exportFormats).map(([key, format]) => {
                const IconComponent = format.icon;
                return (
                  <Card
                    key={key}
                    className={cn(
                      'cursor-pointer transition-colors border-2',
                      exportConfig.format === key 
                        ? 'border-primary bg-primary/5' 
                        : 'border-muted hover:border-primary/50'
                    )}
                    onClick={() => setExportConfig(prev => ({ ...prev, format: key as any }))}
                  >
                    <CardContent className="p-4">
                      <div className="flex items-center gap-3">
                        <IconComponent className="h-8 w-8 text-primary" />
                        <div className="flex-1 min-w-0">
                          <p className="font-medium text-sm">{format.label}</p>
                          <p className="text-xs text-muted-foreground mt-1">
                            {format.description}
                          </p>
                          <Badge variant="outline" className="text-xs mt-1">
                            Max {format.maxRows.toLocaleString()} rows
                          </Badge>
                        </div>
                      </div>
                    </CardContent>
                  </Card>
                );
              })}
            </div>
          </div>

          {/* Field Selection */}
          <div className="space-y-3">
            <Label className="text-base font-medium">Fields to Include</Label>
            <div className="grid grid-cols-1 gap-3 max-h-48 overflow-y-auto">
              {Object.entries(fieldConfigs[data] || {}).map(([category, fields]) => (
                <div key={category} className="space-y-2">
                  <Label className="text-sm font-medium capitalize text-muted-foreground">
                    {category}
                  </Label>
                  <div className="grid grid-cols-2 gap-2 pl-4">
                    {fields.map(field => (
                      <div key={field} className="flex items-center space-x-2">
                        <Checkbox
                          id={field}
                          checked={exportConfig.includeFields.includes(field)}
                          onCheckedChange={(checked) => {
                            setExportConfig(prev => ({
                              ...prev,
                              includeFields: checked
                                ? [...prev.includeFields, field]
                                : prev.includeFields.filter(f => f !== field)
                            }));
                          }}
                        />
                        <Label htmlFor={field} className="text-sm">
                          {formatFieldLabel(field)}
                        </Label>
                      </div>
                    ))}
                  </div>
                </div>
              ))}
            </div>
          </div>

          {/* Additional Options */}
          <div className="space-y-3">
            <Label className="text-base font-medium">Additional Options</Label>
            <div className="space-y-2">
              <div className="flex items-center space-x-2">
                <Checkbox
                  id="includeRelated"
                  checked={exportConfig.includeRelatedData}
                  onCheckedChange={(checked) => 
                    setExportConfig(prev => ({ ...prev, includeRelatedData: !!checked }))
                  }
                />
                <Label htmlFor="includeRelated" className="text-sm">
                  Include related data (vendor info for contracts, etc.)
                </Label>
              </div>
            </div>
          </div>

          {/* Export Preview */}
          {!isExporting && (
            <Alert>
              <FileText className="h-4 w-4" />
              <AlertDescription>
                Ready to export {prepareExportData().length} records with {exportConfig.includeFields.length} fields
                as {exportFormats[exportConfig.format].label}
              </AlertDescription>
            </Alert>
          )}

          {/* Export Progress */}
          {isExporting && (
            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <span className="text-sm font-medium">Exporting...</span>
                <span className="text-sm text-muted-foreground">{exportProgress}%</span>
              </div>
              <Progress value={exportProgress} className="w-full" />
            </div>
          )}

          {/* Actions */}
          <div className="flex justify-end gap-3 pt-4 border-t">
            <Button variant="outline" onClick={() => setIsDialogOpen(false)} disabled={isExporting}>
              Cancel
            </Button>
            <Button onClick={handleExport} disabled={isExporting || exportConfig.includeFields.length === 0}>
              {isExporting ? (
                <>
                  <Clock className="h-4 w-4 mr-2 animate-spin" />
                  Exporting...
                </>
              ) : (
                <>
                  <Download className="h-4 w-4 mr-2" />
                  Export {exportFormats[exportConfig.format].label}
                </>
              )}
            </Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );

  // Render based on variant
  switch (variant) {
    case 'button':
      return (
        <>
          <Button
            variant="outline"
            onClick={() => setIsDialogOpen(true)}
            className={className}
          >
            <Download className="h-4 w-4 mr-2" />
            Export
          </Button>
          {renderExportDialog()}
        </>
      );

    case 'inline':
      return (
        <Card className={className}>
          <CardHeader>
            <CardTitle className="flex items-center gap-2">
              <Download className="h-5 w-5" />
              Export Options
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="grid grid-cols-2 gap-3">
              {Object.entries(exportFormats).map(([key, format]) => {
                const IconComponent = format.icon;
                return (
                  <Button
                    key={key}
                    variant="outline"
                    onClick={() => handleQuickExport(key as any)}
                    className="h-20 flex-col gap-2"
                  >
                    <IconComponent className="h-6 w-6" />
                    <span className="text-xs">{format.label}</span>
                  </Button>
                );
              })}
            </div>
            <Button
              variant="ghost"
              onClick={() => setIsDialogOpen(true)}
              className="w-full mt-3"
            >
              <Settings className="h-4 w-4 mr-2" />
              Advanced Options
            </Button>
          </CardContent>
          {renderExportDialog()}
        </Card>
      );

    default: // dropdown
      return (
        <>
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="outline" className={className}>
                <Download className="h-4 w-4 mr-2" />
                Export
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end" className="w-56">
              <DropdownMenuLabel>Quick Export</DropdownMenuLabel>
              {Object.entries(exportFormats).map(([key, format]) => {
                const IconComponent = format.icon;
                return (
                  <DropdownMenuItem
                    key={key}
                    onClick={() => handleQuickExport(key as any)}
                  >
                    <IconComponent className="h-4 w-4 mr-2" />
                    {format.label}
                  </DropdownMenuItem>
                );
              })}
              <DropdownMenuSeparator />
              <DropdownMenuItem onClick={() => setIsDialogOpen(true)}>
                <Settings className="h-4 w-4 mr-2" />
                Advanced Options...
              </DropdownMenuItem>
            </DropdownMenuContent>
          </DropdownMenu>
          {renderExportDialog()}
        </>
      );
  }
};

export default ExportOptions;
</file>

<file path="src/app/_components/common/GlobalErrorHandler.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { toast } from 'sonner'; // Using Sonner for toast notifications
import { globalErrorHandler, AppError, ErrorSeverity } from '@/lib/error-handler';
import { AlertTriangle, X, Bug, RefreshCw, ExternalLink } from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { ScrollArea } from '@/components/ui/scroll-area';
import { Separator } from '@/components/ui/separator';
import { cn } from '@/lib/utils';

interface GlobalErrorHandlerProps {
  children: React.ReactNode;
  showToasts?: boolean;
  showErrorDialog?: boolean;
  maxToasts?: number;
  toastDuration?: number;
}

// Error notification component
const ErrorToast = ({ error, onDismiss, onViewDetails }: {
  error: AppError;
  onDismiss: () => void;
  onViewDetails?: () => void;
}) => {
  const severityIcons = {
    low: '',
    medium: '', 
    high: '',
    critical: ''
  };

  const severityColors = {
    low: 'bg-blue-50 border-blue-200 text-blue-900',
    medium: 'bg-yellow-50 border-yellow-200 text-yellow-900',
    high: 'bg-orange-50 border-orange-200 text-orange-900',
    critical: 'bg-red-50 border-red-200 text-red-900'
  };

  return (
    <div className={cn(
      'flex items-start gap-3 p-4 border rounded-lg shadow-lg max-w-md',
      severityColors[error.severity]
    )}>
      <span className="text-lg">{severityIcons[error.severity]}</span>
      <div className="flex-1 min-w-0">
        <div className="flex items-center gap-2 mb-1">
          <span className="font-medium text-sm">{error.category.toUpperCase()}</span>
          <Badge variant="outline" className="text-xs">
            {error.severity}
          </Badge>
        </div>
        <p className="text-sm mb-2">{error.userMessage || error.message}</p>
        <div className="flex items-center gap-2">
          {error.retryable && (
            <Button size="sm" variant="outline" className="h-7 text-xs">
              <RefreshCw className="h-3 w-3 mr-1" />
              Retry
            </Button>
          )}
          {onViewDetails && (
            <Button size="sm" variant="ghost" onClick={onViewDetails} className="h-7 text-xs">
              Details
            </Button>
          )}
        </div>
      </div>
      <Button
        variant="ghost"
        size="sm"
        onClick={onDismiss}
        className="h-6 w-6 p-0 opacity-70 hover:opacity-100"
      >
        <X className="h-4 w-4" />
      </Button>
    </div>
  );
};

// Error details dialog
const ErrorDetailsDialog = ({ error, isOpen, onClose }: {
  error: AppError | null;
  isOpen: boolean;
  onClose: () => void;
}) => {
  if (!error) return null;

  const formatTimestamp = (date: Date) => {
    return date.toLocaleString();
  };

  const copyErrorDetails = () => {
    const details = {
      id: error.id,
      message: error.message,
      code: error.code,
      category: error.category,
      severity: error.severity,
      timestamp: error.timestamp.toISOString(),
      stack: error.stack,
      metadata: error.metadata
    };

    navigator.clipboard.writeText(JSON.stringify(details, null, 2))
      .then(() => {
        toast.success('Error details copied to clipboard');
      })
      .catch(() => {
        toast.error('Failed to copy error details');
      });
  };

  return (
    <Dialog open={isOpen} onOpenChange={onClose}>
      <DialogContent className="max-w-2xl max-h-[80vh]">
        <DialogHeader>
          <DialogTitle className="flex items-center gap-2">
            <Bug className="h-5 w-5" />
            Error Details
          </DialogTitle>
        </DialogHeader>
        
        <ScrollArea className="max-h-[60vh]">
          <div className="space-y-4">
            {/* Error Summary */}
            <Alert>
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>
                {error.category.toUpperCase()} Error - {error.severity.toUpperCase()}
              </AlertTitle>
              <AlertDescription className="mt-2">
                {error.userMessage || error.message}
              </AlertDescription>
            </Alert>

            {/* Error Metadata */}
            <div className="grid grid-cols-2 gap-4">
              <div>
                <h4 className="font-medium text-sm mb-2">Error Information</h4>
                <div className="space-y-2 text-sm">
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">ID:</span>
                    <code className="text-xs bg-muted px-1 rounded">{error.id}</code>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Code:</span>
                    <span>{error.code || 'N/A'}</span>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Category:</span>
                    <Badge variant="outline">{error.category}</Badge>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Severity:</span>
                    <Badge variant="outline">{error.severity}</Badge>
                  </div>
                  <div className="flex justify-between">
                    <span className="text-muted-foreground">Time:</span>
                    <span className="text-xs">{formatTimestamp(error.timestamp)}</span>
                  </div>
                </div>
              </div>

              <div>
                <h4 className="font-medium text-sm mb-2">Error Flags</h4>
                <div className="space-y-2">
                  <div className="flex items-center gap-2">
                    <span className="text-muted-foreground text-sm">Actionable:</span>
                    <Badge variant={error.actionable ? "default" : "secondary"}>
                      {error.actionable ? 'Yes' : 'No'}
                    </Badge>
                  </div>
                  <div className="flex items-center gap-2">
                    <span className="text-muted-foreground text-sm">Retryable:</span>
                    <Badge variant={error.retryable ? "default" : "secondary"}>
                      {error.retryable ? 'Yes' : 'No'}
                    </Badge>
                  </div>
                </div>
              </div>
            </div>

            {/* Error Message */}
            <div>
              <h4 className="font-medium text-sm mb-2">Technical Message</h4>
              <pre className="text-xs bg-muted p-3 rounded-md overflow-auto">
                {error.message}
              </pre>
            </div>

            {/* Stack Trace */}
            {error.stack && (
              <div>
                <h4 className="font-medium text-sm mb-2">Stack Trace</h4>
                <pre className="text-xs bg-muted p-3 rounded-md overflow-auto max-h-40">
                  {error.stack}
                </pre>
              </div>
            )}

            {/* Metadata */}
            {error.metadata && (
              <div>
                <h4 className="font-medium text-sm mb-2">Additional Data</h4>
                <pre className="text-xs bg-muted p-3 rounded-md overflow-auto max-h-32">
                  {JSON.stringify(error.metadata, null, 2)}
                </pre>
              </div>
            )}
          </div>
        </ScrollArea>

        {/* Actions */}
        <div className="flex justify-between pt-4 border-t">
          <Button variant="outline" onClick={copyErrorDetails}>
            Copy Details
          </Button>
          <div className="flex gap-2">
            {error.retryable && (
              <Button variant="outline">
                <RefreshCw className="h-4 w-4 mr-2" />
                Retry Action
              </Button>
            )}
            <Button onClick={onClose}>Close</Button>
          </div>
        </div>
      </DialogContent>
    </Dialog>
  );
};

// Main global error handler component
export const GlobalErrorHandler: React.FC<GlobalErrorHandlerProps> = ({
  children,
  showToasts = true,
  showErrorDialog = true,
  maxToasts = 5,
  toastDuration = 5000
}) => {
  const [activeToasts, setActiveToasts] = useState<AppError[]>([]);
  const [selectedError, setSelectedError] = useState<AppError | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  useEffect(() => {
    if (!showToasts) return;

    // Subscribe to errors from the global error handler
    const handleNewError = (error: AppError) => {
      // Don't show toasts for low severity errors unless they're actionable
      if (error.severity === 'low' && !error.actionable) {
        return;
      }

      // Add to active toasts
      setActiveToasts(prev => {
        const newToasts = [error, ...prev].slice(0, maxToasts);
        return newToasts;
      });

      // Auto-dismiss toast after duration (except for critical errors)
      if (error.severity !== 'critical') {
        setTimeout(() => {
          setActiveToasts(prev => prev.filter(t => t.id !== error.id));
        }, toastDuration);
      }

      // Use sonner for simpler notifications for non-critical errors
      if (error.severity === 'low' || error.severity === 'medium') {
        const toastFn = error.severity === 'low' ? toast.info : toast.warning;
        toastFn(error.userMessage || error.message, {
          description: `${error.category} error`,
          duration: toastDuration,
        });
      }
    };

    // Since we can't directly subscribe to the global error handler,
    // we'll use a custom event system
    const handleGlobalError = (event: CustomEvent<AppError>) => {
      handleNewError(event.detail);
    };

    window.addEventListener('app-error', handleGlobalError as EventListener);

    return () => {
      window.removeEventListener('app-error', handleGlobalError as EventListener);
    };
  }, [showToasts, maxToasts, toastDuration]);

  const dismissToast = (errorId: string) => {
    setActiveToasts(prev => prev.filter(t => t.id !== errorId));
  };

  const viewErrorDetails = (error: AppError) => {
    setSelectedError(error);
    setIsDialogOpen(true);
  };

  const closeDialog = () => {
    setIsDialogOpen(false);
    setSelectedError(null);
  };

  return (
    <>
      {children}
      
      {/* Error Toasts */}
      {showToasts && activeToasts.length > 0 && (
        <div className="fixed top-4 right-4 z-50 space-y-2">
          {activeToasts.map(error => (
            <ErrorToast
              key={error.id}
              error={error}
              onDismiss={() => dismissToast(error.id)}
              onViewDetails={showErrorDialog ? () => viewErrorDetails(error) : undefined}
            />
          ))}
        </div>
      )}

      {/* Error Details Dialog */}
      {showErrorDialog && (
        <ErrorDetailsDialog
          error={selectedError}
          isOpen={isDialogOpen}
          onClose={closeDialog}
        />
      )}
    </>
  );
};

// HOC to wrap the entire app with error handling
export const withGlobalErrorHandler = <P extends object>(
  WrappedComponent: React.ComponentType<P>,
  config?: Omit<GlobalErrorHandlerProps, 'children'>
) => {
  const WithGlobalErrorHandlerComponent = (props: P) => (
    <GlobalErrorHandler {...config}>
      <WrappedComponent {...props} />
    </GlobalErrorHandler>
  );

  WithGlobalErrorHandlerComponent.displayName = `withGlobalErrorHandler(${
    WrappedComponent.displayName || WrappedComponent.name
  })`;

  return WithGlobalErrorHandlerComponent;
};

// Utility function to trigger error events
export const triggerErrorEvent = (error: AppError) => {
  if (typeof window !== 'undefined') {
    window.dispatchEvent(new CustomEvent('app-error', { detail: error }));
  }
};

// Enhanced error handler that also triggers events
export const handleErrorWithNotification = async (error: any, context?: any) => {
  const appError = await globalErrorHandler.handleError(error, context);
  triggerErrorEvent(appError);
  
  // Also report to Sentry
  if (typeof window !== 'undefined') {
    try {
      const { reportError } = await import('@/lib/monitoring');
      await reportError(error, {
        contexts: {
          appError: {
            id: appError.id,
            category: appError.category,
            severity: appError.severity,
            actionable: appError.actionable,
            retryable: appError.retryable,
          },
        },
        tags: {
          category: appError.category,
          severity: appError.severity,
          source: 'global_error_handler',
        },
        level: appError.severity === 'critical' ? 'fatal' : 
               appError.severity === 'high' ? 'error' :
               appError.severity === 'medium' ? 'warning' : 'info',
        extra: {
          ...context,
          userMessage: appError.userMessage,
          metadata: appError.metadata,
        },
      });
    } catch (monitoringError) {
      console.error('Failed to report error to monitoring:', monitoringError);
    }
  }
  
  return appError;
};

export default GlobalErrorHandler;
</file>

<file path="src/app/_components/common/LoadingSpinner.tsx">
import React from "react";
import { cn } from "@/lib/utils";

type SpinnerSize = "sm" | "default" | "lg" | "xl";
type SpinnerVariant = "default" | "simple" | "dots" | "pulse";

interface LoadingSpinnerProps {
  size?: SpinnerSize;
  variant?: SpinnerVariant;
  className?: string;
  text?: string;
}

const sizeClasses: Record<SpinnerSize, string> = {
  sm: "w-4 h-4",
  default: "w-8 h-8",
  lg: "w-12 h-12",
  xl: "w-16 h-16",
};

const textSizeClasses: Record<SpinnerSize, string> = {
  sm: "text-xs",
  default: "text-sm",
  lg: "text-base",
  xl: "text-lg",
};

export const LoadingSpinner = ({
  size = "default",
  variant = "default",
  className,
  text,
}: LoadingSpinnerProps) => {
  const renderSpinner = () => {
    switch (variant) {
      case "simple":
        return (
          <div
            className={cn(
              "border-t-2 border-gold rounded-full animate-spin",
              sizeClasses[size],
              className
            )}
          />
        );

      case "dots":
        return (
          <div className="flex space-x-2">
            {[0, 1, 2].map((i) => (
              <div
                key={i}
                className={cn(
                  "rounded-full bg-gold animate-pulse",
                  size === "sm" && "w-1 h-1",
                  size === "default" && "w-2 h-2",
                  size === "lg" && "w-3 h-3",
                  size === "xl" && "w-4 h-4",
                  `animation-delay-${i * 200}`
                )}
              />
            ))}
          </div>
        );

      case "pulse":
        return (
          <div className={cn("relative", sizeClasses[size])}>
            <div className="absolute inset-0 rounded-full bg-gold/20 animate-ping" />
            <div className="absolute inset-0 rounded-full bg-gold/40" />
          </div>
        );

      default:
        return (
          <div
            className={cn(
              "border-4 border-t-gold border-r-gold/30 border-b-gold/10 border-l-gold/50 rounded-full animate-spin",
              sizeClasses[size],
              className
            )}
          />
        );
    }
  };

  return (
    <div className="flex flex-col items-center justify-center gap-3">
      {renderSpinner()}
      {text && (
        <p
          className={cn(
            "text-muted-foreground font-serif",
            textSizeClasses[size]
          )}
        >
          {text}
        </p>
      )}
    </div>
  );
};

export default LoadingSpinner;
</file>

<file path="src/app/_components/common/LoadingStates.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { Loader2, FileText, Building, Users, BarChart3, Search, Sparkles } from 'lucide-react';
import { Card, CardContent, CardHeader } from '@/components/ui/card';
import { Progress } from '@/components/ui/progress';
import { Skeleton } from '@/components/ui/skeleton';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';

// Loading spinner variants
export interface LoadingSpinnerProps {
  size?: 'sm' | 'md' | 'lg' | 'xl';
  variant?: 'default' | 'dots' | 'pulse' | 'spin' | 'bounce';
  color?: 'primary' | 'secondary' | 'muted';
  className?: string;
}

export const LoadingSpinner: React.FC<LoadingSpinnerProps> = ({
  size = 'md',
  variant = 'default',
  color = 'primary',
  className
}) => {
  const sizeClasses = {
    sm: 'h-4 w-4',
    md: 'h-6 w-6',
    lg: 'h-8 w-8',
    xl: 'h-12 w-12'
  };

  const colorClasses = {
    primary: 'text-primary',
    secondary: 'text-secondary',
    muted: 'text-muted-foreground'
  };

  if (variant === 'dots') {
    return (
      <div className={cn('flex items-center space-x-1', className)}>
        {[0, 1, 2].map((i) => (
          <div
            key={i}
            className={cn(
              'rounded-full bg-current animate-pulse',
              size === 'sm' ? 'h-1 w-1' : size === 'md' ? 'h-2 w-2' : 'h-3 w-3',
              colorClasses[color]
            )}
            style={{
              animationDelay: `${i * 0.15}s`,
              animationDuration: '0.8s'
            }}
          />
        ))}
      </div>
    );
  }

  if (variant === 'pulse') {
    return (
      <div className={cn('flex items-center space-x-2', className)}>
        {[0, 1, 2, 3].map((i) => (
          <div
            key={i}
            className={cn(
              'rounded-full bg-current animate-pulse',
              size === 'sm' ? 'h-2 w-2' : size === 'md' ? 'h-3 w-3' : 'h-4 w-4',
              colorClasses[color]
            )}
            style={{
              animationDelay: `${i * 0.2}s`,
              animationDuration: '1.2s'
            }}
          />
        ))}
      </div>
    );
  }

  if (variant === 'bounce') {
    return (
      <div className={cn('flex items-end space-x-1', className)}>
        {[0, 1, 2].map((i) => (
          <div
            key={i}
            className={cn(
              'bg-current rounded-sm animate-bounce',
              size === 'sm' ? 'h-3 w-1' : size === 'md' ? 'h-4 w-1.5' : 'h-6 w-2',
              colorClasses[color]
            )}
            style={{
              animationDelay: `${i * 0.1}s`,
              animationDuration: '0.6s'
            }}
          />
        ))}
      </div>
    );
  }

  return (
    <Loader2 
      className={cn(
        'animate-spin',
        sizeClasses[size],
        colorClasses[color],
        className
      )}
    />
  );
};

// Enhanced loading state with progress
export interface LoadingWithProgressProps {
  progress?: number;
  message?: string;
  subMessage?: string;
  showPercentage?: boolean;
  variant?: 'default' | 'minimal' | 'detailed';
  className?: string;
}

export const LoadingWithProgress: React.FC<LoadingWithProgressProps> = ({
  progress = 0,
  message = 'Loading...',
  subMessage,
  showPercentage = true,
  variant = 'default',
  className
}) => {
  const [displayProgress, setDisplayProgress] = useState(0);

  useEffect(() => {
    const timer = setTimeout(() => {
      setDisplayProgress(progress);
    }, 100);
    return () => clearTimeout(timer);
  }, [progress]);

  if (variant === 'minimal') {
    return (
      <div className={cn('flex items-center gap-3', className)}>
        <LoadingSpinner size="sm" />
        <span className="text-sm text-muted-foreground">{message}</span>
        {showPercentage && progress > 0 && (
          <Badge variant="outline" className="text-xs">
            {Math.round(displayProgress)}%
          </Badge>
        )}
      </div>
    );
  }

  if (variant === 'detailed') {
    return (
      <Card className={cn('w-full max-w-md', className)}>
        <CardHeader className="pb-3">
          <div className="flex items-center gap-3">
            <LoadingSpinner />
            <div className="flex-1">
              <p className="font-medium text-sm">{message}</p>
              {subMessage && (
                <p className="text-xs text-muted-foreground mt-1">{subMessage}</p>
              )}
            </div>
            {showPercentage && progress > 0 && (
              <Badge variant="outline">
                {Math.round(displayProgress)}%
              </Badge>
            )}
          </div>
        </CardHeader>
        <CardContent className="pt-0">
          <Progress value={displayProgress} className="h-2" />
        </CardContent>
      </Card>
    );
  }

  return (
    <div className={cn('space-y-3', className)}>
      <div className="flex items-center gap-3">
        <LoadingSpinner />
        <div className="flex-1">
          <p className="text-sm font-medium">{message}</p>
          {subMessage && (
            <p className="text-xs text-muted-foreground">{subMessage}</p>
          )}
        </div>
        {showPercentage && progress > 0 && (
          <span className="text-sm text-muted-foreground">
            {Math.round(displayProgress)}%
          </span>
        )}
      </div>
      <Progress value={displayProgress} className="h-2" />
    </div>
  );
};

// Full page loading state
export interface FullPageLoadingProps {
  message?: string;
  subMessage?: string;
  showLogo?: boolean;
  variant?: 'default' | 'minimal' | 'branded';
  className?: string;
}

export const FullPageLoading: React.FC<FullPageLoadingProps> = ({
  message = 'Loading...',
  subMessage,
  showLogo = true,
  variant = 'default',
  className
}) => {
  if (variant === 'minimal') {
    return (
      <div className={cn(
        'fixed inset-0 flex items-center justify-center bg-background/80 backdrop-blur-sm z-50',
        className
      )}>
        <div className="text-center space-y-4">
          <LoadingSpinner size="xl" />
          <p className="text-lg font-medium">{message}</p>
          {subMessage && (
            <p className="text-sm text-muted-foreground">{subMessage}</p>
          )}
        </div>
      </div>
    );
  }

  if (variant === 'branded') {
    return (
      <div className={cn(
        'fixed inset-0 flex items-center justify-center bg-gradient-to-br from-background to-muted/20 z-50',
        className
      )}>
        <Card className="w-full max-w-sm">
          <CardContent className="p-8 text-center space-y-6">
            {showLogo && (
              <div className="flex justify-center">
                <div className="w-16 h-16 bg-primary rounded-xl flex items-center justify-center">
                  <FileText className="h-8 w-8 text-primary-foreground" />
                </div>
              </div>
            )}
            <div className="space-y-2">
              <LoadingSpinner size="lg" />
              <p className="text-lg font-medium">{message}</p>
              {subMessage && (
                <p className="text-sm text-muted-foreground">{subMessage}</p>
              )}
            </div>
          </CardContent>
        </Card>
      </div>
    );
  }

  return (
    <div className={cn(
      'fixed inset-0 flex items-center justify-center bg-background/95 backdrop-blur-sm z-50',
      className
    )}>
      <div className="text-center space-y-6 p-8">
        {showLogo && (
          <div className="flex justify-center">
            <div className="w-20 h-20 bg-primary/10 rounded-2xl flex items-center justify-center">
              <FileText className="h-10 w-10 text-primary" />
            </div>
          </div>
        )}
        <div className="space-y-3">
          <LoadingSpinner size="xl" />
          <p className="text-xl font-medium">{message}</p>
          {subMessage && (
            <p className="text-muted-foreground">{subMessage}</p>
          )}
        </div>
      </div>
    </div>
  );
};

// Skeleton loading states for specific components
export const ContractTableSkeleton: React.FC<{ rows?: number }> = ({ rows = 5 }) => (
  <div className="space-y-4">
    <div className="flex items-center justify-between">
      <Skeleton className="h-8 w-48" />
      <div className="flex gap-2">
        <Skeleton className="h-8 w-32" />
        <Skeleton className="h-8 w-24" />
      </div>
    </div>
    <div className="space-y-2">
      {Array.from({ length: rows }).map((_, i) => (
        <div key={i} className="flex items-center space-x-4 p-4 border rounded-lg">
          <Skeleton className="h-10 w-10 rounded" />
          <div className="flex-1 space-y-2">
            <Skeleton className="h-4 w-full max-w-sm" />
            <Skeleton className="h-3 w-3/4" />
          </div>
          <Skeleton className="h-6 w-20" />
          <Skeleton className="h-8 w-16" />
        </div>
      ))}
    </div>
  </div>
);

export const VendorTableSkeleton: React.FC<{ rows?: number }> = ({ rows = 5 }) => (
  <div className="space-y-4">
    <div className="flex items-center justify-between">
      <Skeleton className="h-8 w-32" />
      <div className="flex gap-2">
        <Skeleton className="h-8 w-40" />
        <Skeleton className="h-8 w-32" />
      </div>
    </div>
    <div className="space-y-2">
      {Array.from({ length: rows }).map((_, i) => (
        <div key={i} className="flex items-center space-x-4 p-4 border rounded-lg">
          <Skeleton className="h-12 w-12 rounded-full" />
          <div className="flex-1 space-y-2">
            <Skeleton className="h-4 w-full max-w-xs" />
            <div className="flex gap-2">
              <Skeleton className="h-3 w-16" />
              <Skeleton className="h-3 w-24" />
            </div>
          </div>
          <Skeleton className="h-6 w-16" />
          <Skeleton className="h-6 w-12" />
          <Skeleton className="h-8 w-20" />
        </div>
      ))}
    </div>
  </div>
);

export const DashboardSkeleton: React.FC = () => (
  <div className="space-y-6">
    {/* Header */}
    <div className="flex items-center justify-between">
      <div className="space-y-2">
        <Skeleton className="h-8 w-48" />
        <Skeleton className="h-4 w-72" />
      </div>
      <Skeleton className="h-10 w-32" />
    </div>

    {/* KPI Cards */}
    <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
      {Array.from({ length: 4 }).map((_, i) => (
        <Card key={i}>
          <CardContent className="p-6">
            <div className="flex items-center justify-between">
              <div className="space-y-2">
                <Skeleton className="h-4 w-24" />
                <Skeleton className="h-8 w-16" />
              </div>
              <Skeleton className="h-8 w-8 rounded" />
            </div>
          </CardContent>
        </Card>
      ))}
    </div>

    {/* Charts */}
    <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-40" />
        </CardHeader>
        <CardContent>
          <Skeleton className="h-64 w-full" />
        </CardContent>
      </Card>
      <Card>
        <CardHeader>
          <Skeleton className="h-6 w-36" />
        </CardHeader>
        <CardContent>
          <Skeleton className="h-64 w-full" />
        </CardContent>
      </Card>
    </div>
  </div>
);

// Contextual loading states
export const ContextualLoading: React.FC<{
  context: 'contracts' | 'vendors' | 'analytics' | 'search' | 'upload' | 'analysis';
  message?: string;
  size?: 'sm' | 'md' | 'lg';
  className?: string;
}> = ({ context, message, size = 'md', className }) => {
  const contextConfig = {
    contracts: {
      icon: FileText,
      defaultMessage: 'Loading contracts...',
      color: 'text-blue-600'
    },
    vendors: {
      icon: Building,
      defaultMessage: 'Loading vendors...',
      color: 'text-green-600'
    },
    analytics: {
      icon: BarChart3,
      defaultMessage: 'Generating analytics...',
      color: 'text-purple-600'
    },
    search: {
      icon: Search,
      defaultMessage: 'Searching...',
      color: 'text-orange-600'
    },
    upload: {
      icon: FileText,
      defaultMessage: 'Uploading document...',
      color: 'text-indigo-600'
    },
    analysis: {
      icon: Sparkles,
      defaultMessage: 'Analyzing document...',
      color: 'text-pink-600'
    }
  };

  const config = contextConfig[context];
  const IconComponent = config.icon;

  return (
    <div className={cn(
      'flex items-center gap-3',
      size === 'sm' ? 'py-2' : size === 'lg' ? 'py-6' : 'py-4',
      className
    )}>
      <div className="relative">
        <IconComponent className={cn(
          config.color,
          size === 'sm' ? 'h-4 w-4' : size === 'lg' ? 'h-8 w-8' : 'h-6 w-6'
        )} />
        <LoadingSpinner 
          size={size === 'sm' ? 'sm' : size === 'lg' ? 'lg' : 'md'}
          className="absolute -top-1 -right-1"
        />
      </div>
      <span className={cn(
        'text-muted-foreground',
        size === 'sm' ? 'text-sm' : size === 'lg' ? 'text-lg' : 'text-base'
      )}>
        {message || config.defaultMessage}
      </span>
    </div>
  );
};

export default LoadingSpinner;
</file>

<file path="src/app/_components/common/NotificationCenter.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { useConvexQuery, useConvexMutation } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';
import { format, formatDistanceToNow } from 'date-fns';

// UI Components
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Sheet, SheetContent, SheetHeader, SheetTitle, SheetTrigger } from "@/components/ui/sheet";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

// Icons
import {
  Bell,
  BellRing,
  Check,
  CheckCheck,
  X,
  Settings,
  FileText,
  Building,
  AlertTriangle,
  Calendar,
  CreditCard,
  Users,
  Shield,
  Zap,
  Clock,
  Eye,
  ExternalLink,
  Archive,
  Filter,
  MoreHorizontal
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface NotificationCenterProps {
  variant?: 'popover' | 'sheet' | 'inline';
  showUnreadCount?: boolean;
  maxHeight?: string;
  className?: string;
}

type NotificationWithRelations = {
  _id: Id<"notifications">;
  type: string;
  title: string;
  message: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  isRead: boolean;
  createdAt: string;
  actionUrl?: string;
  contract?: {
    _id: Id<"contracts">;
    title: string;
    status: string;
  };
  vendor?: {
    _id: Id<"vendors">;
    name: string;
    category?: string;
  };
};

// Priority colors
const priorityColors = {
  low: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300',
  medium: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/70 dark:text-yellow-300',
  high: 'bg-orange-100 text-orange-800 dark:bg-orange-900/70 dark:text-orange-300',
  critical: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300',
};

// Type icons
const typeIcons = {
  contract_expiration: Calendar,
  contract_created: FileText,
  approval_required: CheckCheck,
  payment_reminder: CreditCard,
  vendor_risk_alert: AlertTriangle,
  compliance_issue: Shield,
  task_assigned: Users,
  system_alert: Zap,
  digest: Bell,
};

export const NotificationCenter = ({
  variant = 'popover',
  showUnreadCount = true,
  maxHeight = 'max-h-96',
  className
}: NotificationCenterProps) => {
  // State
  const [isOpen, setIsOpen] = useState(false);
  const [filter, setFilter] = useState<'all' | 'unread' | 'high'>('all');
  const [selectedTab, setSelectedTab] = useState('all');

  // Queries
  const { data: notificationData, isLoading } = useConvexQuery(
    api.notifications.getMyNotifications,
    { 
      limit: 50, 
      includeRead: filter !== 'unread',
      priority: filter === 'high' ? 'high' : undefined 
    }
  );

  const { data: unreadCount } = useConvexQuery(
    api.notifications.getUnreadCount,
    {}
  );

  // Mutations
  const markAsRead = useConvexMutation(api.notifications.markAsRead);
  const markAllAsRead = useConvexMutation(api.notifications.markAllAsRead);
  const dismissNotification = useConvexMutation(api.notifications.dismissNotification);

  const notifications = notificationData?.notifications || [];
  const totalUnread = unreadCount?.total || 0;

  // Filter notifications based on selected tab
  const filteredNotifications = notifications.filter(notification => {
    switch (selectedTab) {
      case 'unread':
        return !notification.isRead;
      case 'contracts':
        return ['contract_expiration', 'contract_created'].includes(notification.type);
      case 'approvals':
        return notification.type === 'approval_required';
      case 'alerts':
        return ['vendor_risk_alert', 'compliance_issue', 'system_alert'].includes(notification.type);
      default:
        return true;
    }
  });

  // Handlers
  const handleMarkAsRead = async (notificationId: Id<"notifications">) => {
    try {
      await markAsRead({ notificationId });
    } catch (error) {
      console.error('Failed to mark notification as read:', error);
    }
  };

  const handleMarkAllAsRead = async () => {
    try {
      await markAllAsRead({});
    } catch (error) {
      console.error('Failed to mark all notifications as read:', error);
    }
  };

  const handleDismiss = async (notificationId: Id<"notifications">) => {
    try {
      await dismissNotification({ notificationId });
    } catch (error) {
      console.error('Failed to dismiss notification:', error);
    }
  };

  const handleNotificationClick = async (notification: NotificationWithRelations) => {
    // Mark as read if unread
    if (!notification.isRead) {
      await handleMarkAsRead(notification._id);
    }

    // Navigate to action URL if provided
    if (notification.actionUrl) {
      window.open(notification.actionUrl, '_blank');
    }
  };

  // Render notification item
  const renderNotificationItem = (notification: NotificationWithRelations) => {
    const IconComponent = typeIcons[notification.type as keyof typeof typeIcons] || Bell;
    const priorityColor = priorityColors[notification.priority];

    return (
      <div
        key={notification._id}
        className={cn(
          'flex items-start gap-3 p-3 rounded-lg border transition-colors cursor-pointer',
          notification.isRead 
            ? 'bg-muted/20 border-muted' 
            : 'bg-background border-border hover:bg-muted/30',
          notification.priority === 'critical' && !notification.isRead && 'ring-2 ring-red-200'
        )}
        onClick={() => handleNotificationClick(notification)}
      >
        {/* Icon and priority indicator */}
        <div className="flex-shrink-0 relative">
          <div className={cn(
            'w-8 h-8 rounded-full flex items-center justify-center',
            notification.isRead ? 'bg-muted' : priorityColor
          )}>
            <IconComponent className={cn(
              'h-4 w-4',
              notification.isRead ? 'text-muted-foreground' : 'text-current'
            )} />
          </div>
          {!notification.isRead && (
            <div className="absolute -top-1 -right-1 w-3 h-3 bg-primary rounded-full border-2 border-background" />
          )}
        </div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-2">
            <div className="flex-1 min-w-0">
              <p className={cn(
                'text-sm font-medium truncate',
                notification.isRead ? 'text-muted-foreground' : 'text-foreground'
              )}>
                {notification.title}
              </p>
              <p className={cn(
                'text-xs mt-1 line-clamp-2',
                notification.isRead ? 'text-muted-foreground/70' : 'text-muted-foreground'
              )}>
                {notification.message}
              </p>
            </div>
            
            {/* Actions */}
            <div className="flex items-center gap-1 opacity-0 group-hover:opacity-100 transition-opacity">
              {!notification.isRead && (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={(e) => {
                    e.stopPropagation();
                    handleMarkAsRead(notification._id);
                  }}
                  className="h-6 w-6 p-0"
                >
                  <Check className="h-3 w-3" />
                </Button>
              )}
              <Button
                variant="ghost"
                size="sm"
                onClick={(e) => {
                  e.stopPropagation();
                  handleDismiss(notification._id);
                }}
                className="h-6 w-6 p-0"
              >
                <X className="h-3 w-3" />
              </Button>
            </div>
          </div>

          {/* Metadata */}
          <div className="flex items-center gap-2 mt-2 text-xs text-muted-foreground">
            <Clock className="h-3 w-3" />
            <span>
              {formatDistanceToNow(new Date(notification.createdAt), { addSuffix: true })}
            </span>
            
            {notification.contract && (
              <>
                <span></span>
                <FileText className="h-3 w-3" />
                <span className="truncate max-w-24">{notification.contract.title}</span>
              </>
            )}
            
            {notification.vendor && (
              <>
                <span></span>
                <Building className="h-3 w-3" />
                <span className="truncate max-w-24">{notification.vendor.name}</span>
              </>
            )}

            {notification.priority !== 'medium' && (
              <>
                <span></span>
                <Badge variant="outline" className={cn(priorityColor, 'text-xs px-1 py-0')}>
                  {notification.priority}
                </Badge>
              </>
            )}
          </div>
        </div>
      </div>
    );
  };

  // Render content
  const renderContent = () => {
    if (isLoading) {
      return (
        <div className="flex items-center justify-center py-8">
          <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
        </div>
      );
    }

    if (filteredNotifications.length === 0) {
      return (
        <div className="text-center py-8">
          <Bell className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
          <p className="text-sm font-medium text-muted-foreground">
            {selectedTab === 'unread' ? 'No unread notifications' : 'No notifications'}
          </p>
          <p className="text-xs text-muted-foreground mt-1">
            {selectedTab === 'unread' 
              ? "You're all caught up!" 
              : 'Notifications will appear here when you have updates'}
          </p>
        </div>
      );
    }

    return (
      <div className="space-y-1">
        {filteredNotifications.map(renderNotificationItem)}
      </div>
    );
  };

  // Render trigger button
  const triggerButton = (
    <Button
      variant="ghost"
      size="sm"
      className={cn("relative", className)}
    >
      {totalUnread > 0 ? <BellRing className="h-5 w-5" /> : <Bell className="h-5 w-5" />}
      {showUnreadCount && totalUnread > 0 && (
        <Badge 
          variant="destructive" 
          className="absolute -top-2 -right-2 h-5 w-5 p-0 flex items-center justify-center text-xs"
        >
          {totalUnread > 99 ? '99+' : totalUnread}
        </Badge>
      )}
    </Button>
  );

  // Render header actions
  const headerActions = (
    <div className="flex items-center gap-2">
      {filteredNotifications.some(n => !n.isRead) && (
        <Button
          variant="ghost"
          size="sm"
          onClick={handleMarkAllAsRead}
          className="text-xs"
        >
          <CheckCheck className="h-4 w-4 mr-1" />
          Mark all read
        </Button>
      )}
      <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
        <Settings className="h-4 w-4" />
      </Button>
    </div>
  );

  // Render tabs
  const tabs = (
    <Tabs value={selectedTab} onValueChange={setSelectedTab} className="w-full">
      <TabsList className="grid w-full grid-cols-5 h-8">
        <TabsTrigger value="all" className="text-xs">All</TabsTrigger>
        <TabsTrigger value="unread" className="text-xs">
          Unread
          {totalUnread > 0 && (
            <Badge variant="secondary" className="ml-1 h-4 w-4 p-0 text-xs">
              {totalUnread}
            </Badge>
          )}
        </TabsTrigger>
        <TabsTrigger value="contracts" className="text-xs">Contracts</TabsTrigger>
        <TabsTrigger value="approvals" className="text-xs">Approvals</TabsTrigger>
        <TabsTrigger value="alerts" className="text-xs">Alerts</TabsTrigger>
      </TabsList>
      
      <TabsContent value={selectedTab} className="mt-4">
        <ScrollArea className={cn(maxHeight)}>
          {renderContent()}
        </ScrollArea>
      </TabsContent>
    </Tabs>
  );

  // Render based on variant
  switch (variant) {
    case 'sheet':
      return (
        <Sheet open={isOpen} onOpenChange={setIsOpen}>
          <SheetTrigger asChild>
            {triggerButton}
          </SheetTrigger>
          <SheetContent side="right" className="w-96">
            <SheetHeader className="flex flex-row items-center justify-between space-y-0 pb-4">
              <SheetTitle className="flex items-center gap-2">
                <Bell className="h-5 w-5" />
                Notifications
              </SheetTitle>
              {headerActions}
            </SheetHeader>
            {tabs}
          </SheetContent>
        </Sheet>
      );

    case 'inline':
      return (
        <Card className={className}>
          <CardHeader className="flex flex-row items-center justify-between space-y-0 pb-4">
            <CardTitle className="flex items-center gap-2">
              <Bell className="h-5 w-5" />
              Notifications
            </CardTitle>
            {headerActions}
          </CardHeader>
          <CardContent>
            {tabs}
          </CardContent>
        </Card>
      );

    default: // popover
      return (
        <Popover open={isOpen} onOpenChange={setIsOpen}>
          <PopoverTrigger asChild>
            {triggerButton}
          </PopoverTrigger>
          <PopoverContent className="w-96 p-0" align="end">
            <div className="flex items-center justify-between p-4 border-b">
              <h4 className="flex items-center gap-2 font-semibold">
                <Bell className="h-5 w-5" />
                Notifications
              </h4>
              {headerActions}
            </div>
            <div className="p-4">
              {tabs}
            </div>
          </PopoverContent>
        </Popover>
      );
  }
};

export default NotificationCenter;
</file>

<file path="src/app/_components/common/SectionErrorBoundary.tsx">
'use client';

import React from 'react';
import { ErrorBoundary } from './ErrorBoundary';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Button } from '@/components/ui/button';
import { AlertTriangle, RefreshCw, Home } from 'lucide-react';

interface SectionErrorBoundaryProps {
  children: React.ReactNode;
  sectionName: string;
  description?: string;
  showHomeButton?: boolean;
  onRetry?: () => void;
}

export const SectionErrorBoundary: React.FC<SectionErrorBoundaryProps> = ({
  children,
  sectionName,
  description,
  showHomeButton = true,
  onRetry,
}) => {
  const handleRetry = () => {
    if (onRetry) {
      onRetry();
    } else {
      window.location.reload();
    }
  };

  const handleGoHome = () => {
    window.location.href = '/dashboard';
  };

  return (
    <ErrorBoundary
      fallback={
        <Card className="w-full border-destructive">
          <CardHeader>
            <div className="flex items-center gap-3">
              <AlertTriangle className="h-5 w-5 text-destructive" />
              <div>
                <CardTitle className="text-destructive">
                  {sectionName} Error
                </CardTitle>
                {description && (
                  <p className="text-sm text-muted-foreground mt-1">
                    {description}
                  </p>
                )}
              </div>
            </div>
          </CardHeader>
          <CardContent>
            <Alert variant="destructive" className="mb-4">
              <AlertTriangle className="h-4 w-4" />
              <AlertTitle>Section Unavailable</AlertTitle>
              <AlertDescription>
                This section encountered an error and couldn't load properly. 
                Other parts of the application should continue to work normally.
              </AlertDescription>
            </Alert>
            
            <div className="flex gap-3">
              <Button onClick={handleRetry} size="sm">
                <RefreshCw className="h-4 w-4 mr-2" />
                Retry
              </Button>
              {showHomeButton && (
                <Button variant="outline" onClick={handleGoHome} size="sm">
                  <Home className="h-4 w-4 mr-2" />
                  Dashboard
                </Button>
              )}
            </div>
          </CardContent>
        </Card>
      }
      showErrorDetails={process.env.NODE_ENV === 'development'}
      isolate={true}
    >
      {children}
    </ErrorBoundary>
  );
};

// Pre-configured error boundaries for common sections
export const ContractsErrorBoundary: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <SectionErrorBoundary
    sectionName="Contracts"
    description="There was an issue loading contract data"
  >
    {children}
  </SectionErrorBoundary>
);

export const AnalyticsErrorBoundary: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <SectionErrorBoundary
    sectionName="Analytics"
    description="There was an issue loading analytics data"
  >
    {children}
  </SectionErrorBoundary>
);

export const VendorsErrorBoundary: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <SectionErrorBoundary
    sectionName="Vendors"
    description="There was an issue loading vendor data"
  >
    {children}
  </SectionErrorBoundary>
);

export const DashboardErrorBoundary: React.FC<{ children: React.ReactNode }> = ({ children }) => (
  <SectionErrorBoundary
    sectionName="Dashboard"
    description="There was an issue loading dashboard data"
    showHomeButton={false}
  >
    {children}
  </SectionErrorBoundary>
);

export default SectionErrorBoundary;
</file>

<file path="src/app/_components/common/ToastNotifications.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { Toaster, toast } from 'sonner';
import { 
  CheckCircle, 
  AlertCircle, 
  Info, 
  AlertTriangle, 
  X, 
  Loader2,
  ExternalLink,
  Copy,
  RefreshCw
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { cn } from '@/lib/utils';

// Enhanced toast types
export type ToastType = 'success' | 'error' | 'warning' | 'info' | 'loading' | 'promise';

export interface ToastAction {
  label: string;
  onClick: () => void;
  variant?: 'default' | 'destructive' | 'outline';
}

export interface CustomToastOptions {
  title?: string;
  description?: string;
  duration?: number;
  action?: ToastAction;
  onDismiss?: () => void;
  dismissible?: boolean;
  position?: 'top-left' | 'top-center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'bottom-right';
  className?: string;
  id?: string;
  data?: Record<string, any>;
}

export interface PromiseToastOptions {
  loading: string;
  success: string | ((data: any) => string);
  error: string | ((error: any) => string);
  duration?: {
    loading?: number;
    success?: number;
    error?: number;
  };
}

// Custom toast component for enhanced functionality
const CustomToast = ({ 
  type, 
  title, 
  description, 
  action, 
  onDismiss, 
  dismissible = true,
  className,
  data 
}: {
  type: ToastType;
  title?: string;
  description?: string;
  action?: ToastAction;
  onDismiss?: () => void;
  dismissible?: boolean;
  className?: string;
  data?: Record<string, any>;
}) => {
  const iconMap = {
    success: CheckCircle,
    error: AlertCircle,
    warning: AlertTriangle,
    info: Info,
    loading: Loader2,
    promise: Info,
  };

  const colorMap = {
    success: 'text-green-600 bg-green-50 border-green-200',
    error: 'text-red-600 bg-red-50 border-red-200',
    warning: 'text-yellow-600 bg-yellow-50 border-yellow-200',
    info: 'text-blue-600 bg-blue-50 border-blue-200',
    loading: 'text-blue-600 bg-blue-50 border-blue-200',
    promise: 'text-purple-600 bg-purple-50 border-purple-200',
  };

  const IconComponent = iconMap[type];

  return (
    <div className={cn(
      'flex items-start gap-3 p-4 border rounded-lg shadow-lg max-w-md',
      colorMap[type],
      className
    )}>
      <IconComponent 
        className={cn(
          'h-5 w-5 flex-shrink-0 mt-0.5',
          type === 'loading' && 'animate-spin'
        )} 
      />
      
      <div className="flex-1 min-w-0">
        {title && (
          <p className="font-medium text-sm mb-1">{title}</p>
        )}
        {description && (
          <p className="text-sm text-muted-foreground">{description}</p>
        )}
        
        {action && (
          <div className="mt-3">
            <Button
              size="sm"
              variant={action.variant || 'default'}
              onClick={action.onClick}
              className="h-7"
            >
              {action.label}
            </Button>
          </div>
        )}
      </div>

      {dismissible && (
        <Button
          variant="ghost"
          size="sm"
          onClick={onDismiss}
          className="h-6 w-6 p-0 opacity-70 hover:opacity-100 flex-shrink-0"
        >
          <X className="h-4 w-4" />
        </Button>
      )}
    </div>
  );
};

// Enhanced toast functions
export const showToast = {
  success: (message: string, options?: CustomToastOptions) => {
    return toast.custom(
      (t) => (
        <CustomToast
          type="success"
          title={options?.title}
          description={message}
          action={options?.action}
          onDismiss={() => toast.dismiss(t)}
          dismissible={options?.dismissible}
          className={options?.className}
          data={options?.data}
        />
      ),
      {
        duration: options?.duration || 4000,
        id: options?.id,
      }
    );
  },

  error: (message: string, options?: CustomToastOptions) => {
    return toast.custom(
      (t) => (
        <CustomToast
          type="error"
          title={options?.title || 'Error'}
          description={message}
          action={options?.action}
          onDismiss={() => toast.dismiss(t)}
          dismissible={options?.dismissible}
          className={options?.className}
          data={options?.data}
        />
      ),
      {
        duration: options?.duration || 6000,
        id: options?.id,
      }
    );
  },

  warning: (message: string, options?: CustomToastOptions) => {
    return toast.custom(
      (t) => (
        <CustomToast
          type="warning"
          title={options?.title || 'Warning'}
          description={message}
          action={options?.action}
          onDismiss={() => toast.dismiss(t)}
          dismissible={options?.dismissible}
          className={options?.className}
          data={options?.data}
        />
      ),
      {
        duration: options?.duration || 5000,
        id: options?.id,
      }
    );
  },

  info: (message: string, options?: CustomToastOptions) => {
    return toast.custom(
      (t) => (
        <CustomToast
          type="info"
          title={options?.title}
          description={message}
          action={options?.action}
          onDismiss={() => toast.dismiss(t)}
          dismissible={options?.dismissible}
          className={options?.className}
          data={options?.data}
        />
      ),
      {
        duration: options?.duration || 4000,
        id: options?.id,
      }
    );
  },

  loading: (message: string, options?: CustomToastOptions) => {
    return toast.custom(
      (t) => (
        <CustomToast
          type="loading"
          title={options?.title}
          description={message}
          onDismiss={() => toast.dismiss(t)}
          dismissible={options?.dismissible !== false}
          className={options?.className}
          data={options?.data}
        />
      ),
      {
        duration: options?.duration || Infinity,
        id: options?.id,
      }
    );
  },

  promise: <T,>(
    promise: Promise<T>,
    options: PromiseToastOptions
  ): Promise<T> => {
    return toast.promise(promise, {
      loading: options.loading,
      success: (data) => {
        return typeof options.success === 'function' 
          ? options.success(data) 
          : options.success;
      },
      error: (error) => {
        return typeof options.error === 'function' 
          ? options.error(error) 
          : options.error;
      },
    });
  },

  dismiss: (toastId?: string | number) => {
    return toast.dismiss(toastId);
  },

  dismissAll: () => {
    return toast.dismiss();
  },
};

// Specialized toast functions for common use cases
export const contractToasts = {
  created: (contractTitle: string) => {
    showToast.success('Contract created successfully', {
      title: 'Success',
      description: `"${contractTitle}" has been created and is ready for review.`,
      action: {
        label: 'View Contract',
        onClick: () => {
          // Navigate to contract details
          console.log('Navigate to contract');
        }
      }
    });
  },

  updated: (contractTitle: string) => {
    showToast.success('Contract updated', {
      description: `"${contractTitle}" has been saved.`,
    });
  },

  deleted: (contractTitle: string) => {
    showToast.info('Contract deleted', {
      description: `"${contractTitle}" has been moved to archive.`,
      action: {
        label: 'Undo',
        onClick: () => {
          // Implement undo functionality
          console.log('Undo delete');
        },
        variant: 'outline'
      }
    });
  },

  expiring: (contractTitle: string, daysLeft: number) => {
    showToast.warning('Contract expiring soon', {
      description: `"${contractTitle}" expires in ${daysLeft} days.`,
      action: {
        label: 'Review',
        onClick: () => {
          // Navigate to contract renewal
          console.log('Navigate to renewal');
        }
      },
      duration: 8000
    });
  },

  analysisComplete: (contractTitle: string) => {
    showToast.success('Analysis complete', {
      description: `AI analysis for "${contractTitle}" is ready.`,
      action: {
        label: 'View Results',
        onClick: () => {
          // Navigate to analysis results
          console.log('View analysis');
        }
      }
    });
  },

  uploadProgress: (fileName: string) => {
    return showToast.loading(`Uploading "${fileName}"...`, {
      title: 'Upload in progress',
      dismissible: false
    });
  },
};

export const vendorToasts = {
  created: (vendorName: string) => {
    showToast.success('Vendor added successfully', {
      description: `${vendorName} has been added to your vendor database.`,
    });
  },

  updated: (vendorName: string) => {
    showToast.success('Vendor updated', {
      description: `${vendorName} information has been saved.`,
    });
  },

  riskAlert: (vendorName: string, riskLevel: string) => {
    showToast.warning('Vendor risk alert', {
      description: `${vendorName} has been flagged as ${riskLevel} risk.`,
      action: {
        label: 'Review',
        onClick: () => {
          // Navigate to vendor risk assessment
          console.log('Review risk');
        }
      },
      duration: 10000
    });
  },

  complianceIssue: (vendorName: string) => {
    showToast.error('Compliance issue detected', {
      description: `${vendorName} has compliance issues that need attention.`,
      action: {
        label: 'View Details',
        onClick: () => {
          // Navigate to compliance details
          console.log('View compliance');
        }
      },
      duration: 0 // Persistent until dismissed
    });
  },
};

export const systemToasts = {
  offline: () => {
    showToast.error('Connection lost', {
      description: 'You are currently offline. Some features may not be available.',
      dismissible: false,
      id: 'offline-toast'
    });
  },

  online: () => {
    showToast.success('Connection restored', {
      description: 'You are back online.',
      id: 'online-toast'
    });
    showToast.dismiss('offline-toast');
  },

  maintenanceMode: (message: string) => {
    showToast.warning('Maintenance notice', {
      description: message,
      action: {
        label: 'Learn More',
        onClick: () => {
          window.open('/maintenance-info', '_blank');
        }
      },
      duration: 0 // Persistent
    });
  },

  sessionExpiring: (minutesLeft: number) => {
    showToast.warning('Session expiring', {
      description: `Your session will expire in ${minutesLeft} minutes.`,
      action: {
        label: 'Extend Session',
        onClick: () => {
          // Refresh session
          console.log('Extend session');
        }
      },
      duration: 30000 // 30 seconds
    });
  },

  autoSaved: () => {
    showToast.info('Draft saved', {
      description: 'Your changes have been automatically saved.',
      duration: 2000
    });
  },

  exportReady: (fileName: string, downloadUrl: string) => {
    showToast.success('Export completed', {
      description: `${fileName} is ready for download.`,
      action: {
        label: 'Download',
        onClick: () => {
          window.open(downloadUrl, '_blank');
        }
      },
      duration: 10000
    });
  },

  copyToClipboard: (text: string) => {
    navigator.clipboard.writeText(text).then(() => {
      showToast.success('Copied to clipboard', {
        duration: 2000
      });
    }).catch(() => {
      showToast.error('Failed to copy', {
        description: 'Please copy manually.',
        duration: 3000
      });
    });
  },
};

// Toast provider component
export const ToastProvider: React.FC<{
  children: React.ReactNode;
  position?: 'top-left' | 'top-center' | 'top-right' | 'bottom-left' | 'bottom-center' | 'bottom-right';
  expand?: boolean;
  richColors?: boolean;
  closeButton?: boolean;
}> = ({ 
  children, 
  position = 'top-right',
  expand = true,
  richColors = true,
  closeButton = true 
}) => {
  // Network status monitoring
  useEffect(() => {
    const handleOnline = () => systemToasts.online();
    const handleOffline = () => systemToasts.offline();

    window.addEventListener('online', handleOnline);
    window.addEventListener('offline', handleOffline);

    return () => {
      window.removeEventListener('online', handleOnline);
      window.removeEventListener('offline', handleOffline);
    };
  }, []);

  return (
    <>
      {children}
      <Toaster
        position={position}
        expand={expand}
        richColors={richColors}
        closeButton={closeButton}
        toastOptions={{
          duration: 4000,
          className: 'font-sans',
          style: {
            background: 'hsl(var(--background))',
            color: 'hsl(var(--foreground))',
            border: '1px solid hsl(var(--border))',
          },
        }}
      />
    </>
  );
};

export default ToastProvider;
</file>

<file path="src/app/_components/contracts/NewContractButton.tsx">
'use client';

import React, { useState } from 'react';

import { Button } from '@/components/ui/button';
import { PlusCircle } from 'lucide-react';
import ContractFormModal from './ContractFormModal';
import { Id } from '../../../../convex/_generated/dataModel';

interface NewContractButtonProps {
  variant?: 'default' | 'outline' | 'secondary' | 'ghost' | 'link';
  size?: 'default' | 'sm' | 'lg' | 'icon';
  buttonText?: string;
  showIcon?: boolean;
  onContractCreated?: (contractId: Id<"contracts">) => void;
  className?:string
}

export const NewContractButton: React.FC<NewContractButtonProps> = ({
  variant = 'default',
  size = 'default',
  buttonText = 'New Contract',
  showIcon = true,
  onContractCreated,
  className,
  ...props
}) => {
  const [isModalOpen, setIsModalOpen] = useState(false);

  const handleSuccess = (contractId: Id<"contracts">) => {
    if (onContractCreated) {
      onContractCreated(contractId);
    }
    setIsModalOpen(false);
  };

  return (
    <>
      <Button
        variant={variant}
        size={size}
        onClick={() => setIsModalOpen(true)}
        className={className}
        {...props}
      >
        {showIcon && <PlusCircle className="mr-2 h-4 w-4" />}
        {buttonText}
      </Button>

      <ContractFormModal
        isOpen={isModalOpen}
        onClose={() => setIsModalOpen(false)}
        onSuccess={handleSuccess}
      />
    </>
  );
};

export default NewContractButton;
</file>

<file path="src/app/_components/mobile/MobileCard.tsx">
'use client';

import React, { useState } from 'react';
import { format, formatDistanceToNow, isAfter } from 'date-fns';
import { 
  ChevronRight, 
  MoreVertical, 
  Star, 
  Share, 
  Eye, 
  Edit, 
  Trash2,
  Download,
  Archive,
  Clock,
  Calendar,
  DollarSign,
  User,
  Users,
  Building,
  FileText,
  AlertTriangle,
  CheckCircle,
  XCircle,
  Zap,
  TrendingUp,
  MapPin,
  Phone,
  Mail,
  Globe,
  Activity,
  Bookmark,
  Flag,
  MessageSquare,
  Settings
} from 'lucide-react';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Progress } from '@/components/ui/progress';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger, DropdownMenuSeparator } from '@/components/ui/dropdown-menu';
import { cn } from '@/lib/utils';

// Base card props
interface BaseCardProps {
  id: string;
  onClick?: () => void;
  onAction?: (action: string, id: string) => void;
  className?: string;
  actions?: CardAction[];
  priority?: 'low' | 'medium' | 'high' | 'urgent';
  status?: string;
  isFavorite?: boolean;
  isBookmarked?: boolean;
}

// Card action
interface CardAction {
  id: string;
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  onClick: () => void;
  variant?: 'default' | 'destructive';
}

// Contract card props
export interface ContractCardProps extends BaseCardProps {
  type: 'contract';
  title: string;
  vendor: string;
  value: number;
  startDate: Date;
  endDate: Date;
  progress?: number;
  renewalStatus?: 'auto' | 'manual' | 'expired';
  department?: string;
  assignedTo?: {
    id: string;
    name: string;
    avatar?: string;
  }[];
}

// Vendor card props
export interface VendorCardProps extends BaseCardProps {
  type: 'vendor';
  name: string;
  category: string;
  location?: string;
  contactPerson?: string;
  email?: string;
  phone?: string;
  website?: string;
  riskLevel: 'low' | 'medium' | 'high';
  complianceScore: number;
  totalSpend: number;
  activeContracts: number;
  lastActivity?: Date;
}

// Workflow card props
export interface WorkflowCardProps extends BaseCardProps {
  type: 'workflow';
  name: string;
  description?: string;
  currentStep: string;
  progress: number;
  assignedTo?: {
    id: string;
    name: string;
    avatar?: string;
  }[];
  dueDate?: Date;
  startedAt: Date;
  estimatedCompletion?: Date;
}

// User card props
export interface UserCardProps extends BaseCardProps {
  type: 'user';
  name: string;
  email: string;
  role: string;
  department: string;
  avatar?: string;
  lastActive?: Date;
  activeContracts?: number;
  pendingApprovals?: number;
}

// Document card props
export interface DocumentCardProps extends BaseCardProps {
  type: 'document';
  title: string;
  description?: string;
  fileType: string;
  size: string;
  uploadedBy: string;
  uploadedAt: Date;
  tags?: string[];
  version?: string;
}

// Union type for all card props
export type MobileCardProps = 
  | ContractCardProps 
  | VendorCardProps 
  | WorkflowCardProps 
  | UserCardProps 
  | DocumentCardProps;

// Status colors
const getStatusColor = (status: string) => {
  switch (status.toLowerCase()) {
    case 'active':
    case 'approved':
    case 'completed':
      return 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300';
    case 'pending':
    case 'review':
    case 'running':
      return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300';
    case 'expired':
    case 'rejected':
    case 'failed':
      return 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300';
    case 'draft':
    case 'inactive':
      return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
    default:
      return 'bg-blue-100 text-blue-800 dark:bg-blue-900/30 dark:text-blue-300';
  }
};

// Priority colors
const getPriorityColor = (priority: string) => {
  switch (priority) {
    case 'urgent':
      return 'bg-red-500';
    case 'high':
      return 'bg-orange-500';
    case 'medium':
      return 'bg-yellow-500';
    case 'low':
      return 'bg-blue-500';
    default:
      return 'bg-gray-500';
  }
};

// Risk level colors
const getRiskLevelColor = (riskLevel: string) => {
  switch (riskLevel) {
    case 'high':
      return 'bg-red-100 text-red-800 dark:bg-red-900/30 dark:text-red-300';
    case 'medium':
      return 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/30 dark:text-yellow-300';
    case 'low':
      return 'bg-green-100 text-green-800 dark:bg-green-900/30 dark:text-green-300';
    default:
      return 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
  }
};

// Common card actions
const getDefaultActions = (type: string): CardAction[] => {
  const baseActions: CardAction[] = [
    { id: 'view', label: 'View Details', icon: Eye, onClick: () => {} },
    { id: 'edit', label: 'Edit', icon: Edit, onClick: () => {} },
    { id: 'share', label: 'Share', icon: Share, onClick: () => {} },
  ];

  switch (type) {
    case 'contract':
      return [
        ...baseActions,
        { id: 'download', label: 'Download', icon: Download, onClick: () => {} },
        { id: 'archive', label: 'Archive', icon: Archive, onClick: () => {} },
        { id: 'delete', label: 'Delete', icon: Trash2, onClick: () => {}, variant: 'destructive' },
      ];
    case 'vendor':
      return [
        ...baseActions,
        { id: 'contact', label: 'Contact', icon: MessageSquare, onClick: () => {} },
        { id: 'archive', label: 'Archive', icon: Archive, onClick: () => {} },
      ];
    case 'workflow':
      return [
        ...baseActions,
        { id: 'pause', label: 'Pause', icon: XCircle, onClick: () => {} },
        { id: 'settings', label: 'Settings', icon: Settings, onClick: () => {} },
      ];
    default:
      return baseActions;
  }
};

// Contract card component
const ContractCard: React.FC<ContractCardProps> = (props) => {
  const {
    title,
    vendor,
    value,
    startDate,
    endDate,
    progress,
    renewalStatus,
    department,
    assignedTo,
    status,
    priority,
    isFavorite,
    onClick,
    onAction,
    actions = getDefaultActions('contract'),
    className
  } = props;

  const isExpiringSoon = endDate && isAfter(endDate, new Date()) && 
    (endDate.getTime() - new Date().getTime()) < (30 * 24 * 60 * 60 * 1000);

  return (
    <Card className={cn(
      'cursor-pointer transition-all hover:shadow-md active:scale-[0.98]',
      priority && 'border-l-4',
      priority === 'urgent' && 'border-l-red-500',
      priority === 'high' && 'border-l-orange-500',
      priority === 'medium' && 'border-l-yellow-500',
      priority === 'low' && 'border-l-blue-500',
      className
    )} onClick={onClick}>
      <CardContent className="p-4">
        {/* Header */}
        <div className="flex items-start justify-between mb-3">
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-1">
              <h3 className="font-semibold text-base line-clamp-1">{title}</h3>
              {isFavorite && <Star className="h-4 w-4 text-yellow-500 fill-current" />}
            </div>
            <p className="text-sm text-muted-foreground line-clamp-1">{vendor}</p>
          </div>
          
          <div className="flex items-center gap-1 ml-2">
            {status && (
              <Badge className={cn('text-xs', getStatusColor(status))}>
                {status}
              </Badge>
            )}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                  <MoreVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {actions.map((action, index) => (
                  <React.Fragment key={action.id}>
                    <DropdownMenuItem 
                      onClick={(e) => {
                        e.stopPropagation();
                        action.onClick();
                        onAction?.(action.id, props.id);
                      }}
                      className={action.variant === 'destructive' ? 'text-red-600' : ''}
                    >
                      <action.icon className="h-4 w-4 mr-2" />
                      {action.label}
                    </DropdownMenuItem>
                    {index === actions.length - 2 && <DropdownMenuSeparator />}
                  </React.Fragment>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>

        {/* Value and dates */}
        <div className="grid grid-cols-2 gap-4 mb-3">
          <div>
            <div className="flex items-center gap-1 text-xs text-muted-foreground mb-1">
              <DollarSign className="h-3 w-3" />
              <span>Value</span>
            </div>
            <p className="font-semibold text-lg">${value.toLocaleString()}</p>
          </div>
          
          <div>
            <div className="flex items-center gap-1 text-xs text-muted-foreground mb-1">
              <Calendar className="h-3 w-3" />
              <span>End Date</span>
            </div>
            <p className={cn(
              'text-sm font-medium',
              isExpiringSoon && 'text-orange-600'
            )}>
              {format(endDate, 'MMM dd, yyyy')}
            </p>
          </div>
        </div>

        {/* Progress */}
        {progress !== undefined && (
          <div className="mb-3">
            <div className="flex items-center justify-between text-xs text-muted-foreground mb-1">
              <span>Progress</span>
              <span>{progress}%</span>
            </div>
            <Progress value={progress} className="h-2" />
          </div>
        )}

        {/* Additional info */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            {department && (
              <Badge variant="secondary" className="text-xs">
                {department}
              </Badge>
            )}
            {renewalStatus && (
              <Badge variant="outline" className="text-xs">
                {renewalStatus} renewal
              </Badge>
            )}
          </div>
          
          {assignedTo && assignedTo.length > 0 && (
            <div className="flex items-center gap-1">
              <div className="flex -space-x-1">
                {assignedTo.slice(0, 3).map(person => (
                  <Avatar key={person.id} className="h-6 w-6 border-2 border-background">
                    <AvatarImage src={person.avatar} />
                    <AvatarFallback className="text-xs">
                      {person.name.charAt(0)}
                    </AvatarFallback>
                  </Avatar>
                ))}
                {assignedTo.length > 3 && (
                  <div className="h-6 w-6 rounded-full bg-muted border-2 border-background flex items-center justify-center">
                    <span className="text-xs">+{assignedTo.length - 3}</span>
                  </div>
                )}
              </div>
            </div>
          )}
        </div>

        {isExpiringSoon && (
          <div className="mt-3 p-2 bg-orange-50 border border-orange-200 rounded-lg flex items-center gap-2">
            <AlertTriangle className="h-4 w-4 text-orange-600" />
            <span className="text-xs text-orange-800">Expires in {formatDistanceToNow(endDate)}</span>
          </div>
        )}
      </CardContent>
    </Card>
  );
};

// Vendor card component
const VendorCard: React.FC<VendorCardProps> = (props) => {
  const {
    name,
    category,
    location,
    contactPerson,
    email,
    phone,
    riskLevel,
    complianceScore,
    totalSpend,
    activeContracts,
    lastActivity,
    status,
    onClick,
    onAction,
    actions = getDefaultActions('vendor'),
    className
  } = props;

  return (
    <Card className={cn(
      'cursor-pointer transition-all hover:shadow-md active:scale-[0.98]',
      className
    )} onClick={onClick}>
      <CardContent className="p-4">
        {/* Header */}
        <div className="flex items-start justify-between mb-3">
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-base line-clamp-1 mb-1">{name}</h3>
            <div className="flex items-center gap-2">
              <Badge variant="outline" className="text-xs">{category}</Badge>
              <Badge className={cn('text-xs', getRiskLevelColor(riskLevel))}>
                {riskLevel} risk
              </Badge>
            </div>
          </div>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {actions.map((action, index) => (
                <React.Fragment key={action.id}>
                  <DropdownMenuItem 
                    onClick={(e) => {
                      e.stopPropagation();
                      action.onClick();
                      onAction?.(action.id, props.id);
                    }}
                  >
                    <action.icon className="h-4 w-4 mr-2" />
                    {action.label}
                  </DropdownMenuItem>
                  {index === actions.length - 2 && <DropdownMenuSeparator />}
                </React.Fragment>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>

        {/* Contact info */}
        {(location || contactPerson) && (
          <div className="space-y-1 mb-3">
            {location && (
              <div className="flex items-center gap-1 text-sm text-muted-foreground">
                <MapPin className="h-3 w-3" />
                <span>{location}</span>
              </div>
            )}
            {contactPerson && (
              <div className="flex items-center gap-1 text-sm text-muted-foreground">
                <User className="h-3 w-3" />
                <span>{contactPerson}</span>
              </div>
            )}
          </div>
        )}

        {/* Metrics */}
        <div className="grid grid-cols-2 gap-4 mb-3">
          <div>
            <div className="text-xs text-muted-foreground mb-1">Total Spend</div>
            <p className="font-semibold">${totalSpend.toLocaleString()}</p>
          </div>
          
          <div>
            <div className="text-xs text-muted-foreground mb-1">Compliance</div>
            <div className="flex items-center gap-2">
              <Progress value={complianceScore} className="h-2 flex-1" />
              <span className="text-sm font-medium">{complianceScore}%</span>
            </div>
          </div>
        </div>

        {/* Footer */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2 text-sm text-muted-foreground">
            <FileText className="h-3 w-3" />
            <span>{activeContracts} active contracts</span>
          </div>
          
          {lastActivity && (
            <div className="flex items-center gap-1 text-xs text-muted-foreground">
              <Activity className="h-3 w-3" />
              <span>{formatDistanceToNow(lastActivity, { addSuffix: true })}</span>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

// Workflow card component
const WorkflowCard: React.FC<WorkflowCardProps> = (props) => {
  const {
    name,
    description,
    currentStep,
    progress,
    assignedTo,
    dueDate,
    startedAt,
    estimatedCompletion,
    status,
    onClick,
    onAction,
    actions = getDefaultActions('workflow'),
    className
  } = props;

  const isOverdue = dueDate && isAfter(new Date(), dueDate);

  return (
    <Card className={cn(
      'cursor-pointer transition-all hover:shadow-md active:scale-[0.98]',
      isOverdue && 'border-red-200 bg-red-50/50',
      className
    )} onClick={onClick}>
      <CardContent className="p-4">
        {/* Header */}
        <div className="flex items-start justify-between mb-3">
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-base line-clamp-1 mb-1">{name}</h3>
            <p className="text-sm text-muted-foreground line-clamp-2">{description}</p>
          </div>
          
          <div className="flex items-center gap-1 ml-2">
            {status && (
              <Badge className={cn('text-xs', getStatusColor(status))}>
                {status}
              </Badge>
            )}
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                  <MoreVertical className="h-4 w-4" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent align="end">
                {actions.map(action => (
                  <DropdownMenuItem 
                    key={action.id}
                    onClick={(e) => {
                      e.stopPropagation();
                      action.onClick();
                      onAction?.(action.id, props.id);
                    }}
                  >
                    <action.icon className="h-4 w-4 mr-2" />
                    {action.label}
                  </DropdownMenuItem>
                ))}
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        </div>

        {/* Current step */}
        <div className="mb-3">
          <div className="text-xs text-muted-foreground mb-1">Current Step</div>
          <p className="text-sm font-medium">{currentStep}</p>
        </div>

        {/* Progress */}
        <div className="mb-3">
          <div className="flex items-center justify-between text-xs text-muted-foreground mb-1">
            <span>Progress</span>
            <span>{progress}%</span>
          </div>
          <Progress value={progress} className="h-2" />
        </div>

        {/* Footer */}
        <div className="flex items-center justify-between">
          <div className="flex items-center gap-2">
            {assignedTo && assignedTo.length > 0 && (
              <div className="flex items-center gap-1">
                <Users className="h-3 w-3 text-muted-foreground" />
                <div className="flex -space-x-1">
                  {assignedTo.slice(0, 2).map(person => (
                    <Avatar key={person.id} className="h-5 w-5 border border-background">
                      <AvatarImage src={person.avatar} />
                      <AvatarFallback className="text-xs">
                        {person.name.charAt(0)}
                      </AvatarFallback>
                    </Avatar>
                  ))}
                </div>
              </div>
            )}
          </div>
          
          <div className="text-xs text-muted-foreground">
            {dueDate && (
              <div className={cn(
                'flex items-center gap-1',
                isOverdue && 'text-red-600'
              )}>
                <Clock className="h-3 w-3" />
                <span>
                  {isOverdue ? 'Overdue' : `Due ${formatDistanceToNow(dueDate, { addSuffix: true })}`}
                </span>
              </div>
            )}
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// User card component
const UserCard: React.FC<UserCardProps> = (props) => {
  const {
    name,
    email,
    role,
    department,
    avatar,
    lastActive,
    activeContracts,
    pendingApprovals,
    status,
    onClick,
    onAction,
    actions = getDefaultActions('user'),
    className
  } = props;

  return (
    <Card className={cn(
      'cursor-pointer transition-all hover:shadow-md active:scale-[0.98]',
      className
    )} onClick={onClick}>
      <CardContent className="p-4">
        {/* Header */}
        <div className="flex items-start gap-3 mb-3">
          <Avatar className="h-12 w-12">
            <AvatarImage src={avatar} />
            <AvatarFallback>{name.charAt(0)}</AvatarFallback>
          </Avatar>
          
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-base line-clamp-1">{name}</h3>
            <p className="text-sm text-muted-foreground line-clamp-1">{email}</p>
            <div className="flex items-center gap-2 mt-1">
              <Badge variant="outline" className="text-xs">{role}</Badge>
              <Badge variant="secondary" className="text-xs">{department}</Badge>
            </div>
          </div>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {actions.map(action => (
                <DropdownMenuItem 
                  key={action.id}
                  onClick={(e) => {
                    e.stopPropagation();
                    action.onClick();
                    onAction?.(action.id, props.id);
                  }}
                >
                  <action.icon className="h-4 w-4 mr-2" />
                  {action.label}
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>

        {/* Stats */}
        {(activeContracts !== undefined || pendingApprovals !== undefined) && (
          <div className="grid grid-cols-2 gap-4 mb-3">
            {activeContracts !== undefined && (
              <div>
                <div className="text-xs text-muted-foreground mb-1">Active Contracts</div>
                <p className="font-semibold text-lg">{activeContracts}</p>
              </div>
            )}
            
            {pendingApprovals !== undefined && (
              <div>
                <div className="text-xs text-muted-foreground mb-1">Pending Approvals</div>
                <p className="font-semibold text-lg">{pendingApprovals}</p>
              </div>
            )}
          </div>
        )}

        {/* Footer */}
        <div className="flex items-center justify-between">
          {status && (
            <Badge className={cn('text-xs', getStatusColor(status))}>
              {status}
            </Badge>
          )}
          
          {lastActive && (
            <div className="flex items-center gap-1 text-xs text-muted-foreground">
              <Activity className="h-3 w-3" />
              <span>Active {formatDistanceToNow(lastActive, { addSuffix: true })}</span>
            </div>
          )}
        </div>
      </CardContent>
    </Card>
  );
};

// Document card component
const DocumentCard: React.FC<DocumentCardProps> = (props) => {
  const {
    title,
    description,
    fileType,
    size,
    uploadedBy,
    uploadedAt,
    tags,
    version,
    onClick,
    onAction,
    actions = getDefaultActions('document'),
    className
  } = props;

  return (
    <Card className={cn(
      'cursor-pointer transition-all hover:shadow-md active:scale-[0.98]',
      className
    )} onClick={onClick}>
      <CardContent className="p-4">
        {/* Header */}
        <div className="flex items-start justify-between mb-3">
          <div className="flex-1 min-w-0">
            <h3 className="font-semibold text-base line-clamp-1 mb-1">{title}</h3>
            {description && (
              <p className="text-sm text-muted-foreground line-clamp-2">{description}</p>
            )}
          </div>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {actions.map(action => (
                <DropdownMenuItem 
                  key={action.id}
                  onClick={(e) => {
                    e.stopPropagation();
                    action.onClick();
                    onAction?.(action.id, props.id);
                  }}
                >
                  <action.icon className="h-4 w-4 mr-2" />
                  {action.label}
                </DropdownMenuItem>
              ))}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>

        {/* File info */}
        <div className="grid grid-cols-2 gap-4 mb-3">
          <div>
            <div className="text-xs text-muted-foreground mb-1">Type</div>
            <Badge variant="outline" className="text-xs">{fileType}</Badge>
          </div>
          
          <div>
            <div className="text-xs text-muted-foreground mb-1">Size</div>
            <p className="text-sm font-medium">{size}</p>
          </div>
        </div>

        {/* Tags */}
        {tags && tags.length > 0 && (
          <div className="flex flex-wrap gap-1 mb-3">
            {tags.slice(0, 3).map(tag => (
              <Badge key={tag} variant="secondary" className="text-xs">
                {tag}
              </Badge>
            ))}
            {tags.length > 3 && (
              <Badge variant="secondary" className="text-xs">
                +{tags.length - 3}
              </Badge>
            )}
          </div>
        )}

        {/* Footer */}
        <div className="flex items-center justify-between text-xs text-muted-foreground">
          <div className="flex items-center gap-1">
            <User className="h-3 w-3" />
            <span>{uploadedBy}</span>
          </div>
          
          <div className="flex items-center gap-2">
            {version && <span>v{version}</span>}
            <span>{formatDistanceToNow(uploadedAt, { addSuffix: true })}</span>
          </div>
        </div>
      </CardContent>
    </Card>
  );
};

// Main mobile card component
export const MobileCard: React.FC<MobileCardProps> = (props) => {
  switch (props.type) {
    case 'contract':
      return <ContractCard {...props} />;
    case 'vendor':
      return <VendorCard {...props} />;
    case 'workflow':
      return <WorkflowCard {...props} />;
    case 'user':
      return <UserCard {...props} />;
    case 'document':
      return <DocumentCard {...props} />;
    default:
      return null;
  }
};

export default MobileCard;
</file>

<file path="src/app/_components/mobile/MobileNavigation.tsx">
'use client';

import React, { useState, useEffect } from 'react';
import { usePathname, useRouter } from 'next/navigation';
import { 
  Home, 
  FileText, 
  Building, 
  Users, 
  BarChart3,
  Settings,
  Menu,
  X,
  Search,
  Bell,
  Plus,
  ChevronRight,
  User,
  LogOut,
  Moon,
  Sun,
  Zap,
  Calendar,
  Archive,
  Clock,
  CheckCircle,
  AlertCircle,
  Eye,
  Grid,
  List
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet';
import { Separator } from '@/components/ui/separator';
import { Switch } from '@/components/ui/switch';
import { ScrollArea } from '@/components/ui/scroll-area';
import { cn } from '@/lib/utils';
import { useUser, useClerk } from '@clerk/nextjs';

// Navigation item interface
interface NavItem {
  id: string;
  label: string;
  icon: React.ComponentType<{ className?: string }>;
  href: string;
  badge?: number;
  subItems?: NavItem[];
  isActive?: boolean;
}

// Main navigation items
const mainNavItems: NavItem[] = [
  {
    id: 'dashboard',
    label: 'Dashboard',
    icon: Home,
    href: '/dashboard'
  },
  {
    id: 'contracts',
    label: 'Contracts',
    icon: FileText,
    href: '/dashboard/contracts',
    badge: 12,
    subItems: [
      { id: 'active', label: 'Active', icon: CheckCircle, href: '/dashboard/contracts/active' },
      { id: 'drafts', label: 'Drafts', icon: Clock, href: '/dashboard/contracts/drafts' },
      { id: 'pending', label: 'Pending', icon: AlertCircle, href: '/dashboard/contracts/pending' },
      { id: 'expired', label: 'Expired', icon: Archive, href: '/dashboard/contracts/expired' },
    ]
  },
  {
    id: 'vendors',
    label: 'Vendors',
    icon: Building,
    href: '/dashboard/vendors',
    badge: 8,
    subItems: [
      { id: 'active-vendors', label: 'Active', icon: CheckCircle, href: '/dashboard/vendors/active' },
      { id: 'inactive-vendors', label: 'Inactive', icon: Archive, href: '/dashboard/vendors/inactive' },
    ]
  },
  {
    id: 'analytics',
    label: 'Analytics',
    icon: BarChart3,
    href: '/dashboard/analytics'
  },
  {
    id: 'agents',
    label: 'AI Agents',
    icon: Zap,
    href: '/dashboard/agents',
    badge: 3
  }
];

// Quick actions
const quickActions = [
  {
    id: 'new-contract',
    label: 'New Contract',
    icon: FileText,
    href: '/dashboard/contracts/new',
    color: 'bg-blue-500'
  },
  {
    id: 'search',
    label: 'Search',
    icon: Search,
    href: '/dashboard/search',
    color: 'bg-green-500'
  },
  {
    id: 'calendar',
    label: 'Calendar',
    icon: Calendar,
    href: '/dashboard/calendar',
    color: 'bg-purple-500'
  }
];

// Mobile navigation props
export interface MobileNavigationProps {
  className?: string;
}

export const MobileNavigation: React.FC<MobileNavigationProps> = ({ className }) => {
  const pathname = usePathname();
  const router = useRouter();
  const { user } = useUser();
  const { signOut } = useClerk();
  
  // State
  const [isOpen, setIsOpen] = useState(false);
  const [expandedItems, setExpandedItems] = useState<Set<string>>(new Set());
  const [isDarkMode, setIsDarkMode] = useState(false);
  const [notifications, setNotifications] = useState(5);

  // Check if item is active
  const isActiveItem = (item: NavItem): boolean => {
    if (pathname === item.href) return true;
    if (item.subItems) {
      return item.subItems.some(subItem => pathname === subItem.href);
    }
    return pathname.startsWith(item.href) && item.href !== '/dashboard';
  };

  // Toggle expanded items
  const toggleExpanded = (itemId: string) => {
    setExpandedItems(prev => {
      const next = new Set(prev);
      if (next.has(itemId)) {
        next.delete(itemId);
      } else {
        next.add(itemId);
      }
      return next;
    });
  };

  // Handle navigation
  const handleNavigation = (href: string) => {
    router.push(href);
    setIsOpen(false);
  };

  // Handle sign out
  const handleSignOut = () => {
    signOut();
    setIsOpen(false);
  };

  // Bottom tab bar for main navigation
  const BottomTabBar: React.FC = () => (
    <div className="fixed bottom-0 left-0 right-0 bg-background border-t md:hidden z-50">
      <div className="flex items-center justify-around py-2">
        {mainNavItems.slice(0, 4).map(item => {
          const IconComponent = item.icon;
          const isActive = isActiveItem(item);
          
          return (
            <button
              key={item.id}
              onClick={() => handleNavigation(item.href)}
              className={cn(
                'flex flex-col items-center gap-1 py-2 px-3 rounded-lg transition-colors relative',
                isActive 
                  ? 'text-primary bg-primary/10' 
                  : 'text-muted-foreground hover:text-foreground'
              )}
            >
              <div className="relative">
                <IconComponent className="h-5 w-5" />
                {item.badge && item.badge > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-4 w-4 p-0 text-xs flex items-center justify-center">
                    {item.badge > 99 ? '99+' : item.badge}
                  </Badge>
                )}
              </div>
              <span className="text-xs font-medium">{item.label}</span>
            </button>
          );
        })}
        
        {/* More button */}
        <Sheet open={isOpen} onOpenChange={setIsOpen}>
          <SheetTrigger asChild>
            <button className="flex flex-col items-center gap-1 py-2 px-3 rounded-lg transition-colors relative text-muted-foreground hover:text-foreground">
              <div className="relative">
                <Menu className="h-5 w-5" />
                {notifications > 0 && (
                  <Badge className="absolute -top-2 -right-2 h-4 w-4 p-0 text-xs flex items-center justify-center bg-red-500">
                    {notifications > 99 ? '99+' : notifications}
                  </Badge>
                )}
              </div>
              <span className="text-xs font-medium">More</span>
            </button>
          </SheetTrigger>
        </Sheet>
      </div>
    </div>
  );

  // Navigation item component
  const NavItemComponent: React.FC<{ item: NavItem; level?: number }> = ({ item, level = 0 }) => {
    const IconComponent = item.icon;
    const isActive = isActiveItem(item);
    const isExpanded = expandedItems.has(item.id);
    const hasSubItems = item.subItems && item.subItems.length > 0;

    return (
      <div>
        <button
          onClick={() => {
            if (hasSubItems) {
              toggleExpanded(item.id);
            } else {
              handleNavigation(item.href);
            }
          }}
          className={cn(
            'w-full flex items-center justify-between p-3 rounded-lg transition-colors text-left',
            level > 0 && 'ml-4 pl-8',
            isActive 
              ? 'bg-primary text-primary-foreground' 
              : 'hover:bg-muted'
          )}
        >
          <div className="flex items-center gap-3">
            <IconComponent className="h-5 w-5" />
            <span className="font-medium">{item.label}</span>
            {item.badge && item.badge > 0 && (
              <Badge variant={isActive ? 'secondary' : 'default'} className="text-xs">
                {item.badge > 99 ? '99+' : item.badge}
              </Badge>
            )}
          </div>
          
          {hasSubItems && (
            <ChevronRight className={cn(
              'h-4 w-4 transition-transform',
              isExpanded && 'rotate-90'
            )} />
          )}
        </button>
        
        {hasSubItems && isExpanded && (
          <div className="mt-1 space-y-1">
            {item.subItems!.map(subItem => (
              <NavItemComponent key={subItem.id} item={subItem} level={level + 1} />
            ))}
          </div>
        )}
      </div>
    );
  };

  // Full screen navigation sheet
  const NavigationSheet: React.FC = () => (
    <SheetContent side="right" className="w-full sm:w-80 p-0">
      <div className="flex flex-col h-full">
        {/* Header */}
        <div className="p-4 border-b">
          <div className="flex items-center justify-between mb-4">
            <h2 className="text-lg font-semibold">Menu</h2>
            <Button variant="ghost" size="sm" onClick={() => setIsOpen(false)}>
              <X className="h-4 w-4" />
            </Button>
          </div>
          
          {/* User info */}
          {user && (
            <div className="flex items-center gap-3 p-3 bg-muted/50 rounded-lg">
              <Avatar>
                <AvatarImage src={user.imageUrl} />
                <AvatarFallback>
                  {user.firstName?.charAt(0) || user.emailAddresses[0]?.emailAddress.charAt(0)}
                </AvatarFallback>
              </Avatar>
              <div className="flex-1 min-w-0">
                <p className="font-medium truncate">
                  {user.firstName} {user.lastName}
                </p>
                <p className="text-sm text-muted-foreground truncate">
                  {user.primaryEmailAddress?.emailAddress}
                </p>
              </div>
              <Button
                variant="ghost"
                size="sm"
                onClick={() => handleNavigation('/dashboard/profile')}
              >
                <User className="h-4 w-4" />
              </Button>
            </div>
          )}
        </div>
        
        {/* Quick actions */}
        <div className="p-4 border-b">
          <h3 className="text-sm font-medium text-muted-foreground mb-3">Quick Actions</h3>
          <div className="grid grid-cols-3 gap-2">
            {quickActions.map(action => {
              const IconComponent = action.icon;
              return (
                <button
                  key={action.id}
                  onClick={() => handleNavigation(action.href)}
                  className="flex flex-col items-center gap-2 p-3 rounded-lg hover:bg-muted transition-colors"
                >
                  <div className={cn('w-10 h-10 rounded-full flex items-center justify-center', action.color)}>
                    <IconComponent className="h-5 w-5 text-white" />
                  </div>
                  <span className="text-xs font-medium">{action.label}</span>
                </button>
              );
            })}
          </div>
        </div>
        
        {/* Navigation */}
        <ScrollArea className="flex-1 p-4">
          <div className="space-y-2">
            <h3 className="text-sm font-medium text-muted-foreground mb-3">Navigation</h3>
            {mainNavItems.map(item => (
              <NavItemComponent key={item.id} item={item} />
            ))}
          </div>
        </ScrollArea>
        
        {/* Footer */}
        <div className="p-4 border-t space-y-3">
          {/* Theme toggle */}
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-2">
              {isDarkMode ? <Moon className="h-4 w-4" /> : <Sun className="h-4 w-4" />}
              <span className="text-sm font-medium">Dark mode</span>
            </div>
            <Switch
              checked={isDarkMode}
              onCheckedChange={setIsDarkMode}
            />
          </div>
          
          <Separator />
          
          {/* Settings and logout */}
          <div className="space-y-1">
            <button
              onClick={() => handleNavigation('/dashboard/settings')}
              className="w-full flex items-center gap-3 p-2 rounded-lg hover:bg-muted transition-colors text-left"
            >
              <Settings className="h-4 w-4" />
              <span>Settings</span>
            </button>
            
            <button
              onClick={handleSignOut}
              className="w-full flex items-center gap-3 p-2 rounded-lg hover:bg-muted transition-colors text-left text-red-600"
            >
              <LogOut className="h-4 w-4" />
              <span>Sign out</span>
            </button>
          </div>
        </div>
      </div>
    </SheetContent>
  );

  return (
    <>
      {/* Bottom tab bar for mobile */}
      <BottomTabBar />
      
      {/* Navigation sheet */}
      <Sheet open={isOpen} onOpenChange={setIsOpen}>
        <NavigationSheet />
      </Sheet>
      
      {/* Spacer for bottom navigation */}
      <div className="h-16 md:h-0" />
    </>
  );
};

// Top mobile header component
export interface MobileHeaderProps {
  title?: string;
  showBack?: boolean;
  onBack?: () => void;
  actions?: React.ReactNode;
  className?: string;
}

export const MobileHeader: React.FC<MobileHeaderProps> = ({
  title,
  showBack,
  onBack,
  actions,
  className
}) => {
  const router = useRouter();
  const [notifications] = useState(5);

  const handleBack = () => {
    if (onBack) {
      onBack();
    } else {
      router.back();
    }
  };

  return (
    <div className={cn('sticky top-0 z-40 bg-background border-b md:hidden', className)}>
      <div className="flex items-center justify-between p-4">
        <div className="flex items-center gap-3">
          {showBack && (
            <Button variant="ghost" size="sm" onClick={handleBack}>
              <ChevronRight className="h-4 w-4 rotate-180" />
            </Button>
          )}
          {title && (
            <h1 className="text-lg font-semibold truncate">{title}</h1>
          )}
        </div>
        
        <div className="flex items-center gap-2">
          {actions}
          
          {/* Notifications */}
          <Button variant="ghost" size="sm" className="relative">
            <Bell className="h-4 w-4" />
            {notifications > 0 && (
              <Badge className="absolute -top-1 -right-1 h-4 w-4 p-0 text-xs flex items-center justify-center bg-red-500">
                {notifications > 99 ? '99+' : notifications}
              </Badge>
            )}
          </Button>
          
          {/* Search */}
          <Button variant="ghost" size="sm" onClick={() => router.push('/dashboard/search')}>
            <Search className="h-4 w-4" />
          </Button>
        </div>
      </div>
    </div>
  );
};

// Floating action button
export interface FloatingActionButtonProps {
  icon?: React.ComponentType<{ className?: string }>;
  onClick?: () => void;
  href?: string;
  className?: string;
}

export const FloatingActionButton: React.FC<FloatingActionButtonProps> = ({
  icon: IconComponent = Plus,
  onClick,
  href,
  className
}) => {
  const router = useRouter();

  const handleClick = () => {
    if (onClick) {
      onClick();
    } else if (href) {
      router.push(href);
    }
  };

  return (
    <Button
      onClick={handleClick}
      className={cn(
        'fixed bottom-20 right-4 h-14 w-14 rounded-full shadow-lg md:hidden z-40',
        className
      )}
    >
      <IconComponent className="h-6 w-6" />
    </Button>
  );
};

export default MobileNavigation;
</file>

<file path="src/app/_components/onboarding/AccountTypeStep.tsx">
// src/app/_components/onboarding/AccountTypeStep.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useConvexQuery, useConvexMutation } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';
import { ONBOARDING_STEPS, OnboardingStep } from '@/../convex/onboarding';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { LoadingSpinner } from '@/app/_components/common/LoadingSpinner';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, Building, Users, Mail } from 'lucide-react';
import { useRouter } from 'next/navigation';
import { Id } from '@/../convex/_generated/dataModel';

interface AccountTypeStepProps {
  userEmail?: string;
  onStepComplete: (nextStep: OnboardingStep, metadata?: any) => void;
}

const AccountTypeStep: React.FC<AccountTypeStepProps> = ({ userEmail, onStepComplete }) => {
  const router = useRouter();
  const [selectedInvitation, setSelectedInvitation] = useState<any | null>(null);
  const [error, setError] = useState<string | null>(null);
  
  const { data: domainMatch, isLoading: isLoadingDomainMatch } = useConvexQuery(
    api.onboarding.checkEmailDomain,
    userEmail ? { email: userEmail } : "skip"
  );

  const { data: pendingInvitations, isLoading: isLoadingInvitations } = useConvexQuery(
    api.onboarding.checkPendingInvitations,
    userEmail ? { email: userEmail } : "skip"
  );

  const acceptInvitationMutation = useConvexMutation(api.enterprises.acceptInvitation);
  const upsertUserMutation = useConvexMutation(api.users.upsertUser); // To link user after accepting

  const handleAcceptInvitation = async (token: string, enterpriseId: Id<"enterprises">) => {
    setError(null);
    try {
      // 1. Accept the invitation in Convex
      const acceptanceResult = await acceptInvitationMutation.execute({ token });
      if (!acceptanceResult) { // `acceptInvitation` returns userId or throws
        throw new Error(acceptInvitationMutation.error?.message || "Failed to accept invitation.");
      }
      
      // 2. Ensure Convex user is fully upserted/linked with this enterprise and role
      // `acceptInvitation` already creates/updates the user with the enterpriseId and role from invitation.
      // We might call upsertUser again just to ensure Clerk session data is synced if necessary,
      // or if `acceptInvitation` doesn't return the full user object needed for redirection.
      // For now, we assume `acceptInvitation` handles user creation/linking sufficiently.
      
      // 3. Update onboarding state locally (the manager will fetch the new state)
      // The next step after joining is usually profile setup.
      onStepComplete(ONBOARDING_STEPS.PROFILE_SETUP, { joinedEnterpriseId: enterpriseId });
      router.push('/dashboard'); // Or let OnboardingFlowManager handle next step rendering

    } catch (err: any) {
      setError(err.message || "Could not process invitation.");
    }
  };

  const isLoading = isLoadingDomainMatch || isLoadingInvitations;

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-slate-50 to-transparent p-4">
      <Card className="w-full max-w-lg shadow-xl">
        <CardHeader className="text-center">
          <CardTitle className="text-2xl font-serif text-primary">Welcome to PactWise!</CardTitle>
          <CardDescription>How would you like to get started?</CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          {error && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{error}</AlertDescription>
            </Alert>
          )}

          {isLoading && <LoadingSpinner text="Checking your options..." />}

          {!isLoading && (
            <>
              <Button 
                className="w-full py-6 text-lg" 
                onClick={() => onStepComplete(ONBOARDING_STEPS.CREATE_ENTERPRISE)}
              >
                <Building className="mr-2 h-5 w-5" /> Create New Enterprise
              </Button>

              {domainMatch && domainMatch.enterpriseId && (
                <Button 
                  variant="outline" 
                  className="w-full py-6 text-lg" 
                  onClick={() => {
                    // This flow implies `upsertUser` will handle domain-based joining
                    // by passing the matched enterpriseId if user chooses this.
                    // For simplicity, we assume `upsertUser` is smart enough or 
                    // there's a specific "Join by Domain" mutation.
                    // For now, this also moves to profile setup, assuming `upsertUser` does its job.
                    onStepComplete(ONBOARDING_STEPS.PROFILE_SETUP, { joinedEnterpriseId: domainMatch.enterpriseId });
                  }}
                >
                  <Users className="mr-2 h-5 w-5" /> Join {domainMatch.enterpriseName} (via domain)
                </Button>
              )}

              {pendingInvitations && pendingInvitations.length > 0 && (
                <div className="space-y-3 pt-4 border-t">
                  <h3 className="text-md font-semibold text-center text-muted-foreground">Your Invitations:</h3>
                  {pendingInvitations.map(inv => (
                    <Card key={inv.id} className="p-4">
                      <div className="flex justify-between items-center">
                        <div>
                          <p className="font-medium">Join <span className="text-primary">{inv.enterpriseName}</span></p>
                          <p className="text-xs text-muted-foreground">Invited by: {inv.inviterName} as {inv.role}</p>
                        </div>
                        <Button 
                          size="sm"
                          onClick={() => handleAcceptInvitation(inv.token, inv.enterpriseId)} 
                          disabled={acceptInvitationMutation.isLoading}
                        >
                          {acceptInvitationMutation.isLoading && selectedInvitation?.id === inv.id ? <LoadingSpinner size="sm" /> : "Accept"}
                        </Button>
                      </div>
                    </Card>
                  ))}
                </div>
              )}
            </>
          )}
        </CardContent>
         <CardFooter className="text-center text-xs text-muted-foreground">
           <p>If you don't see an invitation or your company's domain, please contact your administrator or create a new enterprise.</p>
        </CardFooter>
      </Card>
    </div>
  );
};

export default AccountTypeStep;
</file>

<file path="src/app/_components/onboarding/CompleteOnboardingStep.tsx">
'use client';

import React, { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle, CardFooter } from '@/components/ui/card';
import { CheckCircle, ArrowRight } from 'lucide-react';
import { useConvexMutation, useConvexAction } from '@/lib/api-client'; // Assuming useConvexAction is similar to useConvexMutation for actions
import { api } from '@/../convex/_generated/api';

const CompleteOnboardingStep: React.FC = () => {
  const router = useRouter();
  const completeOnboardingAction = useConvexAction(api.onboarding.completeOnboarding);

  useEffect(() => {
    // Call the action to finalize onboarding on the backend
    completeOnboardingAction.execute({}).catch(console.error);
  }, [completeOnboardingAction]);

  const handleGoToDashboard = () => {
    router.push('/dashboard');
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-slate-50 to-transparent p-4">
      <Card className="w-full max-w-md shadow-xl text-center">
        <CardHeader>
          <CheckCircle className="mx-auto h-16 w-16 text-green-500 mb-4" />
          <CardTitle className="text-3xl font-serif text-primary">Setup Complete!</CardTitle>
          <CardDescription className="text-lg text-muted-foreground mt-2">
            You're all set to manage your contracts with PactWise.
          </CardDescription>
        </CardHeader>
        <CardContent className="space-y-6">
          <p>
            Explore your dashboard to get started with contract analysis, vendor management, and more.
          </p>
          <Button size="lg" className="w-full" onClick={handleGoToDashboard}>
            Go to Dashboard <ArrowRight className="ml-2 h-5 w-5" />
          </Button>
        </CardContent>
         <CardFooter>
          <p className="text-xs text-muted-foreground">
            If you have any questions, check out our help center or contact support.
          </p>
        </CardFooter>
      </Card>
    </div>
  );
};

export default CompleteOnboardingStep;
</file>

<file path="src/app/_components/onboarding/CreateEnterpriseStep.tsx">
// src/app/_components/onboarding/CreateEnterpriseStep.tsx
'use client';

import React, { useState } from 'react';
import { useConvexMutation } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, Building, Loader2 } from 'lucide-react';

interface CreateEnterpriseStepProps {
  onStepComplete: () => void; // Callback to advance to the next onboarding step
}

const CreateEnterpriseStep: React.FC<CreateEnterpriseStepProps> = ({ onStepComplete }) => {
  const [enterpriseName, setEnterpriseName] = useState('');
  const [domain, setDomain] = useState(''); // Optional domain
  const [error, setError] = useState<string | null>(null);
  
  const createEnterpriseMutation = useConvexMutation(api.enterprises.createEnterpriseWithOwner);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    if (!enterpriseName.trim()) {
      setError("Enterprise name is required.");
      return;
    }

    try {
      await createEnterpriseMutation.execute({ 
        enterpriseName: enterpriseName.trim(),
        domain: domain.trim() || undefined,
      });
      onStepComplete(); // Advance to the next step in the onboarding flow
    } catch (err: any) {
      setError(err.message || 'Failed to create enterprise.');
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-slate-50 to-transparent p-4">
      <Card className="w-full max-w-md shadow-xl">
        <CardHeader className="text-center">
          <Building className="mx-auto h-12 w-12 text-gold mb-4" />
          <CardTitle className="text-2xl font-serif text-primary">Create Your Enterprise</CardTitle>
          <CardDescription>Let's set up your company's workspace in PactWise.</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-6">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            <div className="space-y-2">
              <Label htmlFor="enterpriseName">Enterprise Name <span className="text-destructive">*</span></Label>
              <Input
                id="enterpriseName"
                value={enterpriseName}
                onChange={(e) => setEnterpriseName(e.target.value)}
                placeholder="e.g., Acme Corporation"
                required
              />
            </div>
            <div className="space-y-2">
              <Label htmlFor="domain">Company Domain (Optional)</Label>
              <Input
                id="domain"
                value={domain}
                onChange={(e) => setDomain(e.target.value)}
                placeholder="e.g., acme.com"
              />
              <p className="text-xs text-muted-foreground">
                If provided, users with this email domain might be able to join automatically.
              </p>
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={createEnterpriseMutation.isLoading}>
              {createEnterpriseMutation.isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Create Enterprise
            </Button>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
};

export default CreateEnterpriseStep;
</file>

<file path="src/app/_components/onboarding/EnterpriseConfigStep.tsx">
// src/app/_components/onboarding/EnterpriseConfigStep.tsx
'use client';

import React, { useState } from 'react';
import { useConvexMutation } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, Briefcase, Users, BarChart, Loader2 } from 'lucide-react';

interface EnterpriseConfigStepProps {
  onStepComplete: () => void;
}

const companySizes = ["1-10", "11-50", "51-200", "201-500", "501-1000", "1000+"] as const;
const contractVolumes = ["low", "medium", "high", "enterprise"] as const;

const EnterpriseConfigStep: React.FC<EnterpriseConfigStepProps> = ({ onStepComplete }) => {
  const [industry, setIndustry] = useState('');
  const [size, setSize] = useState<typeof companySizes[number] | ''>('');
  const [contractVolume, setContractVolume] = useState<typeof contractVolumes[number] | ''>('');
  // primaryUseCase can be a multi-select or comma-separated input; simplified here
  const [primaryUseCase, setPrimaryUseCase] = useState(''); 
  const [error, setError] = useState<string | null>(null);

  const completeConfigMutation = useConvexMutation(api.onboarding.completeEnterpriseConfig);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    if (!industry.trim() || !size) {
      setError("Industry and company size are required.");
      return;
    }

    try {
      await completeConfigMutation.execute({
        industry: industry.trim(),
        size: size as typeof companySizes[number], // Ensure type safety
        contractVolume: contractVolume || undefined, // Optional
        primaryUseCase: primaryUseCase.split(',').map(s => s.trim()).filter(s => s) || undefined, // Optional
      });
      onStepComplete();
    } catch (err: any) {
      setError(err.message || 'Failed to save enterprise configuration.');
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-slate-50 to-transparent p-4">
      <Card className="w-full max-w-lg shadow-xl">
        <CardHeader className="text-center">
          <Briefcase className="mx-auto h-12 w-12 text-gold mb-4" />
          <CardTitle className="text-2xl font-serif text-primary">Configure Your Enterprise</CardTitle>
          <CardDescription>Help us tailor PactWise to your company's needs.</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            <div className="space-y-1.5">
              <Label htmlFor="industry">Industry <span className="text-destructive">*</span></Label>
              <Input id="industry" value={industry} onChange={(e) => setIndustry(e.target.value)} placeholder="e.g., Technology, Healthcare, Finance" required />
            </div>
            <div className="space-y-1.5">
              <Label htmlFor="size">Company Size <span className="text-destructive">*</span></Label>
              <Select value={size} onValueChange={(value) => setSize(value as typeof companySizes[number])} required>
                <SelectTrigger id="size"><SelectValue placeholder="Select company size..." /></SelectTrigger>
                <SelectContent>
                  {companySizes.map(s => <SelectItem key={s} value={s}>{s} employees</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
             <div className="space-y-1.5">
              <Label htmlFor="contractVolume">Typical Contract Volume (Optional)</Label>
              <Select value={contractVolume} onValueChange={(value) => setContractVolume(value as typeof contractVolumes[number])}>
                <SelectTrigger id="contractVolume"><SelectValue placeholder="Select contract volume..." /></SelectTrigger>
                <SelectContent>
                  {contractVolumes.map(v => <SelectItem key={v} value={v}>{v.charAt(0).toUpperCase() + v.slice(1)}</SelectItem>)}
                </SelectContent>
              </Select>
            </div>
             <div className="space-y-1.5">
              <Label htmlFor="primaryUseCase">Primary Use Cases (Optional, comma-separated)</Label>
              <Input id="primaryUseCase" value={primaryUseCase} onChange={(e) => setPrimaryUseCase(e.target.value)} placeholder="e.g., Vendor Management, Sales Contracts" />
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={completeConfigMutation.isLoading}>
              {completeConfigMutation.isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Save Configuration & Continue
            </Button>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
};

export default EnterpriseConfigStep;
</file>

<file path="src/app/_components/onboarding/FirstContractStep.tsx">
'use client';

import React, { useState } from 'react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { FilePlus2, SkipForward, CheckCircle } from 'lucide-react';
import ContractFormModal from '@/app/_components/contracts/ContractFormModal'; // Re-use the existing modal
import { Id } from '@/../convex/_generated/dataModel';
import { ONBOARDING_STEPS, OnboardingStep } from '@/../convex/onboarding';
import { useConvexMutation } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';

interface FirstContractStepProps {
  onStepComplete: (nextStep?: OnboardingStep, metadata?: any) => void;
  onSkip: (nextStep?: OnboardingStep) => void;
}

const FirstContractStep: React.FC<FirstContractStepProps> = ({ onStepComplete, onSkip }) => {
  const [isModalOpen, setIsModalOpen] = useState(false);
  const updateStepMutation = useConvexMutation(api.onboarding.updateOnboardingStep);

  const handleContractCreated = async (contractId: Id<"contracts">) => {
    setIsModalOpen(false);
    // Mark this step as completed in the backend
    await updateStepMutation.execute({ step: ONBOARDING_STEPS.FIRST_CONTRACT, completed: true, metadata: { firstContractId: contractId } });
    onStepComplete(ONBOARDING_STEPS.COMPLETE); // Proceed to the final onboarding step or dashboard
  };

  const handleSkip = async () => {
     await updateStepMutation.execute({ step: ONBOARDING_STEPS.FIRST_CONTRACT, completed: false, metadata: { skipped: true } });
    onSkip(ONBOARDING_STEPS.COMPLETE); // Skip to the final step
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-slate-50 to-transparent p-4">
      <Card className="w-full max-w-lg shadow-xl text-center">
        <CardHeader>
          <FilePlus2 className="mx-auto h-12 w-12 text-gold mb-4" />
          <CardTitle className="text-2xl font-serif text-primary">Create Your First Contract</CardTitle>
          <CardDescription>
            Ready to dive in? Add your first contract to see PactWise in action.
            You can also skip this for now.
          </CardDescription>
        </CardHeader>
        <CardContent className="flex flex-col items-center space-y-6">
          <p className="text-muted-foreground">
            Click the button below to open the contract creation form.
          </p>
          <Button size="lg" onClick={() => setIsModalOpen(true)}>
            <FilePlus2 className="mr-2 h-5 w-5" /> Add First Contract
          </Button>
        </CardContent>
        <CardFooter className="flex flex-col sm:flex-row justify-center gap-3 pt-6">
          <Button variant="ghost" onClick={handleSkip} className="w-full sm:w-auto">
            <SkipForward className="mr-2 h-4 w-4" /> Skip This Step
          </Button>
        </CardFooter>
      </Card>

      {isModalOpen && (
        <ContractFormModal
          isOpen={isModalOpen}
          onClose={() => setIsModalOpen(false)}
          onSuccess={handleContractCreated}
        />
      )}
    </div>
  );
};

export default FirstContractStep;
</file>

<file path="src/app/_components/onboarding/InviteTeamStep.tsx">
// src/app/_components/onboarding/InviteTeamStep.tsx
'use client';

import React, { useState } from 'react';
import { useConvexMutation } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, Loader2, Send, UserPlus, SkipForward, Trash2 } from 'lucide-react';
import { userRoleOptions } from '@/../convex/schema'; 
import type { UserRole } from '@/../convex/schema';
import { ONBOARDING_STEPS, OnboardingStep } from '@/../convex/onboarding';

interface InviteTeamStepProps {
  onStepComplete: (nextStep?: OnboardingStep, metadata?: any) => void;
  onSkip: (nextStep?: OnboardingStep) => void;
}

interface Invitation {
  email: string;
  role: UserRole;
}

const InviteTeamStep: React.FC<InviteTeamStepProps> = ({ onStepComplete, onSkip }) => {
  const [invitations, setInvitations] = useState<Invitation[]>([{ email: '', role: 'user' }]);
  const [error, setError] = useState<string | null>(null);
  const [successMessage, setSuccessMessage] = useState<string | null>(null);
  
  const createInvitationMutation = useConvexMutation(api.enterprises.createInvitation);

  const handleInputChange = (index: number, field: keyof Invitation, value: string) => {
    const newInvitations = [...invitations];
    if (field === 'role') {
      newInvitations[index][field] = value as UserRole;
    } else {
      newInvitations[index][field] = value;
    }
    setInvitations(newInvitations);
  };

  const addInvitationField = () => {
    setInvitations([...invitations, { email: '', role: 'user' }]);
  };

  const removeInvitationField = (index: number) => {
    const newInvitations = invitations.filter((_, i) => i !== index);
    setInvitations(newInvitations);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    setSuccessMessage(null);

    const validInvitations = invitations.filter(inv => inv.email.trim() !== '');
    if (validInvitations.length === 0) {
      setError("Please enter at least one email address to invite.");
      return;
    }

    let allSuccessful = true;
    const sentEmails: string[] = [];

    for (const inv of validInvitations) {
      try {
        await createInvitationMutation.execute({ email: inv.email, role: inv.role });
        sentEmails.push(inv.email);
      } catch (err: any) {
        setError(`Failed to send invitation to ${inv.email}: ${err.message}`);
        allSuccessful = false;
        // Optionally break or collect all errors
      }
    }

    if (allSuccessful && sentEmails.length > 0) {
      setSuccessMessage(`Successfully sent ${sentEmails.length} invitation(s).`);
      // Clear fields after successful submission
      setInvitations([{ email: '', role: 'user' }]);
      // Wait a bit for the user to see the success message before proceeding
      setTimeout(() => {
        onStepComplete(ONBOARDING_STEPS.COMPLETE); 
      }, 2000);
    } else if (sentEmails.length > 0) {
       setSuccessMessage(`Sent ${sentEmails.length} invitation(s) with some errors.`);
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-slate-50 to-transparent p-4">
      <Card className="w-full max-w-lg shadow-xl">
        <CardHeader className="text-center">
          <UserPlus className="mx-auto h-12 w-12 text-gold mb-4" />
          <CardTitle className="text-2xl font-serif text-primary">Invite Your Team</CardTitle>
          <CardDescription>Add team members to collaborate in PactWise. You can always do this later.</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4 max-h-[60vh] overflow-y-auto pr-2">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            {successMessage && (
              <Alert variant="default"> {/* Changed to default for success */}
                <AlertCircle className="h-4 w-4" /> {/* Consider CheckCircle for success */}
                <AlertTitle>Success</AlertTitle>
                <AlertDescription>{successMessage}</AlertDescription>
              </Alert>
            )}

            {invitations.map((inv, index) => (
              <div key={index} className="space-y-3 p-3 border rounded-md bg-card">
                <div className="flex items-end space-x-2">
                  <div className="flex-grow space-y-1.5">
                    <Label htmlFor={`email-${index}`}>Email Address</Label>
                    <Input
                      id={`email-${index}`}
                      type="email"
                      value={inv.email}
                      onChange={(e) => handleInputChange(index, 'email', e.target.value)}
                      placeholder="teammate@example.com"
                    />
                  </div>
                  <div className="space-y-1.5 w-1/3">
                    <Label htmlFor={`role-${index}`}>Role</Label>
                    <Select
                      value={inv.role}
                      onValueChange={(value) => handleInputChange(index, 'role', value)}
                    >
                      <SelectTrigger id={`role-${index}`}>
                        <SelectValue placeholder="Select role" />
                      </SelectTrigger>
                      <SelectContent>
                        {userRoleOptions.map(role => (
                          <SelectItem key={role} value={role}>
                            {role.charAt(0).toUpperCase() + role.slice(1)}
                          </SelectItem>
                        ))}
                      </SelectContent>
                    </Select>
                  </div>
                  {invitations.length > 1 && (
                    <Button
                      type="button"
                      variant="ghost"
                      size="icon"
                      onClick={() => removeInvitationField(index)}
                      className="text-destructive hover:bg-destructive/10"
                    >
                      <Trash2 className="h-4 w-4" />
                    </Button>
                  )}
                </div>
              </div>
            ))}
            
            <Button type="button" variant="outline" onClick={addInvitationField} className="w-full">
              <UserPlus className="mr-2 h-4 w-4" /> Add Another Teammate
            </Button>
          </CardContent>
          <CardFooter className="flex flex-col sm:flex-row justify-between gap-3 pt-6">
            <Button type="button" variant="ghost" onClick={() => onSkip(ONBOARDING_STEPS.COMPLETE)} className="w-full sm:w-auto">
              <SkipForward className="mr-2 h-4 w-4" /> Skip for Now
            </Button>
            <Button type="submit" className="w-full sm:w-auto" disabled={createInvitationMutation.isLoading}>
              {createInvitationMutation.isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              <Send className="mr-2 h-4 w-4" /> Send Invitations
            </Button>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
};

export default InviteTeamStep;
</file>

<file path="src/app/_components/onboarding/OnboardingFlowManager.tsx">
'use client';

import React, { useEffect } from 'react';
import { useConvexQuery, useConvexMutation } from '@/lib/api-client';
import { api } from "@/../convex/_generated/api"
import { ONBOARDING_STEPS, OnboardingStep } from '@/../convex/onboarding';
import { useUser } from '@clerk/nextjs';
import { useRouter } from 'next/navigation';

import AccountTypeStep from './AccountTypeStep';
import CreateEnterpriseStep from './CreateEnterpriseStep';
import ProfileSetupStep from './ProfileSetupStep';
import EnterpriseConfigStep from './EnterpriseConfigStep';
import InviteTeamStep from './InviteTeamStep'; 
import FirstContractStep from './FirstContractStep'; 
import CompleteOnboardingStep from './CompleteOnboardingStep'; 

import { LoadingSpinner } from '@/app/_components/common/LoadingSpinner';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle } from 'lucide-react';

const OnboardingFlowManager = () => {
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();
  const router = useRouter();

  // Ensure upsertUser is called when Clerk user is loaded and doesn't have a Convex user yet,
  // or to update lastLoginAt. This might be handled in a global layout or on specific page loads.
  // For this component, we assume `upsertUser` has been or will be called.
  const upsertUserMutation = useConvexMutation(api.users.upsertUser);

  useEffect(() => {
    if (isClerkLoaded && clerkUser) {
      // Call upsertUser to ensure Convex user record exists or is updated.
      // This is important before fetching onboarding status.
      upsertUserMutation.execute({}).catch(console.error);
    }
  }, [isClerkLoaded, clerkUser, upsertUserMutation]);


  const { data: onboardingStatus, isLoading: isLoadingOnboarding, error: onboardingError } = useConvexQuery(
    api.onboarding.getOnboardingStatus,
    isClerkLoaded && clerkUser ? {} : "skip" // Skip if Clerk user isn't loaded
  );

  const updateStepMutation = useConvexMutation(api.onboarding.updateOnboardingStep);

  const handleStepCompletion = async (nextStep?: OnboardingStep, metadata?: any) => {
    if (onboardingStatus?.currentStep) {
      await updateStepMutation.execute({
        step: onboardingStatus.currentStep,
        completed: true,
        metadata: metadata || {},
      });
      if (nextStep) {
        // This might cause a re-fetch of onboardingStatus, which will update currentStep
      }
    }
  };

  const advanceToStep = async (step: OnboardingStep, metadata?: any) => {
    await updateStepMutation.execute({
      step: step,
      completed: false, // Mark the new step as current, not necessarily completed yet
      metadata: metadata || {},
    });
    // The UI should re-render based on the new onboardingStatus.currentStep
  };


  if (!isClerkLoaded || isLoadingOnboarding) {
    return (
      <div className="flex flex-col items-center justify-center min-h-screen p-4">
        <LoadingSpinner text="Loading onboarding status..." size="lg" />
      </div>
    );
  }

  if (!clerkUser) {
    // This case should ideally be handled by Clerk's <SignedIn> or redirects.
    // If reached, means Clerk is loaded but user is not signed in.
    router.push('/auth/sign-in'); // Or your main sign-in page
    return <LoadingSpinner text="Redirecting to sign in..." />;
  }
  
  if (onboardingError) {
    return (
       <div className="container mx-auto py-10 px-4">
         <Alert variant="destructive">
           <AlertCircle className="h-4 w-4" />
           <AlertTitle>Error Loading Onboarding</AlertTitle>
           <AlertDescription>{onboardingError.message}</AlertDescription>
         </Alert>
       </div>
    );
  }

  if (!onboardingStatus) {
     return (
      <div className="flex flex-col items-center justify-center min-h-screen p-4">
        <LoadingSpinner text="Initializing onboarding..." size="lg" />
      </div>
    );
  }

  if (onboardingStatus.isOnboarded) {
    // User is fully onboarded, redirect to dashboard if not already there.
    // This component might not even be rendered if they are correctly redirected.
    if (typeof window !== 'undefined' && window.location.pathname !== '/dashboard') {
        router.push('/dashboard');
        return <LoadingSpinner text="Redirecting to dashboard..." />;
    }
    return null; // Or a "Welcome Back" message if on a dedicated onboarding page
  }

  // Render the current step
  switch (onboardingStatus.currentStep) {
    case ONBOARDING_STEPS.ACCOUNT_TYPE:
      return <AccountTypeStep userEmail={clerkUser.primaryEmailAddress?.emailAddress} onStepComplete={advanceToStep} />;
    case ONBOARDING_STEPS.CREATE_ENTERPRISE:
      return <CreateEnterpriseStep onStepComplete={() => advanceToStep(ONBOARDING_STEPS.PROFILE_SETUP)} />;
    // JOIN_ENTERPRISE is often handled by invitation link or within AccountTypeStep logic
    case ONBOARDING_STEPS.PROFILE_SETUP:
      return <ProfileSetupStep onStepComplete={() => {
        const nextStep = (clerkUser.publicMetadata?.role === 'owner' || clerkUser.publicMetadata?.role === 'admin')
                         ? ONBOARDING_STEPS.ENTERPRISE_CONFIG
                         : ONBOARDING_STEPS.INVITE_TEAM; // Or COMPLETE if invite is optional
        advanceToStep(nextStep);
      }} />;
    case ONBOARDING_STEPS.ENTERPRISE_CONFIG:
      return <EnterpriseConfigStep onStepComplete={() => advanceToStep(ONBOARDING_STEPS.INVITE_TEAM)} />; // Next could be INVITE_TEAM or FIRST_CONTRACT or COMPLETE
    case ONBOARDING_STEPS.INVITE_TEAM:
       return <InviteTeamStep onStepComplete={() => advanceToStep(ONBOARDING_STEPS.COMPLETE)} onSkip={() => advanceToStep(ONBOARDING_STEPS.COMPLETE)} />;
    case ONBOARDING_STEPS.FIRST_CONTRACT:
       return <FirstContractStep onStepComplete={() => advanceToStep(ONBOARDING_STEPS.COMPLETE)} onSkip={() => advanceToStep(ONBOARDING_STEPS.COMPLETE)} />;
    case ONBOARDING_STEPS.COMPLETE:
      // This step might show a summary or trigger final actions
      return <CompleteOnboardingStep />;
    default:
      return (
        <div className="container mx-auto py-10 px-4">
          <Alert variant="destructive">
            <AlertCircle className="h-4 w-4" />
            <AlertTitle>Unknown Onboarding Step</AlertTitle>
            <AlertDescription>
              Current step: {onboardingStatus.currentStep}. Please contact support.
            </AlertDescription>
          </Alert>
        </div>
      );
  }
};

export default OnboardingFlowManager;
</file>

<file path="src/app/_components/onboarding/ProfileSetupStep.tsx">
// src/app/_components/onboarding/ProfileSetupStep.tsx
'use client';

import React, { useState, useEffect } from 'react';
import { useConvexMutation, useConvexQuery } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, User, Loader2 } from 'lucide-react';
import { useUser } from '@clerk/nextjs';

interface ProfileSetupStepProps {
  onStepComplete: () => void;
}

const ProfileSetupStep: React.FC<ProfileSetupStepProps> = ({ onStepComplete }) => {
  const { user: clerkUser } = useUser();
  const [firstName, setFirstName] = useState('');
  const [lastName, setLastName] = useState('');
  const [phoneNumber, setPhoneNumber] = useState('');
  const [department, setDepartment] = useState('');
  const [title, setTitle] = useState('');
  const [error, setError] = useState<string | null>(null);

  const completeProfileMutation = useConvexMutation(api.onboarding.completeProfileSetup);
  
  // Pre-fill from Clerk if available
  useEffect(() => {
    if (clerkUser) {
      setFirstName(clerkUser.firstName || '');
      setLastName(clerkUser.lastName || '');
      // Clerk might not have these other fields readily, or they are custom attributes
    }
  }, [clerkUser]);

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null);
    if (!firstName.trim() || !lastName.trim()) {
      setError("First name and last name are required.");
      return;
    }

    try {
      await completeProfileMutation.execute({
        firstName: firstName.trim(),
        lastName: lastName.trim(),
        phoneNumber: phoneNumber.trim() || undefined,
        department: department.trim() || undefined,
        title: title.trim() || undefined,
      });
      onStepComplete();
    } catch (err: any) {
      setError(err.message || 'Failed to save profile.');
    }
  };

  return (
    <div className="min-h-screen flex flex-col items-center justify-center bg-gradient-to-b from-slate-50 to-transparent p-4">
      <Card className="w-full max-w-lg shadow-xl">
        <CardHeader className="text-center">
          <User className="mx-auto h-12 w-12 text-gold mb-4" />
          <CardTitle className="text-2xl font-serif text-primary">Complete Your Profile</CardTitle>
          <CardDescription>Tell us a bit more about yourself.</CardDescription>
        </CardHeader>
        <form onSubmit={handleSubmit}>
          <CardContent className="space-y-4">
            {error && (
              <Alert variant="destructive">
                <AlertCircle className="h-4 w-4" />
                <AlertTitle>Error</AlertTitle>
                <AlertDescription>{error}</AlertDescription>
              </Alert>
            )}
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-1.5">
                <Label htmlFor="firstName">First Name <span className="text-destructive">*</span></Label>
                <Input id="firstName" value={firstName} onChange={(e) => setFirstName(e.target.value)} required />
              </div>
              <div className="space-y-1.5">
                <Label htmlFor="lastName">Last Name <span className="text-destructive">*</span></Label>
                <Input id="lastName" value={lastName} onChange={(e) => setLastName(e.target.value)} required />
              </div>
            </div>
            <div className="space-y-1.5">
              <Label htmlFor="phoneNumber">Phone Number (Optional)</Label>
              <Input id="phoneNumber" type="tel" value={phoneNumber} onChange={(e) => setPhoneNumber(e.target.value)} />
            </div>
            <div className="space-y-1.5">
              <Label htmlFor="title">Job Title (Optional)</Label>
              <Input id="title" value={title} onChange={(e) => setTitle(e.target.value)} placeholder="e.g., Contract Manager" />
            </div>
            <div className="space-y-1.5">
              <Label htmlFor="department">Department (Optional)</Label>
              <Input id="department" value={department} onChange={(e) => setDepartment(e.target.value)} placeholder="e.g., Legal, Sales" />
            </div>
          </CardContent>
          <CardFooter>
            <Button type="submit" className="w-full" disabled={completeProfileMutation.isLoading}>
              {completeProfileMutation.isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              Save Profile & Continue
            </Button>
          </CardFooter>
        </form>
      </Card>
    </div>
  );
};

export default ProfileSetupStep;
</file>

<file path="src/app/_components/search/AdvancedFilters.tsx">
'use client';

import React, { useState, useCallback, useEffect } from 'react';
import { format, subDays, subMonths, subYears } from 'date-fns';
import { 
  Filter, 
  X, 
  Calendar, 
  Tag, 
  User, 
  Building, 
  DollarSign, 
  Clock,
  Save,
  RefreshCw,
  Star,
  Plus,
  Trash2,
  ChevronDown,
  ChevronRight,
  Search,
  Settings
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Checkbox } from '@/components/ui/checkbox';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Slider } from '@/components/ui/slider';
import { Calendar as CalendarComponent } from '@/components/ui/calendar';
import { Popover, PopoverContent, PopoverTrigger } from '@/components/ui/popover';
import { Collapsible, CollapsibleContent, CollapsibleTrigger } from '@/components/ui/collapsible';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Textarea } from '@/components/ui/textarea';
import { cn } from '@/lib/utils';

// Filter value types
export type FilterValue = string | string[] | number | Date | boolean | { min: number; max: number } | { start: Date; end: Date };

// Filter field definition
export interface FilterField {
  id: string;
  label: string;
  type: 'text' | 'select' | 'multiselect' | 'checkbox' | 'radio' | 'date' | 'daterange' | 'number' | 'numberrange' | 'slider';
  category: string;
  options?: { value: string; label: string; count?: number }[];
  placeholder?: string;
  min?: number;
  max?: number;
  step?: number;
  defaultValue?: FilterValue;
  required?: boolean;
  description?: string;
}

// Active filter
export interface ActiveFilter {
  fieldId: string;
  value: FilterValue;
  operator?: 'equals' | 'contains' | 'gt' | 'lt' | 'between' | 'in' | 'not_in';
  label?: string;
}

// Saved filter
export interface SavedFilter {
  id: string;
  name: string;
  description?: string;
  filters: ActiveFilter[];
  isGlobal?: boolean;
  createdAt: Date;
  usageCount?: number;
}

// Quick filter presets
export interface QuickFilter {
  id: string;
  label: string;
  icon?: React.ComponentType<{ className?: string }>;
  filters: ActiveFilter[];
  category?: string;
}

// Advanced filters props
export interface AdvancedFiltersProps {
  fields: FilterField[];
  activeFilters: ActiveFilter[];
  onFiltersChange: (filters: ActiveFilter[]) => void;
  onSaveFilter?: (name: string, description?: string) => void;
  savedFilters?: SavedFilter[];
  onLoadFilter?: (filterId: string) => void;
  onDeleteSavedFilter?: (filterId: string) => void;
  quickFilters?: QuickFilter[];
  variant?: 'sidebar' | 'modal' | 'inline';
  showQuickFilters?: boolean;
  showSavedFilters?: boolean;
  className?: string;
}

// Predefined filter fields for contracts and vendors
export const contractFilterFields: FilterField[] = [
  {
    id: 'status',
    label: 'Status',
    type: 'multiselect',
    category: 'General',
    options: [
      { value: 'draft', label: 'Draft', count: 12 },
      { value: 'active', label: 'Active', count: 45 },
      { value: 'expired', label: 'Expired', count: 8 },
      { value: 'terminated', label: 'Terminated', count: 3 }
    ]
  },
  {
    id: 'contractType',
    label: 'Contract Type',
    type: 'multiselect',
    category: 'General',
    options: [
      { value: 'nda', label: 'NDA', count: 15 },
      { value: 'msa', label: 'MSA', count: 8 },
      { value: 'saas', label: 'SaaS', count: 22 },
      { value: 'lease', label: 'Lease', count: 5 }
    ]
  },
  {
    id: 'vendor',
    label: 'Vendor',
    type: 'select',
    category: 'Relationships',
    options: [
      { value: 'vendor1', label: 'Microsoft Corporation' },
      { value: 'vendor2', label: 'Google LLC' },
      { value: 'vendor3', label: 'Amazon Web Services' }
    ]
  },
  {
    id: 'value',
    label: 'Contract Value',
    type: 'numberrange',
    category: 'Financial',
    min: 0,
    max: 1000000,
    step: 1000
  },
  {
    id: 'createdDate',
    label: 'Created Date',
    type: 'daterange',
    category: 'Timeline'
  },
  {
    id: 'endDate',
    label: 'End Date',
    type: 'daterange',
    category: 'Timeline'
  },
  {
    id: 'analysisStatus',
    label: 'Analysis Complete',
    type: 'checkbox',
    category: 'Analysis'
  }
];

export const vendorFilterFields: FilterField[] = [
  {
    id: 'status',
    label: 'Status',
    type: 'multiselect',
    category: 'General',
    options: [
      { value: 'active', label: 'Active', count: 28 },
      { value: 'inactive', label: 'Inactive', count: 12 },
      { value: 'pending', label: 'Pending', count: 5 }
    ]
  },
  {
    id: 'category',
    label: 'Category',
    type: 'multiselect',
    category: 'General',
    options: [
      { value: 'technology', label: 'Technology', count: 15 },
      { value: 'marketing', label: 'Marketing', count: 8 },
      { value: 'legal', label: 'Legal', count: 4 },
      { value: 'finance', label: 'Finance', count: 6 }
    ]
  },
  {
    id: 'riskLevel',
    label: 'Risk Level',
    type: 'radio',
    category: 'Risk',
    options: [
      { value: 'low', label: 'Low Risk' },
      { value: 'medium', label: 'Medium Risk' },
      { value: 'high', label: 'High Risk' }
    ]
  },
  {
    id: 'complianceScore',
    label: 'Compliance Score',
    type: 'slider',
    category: 'Performance',
    min: 0,
    max: 100,
    step: 5
  },
  {
    id: 'totalSpend',
    label: 'Total Spend',
    type: 'numberrange',
    category: 'Financial',
    min: 0,
    max: 500000,
    step: 5000
  }
];

// Quick filters for common use cases
export const contractQuickFilters: QuickFilter[] = [
  {
    id: 'expiring_soon',
    label: 'Expiring Soon',
    icon: Clock,
    filters: [
      {
        fieldId: 'endDate',
        value: { start: new Date(), end: subDays(new Date(), -30) },
        operator: 'between'
      }
    ]
  },
  {
    id: 'high_value',
    label: 'High Value',
    icon: DollarSign,
    filters: [
      {
        fieldId: 'value',
        value: 100000,
        operator: 'gt'
      }
    ]
  },
  {
    id: 'pending_analysis',
    label: 'Pending Analysis',
    icon: Search,
    filters: [
      {
        fieldId: 'analysisStatus',
        value: false,
        operator: 'equals'
      }
    ]
  }
];

export const AdvancedFilters: React.FC<AdvancedFiltersProps> = ({
  fields,
  activeFilters,
  onFiltersChange,
  onSaveFilter,
  savedFilters = [],
  onLoadFilter,
  onDeleteSavedFilter,
  quickFilters = [],
  variant = 'sidebar',
  showQuickFilters = true,
  showSavedFilters = true,
  className
}) => {
  // State
  const [isOpen, setIsOpen] = useState(false);
  const [expandedCategories, setExpandedCategories] = useState<Set<string>>(new Set(['General']));
  const [saveFilterDialogOpen, setSaveFilterDialogOpen] = useState(false);
  const [filterName, setFilterName] = useState('');
  const [filterDescription, setFilterDescription] = useState('');

  // Group fields by category
  const fieldsByCategory = fields.reduce((acc, field) => {
    if (!acc[field.category]) {
      acc[field.category] = [];
    }
    acc[field.category].push(field);
    return acc;
  }, {} as Record<string, FilterField[]>);

  // Get active filter for a field
  const getActiveFilter = useCallback((fieldId: string) => {
    return activeFilters.find(filter => filter.fieldId === fieldId);
  }, [activeFilters]);

  // Update filter value
  const updateFilter = useCallback((fieldId: string, value: FilterValue, operator?: string) => {
    const newFilters = activeFilters.filter(filter => filter.fieldId !== fieldId);
    
    if (value !== undefined && value !== null && value !== '' && 
        !(Array.isArray(value) && value.length === 0)) {
      const field = fields.find(f => f.id === fieldId);
      newFilters.push({
        fieldId,
        value,
        operator: operator as any,
        label: field?.label
      });
    }

    onFiltersChange(newFilters);
  }, [activeFilters, fields, onFiltersChange]);

  // Remove filter
  const removeFilter = useCallback((fieldId: string) => {
    const newFilters = activeFilters.filter(filter => filter.fieldId !== fieldId);
    onFiltersChange(newFilters);
  }, [activeFilters, onFiltersChange]);

  // Clear all filters
  const clearAllFilters = useCallback(() => {
    onFiltersChange([]);
  }, [onFiltersChange]);

  // Apply quick filter
  const applyQuickFilter = useCallback((quickFilter: QuickFilter) => {
    onFiltersChange(quickFilter.filters);
  }, [onFiltersChange]);

  // Toggle category expansion
  const toggleCategory = useCallback((category: string) => {
    setExpandedCategories(prev => {
      const next = new Set(prev);
      if (next.has(category)) {
        next.delete(category);
      } else {
        next.add(category);
      }
      return next;
    });
  }, []);

  // Save current filters
  const handleSaveFilter = useCallback(() => {
    if (onSaveFilter && filterName.trim()) {
      onSaveFilter(filterName.trim(), filterDescription.trim() || undefined);
      setSaveFilterDialogOpen(false);
      setFilterName('');
      setFilterDescription('');
    }
  }, [onSaveFilter, filterName, filterDescription]);

  // Render filter field
  const renderFilterField = useCallback((field: FilterField) => {
    const activeFilter = getActiveFilter(field.id);
    const value = activeFilter?.value;

    switch (field.type) {
      case 'text':
        return (
          <Input
            value={(value as string) || ''}
            onChange={(e) => updateFilter(field.id, e.target.value)}
            placeholder={field.placeholder}
          />
        );

      case 'select':
        return (
          <Select
            value={(value as string) || ''}
            onValueChange={(val) => updateFilter(field.id, val)}
          >
            <SelectTrigger>
              <SelectValue placeholder={field.placeholder || 'Select...'} />
            </SelectTrigger>
            <SelectContent>
              {field.options?.map(option => (
                <SelectItem key={option.value} value={option.value}>
                  <div className="flex items-center justify-between w-full">
                    <span>{option.label}</span>
                    {option.count && (
                      <Badge variant="secondary" className="ml-2 text-xs">
                        {option.count}
                      </Badge>
                    )}
                  </div>
                </SelectItem>
              ))}
            </SelectContent>
          </Select>
        );

      case 'multiselect':
        const selectedValues = (value as string[]) || [];
        return (
          <div className="space-y-2">
            {field.options?.map(option => (
              <div key={option.value} className="flex items-center space-x-2">
                <Checkbox
                  checked={selectedValues.includes(option.value)}
                  onCheckedChange={(checked) => {
                    const newValues = checked
                      ? [...selectedValues, option.value]
                      : selectedValues.filter(v => v !== option.value);
                    updateFilter(field.id, newValues);
                  }}
                />
                <Label className="text-sm flex items-center gap-2">
                  {option.label}
                  {option.count && (
                    <Badge variant="outline" className="text-xs">
                      {option.count}
                    </Badge>
                  )}
                </Label>
              </div>
            ))}
          </div>
        );

      case 'radio':
        return (
          <RadioGroup
            value={(value as string) || ''}
            onValueChange={(val) => updateFilter(field.id, val)}
          >
            {field.options?.map(option => (
              <div key={option.value} className="flex items-center space-x-2">
                <RadioGroupItem value={option.value} />
                <Label className="text-sm">{option.label}</Label>
              </div>
            ))}
          </RadioGroup>
        );

      case 'checkbox':
        return (
          <div className="flex items-center space-x-2">
            <Checkbox
              checked={(value as boolean) || false}
              onCheckedChange={(checked) => updateFilter(field.id, checked)}
            />
            <Label className="text-sm">{field.description || 'Enable'}</Label>
          </div>
        );

      case 'date':
        return (
          <Popover>
            <PopoverTrigger asChild>
              <Button variant="outline" className="w-full justify-start text-left">
                <Calendar className="mr-2 h-4 w-4" />
                {value ? format(value as Date, 'PPP') : 'Pick a date'}
              </Button>
            </PopoverTrigger>
            <PopoverContent className="w-auto p-0">
              <CalendarComponent
                mode="single"
                selected={value as Date}
                onSelect={(date) => updateFilter(field.id, date)}
                initialFocus
              />
            </PopoverContent>
          </Popover>
        );

      case 'daterange':
        const dateRange = value as { start: Date; end: Date } || {};
        return (
          <div className="space-y-2">
            <div className="grid grid-cols-2 gap-2">
              <Popover>
                <PopoverTrigger asChild>
                  <Button variant="outline" size="sm">
                    <Calendar className="mr-2 h-4 w-4" />
                    {dateRange.start ? format(dateRange.start, 'MMM dd') : 'Start'}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <CalendarComponent
                    mode="single"
                    selected={dateRange.start}
                    onSelect={(date) => updateFilter(field.id, { ...dateRange, start: date! })}
                    initialFocus
                  />
                </PopoverContent>
              </Popover>

              <Popover>
                <PopoverTrigger asChild>
                  <Button variant="outline" size="sm">
                    <Calendar className="mr-2 h-4 w-4" />
                    {dateRange.end ? format(dateRange.end, 'MMM dd') : 'End'}
                  </Button>
                </PopoverTrigger>
                <PopoverContent className="w-auto p-0">
                  <CalendarComponent
                    mode="single"
                    selected={dateRange.end}
                    onSelect={(date) => updateFilter(field.id, { ...dateRange, end: date! })}
                    initialFocus
                  />
                </PopoverContent>
              </Popover>
            </div>
          </div>
        );

      case 'number':
        return (
          <Input
            type="number"
            value={(value as number) || ''}
            onChange={(e) => updateFilter(field.id, parseInt(e.target.value) || 0)}
            min={field.min}
            max={field.max}
            step={field.step}
          />
        );

      case 'numberrange':
        const numberRange = value as { min: number; max: number } || { min: field.min || 0, max: field.max || 100 };
        return (
          <div className="space-y-2">
            <div className="grid grid-cols-2 gap-2">
              <Input
                type="number"
                placeholder="Min"
                value={numberRange.min || ''}
                onChange={(e) => updateFilter(field.id, { ...numberRange, min: parseInt(e.target.value) || 0 })}
                min={field.min}
                max={field.max}
              />
              <Input
                type="number"
                placeholder="Max"
                value={numberRange.max || ''}
                onChange={(e) => updateFilter(field.id, { ...numberRange, max: parseInt(e.target.value) || 0 })}
                min={field.min}
                max={field.max}
              />
            </div>
          </div>
        );

      case 'slider':
        return (
          <div className="space-y-2">
            <Slider
              value={[value as number || field.min || 0]}
              onValueChange={(vals) => updateFilter(field.id, vals[0])}
              min={field.min}
              max={field.max}
              step={field.step}
            />
            <div className="flex justify-between text-xs text-muted-foreground">
              <span>{field.min}</span>
              <span className="font-medium">{value || field.min}</span>
              <span>{field.max}</span>
            </div>
          </div>
        );

      default:
        return null;
    }
  }, [getActiveFilter, updateFilter]);

  // Active filters summary
  const activeFiltersCount = activeFilters.length;

  // Filter content
  const filterContent = (
    <div className="space-y-6">
      {/* Quick filters */}
      {showQuickFilters && quickFilters.length > 0 && (
        <div>
          <h4 className="font-medium text-sm mb-3">Quick Filters</h4>
          <div className="grid grid-cols-1 gap-2">
            {quickFilters.map(quickFilter => {
              const IconComponent = quickFilter.icon;
              return (
                <Button
                  key={quickFilter.id}
                  variant="outline"
                  size="sm"
                  onClick={() => applyQuickFilter(quickFilter)}
                  className="justify-start"
                >
                  {IconComponent && <IconComponent className="h-4 w-4 mr-2" />}
                  {quickFilter.label}
                </Button>
              );
            })}
          </div>
        </div>
      )}

      {/* Saved filters */}
      {showSavedFilters && savedFilters.length > 0 && (
        <div>
          <h4 className="font-medium text-sm mb-3">Saved Filters</h4>
          <div className="space-y-2">
            {savedFilters.map(savedFilter => (
              <div
                key={savedFilter.id}
                className="flex items-center justify-between p-2 border rounded hover:bg-muted/50"
              >
                <div className="flex-1 cursor-pointer" onClick={() => onLoadFilter?.(savedFilter.id)}>
                  <p className="font-medium text-sm">{savedFilter.name}</p>
                  {savedFilter.description && (
                    <p className="text-xs text-muted-foreground">{savedFilter.description}</p>
                  )}
                </div>
                {onDeleteSavedFilter && (
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => onDeleteSavedFilter(savedFilter.id)}
                    className="h-6 w-6 p-0"
                  >
                    <Trash2 className="h-3 w-3" />
                  </Button>
                )}
              </div>
            ))}
          </div>
        </div>
      )}

      {/* Filter fields by category */}
      {Object.entries(fieldsByCategory).map(([category, categoryFields]) => (
        <Collapsible
          key={category}
          open={expandedCategories.has(category)}
          onOpenChange={() => toggleCategory(category)}
        >
          <CollapsibleTrigger className="flex items-center justify-between w-full p-2 hover:bg-muted/50 rounded">
            <h4 className="font-medium text-sm">{category}</h4>
            {expandedCategories.has(category) ? 
              <ChevronDown className="h-4 w-4" /> : 
              <ChevronRight className="h-4 w-4" />
            }
          </CollapsibleTrigger>
          <CollapsibleContent className="space-y-4 mt-2">
            {categoryFields.map(field => (
              <div key={field.id} className="space-y-2">
                <div className="flex items-center justify-between">
                  <Label className="text-sm">{field.label}</Label>
                  {getActiveFilter(field.id) && (
                    <Button
                      variant="ghost"
                      size="sm"
                      onClick={() => removeFilter(field.id)}
                      className="h-6 w-6 p-0"
                    >
                      <X className="h-3 w-3" />
                    </Button>
                  )}
                </div>
                {renderFilterField(field)}
              </div>
            ))}
          </CollapsibleContent>
        </Collapsible>
      ))}

      {/* Actions */}
      <div className="space-y-2 pt-4 border-t">
        {activeFiltersCount > 0 && (
          <Button variant="outline" onClick={clearAllFilters} className="w-full">
            <RefreshCw className="h-4 w-4 mr-2" />
            Clear All ({activeFiltersCount})
          </Button>
        )}

        {onSaveFilter && activeFiltersCount > 0 && (
          <Dialog open={saveFilterDialogOpen} onOpenChange={setSaveFilterDialogOpen}>
            <DialogTrigger asChild>
              <Button variant="outline" className="w-full">
                <Save className="h-4 w-4 mr-2" />
                Save Filter
              </Button>
            </DialogTrigger>
            <DialogContent>
              <DialogHeader>
                <DialogTitle>Save Filter</DialogTitle>
              </DialogHeader>
              <div className="space-y-4">
                <div>
                  <Label htmlFor="filterName">Filter Name</Label>
                  <Input
                    id="filterName"
                    value={filterName}
                    onChange={(e) => setFilterName(e.target.value)}
                    placeholder="Enter filter name..."
                  />
                </div>
                <div>
                  <Label htmlFor="filterDescription">Description (optional)</Label>
                  <Textarea
                    id="filterDescription"
                    value={filterDescription}
                    onChange={(e) => setFilterDescription(e.target.value)}
                    placeholder="Describe what this filter is for..."
                  />
                </div>
                <div className="flex justify-end gap-2">
                  <Button variant="outline" onClick={() => setSaveFilterDialogOpen(false)}>
                    Cancel
                  </Button>
                  <Button onClick={handleSaveFilter} disabled={!filterName.trim()}>
                    Save Filter
                  </Button>
                </div>
              </div>
            </DialogContent>
          </Dialog>
        )}
      </div>
    </div>
  );

  // Modal variant
  if (variant === 'modal') {
    return (
      <>
        <Button variant="outline" onClick={() => setIsOpen(true)} className={className}>
          <Filter className="h-4 w-4 mr-2" />
          Filters
          {activeFiltersCount > 0 && (
            <Badge className="ml-2" variant="secondary">
              {activeFiltersCount}
            </Badge>
          )}
        </Button>

        <Dialog open={isOpen} onOpenChange={setIsOpen}>
          <DialogContent className="max-w-2xl max-h-[80vh] overflow-y-auto">
            <DialogHeader>
              <DialogTitle>Advanced Filters</DialogTitle>
            </DialogHeader>
            {filterContent}
          </DialogContent>
        </Dialog>
      </>
    );
  }

  // Inline variant
  if (variant === 'inline') {
    return (
      <Card className={className}>
        <CardHeader>
          <CardTitle className="text-base flex items-center gap-2">
            <Filter className="h-4 w-4" />
            Filters
            {activeFiltersCount > 0 && (
              <Badge variant="secondary">
                {activeFiltersCount}
              </Badge>
            )}
          </CardTitle>
        </CardHeader>
        <CardContent>
          {filterContent}
        </CardContent>
      </Card>
    );
  }

  // Sidebar variant (default)
  return (
    <div className={cn('w-64 border-r bg-background', className)}>
      <div className="p-4">
        <div className="flex items-center justify-between mb-4">
          <h3 className="font-semibold flex items-center gap-2">
            <Filter className="h-4 w-4" />
            Filters
          </h3>
          {activeFiltersCount > 0 && (
            <Badge variant="secondary">
              {activeFiltersCount}
            </Badge>
          )}
        </div>
        {filterContent}
      </div>
    </div>
  );
};

export default AdvancedFilters;
</file>

<file path="src/app/_components/search/GlobalSearch.tsx">
'use client';

import React, { useState, useEffect, useCallback, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { 
  Search, 
  X, 
  Clock, 
  FileText, 
  Building, 
  Users, 
  TrendingUp,
  Filter,
  ArrowRight,
  Star,
  History,
  Sparkles,
  Loader2,
  Command
} from 'lucide-react';
import { Input } from '@/components/ui/input';
import { Button } from '@/components/ui/button';
import { Card, CardContent } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Separator } from '@/components/ui/separator';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { Command as CommandPrimitive, CommandEmpty, CommandGroup, CommandInput, CommandItem, CommandList } from '@/components/ui/command';
import { cn } from '@/lib/utils';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { useUser } from '@clerk/nextjs';
import { Id } from '../../../../convex/_generated/dataModel';

// Search result types
export interface SearchResult {
  id: string;
  type: 'contract' | 'vendor' | 'user' | 'workflow' | 'document';
  title: string;
  description?: string;
  metadata?: Record<string, any>;
  score: number; // relevance score
  url?: string;
  entityId?: string;
  timestamp?: Date;
  status?: string;
  category?: string;
}

// Search suggestions
export interface SearchSuggestion {
  id: string;
  query: string;
  type: 'recent' | 'popular' | 'suggested';
  count?: number;
}

// Search filters
export interface SearchFilters {
  types: string[];
  dateRange?: {
    start: Date;
    end: Date;
  };
  status?: string[];
  category?: string[];
  assignedTo?: string[];
}

// Global search props
export interface GlobalSearchProps {
  variant?: 'commandBar' | 'overlay' | 'inline';
  placeholder?: string;
  showSuggestions?: boolean;
  showRecentSearches?: boolean;
  maxResults?: number;
  onResultSelect?: (result: SearchResult) => void;
  onSearch?: (query: string, filters?: SearchFilters) => void;
  className?: string;
}

// Mock search data for demonstration
const mockSearchResults: SearchResult[] = [
  {
    id: '1',
    type: 'contract',
    title: 'Microsoft Enterprise License Agreement',
    description: 'Annual software licensing contract for Microsoft 365 Enterprise',
    score: 0.95,
    status: 'active',
    category: 'software',
    timestamp: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
    url: '/dashboard/contracts/1'
  },
  {
    id: '2',
    type: 'vendor',
    title: 'TechCorp Solutions Inc.',
    description: 'IT services and software development vendor',
    score: 0.87,
    status: 'active',
    category: 'technology',
    timestamp: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),
    url: '/dashboard/vendors/2'
  },
  {
    id: '3',
    type: 'contract',
    title: 'Office Lease Agreement - Downtown Building',
    description: 'Commercial lease for main office space',
    score: 0.76,
    status: 'active',
    category: 'real_estate',
    timestamp: new Date(Date.now() - 10 * 24 * 60 * 60 * 1000),
    url: '/dashboard/contracts/3'
  }
];

const mockSuggestions: SearchSuggestion[] = [
  { id: '1', query: 'microsoft license', type: 'recent' },
  { id: '2', query: 'active contracts', type: 'popular', count: 45 },
  { id: '3', query: 'vendor performance', type: 'suggested' },
  { id: '4', query: 'expiring soon', type: 'popular', count: 23 }
];

// Debounce hook
const useDebounce = (value: string, delay: number) => {
  const [debouncedValue, setDebouncedValue] = useState(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
};

// Main global search component
export const GlobalSearch: React.FC<GlobalSearchProps> = ({
  variant = 'commandBar',
  placeholder = 'Search contracts, vendors, documents...',
  showSuggestions = true,
  showRecentSearches = true,
  maxResults = 10,
  onResultSelect,
  onSearch,
  className
}) => {
  const router = useRouter();
  const { user } = useUser();
  
  // State
  const [isOpen, setIsOpen] = useState(false);
  const [query, setQuery] = useState('');
  const [isSearching, setIsSearching] = useState(false);
  const [results, setResults] = useState<SearchResult[]>([]);
  const [suggestions, setSuggestions] = useState<SearchSuggestion[]>(mockSuggestions);
  const [recentSearches, setRecentSearches] = useState<string[]>([]);
  const [selectedIndex, setSelectedIndex] = useState(-1);

  // Debounced query for API calls
  const debouncedQuery = useDebounce(query, 300);

  // Enterprise ID from user metadata
  const enterpriseId = user?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Search function
  const performSearch = useCallback(async (searchQuery: string) => {
    if (!searchQuery.trim() || !enterpriseId) {
      setResults([]);
      return;
    }

    setIsSearching(true);

    try {
      // In a real implementation, this would call your search API
      // For now, we'll filter mock data
      const filteredResults = mockSearchResults
        .filter(result => 
          result.title.toLowerCase().includes(searchQuery.toLowerCase()) ||
          result.description?.toLowerCase().includes(searchQuery.toLowerCase())
        )
        .slice(0, maxResults)
        .sort((a, b) => b.score - a.score);

      setResults(filteredResults);
      
      // Add to recent searches
      if (searchQuery.length > 2) {
        setRecentSearches(prev => {
          const updated = [searchQuery, ...prev.filter(s => s !== searchQuery)].slice(0, 5);
          localStorage.setItem('pactwise-recent-searches', JSON.stringify(updated));
          return updated;
        });
      }

      onSearch?.(searchQuery);
    } catch (error) {
      console.error('Search failed:', error);
      setResults([]);
    } finally {
      setIsSearching(false);
    }
  }, [enterpriseId, maxResults, onSearch]);

  // Effect to perform search when debounced query changes
  useEffect(() => {
    performSearch(debouncedQuery);
  }, [debouncedQuery, performSearch]);

  // Load recent searches from localStorage
  useEffect(() => {
    try {
      const saved = localStorage.getItem('pactwise-recent-searches');
      if (saved) {
        setRecentSearches(JSON.parse(saved));
      }
    } catch (error) {
      console.error('Failed to load recent searches:', error);
    }
  }, []);

  // Handle result selection
  const handleResultSelect = useCallback((result: SearchResult) => {
    if (onResultSelect) {
      onResultSelect(result);
    } else if (result.url) {
      router.push(result.url);
    }
    setIsOpen(false);
    setQuery('');
  }, [onResultSelect, router]);

  // Handle suggestion click
  const handleSuggestionClick = useCallback((suggestion: SearchSuggestion) => {
    setQuery(suggestion.query);
    performSearch(suggestion.query);
  }, [performSearch]);

  // Keyboard navigation
  const handleKeyDown = useCallback((e: React.KeyboardEvent) => {
    if (!isOpen) return;

    switch (e.key) {
      case 'ArrowDown':
        e.preventDefault();
        setSelectedIndex(prev => 
          prev < results.length - 1 ? prev + 1 : prev
        );
        break;
      case 'ArrowUp':
        e.preventDefault();
        setSelectedIndex(prev => prev > 0 ? prev - 1 : -1);
        break;
      case 'Enter':
        e.preventDefault();
        if (selectedIndex >= 0 && results[selectedIndex]) {
          handleResultSelect(results[selectedIndex]);
        }
        break;
      case 'Escape':
        setIsOpen(false);
        setQuery('');
        setSelectedIndex(-1);
        break;
    }
  }, [isOpen, results, selectedIndex, handleResultSelect]);

  // Global keyboard shortcut (Cmd/Ctrl + K)
  useEffect(() => {
    const handleGlobalKeyDown = (e: KeyboardEvent) => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
        e.preventDefault();
        setIsOpen(true);
      }
    };

    window.addEventListener('keydown', handleGlobalKeyDown);
    return () => window.removeEventListener('keydown', handleGlobalKeyDown);
  }, []);

  // Get result icon
  const getResultIcon = (type: string) => {
    switch (type) {
      case 'contract':
        return FileText;
      case 'vendor':
        return Building;
      case 'user':
        return Users;
      case 'workflow':
        return TrendingUp;
      default:
        return FileText;
    }
  };

  // Result item component
  const SearchResultItem: React.FC<{ 
    result: SearchResult; 
    isSelected: boolean;
    onClick: () => void;
  }> = ({ result, isSelected, onClick }) => {
    const IconComponent = getResultIcon(result.type);

    return (
      <div
        className={cn(
          'flex items-center gap-3 p-3 rounded-lg cursor-pointer transition-colors',
          isSelected ? 'bg-muted' : 'hover:bg-muted/50'
        )}
        onClick={onClick}
      >
        <div className="flex-shrink-0">
          <div className="w-8 h-8 rounded bg-primary/10 flex items-center justify-center">
            <IconComponent className="h-4 w-4 text-primary" />
          </div>
        </div>

        <div className="flex-1 min-w-0">
          <div className="flex items-center gap-2 mb-1">
            <p className="font-medium text-sm truncate">{result.title}</p>
            <Badge variant="outline" className="text-xs">
              {result.type}
            </Badge>
            {result.status && (
              <Badge variant="secondary" className="text-xs">
                {result.status}
              </Badge>
            )}
          </div>
          {result.description && (
            <p className="text-xs text-muted-foreground line-clamp-1">
              {result.description}
            </p>
          )}
        </div>

        <ArrowRight className="h-4 w-4 text-muted-foreground flex-shrink-0" />
      </div>
    );
  };

  // Command bar variant
  if (variant === 'commandBar') {
    return (
      <>
        <Button
          variant="outline"
          onClick={() => setIsOpen(true)}
          className={cn(
            'w-full max-w-md justify-start text-muted-foreground',
            className
          )}
        >
          <Search className="h-4 w-4 mr-2" />
          {placeholder}
          <kbd className="ml-auto pointer-events-none inline-flex h-5 select-none items-center gap-1 rounded border bg-muted px-1.5 font-mono text-[10px] font-medium text-muted-foreground opacity-100">
            <span className="text-xs"></span>K
          </kbd>
        </Button>

        <Dialog open={isOpen} onOpenChange={setIsOpen}>
          <DialogContent className="p-0 max-w-2xl">
            <div className="flex items-center border-b px-4 py-3">
              <Search className="h-4 w-4 mr-2 text-muted-foreground" />
              <Input
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                onKeyDown={handleKeyDown}
                placeholder={placeholder}
                className="border-0 focus-visible:ring-0 flex-1"
                autoFocus
              />
              {isSearching && (
                <Loader2 className="h-4 w-4 animate-spin text-muted-foreground" />
              )}
            </div>

            <div className="max-h-96 overflow-y-auto">
              {query.trim() === '' ? (
                // Show suggestions and recent searches
                <div className="p-4 space-y-4">
                  {showRecentSearches && recentSearches.length > 0 && (
                    <div>
                      <h4 className="text-sm font-medium mb-2 flex items-center gap-2">
                        <History className="h-4 w-4" />
                        Recent Searches
                      </h4>
                      <div className="space-y-1">
                        {recentSearches.map((search, index) => (
                          <div
                            key={index}
                            className="flex items-center gap-2 p-2 rounded hover:bg-muted cursor-pointer"
                            onClick={() => handleSuggestionClick({ id: `recent-${index}`, query: search, type: 'recent' })}
                          >
                            <Clock className="h-3 w-3 text-muted-foreground" />
                            <span className="text-sm">{search}</span>
                          </div>
                        ))}
                      </div>
                    </div>
                  )}

                  {showSuggestions && (
                    <div>
                      <h4 className="text-sm font-medium mb-2 flex items-center gap-2">
                        <Sparkles className="h-4 w-4" />
                        Suggestions
                      </h4>
                      <div className="space-y-1">
                        {suggestions.map(suggestion => (
                          <div
                            key={suggestion.id}
                            className="flex items-center gap-2 p-2 rounded hover:bg-muted cursor-pointer"
                            onClick={() => handleSuggestionClick(suggestion)}
                          >
                            <div className="flex items-center gap-2 flex-1">
                              {suggestion.type === 'popular' && <TrendingUp className="h-3 w-3 text-muted-foreground" />}
                              {suggestion.type === 'suggested' && <Star className="h-3 w-3 text-muted-foreground" />}
                              <span className="text-sm">{suggestion.query}</span>
                            </div>
                            {suggestion.count && (
                              <Badge variant="secondary" className="text-xs">
                                {suggestion.count}
                              </Badge>
                            )}
                          </div>
                        ))}
                      </div>
                    </div>
                  )}
                </div>
              ) : (
                // Show search results
                <div className="p-4">
                  {results.length > 0 ? (
                    <div className="space-y-2">
                      {results.map((result, index) => (
                        <SearchResultItem
                          key={result.id}
                          result={result}
                          isSelected={index === selectedIndex}
                          onClick={() => handleResultSelect(result)}
                        />
                      ))}
                    </div>
                  ) : (
                    <div className="text-center py-8">
                      {isSearching ? (
                        <div className="flex items-center justify-center gap-2">
                          <Loader2 className="h-4 w-4 animate-spin" />
                          <span className="text-sm text-muted-foreground">Searching...</span>
                        </div>
                      ) : (
                        <div>
                          <Search className="h-8 w-8 text-muted-foreground mx-auto mb-2" />
                          <p className="text-sm text-muted-foreground">
                            No results found for "{query}"
                          </p>
                        </div>
                      )}
                    </div>
                  )}
                </div>
              )}
            </div>

            {/* Footer */}
            <div className="border-t px-4 py-2 text-xs text-muted-foreground flex items-center justify-between">
              <div className="flex items-center gap-4">
                <div className="flex items-center gap-1">
                  <kbd className="px-1.5 py-0.5 text-xs bg-muted rounded"></kbd>
                  <span>Navigate</span>
                </div>
                <div className="flex items-center gap-1">
                  <kbd className="px-1.5 py-0.5 text-xs bg-muted rounded">Enter</kbd>
                  <span>Select</span>
                </div>
                <div className="flex items-center gap-1">
                  <kbd className="px-1.5 py-0.5 text-xs bg-muted rounded">Esc</kbd>
                  <span>Close</span>
                </div>
              </div>
              <Button variant="ghost" size="sm" className="h-6 text-xs">
                <Filter className="h-3 w-3 mr-1" />
                Advanced
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </>
    );
  }

  // Inline variant
  if (variant === 'inline') {
    return (
      <div className={cn('relative', className)}>
        <div className="relative">
          <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
          <Input
            value={query}
            onChange={(e) => setQuery(e.target.value)}
            onFocus={() => setIsOpen(true)}
            placeholder={placeholder}
            className="pl-9"
          />
          {isSearching && (
            <Loader2 className="absolute right-3 top-1/2 transform -translate-y-1/2 h-4 w-4 animate-spin text-muted-foreground" />
          )}
        </div>

        {isOpen && (query.trim() !== '' || showSuggestions) && (
          <Card className="absolute top-full left-0 right-0 z-50 mt-1 shadow-lg">
            <CardContent className="p-0 max-h-96 overflow-y-auto">
              {/* Results or suggestions go here - similar to command bar */}
              {query.trim() === '' ? (
                <div className="p-4">
                  <p className="text-sm text-muted-foreground">Start typing to search...</p>
                </div>
              ) : results.length > 0 ? (
                <div className="p-2">
                  {results.map(result => (
                    <SearchResultItem
                      key={result.id}
                      result={result}
                      isSelected={false}
                      onClick={() => handleResultSelect(result)}
                    />
                  ))}
                </div>
              ) : (
                <div className="p-4 text-center">
                  <p className="text-sm text-muted-foreground">No results found</p>
                </div>
              )}
            </CardContent>
          </Card>
        )}
      </div>
    );
  }

  return null;
};

export default GlobalSearch;
</file>

<file path="src/app/_components/search/SearchResults.tsx">
'use client';

import React, { useState, useMemo } from 'react';
import { format, formatDistanceToNow } from 'date-fns';
import { 
  Search, 
  FileText, 
  Building, 
  Users, 
  TrendingUp, 
  Calendar,
  DollarSign,
  Clock,
  ExternalLink,
  Star,
  Bookmark,
  Eye,
  MoreHorizontal,
  Filter,
  Grid,
  List,
  SortAsc,
  SortDesc,
  ArrowRight,
  Tag,
  MapPin,
  AlertCircle,
  CheckCircle,
  XCircle,
  Loader2
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Separator } from '@/components/ui/separator';
import { Progress } from '@/components/ui/progress';
import { cn } from '@/lib/utils';

// Search result interface (reusing from GlobalSearch)
export interface SearchResult {
  id: string;
  type: 'contract' | 'vendor' | 'user' | 'workflow' | 'document';
  title: string;
  description?: string;
  metadata?: Record<string, any>;
  score: number; // relevance score
  url?: string;
  entityId?: string;
  timestamp?: Date;
  status?: string;
  category?: string;
  tags?: string[];
  assignedTo?: {
    id: string;
    name: string;
    avatar?: string;
  }[];
  value?: number;
  priority?: 'low' | 'medium' | 'high' | 'urgent';
  progress?: number;
}

// Search filters
export interface SearchFilters {
  types: string[];
  dateRange?: {
    start: Date;
    end: Date;
  };
  status?: string[];
  category?: string[];
  assignedTo?: string[];
  tags?: string[];
}

// Search results props
export interface SearchResultsProps {
  results: SearchResult[];
  query: string;
  totalResults?: number;
  isLoading?: boolean;
  filters?: SearchFilters;
  onFilterChange?: (filters: SearchFilters) => void;
  onResultClick?: (result: SearchResult) => void;
  onBookmark?: (resultId: string) => void;
  onShare?: (result: SearchResult) => void;
  variant?: 'grid' | 'list' | 'compact';
  showFilters?: boolean;
  showSorting?: boolean;
  className?: string;
}

// Mock data for demonstration
const mockSearchResults: SearchResult[] = [
  {
    id: '1',
    type: 'contract',
    title: 'Microsoft Enterprise License Agreement',
    description: 'Annual software licensing contract for Microsoft 365 Enterprise suite including Teams, SharePoint, and advanced security features',
    score: 0.95,
    status: 'active',
    category: 'software',
    timestamp: new Date(Date.now() - 2 * 24 * 60 * 60 * 1000),
    url: '/dashboard/contracts/1',
    value: 150000,
    tags: ['enterprise', 'software', 'annual'],
    assignedTo: [
      { id: '1', name: 'Sarah Johnson', avatar: undefined },
      { id: '2', name: 'Mike Chen', avatar: undefined }
    ],
    metadata: {
      vendor: 'Microsoft Corporation',
      renewalDate: '2024-12-31',
      department: 'IT'
    }
  },
  {
    id: '2',
    type: 'vendor',
    title: 'TechCorp Solutions Inc.',
    description: 'Full-service IT consulting and software development vendor specializing in cloud infrastructure and enterprise applications',
    score: 0.87,
    status: 'active',
    category: 'technology',
    timestamp: new Date(Date.now() - 5 * 24 * 60 * 60 * 1000),
    url: '/dashboard/vendors/2',
    tags: ['technology', 'consulting', 'cloud'],
    metadata: {
      riskLevel: 'low',
      complianceScore: 92,
      totalSpend: 75000,
      location: 'San Francisco, CA'
    }
  },
  {
    id: '3',
    type: 'workflow',
    title: 'Contract Approval Process - High Value',
    description: 'Multi-stage approval workflow for contracts exceeding $50,000 requiring legal, financial, and executive approval',
    score: 0.76,
    status: 'running',
    category: 'approval',
    timestamp: new Date(Date.now() - 1 * 60 * 60 * 1000),
    url: '/dashboard/workflows/3',
    progress: 65,
    tags: ['approval', 'high-value', 'multi-stage'],
    assignedTo: [
      { id: '3', name: 'Legal Team', avatar: undefined }
    ]
  },
  {
    id: '4',
    type: 'document',
    title: 'Q4 Vendor Performance Report',
    description: 'Comprehensive quarterly analysis of vendor performance metrics, compliance scores, and cost optimization opportunities',
    score: 0.68,
    status: 'final',
    category: 'report',
    timestamp: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000),
    url: '/documents/4',
    tags: ['report', 'quarterly', 'performance'],
    metadata: {
      fileType: 'PDF',
      size: '2.4 MB',
      department: 'Procurement'
    }
  }
];

// Type icons mapping
const getTypeIcon = (type: string) => {
  switch (type) {
    case 'contract':
      return FileText;
    case 'vendor':
      return Building;
    case 'user':
      return Users;
    case 'workflow':
      return TrendingUp;
    case 'document':
      return FileText;
    default:
      return FileText;
  }
};

// Status colors
const getStatusColor = (status: string) => {
  switch (status) {
    case 'active':
    case 'running':
    case 'approved':
      return 'bg-green-100 text-green-800';
    case 'pending':
    case 'review':
      return 'bg-yellow-100 text-yellow-800';
    case 'inactive':
    case 'expired':
    case 'rejected':
      return 'bg-red-100 text-red-800';
    case 'draft':
      return 'bg-gray-100 text-gray-800';
    default:
      return 'bg-blue-100 text-blue-800';
  }
};

export const SearchResults: React.FC<SearchResultsProps> = ({
  results: initialResults = mockSearchResults,
  query,
  totalResults,
  isLoading = false,
  filters = { types: [] },
  onFilterChange,
  onResultClick,
  onBookmark,
  onShare,
  variant = 'list',
  showFilters = true,
  showSorting = true,
  className
}) => {
  // State
  const [sortBy, setSortBy] = useState<'relevance' | 'date' | 'title' | 'value'>('relevance');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('desc');
  const [selectedTypes, setSelectedTypes] = useState<string[]>(filters.types);
  const [viewMode, setViewMode] = useState<'grid' | 'list' | 'compact'>(variant);

  // Filter and sort results
  const results = useMemo(() => {
    let filtered = initialResults;

    // Apply type filter
    if (selectedTypes.length > 0) {
      filtered = filtered.filter(result => selectedTypes.includes(result.type));
    }

    // Sort results
    filtered.sort((a, b) => {
      let aValue: any, bValue: any;
      
      switch (sortBy) {
        case 'relevance':
          aValue = a.score;
          bValue = b.score;
          break;
        case 'date':
          aValue = a.timestamp?.getTime() || 0;
          bValue = b.timestamp?.getTime() || 0;
          break;
        case 'title':
          aValue = a.title.toLowerCase();
          bValue = b.title.toLowerCase();
          break;
        case 'value':
          aValue = a.value || 0;
          bValue = b.value || 0;
          break;
        default:
          return 0;
      }

      if (typeof aValue === 'string') {
        return sortDirection === 'asc' ? aValue.localeCompare(bValue) : bValue.localeCompare(aValue);
      }
      
      return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
    });

    return filtered;
  }, [initialResults, selectedTypes, sortBy, sortDirection]);

  // Get unique types for filtering
  const availableTypes = useMemo(() => {
    const types = Array.from(new Set(initialResults.map(r => r.type)));
    return types.map(type => ({
      value: type,
      label: type.charAt(0).toUpperCase() + type.slice(1),
      count: initialResults.filter(r => r.type === type).length
    }));
  }, [initialResults]);

  // Handle result click
  const handleResultClick = (result: SearchResult) => {
    if (onResultClick) {
      onResultClick(result);
    } else if (result.url) {
      window.open(result.url, '_blank');
    }
  };

  // Result card component
  const ResultCard: React.FC<{ result: SearchResult; mode: 'grid' | 'list' | 'compact' }> = ({ result, mode }) => {
    const IconComponent = getTypeIcon(result.type);

    if (mode === 'compact') {
      return (
        <div 
          className="flex items-center gap-3 p-3 border rounded-lg hover:shadow-md transition-shadow cursor-pointer"
          onClick={() => handleResultClick(result)}
        >
          <div className="flex-shrink-0">
            <div className="w-8 h-8 rounded bg-primary/10 flex items-center justify-center">
              <IconComponent className="h-4 w-4 text-primary" />
            </div>
          </div>
          
          <div className="flex-1 min-w-0">
            <div className="flex items-center gap-2 mb-1">
              <h3 className="font-medium text-sm truncate">{result.title}</h3>
              <Badge variant="outline" className="text-xs">
                {result.type}
              </Badge>
              {result.status && (
                <Badge className={cn('text-xs', getStatusColor(result.status))}>
                  {result.status}
                </Badge>
              )}
            </div>
            {result.description && (
              <p className="text-xs text-muted-foreground line-clamp-1">
                {result.description}
              </p>
            )}
          </div>

          <div className="flex items-center gap-2">
            <span className="text-xs text-muted-foreground">
              {Math.round(result.score * 100)}% match
            </span>
            <ArrowRight className="h-4 w-4 text-muted-foreground" />
          </div>
        </div>
      );
    }

    if (mode === 'grid') {
      return (
        <Card className="cursor-pointer hover:shadow-md transition-shadow" onClick={() => handleResultClick(result)}>
          <CardHeader className="pb-3">
            <div className="flex items-start justify-between">
              <div className="flex items-center gap-2">
                <div className="w-8 h-8 rounded bg-primary/10 flex items-center justify-center">
                  <IconComponent className="h-4 w-4 text-primary" />
                </div>
                <Badge variant="outline" className="text-xs">
                  {result.type}
                </Badge>
              </div>
              
              <DropdownMenu>
                <DropdownMenuTrigger asChild>
                  <Button variant="ghost" size="sm" className="h-6 w-6 p-0">
                    <MoreHorizontal className="h-4 w-4" />
                  </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end">
                  <DropdownMenuItem onClick={() => handleResultClick(result)}>
                    <Eye className="h-4 w-4 mr-2" />
                    View
                  </DropdownMenuItem>
                  {onBookmark && (
                    <DropdownMenuItem onClick={() => onBookmark(result.id)}>
                      <Bookmark className="h-4 w-4 mr-2" />
                      Bookmark
                    </DropdownMenuItem>
                  )}
                  {onShare && (
                    <DropdownMenuItem onClick={() => onShare(result)}>
                      <ExternalLink className="h-4 w-4 mr-2" />
                      Share
                    </DropdownMenuItem>
                  )}
                </DropdownMenuContent>
              </DropdownMenu>
            </div>
            
            <CardTitle className="text-base line-clamp-2">{result.title}</CardTitle>
          </CardHeader>
          
          <CardContent className="pt-0">
            {result.description && (
              <p className="text-sm text-muted-foreground line-clamp-3 mb-3">
                {result.description}
              </p>
            )}
            
            <div className="space-y-2">
              {result.status && (
                <div className="flex items-center justify-between">
                  <span className="text-xs text-muted-foreground">Status:</span>
                  <Badge className={cn('text-xs', getStatusColor(result.status))}>
                    {result.status}
                  </Badge>
                </div>
              )}
              
              {result.progress !== undefined && (
                <div className="space-y-1">
                  <div className="flex items-center justify-between text-xs">
                    <span className="text-muted-foreground">Progress:</span>
                    <span>{result.progress}%</span>
                  </div>
                  <Progress value={result.progress} className="h-1" />
                </div>
              )}
              
              {result.value && (
                <div className="flex items-center justify-between">
                  <span className="text-xs text-muted-foreground">Value:</span>
                  <span className="text-sm font-medium">${result.value.toLocaleString()}</span>
                </div>
              )}
              
              {result.timestamp && (
                <div className="flex items-center gap-1 text-xs text-muted-foreground">
                  <Clock className="h-3 w-3" />
                  {formatDistanceToNow(result.timestamp, { addSuffix: true })}
                </div>
              )}
            </div>
            
            {result.tags && result.tags.length > 0 && (
              <div className="flex flex-wrap gap-1 mt-3">
                {result.tags.slice(0, 3).map(tag => (
                  <Badge key={tag} variant="secondary" className="text-xs">
                    {tag}
                  </Badge>
                ))}
                {result.tags.length > 3 && (
                  <Badge variant="secondary" className="text-xs">
                    +{result.tags.length - 3}
                  </Badge>
                )}
              </div>
            )}
          </CardContent>
        </Card>
      );
    }

    // List mode
    return (
      <Card className="cursor-pointer hover:shadow-md transition-shadow" onClick={() => handleResultClick(result)}>
        <CardContent className="p-4">
          <div className="flex items-start gap-4">
            <div className="flex-shrink-0">
              <div className="w-10 h-10 rounded bg-primary/10 flex items-center justify-center">
                <IconComponent className="h-5 w-5 text-primary" />
              </div>
            </div>
            
            <div className="flex-1 min-w-0">
              <div className="flex items-start justify-between mb-2">
                <div className="flex-1">
                  <div className="flex items-center gap-2 mb-1">
                    <h3 className="font-medium line-clamp-1">{result.title}</h3>
                    <Badge variant="outline" className="text-xs">
                      {result.type}
                    </Badge>
                    {result.status && (
                      <Badge className={cn('text-xs', getStatusColor(result.status))}>
                        {result.status}
                      </Badge>
                    )}
                  </div>
                  
                  {result.description && (
                    <p className="text-sm text-muted-foreground line-clamp-2">
                      {result.description}
                    </p>
                  )}
                </div>
                
                <div className="flex items-center gap-2 ml-4">
                  <span className="text-xs text-muted-foreground">
                    {Math.round(result.score * 100)}% match
                  </span>
                  
                  <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                      <Button variant="ghost" size="sm" className="h-6 w-6 p-0">
                        <MoreHorizontal className="h-4 w-4" />
                      </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end">
                      <DropdownMenuItem onClick={() => handleResultClick(result)}>
                        <Eye className="h-4 w-4 mr-2" />
                        View
                      </DropdownMenuItem>
                      {onBookmark && (
                        <DropdownMenuItem onClick={() => onBookmark(result.id)}>
                          <Bookmark className="h-4 w-4 mr-2" />
                          Bookmark
                        </DropdownMenuItem>
                      )}
                      {onShare && (
                        <DropdownMenuItem onClick={() => onShare(result)}>
                          <ExternalLink className="h-4 w-4 mr-2" />
                          Share
                        </DropdownMenuItem>
                      )}
                    </DropdownMenuContent>
                  </DropdownMenu>
                </div>
              </div>
              
              <div className="flex items-center justify-between">
                <div className="flex items-center gap-4 text-sm">
                  {result.assignedTo && result.assignedTo.length > 0 && (
                    <div className="flex items-center gap-2">
                      <Users className="h-3 w-3 text-muted-foreground" />
                      <div className="flex gap-1">
                        {result.assignedTo.slice(0, 3).map(person => (
                          <Avatar key={person.id} className="h-5 w-5">
                            <AvatarImage src={person.avatar} />
                            <AvatarFallback className="text-xs">
                              {person.name.charAt(0)}
                            </AvatarFallback>
                          </Avatar>
                        ))}
                        {result.assignedTo.length > 3 && (
                          <div className="h-5 w-5 rounded-full bg-muted flex items-center justify-center">
                            <span className="text-xs">+{result.assignedTo.length - 3}</span>
                          </div>
                        )}
                      </div>
                    </div>
                  )}
                  
                  {result.value && (
                    <div className="flex items-center gap-1">
                      <DollarSign className="h-3 w-3 text-muted-foreground" />
                      <span className="text-muted-foreground">${result.value.toLocaleString()}</span>
                    </div>
                  )}
                  
                  {result.progress !== undefined && (
                    <div className="flex items-center gap-2">
                      <span className="text-xs text-muted-foreground">Progress:</span>
                      <Progress value={result.progress} className="h-1 w-16" />
                      <span className="text-xs text-muted-foreground">{result.progress}%</span>
                    </div>
                  )}
                </div>
                
                <div className="flex items-center gap-1 text-xs text-muted-foreground">
                  <Clock className="h-3 w-3" />
                  {result.timestamp && formatDistanceToNow(result.timestamp, { addSuffix: true })}
                </div>
              </div>
              
              {result.tags && result.tags.length > 0 && (
                <div className="flex flex-wrap gap-1 mt-2">
                  {result.tags.slice(0, 5).map(tag => (
                    <Badge key={tag} variant="secondary" className="text-xs">
                      {tag}
                    </Badge>
                  ))}
                  {result.tags.length > 5 && (
                    <Badge variant="secondary" className="text-xs">
                      +{result.tags.length - 5}
                    </Badge>
                  )}
                </div>
              )}
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  // Filter controls
  const FilterControls: React.FC = () => (
    <div className="flex items-center gap-4 p-4 bg-muted/50 rounded-lg">
      <div className="flex items-center gap-2">
        <Filter className="h-4 w-4 text-muted-foreground" />
        <span className="text-sm font-medium">Filters:</span>
      </div>
      
      <div className="flex flex-wrap gap-2">
        {availableTypes.map(type => (
          <Button
            key={type.value}
            variant={selectedTypes.includes(type.value) ? "default" : "outline"}
            size="sm"
            onClick={() => {
              const newTypes = selectedTypes.includes(type.value)
                ? selectedTypes.filter(t => t !== type.value)
                : [...selectedTypes, type.value];
              setSelectedTypes(newTypes);
            }}
          >
            {type.label}
            <Badge variant="secondary" className="ml-1 text-xs">
              {type.count}
            </Badge>
          </Button>
        ))}
      </div>
      
      {selectedTypes.length > 0 && (
        <Button
          variant="ghost"
          size="sm"
          onClick={() => setSelectedTypes([])}
        >
          Clear
        </Button>
      )}
    </div>
  );

  return (
    <div className={cn('space-y-6', className)}>
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-semibold">Search Results</h2>
          <p className="text-muted-foreground">
            {isLoading ? 'Searching...' : (
              <>
                {results.length} of {totalResults || results.length} results
                {query && ` for "${query}"`}
              </>
            )}
          </p>
        </div>
        
        <div className="flex items-center gap-2">
          {/* View mode toggle */}
          <div className="flex items-center border rounded-lg">
            <Button
              variant={viewMode === 'list' ? 'default' : 'ghost'}
              size="sm"
              onClick={() => setViewMode('list')}
              className="rounded-r-none"
            >
              <List className="h-4 w-4" />
            </Button>
            <Button
              variant={viewMode === 'grid' ? 'default' : 'ghost'}
              size="sm"
              onClick={() => setViewMode('grid')}
              className="rounded-none"
            >
              <Grid className="h-4 w-4" />
            </Button>
            <Button
              variant={viewMode === 'compact' ? 'default' : 'ghost'}
              size="sm"
              onClick={() => setViewMode('compact')}
              className="rounded-l-none"
            >
              <Search className="h-4 w-4" />
            </Button>
          </div>
          
          {showSorting && (
            <>
              <Select value={sortBy} onValueChange={(value: any) => setSortBy(value)}>
                <SelectTrigger className="w-40">
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="relevance">Relevance</SelectItem>
                  <SelectItem value="date">Date</SelectItem>
                  <SelectItem value="title">Title</SelectItem>
                  <SelectItem value="value">Value</SelectItem>
                </SelectContent>
              </Select>
              
              <Button
                variant="outline"
                size="sm"
                onClick={() => setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')}
              >
                {sortDirection === 'asc' ? <SortAsc className="h-4 w-4" /> : <SortDesc className="h-4 w-4" />}
              </Button>
            </>
          )}
        </div>
      </div>
      
      {/* Filters */}
      {showFilters && <FilterControls />}
      
      {/* Loading state */}
      {isLoading && (
        <div className="flex items-center justify-center py-12">
          <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
          <span className="ml-2 text-muted-foreground">Searching...</span>
        </div>
      )}
      
      {/* Results */}
      {!isLoading && (
        <>
          {results.length > 0 ? (
            <div className={cn(
              viewMode === 'grid' && 'grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4',
              viewMode === 'list' && 'space-y-4',
              viewMode === 'compact' && 'space-y-2'
            )}>
              {results.map(result => (
                <ResultCard key={result.id} result={result} mode={viewMode} />
              ))}
            </div>
          ) : (
            <div className="text-center py-12">
              <Search className="h-16 w-16 text-muted-foreground mx-auto mb-4" />
              <h3 className="text-lg font-medium text-muted-foreground">No results found</h3>
              <p className="text-muted-foreground">
                {query ? `No results found for "${query}"` : 'Try adjusting your search criteria'}
              </p>
              {selectedTypes.length > 0 && (
                <Button variant="outline" className="mt-4" onClick={() => setSelectedTypes([])}>
                  Clear filters
                </Button>
              )}
            </div>
          )}
        </>
      )}
    </div>
  );
};

export default SearchResults;
</file>

<file path="src/app/_components/vendor/CategoryComponent.tsx">
'use client'

import React, { useState } from "react";
import { Plus, X, Check, Edit2 } from "lucide-react";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import { useDashboardStore } from "../../../stores/dashboard-store";

interface VendorCategory {
  id: string;
  name: string;
  isDefault?: boolean;
}

interface VendorCategoriesProps {
  selectedCategory?: string;
  onCategoryChange: (category: string) => void;
}

export const VendorCategories: React.FC<VendorCategoriesProps> = ({
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  selectedCategory: propSelectedCategory,
  onCategoryChange,
}) => {
  // Default categories that can't be removed
  const defaultCategories: VendorCategory[] = [
    { id: "all", name: "All Vendors", isDefault: true },
    { id: "active", name: "Active", isDefault: true },
    { id: "inactive", name: "Inactive", isDefault: true },
  ];

  // Use Zustand store for categories
  const { selectedType, setSelectedType } = useDashboardStore();
  // eslint-disable-next-line @typescript-eslint/no-unused-vars
  const [isAddingCategory, setIsAddingCategory] = useState(false);
  const [newCategoryName, setNewCategoryName] = useState("");
  const [editingCategory, setEditingCategory] = useState<string | null>(null);
  const [isDialogOpen, setIsDialogOpen] = useState(false);

  // Use local state for categories but could be moved to Zustand if needed across components
  const [categories, setCategories] = useState<VendorCategory[]>([
    ...defaultCategories,
  ]);

  const handleAddCategory = () => {
    if (newCategoryName.trim()) {
      const newCategory: VendorCategory = {
        id: `category-${Date.now()}`,
        name: newCategoryName.trim(),
      };
      setCategories([...categories, newCategory]);
      setNewCategoryName("");
      setIsAddingCategory(false);
      setIsDialogOpen(false);
    }
  };

  const handleEditCategory = (categoryId: string, newName: string) => {
    setCategories(
      categories.map((cat) =>
        cat.id === categoryId ? { ...cat, name: newName } : cat
      )
    );
    setEditingCategory(null);
  };

  const handleDeleteCategory = (categoryId: string) => {
    setCategories(categories.filter((cat) => cat.id !== categoryId));
    if (selectedType === categoryId) {
      setSelectedType("all");
      onCategoryChange("all");
    }
  };

  const handleCategoryChange = (categoryId: string) => {
    setSelectedType(categoryId);
    onCategoryChange(categoryId);
  };

  return (
    <div className="space-y-4">
      <div className="flex items-center space-x-2">
        <Tabs value={selectedType} className="w-full">
          <TabsList className="flex overflow-visible bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
            {categories.map((category) => (
              <TabsTrigger
                key={category.id}
                value={category.id}
                onClick={() => handleCategoryChange(category.id)}
                className="relative group flex items-center space-x-1 px-4 py-2"
              >
                <span className="relative">
                  {category.name}
                  {!category.isDefault && (
                    <div
                      className="absolute -top-8 -right-3 hidden group-hover:flex items-center space-x-1 z-50 
                                  transition-all duration-200 ease-in-out opacity-0 group-hover:opacity-100 
                                  scale-95 group-hover:scale-100 bg-background/80 rounded-md p-1 shadow-md"
                    >
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6 p-1 bg-background/80 backdrop-blur-sm border border-border/50 shadow-sm
                                 hover:bg-primary hover:text-primary-foreground
                                 transition-all duration-200 ease-in-out
                                 hover:scale-110 hover:-translate-y-0.5
                                 focus:scale-105 focus:ring-2 focus:ring-primary"
                        onClick={(e) => {
                          e.stopPropagation();
                          setEditingCategory(category.id);
                        }}
                      >
                        <Edit2 className="h-4 w-4" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        className="h-6 w-6 p-1 bg-background/80 backdrop-blur-sm border border-border/50 shadow-sm
                                 hover:bg-destructive hover:text-destructive-foreground
                                 transition-all duration-200 ease-in-out
                                 hover:scale-110 hover:-translate-y-0.5
                                 focus:scale-105 focus:ring-2 focus:ring-destructive"
                        onClick={(e) => {
                          e.stopPropagation();
                          handleDeleteCategory(category.id);
                        }}
                      >
                        <X className="h-4 w-4" />
                      </Button>
                    </div>
                  )}
                </span>
              </TabsTrigger>
            ))}
          </TabsList>
        </Tabs>

        <Dialog open={isDialogOpen} onOpenChange={setIsDialogOpen}>
          <DialogTrigger asChild>
            <Button
              variant="outline"
              size="icon"
              className="shrink-0 h-8 w-8 hover:scale-110 transition-transform duration-200 ease-in-out"
              onClick={() => setIsAddingCategory(true)}
            >
              <Plus className="h-4 w-4" />
            </Button>
          </DialogTrigger>
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Add New Category</DialogTitle>
            </DialogHeader>
            <div className="flex items-center space-x-2">
              <Input
                value={newCategoryName}
                onChange={(e) => setNewCategoryName(e.target.value)}
                placeholder="Enter category name"
                className="flex-1"
              />
              <Button onClick={handleAddCategory}>
                <Check className="h-4 w-4" />
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      </div>

      {/* Edit Category Dialog */}
      {editingCategory && (
        <Dialog
          open={!!editingCategory}
          onOpenChange={() => setEditingCategory(null)}
        >
          <DialogContent>
            <DialogHeader>
              <DialogTitle>Edit Category</DialogTitle>
            </DialogHeader>
            <div className="flex items-center space-x-2">
              <Input
                value={
                  categories.find((cat) => cat.id === editingCategory)?.name ||
                  ""
                }
                onChange={(e) =>
                  handleEditCategory(editingCategory, e.target.value)
                }
                placeholder="Enter category name"
                className="flex-1"
              />
              <Button
                onClick={() => setEditingCategory(null)}
                className="shrink-0"
              >
                <Check className="h-4 w-4" />
              </Button>
            </div>
          </DialogContent>
        </Dialog>
      )}
    </div>
  );
};

export default VendorCategories;
</file>

<file path="src/app/_components/vendor/VendorDetails.tsx">
'use client'

import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Badge } from "@/components/ui/badge";
import { Button } from "@/components/ui/button";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Avatar, AvatarFallback } from "@/components/ui/avatar";
import { Separator } from "@/components/ui/separator";
import {
  Mail,
  Phone,
  Globe,
  MapPin,
  Edit,
  FileText,
  AlertTriangle,
  TrendingUp,
  Calendar,
  DollarSign,
  Users,
  Activity,
  Clock,
  Star,
  ExternalLink,
} from "lucide-react";
import { VendorType } from "@/types/vendor.types";

interface VendorDetailsProps {
  vendor: VendorType;
  onEdit?: () => void;
  onClose?: () => void;
}

export const VendorDetails: React.FC<VendorDetailsProps> = ({
  vendor,
  onEdit,
}) => {
  const [activeTab, setActiveTab] = useState("overview");

  // Mock data for demonstration - in real app, this would come from API
  const vendorContracts = [
    {
      id: "1",
      title: "Software License Agreement",
      status: "active",
      value: 50000,
      startDate: "2024-01-15",
      endDate: "2024-12-31",
      type: "software",
    },
    {
      id: "2", 
      title: "Maintenance Contract",
      status: "active",
      value: 15000,
      startDate: "2024-03-01",
      endDate: "2025-02-28",
      type: "maintenance",
    },
  ];

  const performanceMetrics = {
    deliveryScore: 85,
    qualityScore: 92,
    communicationScore: 88,
    timelinessScore: 79,
    overallScore: 86,
  };

  const recentActivity = [
    {
      date: "2024-06-01",
      type: "contract_renewal",
      description: "Renewed maintenance contract",
    },
    {
      date: "2024-05-15",
      type: "payment",
      description: "Payment processed: $12,500",
    },
    {
      date: "2024-04-20",
      type: "meeting",
      description: "Quarterly business review completed",
    },
  ];

  const getStatusColor = (status: string) => {
    switch (status) {
      case "active":
        return "bg-green-100 text-green-800 border-green-200";
      case "inactive":
        return "bg-gray-100 text-gray-800 border-gray-200";
      case "pending":
        return "bg-yellow-100 text-yellow-800 border-yellow-200";
      default:
        return "bg-gray-100 text-gray-800 border-gray-200";
    }
  };

  const getRiskColor = (level: string) => {
    switch (level) {
      case "low":
        return "text-green-600";
      case "medium":
        return "text-yellow-600";
      case "high":
        return "text-red-600";
      default:
        return "text-gray-600";
    }
  };

  const getScoreColor = (score: number) => {
    if (score >= 90) return "text-green-600";
    if (score >= 75) return "text-yellow-600";
    return "text-red-600";
  };

  return (
    <div className="space-y-6">
      {/* Header Section */}
      <div className="flex items-start justify-between">
        <div className="flex items-start space-x-4">
          <Avatar className="h-16 w-16">
            <AvatarFallback className="text-lg font-semibold bg-primary/10">
              {vendor.name.substring(0, 2).toUpperCase()}
            </AvatarFallback>
          </Avatar>
          <div className="space-y-2">
            <div className="flex items-center space-x-3">
              <h1 className="text-2xl font-bold">{vendor.name}</h1>
              <Badge className={getStatusColor(vendor.status || "active")}>
                {vendor.status || "Active"}
              </Badge>
            </div>
            <div className="flex items-center space-x-4 text-sm text-muted-foreground">
              <span>#{vendor.vendor_number}</span>
              <span></span>
              <span className="capitalize">{vendor.category}</span>
              <span></span>
              <span className={getRiskColor(vendor.risk_level || "low")}>
                {vendor.risk_level?.toUpperCase()} Risk
              </span>
            </div>
          </div>
        </div>
        <Button onClick={onEdit} variant="outline">
          <Edit className="mr-2 h-4 w-4" />
          Edit Vendor
        </Button>
      </div>

      {/* Quick Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-2">
              <DollarSign className="h-5 w-5 text-green-600" />
              <div>
                <p className="text-sm font-medium">Total Spend</p>
                <p className="text-2xl font-bold">
                  ${vendor.total_spend?.toLocaleString() || 0}
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-2">
              <FileText className="h-5 w-5 text-blue-600" />
              <div>
                <p className="text-sm font-medium">Active Contracts</p>
                <p className="text-2xl font-bold">{vendor.active_contracts || 0}</p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-2">
              <Star className="h-5 w-5 text-yellow-600" />
              <div>
                <p className="text-sm font-medium">Performance Score</p>
                <p className={`text-2xl font-bold ${getScoreColor(performanceMetrics.overallScore)}`}>
                  {performanceMetrics.overallScore}%
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardContent className="p-4">
            <div className="flex items-center space-x-2">
              <TrendingUp className="h-5 w-5 text-purple-600" />
              <div>
                <p className="text-sm font-medium">Compliance Score</p>
                <p className={`text-2xl font-bold ${getScoreColor(vendor.compliance_score || 0)}`}>
                  {vendor.compliance_score || 0}%
                </p>
              </div>
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Main Content Tabs */}
      <Tabs value={activeTab} onValueChange={setActiveTab}>
        <TabsList className="grid w-full grid-cols-4">
          <TabsTrigger value="overview">Overview</TabsTrigger>
          <TabsTrigger value="contracts">Contracts</TabsTrigger>
          <TabsTrigger value="performance">Performance</TabsTrigger>
          <TabsTrigger value="activity">Activity</TabsTrigger>
        </TabsList>

        <TabsContent value="overview" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Contact Information */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center space-x-2">
                  <Users className="h-5 w-5" />
                  <span>Contact Information</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                {vendor.contactEmail && (
                  <div className="flex items-center space-x-3">
                    <Mail className="h-4 w-4 text-muted-foreground" />
                    <div>
                      <p className="text-sm font-medium">Email</p>
                      <p className="text-sm text-muted-foreground">{vendor.contactEmail}</p>
                    </div>
                  </div>
                )}
                {vendor.contactPhone && (
                  <div className="flex items-center space-x-3">
                    <Phone className="h-4 w-4 text-muted-foreground" />
                    <div>
                      <p className="text-sm font-medium">Phone</p>
                      <p className="text-sm text-muted-foreground">{vendor.contactPhone}</p>
                    </div>
                  </div>
                )}
                {vendor.website && (
                  <div className="flex items-center space-x-3">
                    <Globe className="h-4 w-4 text-muted-foreground" />
                    <div>
                      <p className="text-sm font-medium">Website</p>
                      <a 
                        href={vendor.website}
                        target="_blank"
                        rel="noopener noreferrer"
                        className="text-sm text-blue-600 hover:underline flex items-center space-x-1"
                      >
                        <span>{vendor.website}</span>
                        <ExternalLink className="h-3 w-3" />
                      </a>
                    </div>
                  </div>
                )}
                {vendor.address && (
                  <div className="flex items-center space-x-3">
                    <MapPin className="h-4 w-4 text-muted-foreground" />
                    <div>
                      <p className="text-sm font-medium">Address</p>
                      <p className="text-sm text-muted-foreground">{vendor.address}</p>
                    </div>
                  </div>
                )}
              </CardContent>
            </Card>

            {/* Risk Assessment */}
            <Card>
              <CardHeader>
                <CardTitle className="flex items-center space-x-2">
                  <AlertTriangle className="h-5 w-5" />
                  <span>Risk Assessment</span>
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">Risk Level</span>
                  <Badge variant="outline" className={getRiskColor(vendor.risk_level || "low")}>
                    {vendor.risk_level?.toUpperCase() || "LOW"}
                  </Badge>
                </div>
                <div className="flex items-center justify-between">
                  <span className="text-sm font-medium">Compliance Score</span>
                  <span className={`font-bold ${getScoreColor(vendor.compliance_score || 0)}`}>
                    {vendor.compliance_score || 0}%
                  </span>
                </div>
                <Separator />
                <div className="space-y-2">
                  <p className="text-sm font-medium">Last Review</p>
                  <p className="text-sm text-muted-foreground">
                    {vendor.updated_at ? new Date(vendor.updated_at).toLocaleDateString() : "Not reviewed"}
                  </p>
                </div>
              </CardContent>
            </Card>
          </div>

          {/* Notes Section */}
          {vendor.notes && (
            <Card>
              <CardHeader>
                <CardTitle>Notes</CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-muted-foreground">{vendor.notes}</p>
              </CardContent>
            </Card>
          )}
        </TabsContent>

        <TabsContent value="contracts" className="space-y-4">
          <div className="flex items-center justify-between">
            <h3 className="text-lg font-semibold">Active Contracts</h3>
            <Button size="sm">
              <FileText className="mr-2 h-4 w-4" />
              View All Contracts
            </Button>
          </div>
          <div className="space-y-4">
            {vendorContracts.map((contract) => (
              <Card key={contract.id}>
                <CardContent className="p-4">
                  <div className="flex items-center justify-between">
                    <div className="space-y-1">
                      <p className="font-medium">{contract.title}</p>
                      <div className="flex items-center space-x-4 text-sm text-muted-foreground">
                        <span>${contract.value.toLocaleString()}</span>
                        <span></span>
                        <span>{contract.startDate} - {contract.endDate}</span>
                        <span></span>
                        <span className="capitalize">{contract.type}</span>
                      </div>
                    </div>
                    <Badge className={getStatusColor(contract.status)}>
                      {contract.status}
                    </Badge>
                  </div>
                </CardContent>
              </Card>
            ))}
          </div>
        </TabsContent>

        <TabsContent value="performance" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle>Performance Metrics</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div className="space-y-2">
                  <div className="flex justify-between">
                    <span className="text-sm font-medium">Delivery Score</span>
                    <span className={`font-bold ${getScoreColor(performanceMetrics.deliveryScore)}`}>
                      {performanceMetrics.deliveryScore}%
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className="bg-blue-600 h-2 rounded-full" 
                      style={{width: `${performanceMetrics.deliveryScore}%`}}
                    ></div>
                  </div>
                </div>
                
                <div className="space-y-2">
                  <div className="flex justify-between">
                    <span className="text-sm font-medium">Quality Score</span>
                    <span className={`font-bold ${getScoreColor(performanceMetrics.qualityScore)}`}>
                      {performanceMetrics.qualityScore}%
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className="bg-green-600 h-2 rounded-full" 
                      style={{width: `${performanceMetrics.qualityScore}%`}}
                    ></div>
                  </div>
                </div>

                <div className="space-y-2">
                  <div className="flex justify-between">
                    <span className="text-sm font-medium">Communication</span>
                    <span className={`font-bold ${getScoreColor(performanceMetrics.communicationScore)}`}>
                      {performanceMetrics.communicationScore}%
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className="bg-purple-600 h-2 rounded-full" 
                      style={{width: `${performanceMetrics.communicationScore}%`}}
                    ></div>
                  </div>
                </div>

                <div className="space-y-2">
                  <div className="flex justify-between">
                    <span className="text-sm font-medium">Timeliness</span>
                    <span className={`font-bold ${getScoreColor(performanceMetrics.timelinessScore)}`}>
                      {performanceMetrics.timelinessScore}%
                    </span>
                  </div>
                  <div className="w-full bg-gray-200 rounded-full h-2">
                    <div 
                      className="bg-yellow-600 h-2 rounded-full" 
                      style={{width: `${performanceMetrics.timelinessScore}%`}}
                    ></div>
                  </div>
                </div>
              </div>
            </CardContent>
          </Card>
        </TabsContent>

        <TabsContent value="activity" className="space-y-4">
          <Card>
            <CardHeader>
              <CardTitle className="flex items-center space-x-2">
                <Activity className="h-5 w-5" />
                <span>Recent Activity</span>
              </CardTitle>
            </CardHeader>
            <CardContent>
              <div className="space-y-4">
                {recentActivity.map((activity, index) => (
                  <div key={index} className="flex items-start space-x-4">
                    <div className="flex-shrink-0">
                      <div className="w-2 h-2 bg-blue-600 rounded-full mt-2"></div>
                    </div>
                    <div className="flex-1 space-y-1">
                      <p className="text-sm font-medium">{activity.description}</p>
                      <div className="flex items-center space-x-2 text-xs text-muted-foreground">
                        <Calendar className="h-3 w-3" />
                        <span>{new Date(activity.date).toLocaleDateString()}</span>
                        <span></span>
                        <span className="capitalize">{activity.type.replace('_', ' ')}</span>
                      </div>
                    </div>
                  </div>
                ))}
              </div>
            </CardContent>
          </Card>
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default VendorDetails;
</file>

<file path="src/app/_components/vendor/VendorDetailsModal.tsx">
'use client'

import React, { useState } from "react";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog";
import { VendorType } from "@/types/vendor.types";
import VendorDetails from "./VendorDetails";
import VendorForm from "./VendorForm";

interface VendorDetailsModalProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  vendor: VendorType | null;
  onEditVendor?: (vendor: Partial<VendorType>) => Promise<void>;
  onUpdateVendor?: (updatedVendor: VendorType) => void;
}

export const VendorDetailsModal: React.FC<VendorDetailsModalProps> = ({
  open,
  onOpenChange,
  vendor,
  onEditVendor,
  onUpdateVendor,
}) => {
  const [isEditing, setIsEditing] = useState(false);
  const [loading, setLoading] = useState(false);

  const handleEdit = () => {
    setIsEditing(true);
  };

  const handleCancelEdit = () => {
    setIsEditing(false);
  };

  const handleSubmitEdit = async (updatedData: Partial<VendorType>) => {
    if (!vendor || !onEditVendor) return;

    setLoading(true);
    try {
      await onEditVendor(updatedData);
      setIsEditing(false);
      
      // Update the vendor in the parent component if callback provided
      if (onUpdateVendor) {
        onUpdateVendor({ ...vendor, ...updatedData } as VendorType);
      }
    } catch (error) {
      console.error("Error updating vendor:", error);
    } finally {
      setLoading(false);
    }
  };

  if (!vendor) return null;

  return (
    <>
      <Dialog open={open && !isEditing} onOpenChange={onOpenChange}>
        <DialogContent className="max-w-6xl max-h-[90vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Vendor Details</DialogTitle>
          </DialogHeader>
          <VendorDetails
            vendor={vendor}
            onEdit={handleEdit}
            onClose={() => onOpenChange(false)}
          />
        </DialogContent>
      </Dialog>

      <VendorForm
        open={isEditing}
        onOpenChange={(open) => {
          if (!open) {
            handleCancelEdit();
          }
        }}
        vendor={vendor}
        onSubmit={handleSubmitEdit}
        loading={loading}
      />
    </>
  );
};

export default VendorDetailsModal;
</file>

<file path="src/app/_components/vendor/VendorForm.tsx">
'use client'

import React, { useState, useEffect } from "react";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import { VendorType, vendorCategoryOptions } from "@/types/vendor.types";
import { Loader2 } from "lucide-react";

interface VendorFormProps {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  vendor?: VendorType | null;
  onSubmit: (vendor: Partial<VendorType>) => Promise<void>;
  loading?: boolean;
}

export const VendorForm: React.FC<VendorFormProps> = ({
  open,
  onOpenChange,
  vendor,
  onSubmit,
  loading = false,
}) => {
  const [formData, setFormData] = useState<Partial<VendorType>>({
    name: "",
    contactEmail: "",
    contactPhone: "",
    address: "",
    website: "",
    category: undefined,
    status: "active",
    notes: "",
  });

  const [errors, setErrors] = useState<Record<string, string>>({});

  // Reset form when dialog opens/closes or vendor changes
  useEffect(() => {
    if (vendor) {
      setFormData({
        name: vendor.name || "",
        contactEmail: vendor.contactEmail || "",
        contactPhone: vendor.contactPhone || "",
        address: vendor.address || "",
        website: vendor.website || "",
        category: vendor.category,
        status: vendor.status || "active",
        notes: vendor.notes || "",
      });
    } else {
      setFormData({
        name: "",
        contactEmail: "",
        contactPhone: "",
        address: "",
        website: "",
        category: undefined,
        status: "active",
        notes: "",
      });
    }
    setErrors({});
  }, [vendor, open]);

  const validateForm = (): boolean => {
    const newErrors: Record<string, string> = {};

    if (!formData.name?.trim()) {
      newErrors.name = "Vendor name is required";
    }

    if (formData.contactEmail && !/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(formData.contactEmail)) {
      newErrors.contactEmail = "Please enter a valid email address";
    }

    if (formData.website && !formData.website.match(/^https?:\/\/.+/)) {
      newErrors.website = "Please enter a valid URL (starting with http:// or https://)";
    }

    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    
    if (!validateForm()) {
      return;
    }

    try {
      await onSubmit(formData);
      onOpenChange(false);
    } catch (error) {
      console.error("Error submitting vendor form:", error);
    }
  };

  const handleInputChange = (field: keyof VendorType, value: string) => {
    setFormData(prev => ({
      ...prev,
      [field]: value,
    }));
    
    // Clear error when user starts typing
    if (errors[field]) {
      setErrors(prev => ({
        ...prev,
        [field]: "",
      }));
    }
  };

  return (
    <Dialog open={open} onOpenChange={onOpenChange}>
      <DialogContent className="sm:max-w-[600px] max-h-[80vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle>
            {vendor ? "Edit Vendor" : "Add New Vendor"}
          </DialogTitle>
        </DialogHeader>

        <form onSubmit={handleSubmit} className="space-y-6">
          {/* Basic Information */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium">Basic Information</h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="name">
                  Vendor Name <span className="text-red-500">*</span>
                </Label>
                <Input
                  id="name"
                  value={formData.name}
                  onChange={(e) => handleInputChange("name", e.target.value)}
                  placeholder="Enter vendor name"
                  className={errors.name ? "border-red-500" : ""}
                />
                {errors.name && (
                  <p className="text-sm text-red-500">{errors.name}</p>
                )}
              </div>

              <div className="space-y-2">
                <Label htmlFor="category">Category</Label>
                <Select
                  value={formData.category}
                  onValueChange={(value) => handleInputChange("category", value)}
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Select category" />
                  </SelectTrigger>
                  <SelectContent>
                    {vendorCategoryOptions.map((category) => (
                      <SelectItem key={category} value={category}>
                        {category.charAt(0).toUpperCase() + category.slice(1)}
                      </SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="status">Status</Label>
              <Select
                value={formData.status}
                onValueChange={(value) => handleInputChange("status", value)}
              >
                <SelectTrigger>
                  <SelectValue />
                </SelectTrigger>
                <SelectContent>
                  <SelectItem value="active">Active</SelectItem>
                  <SelectItem value="inactive">Inactive</SelectItem>
                  <SelectItem value="pending">Pending</SelectItem>
                </SelectContent>
              </Select>
            </div>
          </div>

          {/* Contact Information */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium">Contact Information</h3>
            
            <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
              <div className="space-y-2">
                <Label htmlFor="contactEmail">Email</Label>
                <Input
                  id="contactEmail"
                  type="email"
                  value={formData.contactEmail}
                  onChange={(e) => handleInputChange("contactEmail", e.target.value)}
                  placeholder="contact@vendor.com"
                  className={errors.contactEmail ? "border-red-500" : ""}
                />
                {errors.contactEmail && (
                  <p className="text-sm text-red-500">{errors.contactEmail}</p>
                )}
              </div>

              <div className="space-y-2">
                <Label htmlFor="contactPhone">Phone</Label>
                <Input
                  id="contactPhone"
                  value={formData.contactPhone}
                  onChange={(e) => handleInputChange("contactPhone", e.target.value)}
                  placeholder="+1 (555) 123-4567"
                />
              </div>
            </div>

            <div className="space-y-2">
              <Label htmlFor="website">Website</Label>
              <Input
                id="website"
                value={formData.website}
                onChange={(e) => handleInputChange("website", e.target.value)}
                placeholder="https://www.vendor.com"
                className={errors.website ? "border-red-500" : ""}
              />
              {errors.website && (
                <p className="text-sm text-red-500">{errors.website}</p>
              )}
            </div>

            <div className="space-y-2">
              <Label htmlFor="address">Address</Label>
              <Textarea
                id="address"
                value={formData.address}
                onChange={(e) => handleInputChange("address", e.target.value)}
                placeholder="Enter full address"
                rows={3}
              />
            </div>
          </div>

          {/* Additional Information */}
          <div className="space-y-4">
            <h3 className="text-lg font-medium">Additional Information</h3>
            
            <div className="space-y-2">
              <Label htmlFor="notes">Notes</Label>
              <Textarea
                id="notes"
                value={formData.notes}
                onChange={(e) => handleInputChange("notes", e.target.value)}
                placeholder="Any additional notes about this vendor..."
                rows={4}
              />
            </div>
          </div>

          <DialogFooter className="flex flex-col sm:flex-row gap-2">
            <Button
              type="button"
              variant="outline"
              onClick={() => onOpenChange(false)}
              disabled={loading}
            >
              Cancel
            </Button>
            <Button type="submit" disabled={loading}>
              {loading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
              {vendor ? "Update Vendor" : "Create Vendor"}
            </Button>
          </DialogFooter>
        </form>
      </DialogContent>
    </Dialog>
  );
};

export default VendorForm;
</file>

<file path="src/app/_components/vendor/VendorTable.tsx">
'use client';

import React, { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { format } from 'date-fns';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';
import type { VendorType, VendorCategory } from '@/types/vendor.types';
import { useUser } from '@clerk/nextjs';

// UI Components
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";
import { Progress } from "@/components/ui/progress";

// Icons
import {
  Search,
  Filter,
  SortAsc,
  SortDesc,
  Eye,
  Edit,
  Building,
  Mail,
  Phone,
  Globe,
  AlertCircle,
  ChevronLeft,
  ChevronRight,
  TrendingUp,
  DollarSign,
  FileText,
  Star,
  AlertTriangle
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface VendorTableProps {
  onVendorSelect?: (vendorId: Id<"vendors">) => void;
  statusFilter?: "active" | "inactive" | "pending";
  categoryFilter?: VendorCategory;
  showSearch?: boolean;
  showFilters?: boolean;
  pageSize?: number;
}

type SortField = 'name' | 'category' | 'status' | 'createdAt' | 'total_spend' | 'compliance_score' | 'risk_level';
type SortDirection = 'asc' | 'desc';

// Status color mapping
const statusColors = {
  active: 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300',
  inactive: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300',
  pending: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/70 dark:text-yellow-300',
};

// Risk level colors
const riskColors = {
  low: 'text-green-600',
  medium: 'text-yellow-600',
  high: 'text-red-600',
};

// Category colors
const categoryColors: Record<string, string> = {
  technology: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300',
  marketing: 'bg-purple-100 text-purple-800 dark:bg-purple-900/70 dark:text-purple-300',
  legal: 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900/70 dark:text-indigo-300',
  finance: 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300',
  hr: 'bg-pink-100 text-pink-800 dark:bg-pink-900/70 dark:text-pink-300',
  facilities: 'bg-orange-100 text-orange-800 dark:bg-orange-900/70 dark:text-orange-300',
  logistics: 'bg-teal-100 text-teal-800 dark:bg-teal-900/70 dark:text-teal-300',
  manufacturing: 'bg-slate-100 text-slate-800 dark:bg-slate-700 dark:text-slate-300',
  consulting: 'bg-cyan-100 text-cyan-800 dark:bg-cyan-900/70 dark:text-cyan-300',
  other: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300',
};

export const VendorTable = ({
  onVendorSelect,
  statusFilter,
  categoryFilter,
  showSearch = true,
  showFilters = true,
  pageSize = 10
}: VendorTableProps) => {
  const router = useRouter();
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();
  
  // State
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedStatus, setSelectedStatus] = useState<"active" | "inactive" | "pending" | "all">(statusFilter || 'all');
  const [selectedCategory, setSelectedCategory] = useState<VendorCategory | "all">(categoryFilter || 'all');
  const [sortField, setSortField] = useState<SortField>('createdAt');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
  const [currentPage, setCurrentPage] = useState(1);

  // Get enterpriseId from user metadata
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch vendors
  const { data: vendors, isLoading, error } = useConvexQuery(
    api.vendors.getVendors,
    (enterpriseId) ? { enterpriseId } : "skip"
  );

  // Memoized filtered and sorted vendors
  const processedVendors = useMemo(() => {
    if (!vendors) return [];

    let filtered = vendors.filter((vendor) => {
      // Search filter
      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        const matchesName = vendor.name.toLowerCase().includes(searchLower);
        const matchesEmail = vendor.contactEmail?.toLowerCase().includes(searchLower);
        const matchesCategory = vendor.category?.toLowerCase().includes(searchLower);
        
        if (!matchesName && !matchesEmail && !matchesCategory) {
          return false;
        }
      }

      // Status filter
      if (selectedStatus !== 'all' && vendor.status !== selectedStatus) {
        return false;
      }

      // Category filter
      if (selectedCategory !== 'all' && vendor.category !== selectedCategory) {
        return false;
      }

      return true;
    });

    // Sort vendors
    filtered.sort((a, b) => {
      let aValue: any;
      let bValue: any;

      switch (sortField) {
        case 'name':
          aValue = a.name.toLowerCase();
          bValue = b.name.toLowerCase();
          break;
        case 'category':
          aValue = a.category || '';
          bValue = b.category || '';
          break;
        case 'status':
          aValue = a.status || 'active';
          bValue = b.status || 'active';
          break;
        case 'createdAt':
          aValue = a._creationTime || 0;
          bValue = b._creationTime || 0;
          break;
        case 'total_spend':
          aValue = a.total_spend || 0;
          bValue = b.total_spend || 0;
          break;
        case 'compliance_score':
          aValue = a.compliance_score || 0;
          bValue = b.compliance_score || 0;
          break;
        case 'risk_level':
          const riskOrder = { low: 1, medium: 2, high: 3 };
          aValue = riskOrder[a.risk_level as keyof typeof riskOrder] || 1;
          bValue = riskOrder[b.risk_level as keyof typeof riskOrder] || 1;
          break;
        default:
          aValue = 0;
          bValue = 0;
      }

      if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });

    return filtered;
  }, [vendors, searchTerm, selectedStatus, selectedCategory, sortField, sortDirection]);

  // Pagination
  const totalPages = Math.ceil(processedVendors.length / pageSize);
  const paginatedVendors = processedVendors.slice(
    (currentPage - 1) * pageSize,
    currentPage * pageSize
  );

  // Handlers
  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const handleView = (vendorId: Id<"vendors">) => {
    if (onVendorSelect) {
      onVendorSelect(vendorId);
    } else {
      // Navigate to vendor details page if no custom handler
      router.push(`/dashboard/vendors/${vendorId}`);
    }
  };

  const handleEdit = (vendorId: Id<"vendors">) => {
    router.push(`/dashboard/vendors/edit/${vendorId}`);
  };

  const formatDate = (timestamp?: number): string => {
    if (!timestamp) return 'N/A';
    try {
      return format(new Date(timestamp), 'MMM dd, yyyy');
    } catch {
      return 'N/A';
    }
  };

  const formatStatusLabel = (status?: string): string => {
    if (!status) return 'Active';
    return status.charAt(0).toUpperCase() + status.slice(1);
  };

  const getComplianceColor = (score?: number): string => {
    if (!score) return 'text-gray-600';
    if (score >= 90) return 'text-green-600';
    if (score >= 75) return 'text-yellow-600';
    return 'text-red-600';
  };

  const SortIcon = ({ field }: { field: SortField }) => {
    if (sortField !== field) return null;
    return sortDirection === 'asc' ? 
      <SortAsc className="h-4 w-4 ml-1" /> : 
      <SortDesc className="h-4 w-4 ml-1" />;
  };

  if (!isClerkLoaded) {
    return (
      <div className="flex justify-center items-center min-h-[200px]">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
      </div>
    );
  }

  if (!enterpriseId) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertDescription>
          Enterprise information is missing. Please contact support.
        </AlertDescription>
      </Alert>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertDescription>
          Failed to load vendors: {error.message}
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <Card className="w-full">
      <CardHeader>
        <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            <Building className="h-5 w-5" />
            Vendors ({processedVendors.length})
          </CardTitle>
          
          {/* Search and Filters */}
          {(showSearch || showFilters) && (
            <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
              {showSearch && (
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Search vendors..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="pl-9 w-full sm:w-64"
                  />
                </div>
              )}
              
              {showFilters && (
                <div className="flex gap-2">
                  <Select value={selectedStatus} onValueChange={(value) => setSelectedStatus(value as typeof selectedStatus)}>
                    <SelectTrigger className="w-full sm:w-32">
                      <Filter className="h-4 w-4 mr-2" />
                      <SelectValue />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All Status</SelectItem>
                      <SelectItem value="active">Active</SelectItem>
                      <SelectItem value="inactive">Inactive</SelectItem>
                      <SelectItem value="pending">Pending</SelectItem>
                    </SelectContent>
                  </Select>
                  
                  <Select value={selectedCategory} onValueChange={(value) => setSelectedCategory(value as typeof selectedCategory)}>
                    <SelectTrigger className="w-full sm:w-36">
                      <SelectValue placeholder="Category" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="all">All Categories</SelectItem>
                      <SelectItem value="technology">Technology</SelectItem>
                      <SelectItem value="marketing">Marketing</SelectItem>
                      <SelectItem value="legal">Legal</SelectItem>
                      <SelectItem value="finance">Finance</SelectItem>
                      <SelectItem value="hr">HR</SelectItem>
                      <SelectItem value="facilities">Facilities</SelectItem>
                      <SelectItem value="logistics">Logistics</SelectItem>
                      <SelectItem value="manufacturing">Manufacturing</SelectItem>
                      <SelectItem value="consulting">Consulting</SelectItem>
                      <SelectItem value="other">Other</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              )}
            </div>
          )}
        </div>
      </CardHeader>

      <CardContent>
        {isLoading ? (
          <div className="flex justify-center items-center min-h-[200px]">
            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
            <span className="ml-3 text-muted-foreground">Loading vendors...</span>
          </div>
        ) : paginatedVendors.length === 0 ? (
          <div className="text-center py-8">
            <Building className="h-16 w-16 text-muted-foreground mx-auto mb-4" />
            <p className="text-lg font-medium text-muted-foreground">No vendors found</p>
            <p className="text-sm text-muted-foreground mt-1">
              {searchTerm || selectedStatus !== 'all' || selectedCategory !== 'all'
                ? 'Try adjusting your search or filters' 
                : 'Get started by adding your first vendor'}
            </p>
          </div>
        ) : (
          <>
            {/* Table */}
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('name')}
                    >
                      <div className="flex items-center">
                        Vendor Name
                        <SortIcon field="name" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('category')}
                    >
                      <div className="flex items-center">
                        Category
                        <SortIcon field="category" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('status')}
                    >
                      <div className="flex items-center">
                        Status
                        <SortIcon field="status" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('total_spend')}
                    >
                      <div className="flex items-center">
                        Total Spend
                        <SortIcon field="total_spend" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('compliance_score')}
                    >
                      <div className="flex items-center">
                        Compliance
                        <SortIcon field="compliance_score" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('risk_level')}
                    >
                      <div className="flex items-center">
                        Risk Level
                        <SortIcon field="risk_level" />
                      </div>
                    </TableHead>
                    <TableHead className="text-right">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {paginatedVendors.map((vendor) => (
                    <TableRow key={vendor._id} className="hover:bg-muted/30">
                      <TableCell className="font-medium">
                        <div className="flex flex-col">
                          <span className="font-medium text-foreground truncate max-w-xs">
                            {vendor.name}
                          </span>
                          <div className="flex items-center gap-2 text-xs text-muted-foreground mt-1">
                            {vendor.contactEmail && (
                              <div className="flex items-center gap-1">
                                <Mail className="h-3 w-3" />
                                <span className="truncate max-w-[120px]">{vendor.contactEmail}</span>
                              </div>
                            )}
                            {vendor.contactPhone && (
                              <div className="flex items-center gap-1">
                                <Phone className="h-3 w-3" />
                                <span>{vendor.contactPhone}</span>
                              </div>
                            )}
                            {vendor.website && (
                              <div className="flex items-center gap-1">
                                <Globe className="h-3 w-3" />
                                <span className="truncate max-w-[100px]">{vendor.website}</span>
                              </div>
                            )}
                          </div>
                        </div>
                      </TableCell>
                      <TableCell>
                        {vendor.category ? (
                          <Badge className={cn(categoryColors[vendor.category], "text-xs")}>
                            {vendor.category.charAt(0).toUpperCase() + vendor.category.slice(1)}
                          </Badge>
                        ) : (
                          <span className="text-muted-foreground text-sm">Uncategorized</span>
                        )}
                      </TableCell>
                      <TableCell>
                        <Badge className={cn(statusColors[vendor.status as keyof typeof statusColors] || statusColors.active, "text-xs")}>
                          {formatStatusLabel(vendor.status)}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <DollarSign className="h-4 w-4 text-muted-foreground" />
                          <span className="font-medium">
                            {vendor.total_spend ? `$${vendor.total_spend.toLocaleString()}` : '$0'}
                          </span>
                        </div>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <div className="flex items-center gap-2 min-w-[80px]">
                            <Progress value={vendor.compliance_score || 0} className="h-2 w-12" />
                            <span className={cn("text-sm font-medium", getComplianceColor(vendor.compliance_score))}>
                              {vendor.compliance_score || 0}%
                            </span>
                          </div>
                        </div>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <AlertTriangle className={cn("h-4 w-4", riskColors[vendor.risk_level as keyof typeof riskColors] || riskColors.low)} />
                          <span className={cn("text-sm font-medium capitalize", riskColors[vendor.risk_level as keyof typeof riskColors] || riskColors.low)}>
                            {vendor.risk_level || 'Low'}
                          </span>
                        </div>
                      </TableCell>
                      <TableCell className="text-right">
                        <div className="flex items-center gap-1 justify-end">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleView(vendor._id)}
                            className="h-8 w-8 p-0"
                          >
                            <Eye className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleEdit(vendor._id)}
                            className="h-8 w-8 p-0"
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-between mt-4">
                <div className="text-sm text-muted-foreground">
                  Showing {((currentPage - 1) * pageSize) + 1} to {Math.min(currentPage * pageSize, processedVendors.length)} of {processedVendors.length} vendors
                </div>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setCurrentPage(currentPage - 1)}
                    disabled={currentPage === 1}
                  >
                    <ChevronLeft className="h-4 w-4" />
                    Previous
                  </Button>
                  <div className="flex items-center gap-1">
                    {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                      const pageNum = i + 1;
                      return (
                        <Button
                          key={pageNum}
                          variant={currentPage === pageNum ? "default" : "outline"}
                          size="sm"
                          onClick={() => setCurrentPage(pageNum)}
                          className="w-8 h-8 p-0"
                        >
                          {pageNum}
                        </Button>
                      );
                    })}
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setCurrentPage(currentPage + 1)}
                    disabled={currentPage === totalPages}
                  >
                    Next
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default VendorTable;
</file>

<file path="src/app/_components/workflow/ApprovalQueue.tsx">
'use client';

import React, { useState, useMemo } from 'react';
import { format, formatDistanceToNow, isAfter, addHours } from 'date-fns';
import { 
  CheckCircle, 
  XCircle, 
  Clock, 
  AlertTriangle, 
  User, 
  FileText, 
  Building, 
  Calendar,
  MessageSquare,
  Eye,
  MoreHorizontal,
  Filter,
  SortAsc,
  SortDesc,
  Bell,
  Send,
  History,
  Users,
  Zap
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Textarea } from '@/components/ui/textarea';
import { Input } from '@/components/ui/input';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Dialog, DialogContent, DialogHeader, DialogTitle } from '@/components/ui/dialog';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Progress } from '@/components/ui/progress';
import { cn } from '@/lib/utils';
import { showToast } from '../common/ToastNotifications';
import { usePermissions } from '../auth/PermissionGate';

// Approval request types
export interface ApprovalRequest {
  id: string;
  title: string;
  description?: string;
  type: 'contract' | 'vendor' | 'expense' | 'general';
  entityId?: string;
  priority: 'low' | 'medium' | 'high' | 'urgent';
  status: 'pending' | 'approved' | 'rejected' | 'escalated' | 'expired';
  
  // Requester info
  requestedBy: {
    id: string;
    name: string;
    email: string;
    avatar?: string;
  };
  
  // Approval details
  approvers: {
    id: string;
    name: string;
    email: string;
    status: 'pending' | 'approved' | 'rejected';
    respondedAt?: Date;
    comment?: string;
  }[];
  
  requiredApprovals: number;
  currentApprovals: number;
  
  // Timing
  createdAt: Date;
  dueDate?: Date;
  escalationDate?: Date;
  
  // Workflow
  workflowId?: string;
  workflowStep?: number;
  
  // Additional data
  metadata?: Record<string, any>;
  attachments?: string[];
  comments?: {
    id: string;
    author: string;
    content: string;
    timestamp: Date;
  }[];
}

// Mock data for demonstration
const mockApprovalRequests: ApprovalRequest[] = [
  {
    id: '1',
    title: 'Software License Agreement - Microsoft Enterprise',
    description: 'Annual Microsoft 365 Enterprise license renewal for 150 users',
    type: 'contract',
    entityId: 'contract_123',
    priority: 'high',
    status: 'pending',
    requestedBy: {
      id: 'user_1',
      name: 'Sarah Johnson',
      email: 'sarah.j@company.com'
    },
    approvers: [
      {
        id: 'user_2',
        name: 'John Smith',
        email: 'john.s@company.com',
        status: 'pending'
      },
      {
        id: 'user_3',
        name: 'Lisa Chen',
        email: 'lisa.c@company.com',
        status: 'approved',
        respondedAt: new Date(Date.now() - 2 * 60 * 60 * 1000),
        comment: 'Approved - pricing looks reasonable'
      }
    ],
    requiredApprovals: 2,
    currentApprovals: 1,
    createdAt: new Date(Date.now() - 6 * 60 * 60 * 1000),
    dueDate: new Date(Date.now() + 18 * 60 * 60 * 1000),
    workflowId: 'workflow_1',
    workflowStep: 2
  },
  {
    id: '2',
    title: 'New Vendor Registration - TechCorp Solutions',
    description: 'Adding new IT services vendor to approved vendor list',
    type: 'vendor',
    entityId: 'vendor_456',
    priority: 'medium',
    status: 'pending',
    requestedBy: {
      id: 'user_4',
      name: 'Mike Davis',
      email: 'mike.d@company.com'
    },
    approvers: [
      {
        id: 'user_5',
        name: 'Anna Wilson',
        email: 'anna.w@company.com',
        status: 'pending'
      }
    ],
    requiredApprovals: 1,
    currentApprovals: 0,
    createdAt: new Date(Date.now() - 24 * 60 * 60 * 1000),
    dueDate: new Date(Date.now() + 48 * 60 * 60 * 1000)
  }
];

// Priority colors
const priorityColors = {
  low: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300',
  medium: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/70 dark:text-yellow-300',
  high: 'bg-orange-100 text-orange-800 dark:bg-orange-900/70 dark:text-orange-300',
  urgent: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300',
};

// Status colors
const statusColors = {
  pending: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/70 dark:text-yellow-300',
  approved: 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300',
  rejected: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300',
  escalated: 'bg-orange-100 text-orange-800 dark:bg-orange-900/70 dark:text-orange-300',
  expired: 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300',
};

// Approval queue props
export interface ApprovalQueueProps {
  requests?: ApprovalRequest[];
  onApprove?: (requestId: string, comment?: string) => Promise<void>;
  onReject?: (requestId: string, comment: string) => Promise<void>;
  onEscalate?: (requestId: string, reason: string) => Promise<void>;
  onView?: (requestId: string) => void;
  className?: string;
}

export const ApprovalQueue: React.FC<ApprovalQueueProps> = ({
  requests = mockApprovalRequests,
  onApprove,
  onReject,
  onEscalate,
  onView,
  className
}) => {
  const { userData } = usePermissions();
  const [selectedRequest, setSelectedRequest] = useState<ApprovalRequest | null>(null);
  const [isDetailDialogOpen, setIsDetailDialogOpen] = useState(false);
  const [filter, setFilter] = useState<'all' | 'pending' | 'requiring_action'>('all');
  const [sortBy, setSortBy] = useState<'dueDate' | 'priority' | 'createdAt'>('dueDate');
  const [sortDirection, setSortDirection] = useState<'asc' | 'desc'>('asc');
  const [actionComment, setActionComment] = useState('');

  // Filter requests based on current user's involvement
  const userRequests = useMemo(() => {
    return requests.filter(request => 
      request.approvers.some(approver => approver.id === userData?._id) ||
      request.requestedBy.id === userData?._id
    );
  }, [requests, userData]);

  // Filter and sort requests
  const filteredRequests = useMemo(() => {
    let filtered = userRequests;

    // Apply filters
    switch (filter) {
      case 'pending':
        filtered = filtered.filter(req => req.status === 'pending');
        break;
      case 'requiring_action':
        filtered = filtered.filter(req => 
          req.status === 'pending' && 
          req.approvers.some(app => app.id === userData?._id && app.status === 'pending')
        );
        break;
    }

    // Sort
    filtered.sort((a, b) => {
      let aValue: any, bValue: any;
      
      switch (sortBy) {
        case 'dueDate':
          aValue = a.dueDate?.getTime() || Infinity;
          bValue = b.dueDate?.getTime() || Infinity;
          break;
        case 'priority':
          const priorityOrder = { urgent: 4, high: 3, medium: 2, low: 1 };
          aValue = priorityOrder[a.priority];
          bValue = priorityOrder[b.priority];
          break;
        case 'createdAt':
          aValue = a.createdAt.getTime();
          bValue = b.createdAt.getTime();
          break;
        default:
          return 0;
      }

      return sortDirection === 'asc' ? aValue - bValue : bValue - aValue;
    });

    return filtered;
  }, [userRequests, filter, sortBy, sortDirection, userData]);

  // Get urgent items count
  const urgentCount = filteredRequests.filter(req => 
    req.priority === 'urgent' && req.status === 'pending'
  ).length;

  // Get overdue items count
  const overdueCount = filteredRequests.filter(req => 
    req.dueDate && isAfter(new Date(), req.dueDate) && req.status === 'pending'
  ).length;

  // Handle approval actions
  const handleApprove = async (request: ApprovalRequest) => {
    if (!onApprove) return;
    
    try {
      await onApprove(request.id, actionComment);
      showToast.success('Request approved successfully');
      setActionComment('');
      setIsDetailDialogOpen(false);
    } catch (error) {
      showToast.error('Failed to approve request');
    }
  };

  const handleReject = async (request: ApprovalRequest) => {
    if (!onReject || !actionComment.trim()) {
      showToast.warning('Please provide a reason for rejection');
      return;
    }
    
    try {
      await onReject(request.id, actionComment);
      showToast.success('Request rejected');
      setActionComment('');
      setIsDetailDialogOpen(false);
    } catch (error) {
      showToast.error('Failed to reject request');
    }
  };

  // Get time status for a request
  const getTimeStatus = (request: ApprovalRequest) => {
    if (!request.dueDate) return null;
    
    const now = new Date();
    if (isAfter(now, request.dueDate)) {
      return { type: 'overdue', label: 'Overdue', color: 'text-red-600' };
    }
    
    const hoursUntilDue = (request.dueDate.getTime() - now.getTime()) / (1000 * 60 * 60);
    if (hoursUntilDue <= 24) {
      return { type: 'urgent', label: 'Due soon', color: 'text-orange-600' };
    }
    
    return { type: 'normal', label: formatDistanceToNow(request.dueDate, { addSuffix: true }), color: 'text-muted-foreground' };
  };

  // Approval request card component
  const ApprovalRequestCard: React.FC<{ request: ApprovalRequest }> = ({ request }) => {
    const timeStatus = getTimeStatus(request);
    const userApprover = request.approvers.find(app => app.id === userData?._id);
    const canApprove = userApprover?.status === 'pending';

    return (
      <Card className={cn(
        'cursor-pointer transition-all hover:shadow-md',
        request.priority === 'urgent' && 'ring-2 ring-red-200',
        timeStatus?.type === 'overdue' && 'bg-red-50/50'
      )}
      onClick={() => {
        setSelectedRequest(request);
        setIsDetailDialogOpen(true);
      }}>
        <CardContent className="p-4">
          <div className="flex items-start justify-between mb-3">
            <div className="flex-1">
              <h3 className="font-medium line-clamp-1 mb-1">{request.title}</h3>
              <p className="text-sm text-muted-foreground line-clamp-2">
                {request.description}
              </p>
            </div>
            <div className="flex items-center gap-2 ml-4">
              <Badge className={cn('text-xs', priorityColors[request.priority])}>
                {request.priority}
              </Badge>
              <Badge className={cn('text-xs', statusColors[request.status])}>
                {request.status}
              </Badge>
            </div>
          </div>

          <div className="flex items-center justify-between">
            <div className="flex items-center gap-4 text-sm">
              {/* Requester */}
              <div className="flex items-center gap-2">
                <Avatar className="h-6 w-6">
                  <AvatarImage src={request.requestedBy.avatar} />
                  <AvatarFallback className="text-xs">
                    {request.requestedBy.name.charAt(0)}
                  </AvatarFallback>
                </Avatar>
                <span className="text-muted-foreground">{request.requestedBy.name}</span>
              </div>

              {/* Progress */}
              <div className="flex items-center gap-2">
                <Progress 
                  value={(request.currentApprovals / request.requiredApprovals) * 100} 
                  className="h-2 w-16" 
                />
                <span className="text-xs text-muted-foreground">
                  {request.currentApprovals}/{request.requiredApprovals}
                </span>
              </div>
            </div>

            <div className="flex items-center gap-2">
              {/* Time status */}
              {timeStatus && (
                <div className={cn('flex items-center gap-1 text-xs', timeStatus.color)}>
                  <Clock className="h-3 w-3" />
                  {timeStatus.label}
                </div>
              )}

              {/* Action indicator for current user */}
              {canApprove && (
                <Badge variant="outline" className="text-xs">
                  Action Required
                </Badge>
              )}
            </div>
          </div>
        </CardContent>
      </Card>
    );
  };

  // Request detail dialog
  const RequestDetailDialog: React.FC = () => {
    if (!selectedRequest) return null;

    const userApprover = selectedRequest.approvers.find(app => app.id === userData?._id);
    const canApprove = userApprover?.status === 'pending';

    return (
      <Dialog open={isDetailDialogOpen} onOpenChange={setIsDetailDialogOpen}>
        <DialogContent className="max-w-4xl max-h-[80vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="flex items-center gap-2">
              <FileText className="h-5 w-5" />
              {selectedRequest.title}
            </DialogTitle>
          </DialogHeader>

          <Tabs defaultValue="details">
            <TabsList>
              <TabsTrigger value="details">Details</TabsTrigger>
              <TabsTrigger value="approvers">Approvers</TabsTrigger>
              <TabsTrigger value="timeline">Timeline</TabsTrigger>
            </TabsList>

            <TabsContent value="details" className="space-y-4">
              <div className="grid grid-cols-2 gap-4">
                <div>
                  <h4 className="font-medium mb-2">Request Information</h4>
                  <div className="space-y-2 text-sm">
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Type:</span>
                      <Badge variant="outline">{selectedRequest.type}</Badge>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Priority:</span>
                      <Badge className={priorityColors[selectedRequest.priority]}>
                        {selectedRequest.priority}
                      </Badge>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Status:</span>
                      <Badge className={statusColors[selectedRequest.status]}>
                        {selectedRequest.status}
                      </Badge>
                    </div>
                    <div className="flex justify-between">
                      <span className="text-muted-foreground">Created:</span>
                      <span>{format(selectedRequest.createdAt, 'MMM dd, yyyy HH:mm')}</span>
                    </div>
                    {selectedRequest.dueDate && (
                      <div className="flex justify-between">
                        <span className="text-muted-foreground">Due Date:</span>
                        <span>{format(selectedRequest.dueDate, 'MMM dd, yyyy HH:mm')}</span>
                      </div>
                    )}
                  </div>
                </div>

                <div>
                  <h4 className="font-medium mb-2">Approval Progress</h4>
                  <div className="space-y-2">
                    <div className="flex items-center gap-2">
                      <Progress 
                        value={(selectedRequest.currentApprovals / selectedRequest.requiredApprovals) * 100} 
                        className="flex-1 h-3" 
                      />
                      <span className="text-sm font-medium">
                        {selectedRequest.currentApprovals}/{selectedRequest.requiredApprovals}
                      </span>
                    </div>
                    <p className="text-xs text-muted-foreground">
                      {selectedRequest.requiredApprovals - selectedRequest.currentApprovals} more approval(s) needed
                    </p>
                  </div>
                </div>
              </div>

              {selectedRequest.description && (
                <div>
                  <h4 className="font-medium mb-2">Description</h4>
                  <p className="text-sm text-muted-foreground">{selectedRequest.description}</p>
                </div>
              )}
            </TabsContent>

            <TabsContent value="approvers" className="space-y-4">
              <h4 className="font-medium">Approvers</h4>
              <div className="space-y-3">
                {selectedRequest.approvers.map(approver => (
                  <div key={approver.id} className="flex items-center justify-between p-3 border rounded-lg">
                    <div className="flex items-center gap-3">
                      <Avatar>
                        <AvatarFallback>{approver.name.charAt(0)}</AvatarFallback>
                      </Avatar>
                      <div>
                        <p className="font-medium">{approver.name}</p>
                        <p className="text-sm text-muted-foreground">{approver.email}</p>
                      </div>
                    </div>
                    <div className="text-right">
                      <Badge className={statusColors[approver.status]}>
                        {approver.status}
                      </Badge>
                      {approver.respondedAt && (
                        <p className="text-xs text-muted-foreground mt-1">
                          {format(approver.respondedAt, 'MMM dd, HH:mm')}
                        </p>
                      )}
                    </div>
                  </div>
                ))}
              </div>
            </TabsContent>

            <TabsContent value="timeline" className="space-y-4">
              <h4 className="font-medium">Timeline</h4>
              <div className="space-y-3">
                <div className="flex items-start gap-3 p-3 border rounded-lg">
                  <div className="w-2 h-2 bg-blue-600 rounded-full mt-2"></div>
                  <div className="flex-1">
                    <p className="font-medium">Request Created</p>
                    <p className="text-sm text-muted-foreground">
                      By {selectedRequest.requestedBy.name}  {format(selectedRequest.createdAt, 'MMM dd, yyyy HH:mm')}
                    </p>
                  </div>
                </div>

                {selectedRequest.approvers
                  .filter(app => app.respondedAt)
                  .map(approver => (
                    <div key={approver.id} className="flex items-start gap-3 p-3 border rounded-lg">
                      <div className={cn(
                        'w-2 h-2 rounded-full mt-2',
                        approver.status === 'approved' ? 'bg-green-600' : 'bg-red-600'
                      )}></div>
                      <div className="flex-1">
                        <p className="font-medium">
                          {approver.status === 'approved' ? 'Approved' : 'Rejected'} by {approver.name}
                        </p>
                        {approver.comment && (
                          <p className="text-sm text-muted-foreground mt-1">"{approver.comment}"</p>
                        )}
                        <p className="text-xs text-muted-foreground">
                          {approver.respondedAt && format(approver.respondedAt, 'MMM dd, yyyy HH:mm')}
                        </p>
                      </div>
                    </div>
                  ))
                }
              </div>
            </TabsContent>
          </Tabs>

          {/* Actions */}
          {canApprove && (
            <div className="border-t pt-4 space-y-4">
              <div>
                <Label className="text-sm font-medium">Comment (optional for approval, required for rejection)</Label>
                <Textarea
                  value={actionComment}
                  onChange={(e) => setActionComment(e.target.value)}
                  placeholder="Add your comment..."
                  className="mt-1"
                />
              </div>
              
              <div className="flex justify-end gap-2">
                <Button
                  variant="outline"
                  onClick={() => handleReject(selectedRequest)}
                  disabled={!actionComment.trim()}
                >
                  <XCircle className="h-4 w-4 mr-2" />
                  Reject
                </Button>
                <Button onClick={() => handleApprove(selectedRequest)}>
                  <CheckCircle className="h-4 w-4 mr-2" />
                  Approve
                </Button>
              </div>
            </div>
          )}
        </DialogContent>
      </Dialog>
    );
  };

  return (
    <div className={cn('space-y-6', className)}>
      {/* Header */}
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-2xl font-semibold">Approval Queue</h2>
          <p className="text-muted-foreground">
            {filteredRequests.length} pending approval{filteredRequests.length !== 1 ? 's' : ''}
          </p>
        </div>

        {/* Alerts */}
        {(urgentCount > 0 || overdueCount > 0) && (
          <div className="flex gap-2">
            {urgentCount > 0 && (
              <Alert className="border-orange-200 bg-orange-50">
                <AlertTriangle className="h-4 w-4" />
                <AlertDescription>
                  {urgentCount} urgent request{urgentCount !== 1 ? 's' : ''} require attention
                </AlertDescription>
              </Alert>
            )}
            {overdueCount > 0 && (
              <Alert className="border-red-200 bg-red-50">
                <AlertTriangle className="h-4 w-4" />
                <AlertDescription>
                  {overdueCount} overdue request{overdueCount !== 1 ? 's' : ''}
                </AlertDescription>
              </Alert>
            )}
          </div>
        )}
      </div>

      {/* Filters and controls */}
      <div className="flex items-center gap-4">
        <Select value={filter} onValueChange={(value: any) => setFilter(value)}>
          <SelectTrigger className="w-48">
            <Filter className="h-4 w-4 mr-2" />
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Requests</SelectItem>
            <SelectItem value="pending">Pending</SelectItem>
            <SelectItem value="requiring_action">Requiring My Action</SelectItem>
          </SelectContent>
        </Select>

        <Select value={sortBy} onValueChange={(value: any) => setSortBy(value)}>
          <SelectTrigger className="w-40">
            <SelectValue />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="dueDate">Due Date</SelectItem>
            <SelectItem value="priority">Priority</SelectItem>
            <SelectItem value="createdAt">Created Date</SelectItem>
          </SelectContent>
        </Select>

        <Button
          variant="outline"
          onClick={() => setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc')}
          className="px-3"
        >
          {sortDirection === 'asc' ? <SortAsc className="h-4 w-4" /> : <SortDesc className="h-4 w-4" />}
        </Button>
      </div>

      {/* Request list */}
      <div className="space-y-3">
        {filteredRequests.map(request => (
          <ApprovalRequestCard key={request.id} request={request} />
        ))}

        {filteredRequests.length === 0 && (
          <div className="text-center py-12">
            <CheckCircle className="h-16 w-16 text-muted-foreground mx-auto mb-4" />
            <h3 className="text-lg font-medium text-muted-foreground">All caught up!</h3>
            <p className="text-muted-foreground">No approval requests at the moment.</p>
          </div>
        )}
      </div>

      {/* Detail dialog */}
      <RequestDetailDialog />
    </div>
  );
};

export default ApprovalQueue;
</file>

<file path="src/app/_components/workflow/WorkflowDesigner.tsx">
'use client';

import React, { useState, useCallback, useMemo } from 'react';
import { 
  Play, 
  Square, 
  Diamond, 
  Circle, 
  ArrowRight, 
  Plus, 
  Trash2, 
  Settings, 
  Copy,
  Save,
  Eye,
  Edit,
  Users,
  Clock,
  CheckCircle,
  XCircle,
  AlertTriangle,
  MoreVertical,
  Zap
} from 'lucide-react';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Textarea } from '@/components/ui/textarea';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { Dialog, DialogContent, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { DropdownMenu, DropdownMenuContent, DropdownMenuItem, DropdownMenuTrigger } from '@/components/ui/dropdown-menu';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Switch } from '@/components/ui/switch';
import { cn } from '@/lib/utils';
import { showToast } from '../common/ToastNotifications';

// Workflow node types
export type WorkflowNodeType = 'start' | 'approval' | 'condition' | 'action' | 'end';

// Workflow node structure
export interface WorkflowNode {
  id: string;
  type: WorkflowNodeType;
  title: string;
  description?: string;
  position: { x: number; y: number };
  data: {
    approvers?: string[];
    requiredApprovals?: number;
    condition?: string;
    action?: string;
    timeLimit?: number;
    autoApprove?: boolean;
    escalation?: {
      enabled: boolean;
      timeLimit: number;
      escalateTo: string[];
    };
  };
  connections: string[]; // IDs of connected nodes
}

// Workflow definition
export interface Workflow {
  id: string;
  name: string;
  description?: string;
  category: 'contract' | 'vendor' | 'general';
  status: 'draft' | 'active' | 'inactive';
  nodes: WorkflowNode[];
  trigger: {
    type: 'manual' | 'automatic';
    conditions?: string[];
  };
  createdAt: Date;
  updatedAt: Date;
}

// Node type configurations
const nodeTypeConfig = {
  start: {
    icon: Play,
    label: 'Start',
    color: 'bg-green-100 text-green-800 border-green-200',
    description: 'Workflow starting point'
  },
  approval: {
    icon: Users,
    label: 'Approval',
    color: 'bg-blue-100 text-blue-800 border-blue-200',
    description: 'Requires approval from specified users'
  },
  condition: {
    icon: Diamond,
    label: 'Condition',
    color: 'bg-yellow-100 text-yellow-800 border-yellow-200',
    description: 'Conditional branching based on criteria'
  },
  action: {
    icon: Zap,
    label: 'Action',
    color: 'bg-purple-100 text-purple-800 border-purple-200',
    description: 'Automated action or task'
  },
  end: {
    icon: Square,
    label: 'End',
    color: 'bg-gray-100 text-gray-800 border-gray-200',
    description: 'Workflow completion point'
  }
};

// Workflow designer component
export interface WorkflowDesignerProps {
  workflow?: Workflow;
  onSave?: (workflow: Workflow) => Promise<void>;
  onPreview?: (workflow: Workflow) => void;
  readonly?: boolean;
  className?: string;
}

export const WorkflowDesigner: React.FC<WorkflowDesignerProps> = ({
  workflow: initialWorkflow,
  onSave,
  onPreview,
  readonly = false,
  className
}) => {
  // State
  const [workflow, setWorkflow] = useState<Workflow>(
    initialWorkflow || {
      id: `workflow_${Date.now()}`,
      name: 'New Workflow',
      description: '',
      category: 'contract',
      status: 'draft',
      nodes: [],
      trigger: { type: 'manual' },
      createdAt: new Date(),
      updatedAt: new Date()
    }
  );

  const [selectedNode, setSelectedNode] = useState<WorkflowNode | null>(null);
  const [isNodeDialogOpen, setIsNodeDialogOpen] = useState(false);
  const [draggedNodeType, setDraggedNodeType] = useState<WorkflowNodeType | null>(null);
  const [isConnecting, setIsConnecting] = useState<string | null>(null);

  // Add node to workflow
  const addNode = useCallback((type: WorkflowNodeType, position: { x: number; y: number }) => {
    const newNode: WorkflowNode = {
      id: `node_${Date.now()}`,
      type,
      title: `${nodeTypeConfig[type].label} ${workflow.nodes.length + 1}`,
      position,
      data: {},
      connections: []
    };

    setWorkflow(prev => ({
      ...prev,
      nodes: [...prev.nodes, newNode],
      updatedAt: new Date()
    }));

    return newNode;
  }, [workflow.nodes.length]);

  // Update node
  const updateNode = useCallback((nodeId: string, updates: Partial<WorkflowNode>) => {
    setWorkflow(prev => ({
      ...prev,
      nodes: prev.nodes.map(node => 
        node.id === nodeId ? { ...node, ...updates } : node
      ),
      updatedAt: new Date()
    }));
  }, []);

  // Delete node
  const deleteNode = useCallback((nodeId: string) => {
    setWorkflow(prev => ({
      ...prev,
      nodes: prev.nodes.filter(node => node.id !== nodeId)
        .map(node => ({
          ...node,
          connections: node.connections.filter(conn => conn !== nodeId)
        })),
      updatedAt: new Date()
    }));
  }, []);

  // Connect nodes
  const connectNodes = useCallback((fromId: string, toId: string) => {
    setWorkflow(prev => ({
      ...prev,
      nodes: prev.nodes.map(node =>
        node.id === fromId 
          ? { ...node, connections: [...node.connections, toId] }
          : node
      ),
      updatedAt: new Date()
    }));
  }, []);

  // Handle canvas drop
  const handleCanvasDrop = useCallback((e: React.DragEvent) => {
    e.preventDefault();
    if (!draggedNodeType) return;

    const rect = e.currentTarget.getBoundingClientRect();
    const position = {
      x: e.clientX - rect.left,
      y: e.clientY - rect.top
    };

    addNode(draggedNodeType, position);
    setDraggedNodeType(null);
  }, [draggedNodeType, addNode]);

  // Handle save
  const handleSave = async () => {
    if (!onSave) return;

    try {
      await onSave(workflow);
      showToast.success('Workflow saved successfully');
    } catch (error) {
      showToast.error('Failed to save workflow');
    }
  };

  // Node component
  const WorkflowNodeComponent: React.FC<{ node: WorkflowNode }> = ({ node }) => {
    const config = nodeTypeConfig[node.type];
    const IconComponent = config.icon;

    return (
      <div
        className={cn(
          'absolute border-2 rounded-lg p-3 bg-background shadow-md cursor-pointer transition-all hover:shadow-lg',
          config.color,
          selectedNode?.id === node.id && 'ring-2 ring-primary'
        )}
        style={{
          left: node.position.x,
          top: node.position.y,
          width: '180px'
        }}
        onClick={() => setSelectedNode(node)}
        onDoubleClick={() => setIsNodeDialogOpen(true)}
      >
        <div className="flex items-center gap-2 mb-2">
          <IconComponent className="h-4 w-4" />
          <span className="font-medium text-sm truncate">{node.title}</span>
        </div>
        
        {node.description && (
          <p className="text-xs text-muted-foreground line-clamp-2">
            {node.description}
          </p>
        )}

        {/* Connection indicators */}
        {node.connections.length > 0 && (
          <div className="absolute -right-2 top-1/2 transform -translate-y-1/2">
            <div className="w-4 h-4 bg-primary rounded-full flex items-center justify-center">
              <ArrowRight className="h-2 w-2 text-primary-foreground" />
            </div>
          </div>
        )}

        {/* Node actions */}
        {!readonly && (
          <div className="absolute -top-2 -right-2">
            <DropdownMenu>
              <DropdownMenuTrigger asChild>
                <Button variant="ghost" size="sm" className="h-6 w-6 p-0 bg-background shadow-sm">
                  <MoreVertical className="h-3 w-3" />
                </Button>
              </DropdownMenuTrigger>
              <DropdownMenuContent>
                <DropdownMenuItem onClick={() => setIsNodeDialogOpen(true)}>
                  <Edit className="h-4 w-4 mr-2" />
                  Edit
                </DropdownMenuItem>
                <DropdownMenuItem onClick={() => {
                  const newNode = { ...node, id: `node_${Date.now()}`, position: { x: node.position.x + 200, y: node.position.y } };
                  setWorkflow(prev => ({ ...prev, nodes: [...prev.nodes, newNode] }));
                }}>
                  <Copy className="h-4 w-4 mr-2" />
                  Duplicate
                </DropdownMenuItem>
                <DropdownMenuItem 
                  onClick={() => deleteNode(node.id)}
                  className="text-destructive"
                >
                  <Trash2 className="h-4 w-4 mr-2" />
                  Delete
                </DropdownMenuItem>
              </DropdownMenuContent>
            </DropdownMenu>
          </div>
        )}
      </div>
    );
  };

  // Node palette
  const NodePalette: React.FC = () => (
    <Card className="w-64">
      <CardHeader>
        <CardTitle className="text-sm">Workflow Elements</CardTitle>
      </CardHeader>
      <CardContent className="space-y-2">
        {Object.entries(nodeTypeConfig).map(([type, config]) => {
          const IconComponent = config.icon;
          return (
            <div
              key={type}
              draggable
              onDragStart={() => setDraggedNodeType(type as WorkflowNodeType)}
              className={cn(
                'flex items-center gap-2 p-2 rounded border cursor-move transition-colors hover:bg-muted',
                config.color
              )}
            >
              <IconComponent className="h-4 w-4" />
              <div className="flex-1">
                <p className="font-medium text-xs">{config.label}</p>
                <p className="text-xs opacity-75">{config.description}</p>
              </div>
            </div>
          );
        })}
      </CardContent>
    </Card>
  );

  // Node editor dialog
  const NodeEditorDialog: React.FC = () => {
    if (!selectedNode) return null;

    return (
      <Dialog open={isNodeDialogOpen} onOpenChange={setIsNodeDialogOpen}>
        <DialogContent className="max-w-2xl">
          <DialogHeader>
            <DialogTitle>Edit {nodeTypeConfig[selectedNode.type].label}</DialogTitle>
          </DialogHeader>

          <Tabs defaultValue="general">
            <TabsList>
              <TabsTrigger value="general">General</TabsTrigger>
              <TabsTrigger value="settings">Settings</TabsTrigger>
              <TabsTrigger value="conditions">Conditions</TabsTrigger>
            </TabsList>

            <TabsContent value="general" className="space-y-4">
              <div>
                <Label htmlFor="title">Title</Label>
                <Input
                  id="title"
                  value={selectedNode.title}
                  onChange={(e) => updateNode(selectedNode.id, { title: e.target.value })}
                />
              </div>
              
              <div>
                <Label htmlFor="description">Description</Label>
                <Textarea
                  id="description"
                  value={selectedNode.description || ''}
                  onChange={(e) => updateNode(selectedNode.id, { description: e.target.value })}
                />
              </div>
            </TabsContent>

            <TabsContent value="settings" className="space-y-4">
              {selectedNode.type === 'approval' && (
                <>
                  <div>
                    <Label>Required Approvals</Label>
                    <Input
                      type="number"
                      value={selectedNode.data.requiredApprovals || 1}
                      onChange={(e) => updateNode(selectedNode.id, {
                        data: { ...selectedNode.data, requiredApprovals: parseInt(e.target.value) }
                      })}
                    />
                  </div>
                  
                  <div>
                    <Label>Time Limit (hours)</Label>
                    <Input
                      type="number"
                      value={selectedNode.data.timeLimit || 24}
                      onChange={(e) => updateNode(selectedNode.id, {
                        data: { ...selectedNode.data, timeLimit: parseInt(e.target.value) }
                      })}
                    />
                  </div>

                  <div className="flex items-center space-x-2">
                    <Switch
                      checked={selectedNode.data.autoApprove || false}
                      onCheckedChange={(checked) => updateNode(selectedNode.id, {
                        data: { ...selectedNode.data, autoApprove: checked }
                      })}
                    />
                    <Label>Auto-approve if no response</Label>
                  </div>
                </>
              )}

              {selectedNode.type === 'condition' && (
                <div>
                  <Label>Condition Logic</Label>
                  <Textarea
                    placeholder="e.g., contract.value > 10000"
                    value={selectedNode.data.condition || ''}
                    onChange={(e) => updateNode(selectedNode.id, {
                      data: { ...selectedNode.data, condition: e.target.value }
                    })}
                  />
                </div>
              )}

              {selectedNode.type === 'action' && (
                <div>
                  <Label>Action Type</Label>
                  <Select
                    value={selectedNode.data.action || ''}
                    onValueChange={(value) => updateNode(selectedNode.id, {
                      data: { ...selectedNode.data, action: value }
                    })}
                  >
                    <SelectTrigger>
                      <SelectValue placeholder="Select action..." />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="send_email">Send Email</SelectItem>
                      <SelectItem value="update_status">Update Status</SelectItem>
                      <SelectItem value="create_task">Create Task</SelectItem>
                      <SelectItem value="send_notification">Send Notification</SelectItem>
                    </SelectContent>
                  </Select>
                </div>
              )}
            </TabsContent>

            <TabsContent value="conditions" className="space-y-4">
              <div>
                <Label>Escalation Settings</Label>
                <div className="space-y-2">
                  <div className="flex items-center space-x-2">
                    <Switch
                      checked={selectedNode.data.escalation?.enabled || false}
                      onCheckedChange={(checked) => updateNode(selectedNode.id, {
                        data: {
                          ...selectedNode.data,
                          escalation: { ...selectedNode.data.escalation, enabled: checked }
                        }
                      })}
                    />
                    <Label>Enable escalation</Label>
                  </div>
                </div>
              </div>
            </TabsContent>
          </Tabs>

          <div className="flex justify-end gap-2 pt-4">
            <Button variant="outline" onClick={() => setIsNodeDialogOpen(false)}>
              Cancel
            </Button>
            <Button onClick={() => setIsNodeDialogOpen(false)}>
              Save Changes
            </Button>
          </div>
        </DialogContent>
      </Dialog>
    );
  };

  return (
    <div className={cn('flex h-full bg-background', className)}>
      {/* Left sidebar - Node palette */}
      {!readonly && <NodePalette />}

      {/* Main canvas area */}
      <div className="flex-1 flex flex-col">
        {/* Toolbar */}
        <div className="border-b p-4 flex items-center justify-between bg-background">
          <div className="flex items-center gap-4">
            <div>
              <Input
                value={workflow.name}
                onChange={(e) => setWorkflow(prev => ({ ...prev, name: e.target.value }))}
                className="font-medium"
                placeholder="Workflow name..."
              />
              <p className="text-xs text-muted-foreground mt-1">
                {workflow.nodes.length} nodes  {workflow.status}
              </p>
            </div>
            
            <Badge variant={workflow.status === 'active' ? 'default' : 'secondary'}>
              {workflow.status}
            </Badge>
          </div>

          <div className="flex items-center gap-2">
            {onPreview && (
              <Button variant="outline" onClick={() => onPreview(workflow)}>
                <Eye className="h-4 w-4 mr-2" />
                Preview
              </Button>
            )}
            
            {!readonly && onSave && (
              <Button onClick={handleSave}>
                <Save className="h-4 w-4 mr-2" />
                Save Workflow
              </Button>
            )}
          </div>
        </div>

        {/* Canvas */}
        <div
          className="flex-1 relative overflow-auto bg-grid-pattern"
          onDrop={handleCanvasDrop}
          onDragOver={(e) => e.preventDefault()}
          style={{
            backgroundImage: `radial-gradient(circle, #e5e7eb 1px, transparent 1px)`,
            backgroundSize: '20px 20px'
          }}
        >
          {/* Workflow nodes */}
          {workflow.nodes.map(node => (
            <WorkflowNodeComponent key={node.id} node={node} />
          ))}

          {/* Connection lines */}
          <svg className="absolute inset-0 pointer-events-none" style={{ zIndex: 1 }}>
            {workflow.nodes.map(node =>
              node.connections.map(targetId => {
                const targetNode = workflow.nodes.find(n => n.id === targetId);
                if (!targetNode) return null;

                return (
                  <line
                    key={`${node.id}-${targetId}`}
                    x1={node.position.x + 180}
                    y1={node.position.y + 40}
                    x2={targetNode.position.x}
                    y2={targetNode.position.y + 40}
                    stroke="#6b7280"
                    strokeWidth="2"
                    markerEnd="url(#arrowhead)"
                  />
                );
              })
            )}
            
            {/* Arrow marker */}
            <defs>
              <marker
                id="arrowhead"
                markerWidth="10"
                markerHeight="7"
                refX="9"
                refY="3.5"
                orient="auto"
              >
                <polygon
                  points="0 0, 10 3.5, 0 7"
                  fill="#6b7280"
                />
              </marker>
            </defs>
          </svg>

          {/* Empty state */}
          {workflow.nodes.length === 0 && (
            <div className="absolute inset-0 flex items-center justify-center">
              <div className="text-center space-y-4">
                <div className="w-16 h-16 bg-muted rounded-full flex items-center justify-center mx-auto">
                  <Play className="h-8 w-8 text-muted-foreground" />
                </div>
                <div>
                  <h3 className="font-medium">Start building your workflow</h3>
                  <p className="text-sm text-muted-foreground">
                    Drag elements from the palette to create your approval process
                  </p>
                </div>
              </div>
            </div>
          )}
        </div>
      </div>

      {/* Node editor dialog */}
      <NodeEditorDialog />
    </div>
  );
};

export default WorkflowDesigner;
</file>

<file path="src/app/_components/workflow/WorkflowStatus.tsx">
'use client';

import React, { useMemo } from 'react';
import { format, formatDistanceToNow, isAfter } from 'date-fns';
import { 
  CheckCircle, 
  Clock, 
  AlertCircle, 
  XCircle, 
  Play, 
  Pause, 
  RotateCcw,
  ArrowRight,
  User,
  Users,
  Zap,
  AlertTriangle,
  Calendar,
  Timer,
  Activity,
  Eye,
  MessageSquare
} from 'lucide-react';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
import { Badge } from '@/components/ui/badge';
import { Progress } from '@/components/ui/progress';
import { Avatar, AvatarFallback, AvatarImage } from '@/components/ui/avatar';
import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';
import { cn } from '@/lib/utils';

// Workflow execution status
export type WorkflowExecutionStatus = 'running' | 'completed' | 'failed' | 'paused' | 'cancelled';

// Workflow step status
export type WorkflowStepStatus = 'pending' | 'running' | 'completed' | 'failed' | 'skipped' | 'waiting_approval';

// Workflow step definition
export interface WorkflowStep {
  id: string;
  title: string;
  type: 'start' | 'approval' | 'condition' | 'action' | 'end';
  status: WorkflowStepStatus;
  assignedTo?: {
    id: string;
    name: string;
    avatar?: string;
  }[];
  startedAt?: Date;
  completedAt?: Date;
  dueDate?: Date;
  duration?: number; // in milliseconds
  output?: any;
  error?: string;
  comments?: {
    id: string;
    author: string;
    content: string;
    timestamp: Date;
  }[];
}

// Workflow execution instance
export interface WorkflowExecution {
  id: string;
  workflowId: string;
  workflowName: string;
  status: WorkflowExecutionStatus;
  steps: WorkflowStep[];
  currentStepIndex: number;
  triggeredBy: {
    id: string;
    name: string;
    avatar?: string;
  };
  startedAt: Date;
  completedAt?: Date;
  estimatedCompletion?: Date;
  context: {
    entityType: 'contract' | 'vendor' | 'general';
    entityId?: string;
    entityTitle?: string;
  };
  metadata?: Record<string, any>;
}

// Step status configurations
const stepStatusConfig = {
  pending: {
    icon: Clock,
    color: 'text-gray-500',
    bgColor: 'bg-gray-100',
    label: 'Pending'
  },
  running: {
    icon: Play,
    color: 'text-blue-600',
    bgColor: 'bg-blue-100',
    label: 'Running'
  },
  completed: {
    icon: CheckCircle,
    color: 'text-green-600',
    bgColor: 'bg-green-100',
    label: 'Completed'
  },
  failed: {
    icon: XCircle,
    color: 'text-red-600',
    bgColor: 'bg-red-100',
    label: 'Failed'
  },
  skipped: {
    icon: ArrowRight,
    color: 'text-gray-400',
    bgColor: 'bg-gray-50',
    label: 'Skipped'
  },
  waiting_approval: {
    icon: Users,
    color: 'text-yellow-600',
    bgColor: 'bg-yellow-100',
    label: 'Waiting for Approval'
  }
};

// Workflow status component props
export interface WorkflowStatusProps {
  execution: WorkflowExecution;
  variant?: 'full' | 'compact' | 'minimal';
  showDetails?: boolean;
  onStepClick?: (step: WorkflowStep) => void;
  onViewExecution?: (execution: WorkflowExecution) => void;
  className?: string;
}

export const WorkflowStatus: React.FC<WorkflowStatusProps> = ({
  execution,
  variant = 'full',
  showDetails = true,
  onStepClick,
  onViewExecution,
  className
}) => {
  // Calculate workflow progress
  const progress = useMemo(() => {
    const completedSteps = execution.steps.filter(step => 
      step.status === 'completed' || step.status === 'skipped'
    ).length;
    return (completedSteps / execution.steps.length) * 100;
  }, [execution.steps]);

  // Calculate total duration
  const totalDuration = useMemo(() => {
    if (!execution.completedAt) return null;
    return execution.completedAt.getTime() - execution.startedAt.getTime();
  }, [execution.startedAt, execution.completedAt]);

  // Get estimated completion
  const getEstimatedCompletion = () => {
    if (execution.status === 'completed') return null;
    if (execution.estimatedCompletion) return execution.estimatedCompletion;
    
    // Simple estimation based on average step duration
    const completedSteps = execution.steps.filter(s => s.completedAt && s.startedAt);
    if (completedSteps.length === 0) return null;
    
    const avgDuration = completedSteps.reduce((sum, step) => 
      sum + (step.completedAt!.getTime() - step.startedAt!.getTime()), 0
    ) / completedSteps.length;
    
    const remainingSteps = execution.steps.length - execution.currentStepIndex;
    return new Date(Date.now() + (avgDuration * remainingSteps));
  };

  // Get current step
  const currentStep = execution.steps[execution.currentStepIndex];

  // Step component
  const WorkflowStepComponent: React.FC<{ 
    step: WorkflowStep; 
    index: number; 
    isActive: boolean;
    isLast: boolean;
  }> = ({ step, index, isActive, isLast }) => {
    const config = stepStatusConfig[step.status];
    const IconComponent = config.icon;
    const isOverdue = step.dueDate && isAfter(new Date(), step.dueDate) && step.status !== 'completed';

    return (
      <TooltipProvider>
        <div className="flex items-start gap-3">
          {/* Step indicator */}
          <div className="flex flex-col items-center">
            <Tooltip>
              <TooltipTrigger asChild>
                <div
                  className={cn(
                    'w-8 h-8 rounded-full flex items-center justify-center transition-all cursor-pointer',
                    config.bgColor,
                    isActive && 'ring-2 ring-primary ring-offset-1',
                    isOverdue && 'ring-2 ring-red-300'
                  )}
                  onClick={() => onStepClick?.(step)}
                >
                  <IconComponent className={cn('h-4 w-4', config.color)} />
                </div>
              </TooltipTrigger>
              <TooltipContent>
                <div className="space-y-1">
                  <p className="font-medium">{step.title}</p>
                  <p className="text-xs">{config.label}</p>
                  {step.dueDate && (
                    <p className="text-xs">Due: {format(step.dueDate, 'MMM dd, HH:mm')}</p>
                  )}
                </div>
              </TooltipContent>
            </Tooltip>

            {/* Connection line */}
            {!isLast && (
              <div className={cn(
                'w-0.5 h-8 mt-2 transition-colors',
                step.status === 'completed' ? 'bg-green-300' : 'bg-gray-200'
              )} />
            )}
          </div>

          {/* Step content */}
          <div className="flex-1 pb-6">
            <div className="flex items-start justify-between">
              <div className="flex-1">
                <h4 className={cn(
                  'font-medium text-sm',
                  isActive && 'text-primary'
                )}>
                  {step.title}
                </h4>
                
                {/* Step details */}
                <div className="flex items-center gap-3 mt-1 text-xs text-muted-foreground">
                  <Badge variant="outline" className={cn('text-xs', config.color)}>
                    {config.label}
                  </Badge>
                  
                  {step.assignedTo && step.assignedTo.length > 0 && (
                    <div className="flex items-center gap-1">
                      <Users className="h-3 w-3" />
                      <span>{step.assignedTo.map(a => a.name).join(', ')}</span>
                    </div>
                  )}
                  
                  {step.duration && (
                    <div className="flex items-center gap-1">
                      <Timer className="h-3 w-3" />
                      <span>{Math.round(step.duration / 1000 / 60)}m</span>
                    </div>
                  )}
                </div>

                {/* Error message */}
                {step.error && (
                  <div className="mt-2 p-2 bg-red-50 border border-red-200 rounded text-xs text-red-700">
                    <AlertTriangle className="h-3 w-3 inline mr-1" />
                    {step.error}
                  </div>
                )}

                {/* Overdue warning */}
                {isOverdue && (
                  <div className="mt-2 flex items-center gap-1 text-xs text-red-600">
                    <AlertTriangle className="h-3 w-3" />
                    Overdue by {formatDistanceToNow(step.dueDate!)}
                  </div>
                )}
              </div>

              {/* Timestamps */}
              <div className="text-right text-xs text-muted-foreground">
                {step.startedAt && (
                  <div>Started: {format(step.startedAt, 'HH:mm')}</div>
                )}
                {step.completedAt && (
                  <div>Completed: {format(step.completedAt, 'HH:mm')}</div>
                )}
              </div>
            </div>
          </div>
        </div>
      </TooltipProvider>
    );
  };

  // Compact variant
  if (variant === 'compact') {
    return (
      <Card className={cn('cursor-pointer hover:shadow-md transition-shadow', className)}
            onClick={() => onViewExecution?.(execution)}>
        <CardContent className="p-4">
          <div className="flex items-center justify-between">
            <div className="flex items-center gap-3">
              <div className={cn(
                'w-3 h-3 rounded-full',
                execution.status === 'running' && 'bg-blue-500',
                execution.status === 'completed' && 'bg-green-500',
                execution.status === 'failed' && 'bg-red-500',
                execution.status === 'paused' && 'bg-yellow-500'
              )} />
              
              <div>
                <p className="font-medium text-sm">{execution.workflowName}</p>
                <p className="text-xs text-muted-foreground">
                  {execution.context.entityTitle || execution.context.entityType}
                </p>
              </div>
            </div>

            <div className="flex items-center gap-2">
              <Progress value={progress} className="w-20 h-2" />
              <span className="text-xs text-muted-foreground">
                {Math.round(progress)}%
              </span>
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  // Minimal variant
  if (variant === 'minimal') {
    return (
      <div className={cn('flex items-center gap-2', className)}>
        <div className={cn(
          'w-2 h-2 rounded-full',
          execution.status === 'running' && 'bg-blue-500 animate-pulse',
          execution.status === 'completed' && 'bg-green-500',
          execution.status === 'failed' && 'bg-red-500',
          execution.status === 'paused' && 'bg-yellow-500'
        )} />
        <span className="text-sm text-muted-foreground">
          Workflow {execution.status}
        </span>
      </div>
    );
  }

  // Full variant
  const estimatedCompletion = getEstimatedCompletion();

  return (
    <Card className={className}>
      <CardHeader>
        <div className="flex items-start justify-between">
          <div>
            <CardTitle className="text-lg">{execution.workflowName}</CardTitle>
            <div className="flex items-center gap-2 mt-1">
              <Badge variant={execution.status === 'completed' ? 'default' : 'secondary'}>
                {execution.status}
              </Badge>
              <span className="text-sm text-muted-foreground">
                for {execution.context.entityTitle || execution.context.entityType}
              </span>
            </div>
          </div>

          {onViewExecution && (
            <Button variant="outline" size="sm" onClick={() => onViewExecution(execution)}>
              <Eye className="h-4 w-4 mr-2" />
              View Details
            </Button>
          )}
        </div>

        {/* Progress overview */}
        <div className="space-y-2">
          <div className="flex items-center justify-between text-sm">
            <span>Progress</span>
            <span className="text-muted-foreground">
              {execution.steps.filter(s => s.status === 'completed').length} of {execution.steps.length} steps
            </span>
          </div>
          <Progress value={progress} className="h-2" />
        </div>

        {/* Timing information */}
        <div className="grid grid-cols-2 md:grid-cols-4 gap-4 text-sm">
          <div>
            <p className="text-muted-foreground">Started</p>
            <p className="font-medium">{format(execution.startedAt, 'MMM dd, HH:mm')}</p>
          </div>
          
          {execution.completedAt && (
            <div>
              <p className="text-muted-foreground">Completed</p>
              <p className="font-medium">{format(execution.completedAt, 'MMM dd, HH:mm')}</p>
            </div>
          )}
          
          {totalDuration && (
            <div>
              <p className="text-muted-foreground">Duration</p>
              <p className="font-medium">
                {Math.round(totalDuration / 1000 / 60)} minutes
              </p>
            </div>
          )}
          
          {estimatedCompletion && execution.status === 'running' && (
            <div>
              <p className="text-muted-foreground">Est. Completion</p>
              <p className="font-medium">{format(estimatedCompletion, 'HH:mm')}</p>
            </div>
          )}
        </div>
      </CardHeader>

      {showDetails && (
        <CardContent className="pt-0">
          {/* Current step highlight */}
          {currentStep && execution.status === 'running' && (
            <div className="mb-6 p-3 bg-blue-50 border border-blue-200 rounded-lg">
              <div className="flex items-center gap-2 mb-2">
                <Activity className="h-4 w-4 text-blue-600" />
                <span className="font-medium text-blue-900">Currently Running</span>
              </div>
              <p className="text-sm text-blue-800">{currentStep.title}</p>
              {currentStep.assignedTo && currentStep.assignedTo.length > 0 && (
                <div className="flex items-center gap-2 mt-2">
                  <span className="text-xs text-blue-700">Assigned to:</span>
                  <div className="flex gap-1">
                    {currentStep.assignedTo.map(assignee => (
                      <Avatar key={assignee.id} className="h-5 w-5">
                        <AvatarImage src={assignee.avatar} />
                        <AvatarFallback className="text-xs">
                          {assignee.name.charAt(0)}
                        </AvatarFallback>
                      </Avatar>
                    ))}
                  </div>
                </div>
              )}
            </div>
          )}

          {/* Steps timeline */}
          <div className="space-y-0">
            {execution.steps.map((step, index) => (
              <WorkflowStepComponent
                key={step.id}
                step={step}
                index={index}
                isActive={index === execution.currentStepIndex}
                isLast={index === execution.steps.length - 1}
              />
            ))}
          </div>
        </CardContent>
      )}
    </Card>
  );
};

// Workflow status list component
export interface WorkflowStatusListProps {
  executions: WorkflowExecution[];
  variant?: 'full' | 'compact';
  onExecutionClick?: (execution: WorkflowExecution) => void;
  className?: string;
}

export const WorkflowStatusList: React.FC<WorkflowStatusListProps> = ({
  executions,
  variant = 'compact',
  onExecutionClick,
  className
}) => {
  if (executions.length === 0) {
    return (
      <div className="text-center py-8">
        <Activity className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
        <p className="text-muted-foreground">No active workflows</p>
      </div>
    );
  }

  return (
    <div className={cn('space-y-4', className)}>
      {executions.map(execution => (
        <WorkflowStatus
          key={execution.id}
          execution={execution}
          variant={variant}
          onViewExecution={onExecutionClick}
          showDetails={variant === 'full'}
        />
      ))}
    </div>
  );
};

export default WorkflowStatus;
</file>

<file path="src/app/auth/[...clerk]/page.tsx">
'use client';

import { ClerkLoaded, ClerkLoading } from "@clerk/clerk-react";

export default function ClerkAuthPage() {
  return (
    <div className="relative bg-gradient-to-b from-slate-50 to-transparent min-h-screen flex items-center justify-center">
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-0 right-0 w-1/3 h-1/3 bg-gradient-to-br from-gold/10 to-transparent" />
        <div className="absolute bottom-0 left-0 w-1/4 h-1/4 bg-gradient-to-tr from-primary/5 to-transparent" />
      </div>
      
      <div className="relative z-10">
        <ClerkLoading>
          <div className="text-center">
            <div className="mb-4 p-3 bg-primary/5 rounded-sm inline-block">
              <div className="w-10 h-10 border-t-2 border-gold animate-spin rounded-full"></div>
            </div>
            <p className="text-muted-foreground">Loading authentication...</p>
          </div>
        </ClerkLoading>
        
        <ClerkLoaded>
          <div className="text-center">
            <p className="text-muted-foreground">Redirecting...</p>
          </div>
        </ClerkLoaded>
      </div>
    </div>
  );
}
</file>

<file path="src/app/dashboard/contracts/[id]/page.tsx">
'use client'

import React from 'react';
import { useParams } from 'next/navigation';
import dynamic from 'next/dynamic';
import { Id } from '../../../../../convex/_generated/dataModel';
import LoadingSpinner from '@/app/_components/common/LoadingSpinner';

const ContractDetails = dynamic(
  () => import('@/app/_components/contracts/ContractDetails'),
  {
    loading: () => <LoadingSpinner />,
    ssr: false
  }
);

const ContractDetailsPage = () => {
  const params = useParams();
  const contractId = params.id as Id<"contracts">;

  return (
    <div className="p-6">
      <ContractDetails contractId={contractId} />
    </div>
  );
};

export default ContractDetailsPage;
</file>

<file path="src/app/dashboard/contracts/active/page.tsx">
'use client'

import React, { useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import useContractStore from "@/stores/contract-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { Button } from "@/components/ui/button";
import { PlusCircle } from "lucide-react";

const ActiveContracts = () => {
  const { contracts } = useContractStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();

  // Filter active contracts and apply search
  const activeContracts = useMemo(() => {
    return contracts.filter((contract) => {
      const isActive = contract.status === "active";
      if (!searchQuery) return isActive;

      // Apply search filter to active contracts
      const searchLower = searchQuery.toLowerCase();
      return (
        isActive &&
        (contract.title.toLowerCase().includes(searchLower) ||
          contract.vendor?.name.toLowerCase().includes(searchLower) ||
          contract.contract_number.toLowerCase().includes(searchLower))
      );
    });
  }, [contracts, searchQuery]);

  // Calculate active contract statistics
  const stats = useMemo(() => {
    const totalValue = activeContracts.reduce(
      (sum, contract) => sum + (contract.value || 0),
      0
    );
    const avgValue =
      activeContracts.length > 0 ? totalValue / activeContracts.length : 0;

    return {
      total: activeContracts.length,
      totalValue: totalValue,
      averageValue: avgValue,
      expiringSoon: activeContracts.filter((contract) => {
        const expiryDate = new Date(contract.expires_at);
        const thirtyDaysFromNow = new Date();
        thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
        return expiryDate <= thirtyDaysFromNow;
      }).length,
    };
  }, [activeContracts]);

  return (
    <div className="space-y-6 p-6">
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">Active Contracts</h2>
        <Button>
          <PlusCircle className="mr-2 h-4 w-4" />
          New Contract
        </Button>
      </div>
      {/* Active Contracts Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Active Contracts
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Value</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${stats.totalValue.toLocaleString()}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Expiring Soon</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.expiringSoon}</div>
          </CardContent>
        </Card>
      </div>

      {/* Search Bar */}
      <div className="flex items-center space-x-2">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search active contracts..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
      </div>

      {/* Contracts Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {activeContracts.map((contract) => (
          <Card key={contract.id} className="hover:shadow-lg transition-shadow">
            <CardHeader>
              <CardTitle className="text-lg font-medium">
                {contract.title}
              </CardTitle>
              <p className="text-sm text-muted-foreground">
                Contract #{contract.contract_number}
              </p>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Value:</span>
                  <span className="font-medium">
                    ${contract.value?.toLocaleString()}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Vendor:</span>
                  <span className="font-medium">{contract.vendor?.name}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Expires:
                  </span>
                  <span className="font-medium">
                    {new Date(contract.expires_at).toLocaleDateString()}
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
        {activeContracts.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No active contracts found
          </div>
        )}
      </div>
    </div>
  );
};

export default ActiveContracts;
</file>

<file path="src/app/dashboard/contracts/archived/page.tsx">
'use client'


import React, { useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import useContractStore from "@/stores/contract-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { RefreshCcw, Archive } from "lucide-react";
import { Button } from "@/components/ui/button";

const ArchivedContracts = () => {
  const { contracts } = useContractStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();

  // Filter archived contracts and apply search
  const archivedContracts = useMemo(() => {
    return contracts.filter((contract) => {
      const isArchived = contract.status === "archived";
      if (!searchQuery) return isArchived;

      const searchLower = searchQuery.toLowerCase();
      return (
        isArchived &&
        (contract.title.toLowerCase().includes(searchLower) ||
          contract.vendor?.name.toLowerCase().includes(searchLower) ||
          contract.contract_number.toLowerCase().includes(searchLower))
      );
    });
  }, [contracts, searchQuery]);

  // Calculate archive statistics
  const stats = useMemo(() => {
    const totalValue = archivedContracts.reduce(
      (sum, contract) => sum + (contract.value || 0),
      0
    );
    const lastThirtyDays = new Date();
    lastThirtyDays.setDate(lastThirtyDays.getDate() - 30);

    return {
      total: archivedContracts.length,
      totalValue: totalValue,
      recentlyArchived: archivedContracts.filter(
        (contract) => new Date(contract.archived_at) > lastThirtyDays
      ).length,
    };
  }, [archivedContracts]);

  return (
    <div className="space-y-6 p-6">
      {/* Header with Stats */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">Archived Contracts</h2>
      </div>

      {/* Archive Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Total Archived
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Value</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${stats.totalValue.toLocaleString()}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Recently Archived
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.recentlyArchived}</div>
          </CardContent>
        </Card>
      </div>

      {/* Search Bar */}
      <div className="flex items-center space-x-2">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search archived contracts..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
      </div>

      {/* Contracts Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {archivedContracts.map((contract) => (
          <Card key={contract.id} className="hover:shadow-lg transition-shadow">
            <CardHeader>
              <div className="flex justify-between items-start">
                <CardTitle className="text-lg font-medium">
                  {contract.title}
                </CardTitle>
                <Button variant="ghost" size="icon">
                  <RefreshCcw className="h-4 w-4" />
                </Button>
              </div>
              <div className="flex items-center text-sm text-muted-foreground">
                <Archive className="h-4 w-4 mr-1" />
                Archived on{" "}
                {new Date(contract.archived_at).toLocaleDateString()}
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Contract #:
                  </span>
                  <span className="font-medium">
                    {contract.contract_number}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Value:</span>
                  <span className="font-medium">
                    ${contract.value?.toLocaleString()}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Vendor:</span>
                  <span className="font-medium">{contract.vendor?.name}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    End Date:
                  </span>
                  <span className="font-medium">
                    {new Date(contract.expires_at).toLocaleDateString()}
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
        {archivedContracts.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No archived contracts found
          </div>
        )}
      </div>
    </div>
  );
};

export default ArchivedContracts;
</file>

<file path="src/app/dashboard/contracts/drafts/page.tsx">
'use client'


import React, { useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search, PlusCircle, Edit, Clock } from "lucide-react";
import { Input } from "@/components/ui/input";
import useContractStore from "@/stores/contract-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { Button } from "@/components/ui/button";

const DraftContracts = () => {
  const { contracts } = useContractStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();

  // Filter draft contracts and apply search
  const draftContracts = useMemo(() => {
    return contracts.filter((contract) => {
      const isDraft = contract.status === "draft";
      if (!searchQuery) return isDraft;

      const searchLower = searchQuery.toLowerCase();
      return (
        isDraft &&
        (contract.title.toLowerCase().includes(searchLower) ||
          contract.vendor?.name.toLowerCase().includes(searchLower) ||
          contract.contract_number.toLowerCase().includes(searchLower))
      );
    });
  }, [contracts, searchQuery]);

  // Calculate draft statistics
  const stats = useMemo(() => {
    // const lastModified = draftContracts.reduce((latest, contract) => {
    //   const modifiedDate = new Date(contract.updated_at || contract.created_at);
    //   return modifiedDate > latest ? modifiedDate : latest;
    // }, new Date(0));

    return {
      total: draftContracts.length,
      recentlyModified: draftContracts.filter((contract) => {
        const lastWeek = new Date();
        lastWeek.setDate(lastWeek.getDate() - 7);
        return new Date(contract.updated_at || contract.created_at) > lastWeek;
      }).length,
      oldestDraft: draftContracts.reduce<Date | null>((oldest, contract) => {
        const createdDate = new Date(contract.created_at);
        return !oldest || createdDate < oldest ? createdDate : oldest;
      }, null),
    };
  }, [draftContracts]);

  return (
    <div className="space-y-6 p-6">
      {/* Header with Action Button */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">Draft Contracts</h2>
        <Button>
          <PlusCircle className="mr-2 h-4 w-4" />
          New Draft
        </Button>
      </div>

      {/* Draft Stats */}
      <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Drafts</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Recently Modified
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.recentlyModified}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Oldest Draft</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {stats.oldestDraft
                ? stats.oldestDraft.toLocaleDateString()
                : "N/A"}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Search Bar */}
      <div className="flex items-center space-x-2">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search draft contracts..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
      </div>

      {/* Drafts Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {draftContracts.map((contract) => (
          <Card key={contract.id} className="hover:shadow-lg transition-shadow">
            <CardHeader>
              <div className="flex justify-between items-start">
                <CardTitle className="text-lg font-medium">
                  {contract.title}
                </CardTitle>
                <Button variant="ghost" size="icon">
                  <Edit className="h-4 w-4" />
                </Button>
              </div>
              <div className="flex items-center text-sm text-muted-foreground">
                <Clock className="h-4 w-4 mr-1" />
                Last modified:{" "}
                {new Date(
                  contract.updated_at || contract.created_at
                ).toLocaleDateString()}
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Draft #:
                  </span>
                  <span className="font-medium">
                    {contract.contract_number}
                  </span>
                </div>
                {contract.value && (
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Estimated Value:
                    </span>
                    <span className="font-medium">
                      ${contract.value.toLocaleString()}
                    </span>
                  </div>
                )}
                {contract.vendor && (
                  <div className="flex justify-between">
                    <span className="text-sm text-muted-foreground">
                      Vendor:
                    </span>
                    <span className="font-medium">{contract.vendor.name}</span>
                  </div>
                )}
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Created:
                  </span>
                  <span className="font-medium">
                    {new Date(contract.created_at).toLocaleDateString()}
                  </span>
                </div>
              </div>
              <div className="mt-4">
                <Button className="w-full" variant="outline">
                  Continue Editing
                </Button>
              </div>
            </CardContent>
          </Card>
        ))}
        {draftContracts.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No draft contracts found
          </div>
        )}
      </div>
    </div>
  );
};

export default DraftContracts;
</file>

<file path="src/app/dashboard/contracts/edit/[id]/page.tsx">
'use client';

import React from 'react';
import { ContractForm } from '@/app/_components/contracts/ContractForm';
import { useParams } from 'next/navigation';
import { Id } from "../../../../../../convex/_generated/dataModel"

const EditContractPage = () => {
  const params = useParams();
  const contractId = params?.id as string;

  if (!contractId) {
    return (
      <div className="container mx-auto py-8">
        <div className="bg-yellow-50 border border-yellow-200 rounded-md p-4 mb-6">
          <h2 className="text-yellow-800 font-medium">Contract ID Missing</h2>
          <p className="text-yellow-700 mt-1">
            No contract ID was provided. Please select a contract to edit.
          </p>
        </div>
      </div>
    );
  }

  return (
    <div className="container mx-auto">
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-primary">Edit Contract</h1>
        <p className="text-muted-foreground mt-1">
          Update the contract details below.
        </p>
      </div>

      <ContractForm contractId={contractId as Id<"contracts">} />
    </div>
  );
};

export default EditContractPage;
</file>

<file path="src/app/dashboard/contracts/expired/page.tsx">
'use client'


import React, { useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search, AlertCircle, History, Archive } from "lucide-react";
import { Input } from "@/components/ui/input";
import useContractStore from "@/stores/contract-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { Button } from "@/components/ui/button";

const ExpiredContracts = () => {
  const { contracts } = useContractStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();

  // Filter expired contracts and apply search
  const expiredContracts = useMemo(() => {
    return contracts.filter((contract) => {
      const isExpired = contract.status === "expired";
      if (!searchQuery) return isExpired;

      const searchLower = searchQuery.toLowerCase();
      return (
        isExpired &&
        (contract.title.toLowerCase().includes(searchLower) ||
          contract.vendor?.name.toLowerCase().includes(searchLower) ||
          contract.contract_number.toLowerCase().includes(searchLower))
      );
    });
  }, [contracts, searchQuery]);

  // Calculate expired contract statistics
  const stats = useMemo(() => {
    const totalValue = expiredContracts.reduce(
      (sum, contract) => sum + (contract.value || 0),
      0
    );
    const now = new Date();
    const lastThirtyDays = new Date(now.setDate(now.getDate() - 30));

    return {
      total: expiredContracts.length,
      totalValue,
      recentlyExpired: expiredContracts.filter(
        (contract) => new Date(contract.expires_at) > lastThirtyDays
      ).length,
      renewableCount: expiredContracts.filter(
        (contract) => contract.is_renewable || contract.auto_renewal
      ).length,
    };
  }, [expiredContracts]);

  return (
    <div className="space-y-6 p-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">Expired Contracts</h2>
      </div>

      {/* Stats Cards */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Expired</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Value</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${stats.totalValue.toLocaleString()}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Recently Expired
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.recentlyExpired}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Renewable</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.renewableCount}</div>
          </CardContent>
        </Card>
      </div>

      {/* Search Bar */}
      <div className="flex items-center space-x-2">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search expired contracts..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
      </div>

      {/* Expired Contracts Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {expiredContracts.map((contract) => (
          <Card key={contract.id} className="hover:shadow-lg transition-shadow">
            <CardHeader>
              <div className="flex justify-between items-start">
                <CardTitle className="text-lg font-medium">
                  {contract.title}
                </CardTitle>
                <div className="flex space-x-2">
                  {contract.is_renewable && (
                    <Button variant="ghost" size="icon" title="Renew Contract">
                      <History className="h-4 w-4" />
                    </Button>
                  )}
                  <Button variant="ghost" size="icon" title="Archive Contract">
                    <Archive className="h-4 w-4" />
                  </Button>
                </div>
              </div>
              <div className="flex items-center text-sm text-red-500">
                <AlertCircle className="h-4 w-4 mr-1" />
                Expired on {new Date(contract.expires_at).toLocaleDateString()}
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Contract #:
                  </span>
                  <span className="font-medium">
                    {contract.contract_number}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Value:</span>
                  <span className="font-medium">
                    ${contract.value?.toLocaleString()}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Vendor:</span>
                  <span className="font-medium">{contract.vendor?.name}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Duration:
                  </span>
                  <span className="font-medium">
                    {new Date(contract.start_date).toLocaleDateString()} -{" "}
                    {new Date(contract.expires_at).toLocaleDateString()}
                  </span>
                </div>
              </div>
              {contract.is_renewable && (
                <Button className="w-full mt-4" variant="outline">
                  <History className="mr-2 h-4 w-4" />
                  Renew Contract
                </Button>
              )}
            </CardContent>
          </Card>
        ))}
        {expiredContracts.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No expired contracts found
          </div>
        )}
      </div>
    </div>
  );
};

export default ExpiredContracts;
</file>

<file path="src/app/dashboard/contracts/new/page.tsx">
'use client';

import React from 'react';
import { ContractForm } from '@/app/_components/contracts/ContractForm';

const NewContractPage = () => {
  return (
    <div className="container mx-auto">
      <div className="mb-6">
        <h1 className="text-2xl font-bold text-primary">Create New Contract</h1>
        <p className="text-muted-foreground mt-1">
          Fill out the form below to create a new contract.
        </p>
      </div>

      <ContractForm />
    </div>
  );
};

export default NewContractPage;
</file>

<file path="src/app/dashboard/contracts/pending/page.tsx">
'use client'


import React, { useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search, Clock, FileSignature, Send, Eye } from "lucide-react";
import { Input } from "@/components/ui/input";
import useContractStore from "@/stores/contract-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { Button } from "@/components/ui/button";

const PendingContracts = () => {
  const { contracts } = useContractStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();

  // Filter pending signature contracts and apply search
  const pendingContracts = useMemo(() => {
    return contracts.filter((contract) => {
      const isPending = contract.status === "pending_signature";
      if (!searchQuery) return isPending;

      const searchLower = searchQuery.toLowerCase();
      return (
        isPending &&
        (contract.title.toLowerCase().includes(searchLower) ||
          contract.vendor?.name.toLowerCase().includes(searchLower) ||
          contract.contract_number.toLowerCase().includes(searchLower))
      );
    });
  }, [contracts, searchQuery]);

  // Calculate pending contract statistics
  const stats = useMemo(() => {
    const now = new Date();
    const twoDaysAgo = new Date(now.setDate(now.getDate() - 2));

    return {
      total: pendingContracts.length,
      urgentSignatures: pendingContracts.filter((contract) => {
        const dueDate = new Date(contract.signature_due_date);
        return dueDate <= now;
      }).length,
      recentlySent: pendingContracts.filter(
        (contract) => new Date(contract.sent_for_signature_at) > twoDaysAgo
      ).length,
      awaitingCounterparty: pendingContracts.filter(
        (contract) => contract.awaiting_counterparty
      ).length,
    };
  }, [pendingContracts]);

  return (
    <div className="space-y-6 p-6">
      {/* Header */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">Pending Signatures</h2>
        <Button>
          <Send className="mr-2 h-4 w-4" />
          Send for Signature
        </Button>
      </div>

      {/* Stats */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Pending</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium text-red-600">
              Urgent Signatures
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold text-red-600">
              {stats.urgentSignatures}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Recently Sent</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.recentlySent}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Awaiting Counterparty
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              {stats.awaitingCounterparty}
            </div>
          </CardContent>
        </Card>
      </div>

      {/* Search */}
      <div className="flex items-center space-x-2">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search pending contracts..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
      </div>

      {/* Pending Contracts Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {pendingContracts.map((contract) => (
          <Card key={contract.id} className="hover:shadow-lg transition-shadow">
            <CardHeader>
              <div className="flex justify-between items-start">
                <CardTitle className="text-lg font-medium">
                  {contract.title}
                </CardTitle>
                <div className="flex space-x-2">
                  <Button variant="ghost" size="icon" title="View Contract">
                    <Eye className="h-4 w-4" />
                  </Button>
                  <Button variant="ghost" size="icon" title="Sign Contract">
                    <FileSignature className="h-4 w-4" />
                  </Button>
                </div>
              </div>
              <div className="flex items-center text-sm text-muted-foreground">
                <Clock className="h-4 w-4 mr-1" />
                Due by:{" "}
                {new Date(contract.signature_due_date).toLocaleDateString()}
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Contract #:
                  </span>
                  <span className="font-medium">
                    {contract.contract_number}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">Vendor:</span>
                  <span className="font-medium">{contract.vendor?.name}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Sent on:
                  </span>
                  <span className="font-medium">
                    {new Date(
                      contract.sent_for_signature_at
                    ).toLocaleDateString()}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Signers:
                  </span>
                  <span className="font-medium">
                    {contract.pending_signers?.length || 0} remaining
                  </span>
                </div>
              </div>

              <div className="mt-4 space-y-2">
                <Button className="w-full" variant="outline">
                  <Eye className="mr-2 h-4 w-4" />
                  View Contract
                </Button>
                <Button className="w-full">
                  <FileSignature className="mr-2 h-4 w-4" />
                  Sign Now
                </Button>
              </div>
            </CardContent>
          </Card>
        ))}
        {pendingContracts.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No contracts pending signature
          </div>
        )}
      </div>
    </div>
  );
};

export default PendingContracts;
</file>

<file path="src/app/dashboard/contracts/layout.tsx">
'use client'

import React, { useEffect } from "react";
import { Tabs, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import { useDashboardStore } from "@/stores/dashboard-store";
import { useRouter, usePathname } from 'next/navigation';

interface ContractDashboardLayoutProps {
  children: React.ReactNode;
}

const contractTypes = [
  { label: "All Contracts", route: "/contracts" },
  { label: "Active", route: "/contracts/active" },
  { label: "Pending Signature", route: "/contracts/pending" },
  { label: "Drafts", route: "/contracts/drafts" },
  { label: "Expired", route: "/contracts/expired" },
  { label: "Archived", route: "/contracts/archived" },
];

export const ContractDashboardLayout: React.FC<ContractDashboardLayoutProps> = ({ 
  children 
}) => {
  const { selectedType, searchQuery, setSelectedType, setSearchQuery } = useDashboardStore();
  const router = useRouter();
  const pathname = usePathname();

  // Update selected tab based on current path
  useEffect(() => {
    const pathToType: { [key: string]: string } = {
      "/contracts": "All Contracts",
      "/contracts/active": "Active",
      "/contracts/pending": "Pending Signature",
      "/contracts/drafts": "Drafts",
      "/contracts/expired": "Expired",
      "/contracts/archived": "Archived",
    };

    const newType = pathToType[pathname] || "All Contracts";
    if (newType !== selectedType) {
      setSelectedType(newType);
    }
  }, [pathname, selectedType, setSelectedType]);

  const handleTabChange = (type: string) => {
    const route = contractTypes.find(t => t.label === type)?.route || "/contracts";
    router.push(route);
  };

  return (
    <main className="flex-1 overflow-hidden">
      <div className="h-full flex flex-col">
        <div className="p-4 border-b bg-white dark:bg-card">
          {/* Header and Search */}
          <div className="flex flex-col space-y-4 md:flex-row md:items-center md:justify-between md:space-y-0">
            <h1 className="text-2xl font-bold text-primary">Contracts</h1>
            <div className="flex items-center space-x-4">
              <div className="relative flex-1 md:w-64">
                <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                <Input
                  placeholder="Search contracts..."
                  value={searchQuery}
                  onChange={(e) => setSearchQuery(e.target.value)}
                  className="pl-8"
                />
              </div>
            </div>
          </div>

          {/* Status Tabs */}
          <div className="mt-4">
            <Tabs value={selectedType} className="w-full">
              <TabsList className="flex overflow-x-auto">
                {contractTypes.map((type) => (
                  <TabsTrigger
                    key={type.label}
                    value={type.label}
                    onClick={() => handleTabChange(type.label)}
                    className="data-[state=active]:bg-primary data-[state=active]:text-primary-foreground"
                  >
                    {type.label}
                  </TabsTrigger>
                ))}
              </TabsList>
            </Tabs>
          </div>
        </div>

        {/* Dynamic Content Area - This is where the children will be rendered */}
        <div className="flex-1 p-4 overflow-auto bg-white dark:bg-card shadow-inner">
          {children}
        </div>
      </div>
    </main>
  );
};

export default ContractDashboardLayout;

    // Calculate contract statistics
    // const stats = useMemo(() => {
    //   return {
    //     total: contracts.length,
    //     active: contracts.filter((c) => c.status === "active").length,
    //     pendingSignature: contracts.filter(
    //       (c) => c.status === "pending_signature"
    //     ).length,
    //     expiringSoon: contracts.filter((c) => {
    //       const expiryDate = new Date(c.expires_at);
    //       const thirtyDaysFromNow = new Date();
    //       thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
    //       return expiryDate <= thirtyDaysFromNow && c.status === "active";
    //     }).length,
    //   };
    // }, [contracts]);
</file>

<file path="src/app/dashboard/profile/page.tsx">
'use client';

import React, { useState, useEffect, useCallback } from 'react';
import { useUser, UserProfile as ClerkUserProfile } from '@clerk/nextjs'; // Clerk UserProfile for some settings
import { useConvexQuery, useConvexMutation } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';
import { Id } from '@/../convex/_generated/dataModel';
import { UserRole, userRoleOptions } from '@/../convex/schema';

// UI Components
import { Button } from '@/components/ui/button';
import {
  Card,
  CardContent,
  CardDescription,
  CardFooter,
  CardHeader,
  CardTitle,
} from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Label } from '@/components/ui/label';
import { Separator } from '@/components/ui/separator';
import { Switch } from '@/components/ui/switch';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { LoadingSpinner } from '@/app/_components/common/LoadingSpinner';

// Icons
import {
  User,
  Building,
  Mail,
  Phone,
  Briefcase,
  Bell,
  Shield,
  Lock,
  LogOut,
  Save,
  AlertCircle,
  CheckCircle,
  Loader2,
  CreditCard,
  Settings,
} from 'lucide-react';

interface UserProfileData {
  firstName?: string;
  lastName?: string;
  phoneNumber?: string;
  department?: string;
  title?: string;
}

interface NotificationPreferencesData {
  inAppEnabled: boolean;
  emailEnabled: boolean;
  contractNotifications: boolean;
  approvalNotifications: boolean;
  paymentNotifications: boolean; // Added based on schema
  vendorNotifications: boolean; // Added based on schema
  complianceNotifications: boolean; // Added based on schema
  systemNotifications: boolean;
  // Add other preferences from your schema if needed
  // e.g., quietHoursEnabled, emailFrequency etc.
}

const UserProfilePage = () => {
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();

  const { data: convexUser, isLoading: isLoadingConvexUser } = useConvexQuery(
    api.users.getCurrentUser,
    {}
  );
  const { data: notificationPrefs, isLoading: isLoadingNotifPrefs } =
    useConvexQuery(api.notifications.getMyPreferences, {});

  const updateUserProfileMutation = useConvexMutation(api.users.updateUserProfile);
  const updateNotificationPrefsMutation = useConvexMutation(
    api.notifications.updatePreferences
  );

  const [profileData, setProfileData] = useState<UserProfileData>({});
  const [
    notificationPreferencesData,
    setNotificationPreferencesData,
  ] = useState<NotificationPreferencesData>({
    inAppEnabled: true,
    emailEnabled: true,
    contractNotifications: true,
    approvalNotifications: true,
    paymentNotifications: true,
    vendorNotifications: true,
    complianceNotifications: true,
    systemNotifications: true,
  });

  const [activeTab, setActiveTab] = useState<string>('details');
  const [statusMessage, setStatusMessage] = useState<{
    type: 'success' | 'error';
    message: string;
  } | null>(null);

  useEffect(() => {
    if (convexUser) {
      setProfileData({
        firstName: convexUser.firstName || '',
        lastName: convexUser.lastName || '',
        phoneNumber: convexUser.phoneNumber || '',
        department: convexUser.department || '',
        title: convexUser.title || '',
      });
    }
  }, [convexUser]);

  useEffect(() => {
    if (notificationPrefs) {
      setNotificationPreferencesData({
        inAppEnabled: notificationPrefs.inAppEnabled,
        emailEnabled: notificationPrefs.emailEnabled,
        contractNotifications: notificationPrefs.contractNotifications,
        approvalNotifications: notificationPrefs.approvalNotifications,
        paymentNotifications: notificationPrefs.paymentNotifications ?? true, // Default if not in schema
        vendorNotifications: notificationPrefs.vendorNotifications ?? true,   // Default if not in schema
        complianceNotifications: notificationPrefs.complianceNotifications ?? true, // Default if not in schema
        systemNotifications: notificationPrefs.systemNotifications,
      });
    }
  }, [notificationPrefs]);

  const handleProfileInputChange = (
    e: React.ChangeEvent<HTMLInputElement>
  ) => {
    const { name, value } = e.target;
    setProfileData((prev) => ({ ...prev, [name]: value }));
  };

  const handleNotificationPrefChange = (
    name: keyof NotificationPreferencesData,
    checked: boolean
  ) => {
    setNotificationPreferencesData((prev) => ({ ...prev, [name]: checked }));
  };

  const handleSaveProfile = async () => {
    setStatusMessage(null);
    try {
      await updateUserProfileMutation.execute(profileData);
      setStatusMessage({
        type: 'success',
        message: 'Profile updated successfully!',
      });
    } catch (error: any) {
      setStatusMessage({
        type: 'error',
        message: error.data?.message || error.message || 'Failed to update profile.',
      });
    }
  };

  const handleSaveNotificationPrefs = async () => {
    setStatusMessage(null);
    try {
      await updateNotificationPrefsMutation.execute({
        preferences: notificationPreferencesData,
      });
      setStatusMessage({
        type: 'success',
        message: 'Notification preferences updated successfully!',
      });
    } catch (error: any) {
      setStatusMessage({
        type: 'error',
        message: error.data?.message || error.message || 'Failed to update preferences.',
      });
    }
  };

  const isLoading = !isClerkLoaded || isLoadingConvexUser || isLoadingNotifPrefs;

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full p-8">
        <LoadingSpinner text="Loading profile..." size="lg" />
      </div>
    );
  }

  if (!clerkUser || !convexUser) {
    return (
      <Alert variant="destructive" className="m-4">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>
          User data could not be loaded. Please try again or contact support.
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="container mx-auto py-8 px-4 md:px-6 lg:px-8 max-w-5xl">
      <Card className="shadow-xl border-border/20 bg-card">
        <CardHeader className="pb-4 border-b border-border/10">
          <div className="flex items-center space-x-4">
            <User className="h-10 w-10 text-gold" />
            <div>
              <CardTitle className="text-3xl font-serif text-primary">
                User Profile
              </CardTitle>
              <CardDescription className="text-muted-foreground">
                Manage your personal information, preferences, and security
                settings.
              </CardDescription>
            </div>
          </div>
        </CardHeader>

        <CardContent className="pt-6">
          {statusMessage && (
            <Alert
              variant={statusMessage.type === 'error' ? 'destructive' : 'default'}
              className="mb-6"
            >
              {statusMessage.type === 'error' ? (
                <AlertCircle className="h-4 w-4" />
              ) : (
                <CheckCircle className="h-4 w-4" />
              )}
              <AlertTitle>
                {statusMessage.type === 'error' ? 'Error' : 'Success'}
              </AlertTitle>
              <AlertDescription>{statusMessage.message}</AlertDescription>
            </Alert>
          )}

          <Tabs value={activeTab} onValueChange={setActiveTab}>
            <TabsList className="grid w-full grid-cols-3 mb-6 bg-muted/50 p-1 rounded-lg">
              <TabsTrigger value="details">
                <User className="mr-2 h-4 w-4" /> Profile Details
              </TabsTrigger>
              <TabsTrigger value="notifications">
                <Bell className="mr-2 h-4 w-4" /> Notifications
              </TabsTrigger>
              <TabsTrigger value="security">
                <Shield className="mr-2 h-4 w-4" /> Security
              </TabsTrigger>
            </TabsList>

            {/* Profile Details Tab */}
            <TabsContent value="details" className="space-y-6">
              <Card className="border-border/20">
                <CardHeader>
                  <CardTitle className="text-xl text-primary font-serif">
                    Personal Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div className="space-y-1.5">
                      <Label htmlFor="firstName">First Name</Label>
                      <Input
                        id="firstName"
                        name="firstName"
                        value={profileData.firstName || ''}
                        onChange={handleProfileInputChange}
                        placeholder="Your first name"
                      />
                    </div>
                    <div className="space-y-1.5">
                      <Label htmlFor="lastName">Last Name</Label>
                      <Input
                        id="lastName"
                        name="lastName"
                        value={profileData.lastName || ''}
                        onChange={handleProfileInputChange}
                        placeholder="Your last name"
                      />
                    </div>
                  </div>
                  <div className="space-y-1.5">
                    <Label htmlFor="email">Email</Label>
                    <div className="flex items-center">
                      <Mail className="mr-2 h-4 w-4 text-muted-foreground" />
                      <Input
                        id="email"
                        type="email"
                        value={convexUser.email}
                        readOnly
                        className="bg-muted/30 cursor-not-allowed"
                      />
                    </div>
                  </div>
                  <div className="space-y-1.5">
                    <Label htmlFor="phoneNumber">Phone Number</Label>
                    <Input
                      id="phoneNumber"
                      name="phoneNumber"
                      type="tel"
                      value={profileData.phoneNumber || ''}
                      onChange={handleProfileInputChange}
                      placeholder="Your phone number (optional)"
                    />
                  </div>
                </CardContent>
              </Card>

              <Card className="border-border/20">
                <CardHeader>
                  <CardTitle className="text-xl text-primary font-serif">
                    Work Information
                  </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <div className="space-y-1.5">
                      <Label htmlFor="title">Job Title</Label>
                      <Input
                        id="title"
                        name="title"
                        value={profileData.title || ''}
                        onChange={handleProfileInputChange}
                        placeholder="e.g., Contract Manager (optional)"
                      />
                    </div>
                    <div className="space-y-1.5">
                      <Label htmlFor="department">Department</Label>
                      <Input
                        id="department"
                        name="department"
                        value={profileData.department || ''}
                        onChange={handleProfileInputChange}
                        placeholder="e.g., Legal, Sales (optional)"
                      />
                    </div>
                  </div>
                  <div className="space-y-1.5">
                    <Label htmlFor="enterpriseName">Enterprise</Label>
                    <div className="flex items-center">
                       <Building className="mr-2 h-4 w-4 text-muted-foreground" />
                       <Input
                        id="enterpriseName"
                        value={convexUser.enterpriseId ? 'Enterprise' : 'N/A'}
                        readOnly
                        className="bg-muted/30 cursor-not-allowed"
                       />
                    </div>
                  </div>
                   <div className="space-y-1.5">
                    <Label htmlFor="userRole">Role</Label>
                     <div className="flex items-center">
                        <Briefcase className="mr-2 h-4 w-4 text-muted-foreground" />
                        <Input
                          id="userRole"
                          value={(convexUser.role.charAt(0).toUpperCase() + convexUser.role.slice(1))}
                          readOnly
                          className="bg-muted/30 cursor-not-allowed"
                        />
                     </div>
                  </div>
                </CardContent>
              </Card>
              <div className="flex justify-end">
                <Button
                  onClick={handleSaveProfile}
                  disabled={updateUserProfileMutation.isLoading}
                >
                  {updateUserProfileMutation.isLoading && (
                    <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                  )}
                  <Save className="mr-2 h-4 w-4" />
                  Save Profile
                </Button>
              </div>
            </TabsContent>

            {/* Notification Preferences Tab */}
            <TabsContent value="notifications" className="space-y-6">
              <Card className="border-border/20">
                <CardHeader>
                  <CardTitle className="text-xl text-primary font-serif">
                    Notification Settings
                  </CardTitle>
                  <CardDescription>
                    Choose how you want to be notified.
                  </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="flex items-center justify-between p-3 rounded-md border border-border/10 bg-card hover:bg-muted/30 transition-colors">
                    <Label htmlFor="inAppEnabled" className="flex-grow cursor-pointer">
                      In-App Notifications
                    </Label>
                    <Switch
                      id="inAppEnabled"
                      checked={notificationPreferencesData.inAppEnabled}
                      onCheckedChange={(checked) =>
                        handleNotificationPrefChange('inAppEnabled', checked)
                      }
                    />
                  </div>
                  <div className="flex items-center justify-between p-3 rounded-md border border-border/10 bg-card hover:bg-muted/30 transition-colors">
                    <Label htmlFor="emailEnabled" className="flex-grow cursor-pointer">
                      Email Notifications
                    </Label>
                    <Switch
                      id="emailEnabled"
                      checked={notificationPreferencesData.emailEnabled}
                      onCheckedChange={(checked) =>
                        handleNotificationPrefChange('emailEnabled', checked)
                      }
                    />
                  </div>
                  <Separator className="my-4" />
                  <h4 className="text-md font-medium text-foreground">
                    Notification Types:
                  </h4>
                  {[
                    { id: 'contractNotifications', label: 'Contract Updates (Expiry, Status Changes)' },
                    { id: 'approvalNotifications', label: 'Approval Requests & Updates' },
                    { id: 'paymentNotifications', label: 'Payment Reminders & Confirmations' },
                    { id: 'vendorNotifications', label: 'Vendor Onboarding & Risk Alerts' },
                    { id: 'complianceNotifications', label: 'Compliance & Audit Notifications' },
                    { id: 'systemNotifications', label: 'System Alerts & Announcements' },
                  ].map(pref => (
                    <div key={pref.id} className="flex items-center justify-between p-3 rounded-md border border-border/10 bg-card hover:bg-muted/30 transition-colors">
                      <Label htmlFor={pref.id} className="flex-grow cursor-pointer">
                        {pref.label}
                      </Label>
                      <Switch
                        id={pref.id}
                        checked={notificationPreferencesData[pref.id as keyof NotificationPreferencesData]}
                        onCheckedChange={(checked) =>
                          handleNotificationPrefChange(pref.id as keyof NotificationPreferencesData, checked)
                        }
                      />
                    </div>
                  ))}
                </CardContent>
                 <CardFooter className="border-t border-border/10 pt-4">
                    <Button
                      onClick={handleSaveNotificationPrefs}
                      disabled={updateNotificationPrefsMutation.isLoading}
                      className="ml-auto"
                    >
                      {updateNotificationPrefsMutation.isLoading && (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      )}
                      <Save className="mr-2 h-4 w-4" />
                      Save Preferences
                    </Button>
                  </CardFooter>
              </Card>
            </TabsContent>

            {/* Security Settings Tab */}
            <TabsContent value="security" className="space-y-6">
             <Card className="border-border/20">
                <CardHeader>
                    <CardTitle className="text-xl text-primary font-serif">Account Security</CardTitle>
                    <CardDescription>
                        Manage your account security settings through Clerk.
                    </CardDescription>
                </CardHeader>
                <CardContent className="space-y-4">
                    <p className="text-sm text-muted-foreground">
                        Your password, multi-factor authentication (MFA), and connected accounts
                        are managed securely by Clerk.
                    </p>
                    <Button
                        variant="outline"
                        onClick={() => window.open("https://clerk.com/dashboard", "_blank")}
                        className="w-full sm:w-auto"
                    >
                        <Settings className="mr-2 h-4 w-4" />
                        Manage Security Settings in Clerk
                    </Button>
                     <Alert variant="default" className="mt-4 border-blue-200 bg-blue-50 dark:bg-blue-900/20">
                        <AlertCircle className="h-4 w-4 text-blue-600" />
                        <AlertTitle className="text-blue-700">Note</AlertTitle>
                        <AlertDescription className="text-blue-600">
                            You will be redirected to your Clerk user profile to manage these settings.
                        </AlertDescription>
                    </Alert>
                </CardContent>
              </Card>

              {/* Placeholder for future application-specific security settings */}
              {/* <Card className="border-border/20">
                <CardHeader>
                  <CardTitle className="text-xl text-primary font-serif">
                    Application Security
                  </CardTitle>
                </CardHeader>
                <CardContent>
                  <p className="text-sm text-muted-foreground">
                    (Placeholder for future application-specific security settings,
                    e.g., API key management, session timeouts if managed by the app itself)
                  </p>
                </CardContent>
              </Card>
              */}
            </TabsContent>
          </Tabs>
        </CardContent>
      </Card>
    </div>
  );
};

export default UserProfilePage;
</file>

<file path="src/app/dashboard/vendors/inactive/page.tsx">
'use client'

import React, { useMemo, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search, AlertCircle } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import useVendorStore from "@/stores/vendor-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { Button } from "@/components/ui/button";
import { RefreshCw } from "lucide-react";

const InactiveVendors = () => {
  const { vendors } = useVendorStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();
  const [categoryFilter, setCategoryFilter] = useState<string>("all");
  const [inactivityFilter, setInactivityFilter] = useState<string>("all");

  // Filter only inactive vendors based on search and filters
  const filteredVendors = useMemo(() => {
    return vendors.filter((vendor) => {
      // First filter for inactive status
      if (vendor.status !== "inactive") return false;

      const matchesSearch =
        !searchQuery ||
        vendor.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        vendor.vendor_number
          ?.toLowerCase()
          .includes(searchQuery.toLowerCase()) ||
        vendor.email?.toLowerCase().includes(searchQuery.toLowerCase());

      const matchesCategory =
        categoryFilter === "all" || vendor.category === categoryFilter;

      // Filter by inactivity period if specified
      if (inactivityFilter !== "all") {
        const lastActiveDate = new Date(vendor.updated_at);
        const monthsDiff =
          (new Date().getTime() - lastActiveDate.getTime()) /
          (1000 * 60 * 60 * 24 * 30);

        switch (inactivityFilter) {
          case "3months":
            if (monthsDiff > 3) return false;
            break;
          case "6months":
            if (monthsDiff > 6) return false;
            break;
          case "1year":
            if (monthsDiff > 12) return false;
            break;
        }
      }

      return matchesSearch && matchesCategory;
    });
  }, [vendors, searchQuery, categoryFilter, inactivityFilter]);

  // Calculate inactive vendor statistics
  const stats = useMemo(() => {
    const totalHistoricalSpend = filteredVendors.reduce(
      (sum, vendor) => sum + (vendor.total_spend || 0),
      0
    );

    const lastActiveVendors = filteredVendors.reduce(
      (counts, vendor) => {
        const monthsDiff =
          (new Date().getTime() - new Date(vendor.updated_at).getTime()) /
          (1000 * 60 * 60 * 24 * 30);
        if (monthsDiff <= 3) counts.threeMonths++;
        if (monthsDiff <= 6) counts.sixMonths++;
        return counts;
      },
      { threeMonths: 0, sixMonths: 0 }
    );

    return {
      total: filteredVendors.length,
      historicalSpend: totalHistoricalSpend,
      recentlyInactive: lastActiveVendors.threeMonths,
      pendingReview: filteredVendors.filter((v) => !v.metadata?.reviewed)
        .length,
    };
  }, [filteredVendors]);

  return (
    <div className="space-y-6 p-6">
      {/* Header with Stats */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">Inactive Vendors</h2>
        <Button variant="outline">
          <RefreshCw className="mr-2 h-4 w-4" />
          Review Inactive Vendors
        </Button>
      </div>

      {/* Inactive Vendor Statistics */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Inactive Vendors
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Historical Spend
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${stats.historicalSpend.toLocaleString()}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Recently Inactive
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.recentlyInactive}</div>
            <p className="text-xs text-muted-foreground">Last 3 months</p>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Pending Review
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.pendingReview}</div>
          </CardContent>
        </Card>
      </div>

      {/* Filters */}
      <div className="flex items-center space-x-4">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search inactive vendors..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
        <Select value={categoryFilter} onValueChange={setCategoryFilter}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Filter by category" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Categories</SelectItem>
            <SelectItem value="technology">Technology</SelectItem>
            <SelectItem value="services">Services</SelectItem>
            <SelectItem value="manufacturing">Manufacturing</SelectItem>
            <SelectItem value="consulting">Consulting</SelectItem>
            <SelectItem value="supplies">Supplies</SelectItem>
          </SelectContent>
        </Select>
        <Select value={inactivityFilter} onValueChange={setInactivityFilter}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Inactive period" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Time</SelectItem>
            <SelectItem value="3months">Last 3 Months</SelectItem>
            <SelectItem value="6months">Last 6 Months</SelectItem>
            <SelectItem value="1year">Last Year</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Inactive Vendors Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {filteredVendors.map((vendor) => (
          <Card
            key={vendor.id}
            className="hover:shadow-lg transition-shadow cursor-pointer"
          >
            <CardHeader>
              <CardTitle className="text-lg font-medium">
                {vendor.name}
              </CardTitle>
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">
                  #{vendor.vendor_number}
                </span>
                <span className="text-sm px-2 py-1 rounded-full bg-gray-100 text-gray-800">
                  Inactive
                </span>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Category:
                  </span>
                  <span className="font-medium">{vendor.category}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Last Active:
                  </span>
                  <span className="font-medium">
                    {new Date(vendor.updated_at).toLocaleDateString()}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Historical Spend:
                  </span>
                  <span className="font-medium">
                    ${vendor.total_spend?.toLocaleString() || 0}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Review Status:
                  </span>
                  <span
                    className={`font-medium flex items-center ${
                      vendor.metadata?.reviewed
                        ? "text-green-600"
                        : "text-yellow-600"
                    }`}
                  >
                    {vendor.metadata?.reviewed ? "Reviewed" : "Pending Review"}
                    {!vendor.metadata?.reviewed && (
                      <AlertCircle className="ml-1 h-4 w-4" />
                    )}
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
        {filteredVendors.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No inactive vendors found
          </div>
        )}
      </div>
    </div>
  );
};

export default InactiveVendors;
</file>

<file path="src/app/hooks/useAuthRedirect.ts">
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@clerk/nextjs';

interface UseAuthRedirectOptions {
  redirectTo?: string;
  redirectOnSignIn?: boolean;
  redirectOnSignOut?: boolean;
}

export const useAuthRedirect = (options: UseAuthRedirectOptions = {}) => {
  const {
    redirectTo = '/dashboard',
    redirectOnSignIn = true,
    redirectOnSignOut = false,
  } = options;

  const { isSignedIn, isLoaded } = useAuth();
  const router = useRouter();

  useEffect(() => {
    if (!isLoaded) return;

    if (redirectOnSignIn && isSignedIn) {
      console.log('User signed in, redirecting to:', redirectTo);
      router.push(redirectTo);
    }

    if (redirectOnSignOut && !isSignedIn) {
      console.log('User signed out, redirecting to home');
      router.push('/');
    }
  }, [isSignedIn, isLoaded, redirectTo, redirectOnSignIn, redirectOnSignOut, router]);

  return { isSignedIn, isLoaded };
};


export const useLandingPageRedirect = () => {
  return useAuthRedirect({
    redirectTo: '/dashboard',
    redirectOnSignIn: true,
    redirectOnSignOut: false,
  });
};
</file>

<file path="src/app/invite/[token]/page.tsx">
'use client';

import React, { useEffect, useState } from 'react';
import { useParams, useRouter } from 'next/navigation';
import { useConvexQuery, useConvexMutation } from '@/lib/api-client';
import { api } from '@/../convex/_generated/api';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from '@/components/ui/card';
import { LoadingSpinner } from '@/app/_components/common/LoadingSpinner';
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle, CheckCircle, Mail, Building, UserCheck, XCircle, Loader2 } from 'lucide-react';
import { useUser } from '@clerk/nextjs'; // To check if user is already signed in

const InvitationHandlerPage = () => {
  const params = useParams();
  const router = useRouter();
  const { isSignedIn, user: clerkUser } = useUser(); // Clerk user
  const token = typeof params.token === 'string' ? params.token : undefined;

  const [pageError, setPageError] = useState<string | null>(null);
  const [pageSuccess, setPageSuccess] = useState<string | null>(null);

  const { data: invitationDetails, isLoading: isLoadingInvitation, error: invitationError } = useConvexQuery(
    api.enterprises.getInvitationByToken,
    token ? { token } : "skip"
  );

  const acceptInvitationMutation = useConvexMutation(api.enterprises.acceptInvitation);
  const upsertUserMutation = useConvexMutation(api.users.upsertUser); // For linking after acceptance

  useEffect(() => {
    if (invitationError) {
      setPageError(invitationError.message || "Failed to load invitation details.");
    }
    if (invitationDetails?.error) {
      setPageError(invitationDetails.error);
    }
  }, [invitationError, invitationDetails]);

  const handleAccept = async () => {
    if (!token) {
      setPageError("Invalid invitation link.");
      return;
    }
    if (!isSignedIn || !clerkUser) {
      // If not signed in, redirect to sign-up, passing the token for post-auth processing
      // Clerk's sign-up can redirect back with query params or use session state.
      // For simplicity, we'll prompt them to sign in/up first.
      // A more robust solution would pass the token through Clerk's redirect URLs.
      router.push(`/auth/sign-up?invitationToken=${token}`);
      return;
    }
    
    // Check if the invited email matches the currently signed-in user's email
    const primaryEmail = clerkUser.primaryEmailAddress?.emailAddress;
    if (invitationDetails?.invitation?.email && primaryEmail && 
        invitationDetails.invitation.email.toLowerCase() !== primaryEmail.toLowerCase()) {
      setPageError(`This invitation is for ${invitationDetails.invitation.email}. You are signed in as ${primaryEmail}. Please sign in with the correct account.`);
      return;
    }


    setPageError(null);
    setPageSuccess(null);

    try {
      const acceptanceResult = await acceptInvitationMutation.execute({ token });
      if (!acceptanceResult) { // `acceptInvitation` returns userId or throws
         throw new Error(acceptInvitationMutation.error?.message || "Failed to accept invitation.");
      }
      
      // Ensure the user record is fully up-to-date, especially if they were new to Convex.
      // `acceptInvitation` should handle linking the user to the enterprise.
      // `upsertUser` here ensures any Clerk profile updates are synced.
      await upsertUserMutation.execute({ invitationToken: token }); // Pass token to ensure correct enterprise linkage

      setPageSuccess(`Successfully joined ${invitationDetails?.enterprise?.name || 'the enterprise'}! Redirecting...`);
      
      // Redirect to dashboard or onboarding flow manager
      // The OnboardingFlowManager will pick up the new state.
      setTimeout(() => {
        router.push('/dashboard'); 
      }, 2000);

    } catch (err: any) {
      setPageError(err.message || "Could not process invitation.");
    }
  };

  if (isLoadingInvitation) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <LoadingSpinner text="Loading invitation..." size="lg" />
      </div>
    );
  }

  if (pageError) {
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <Card className="w-full max-w-md shadow-lg">
          <CardHeader className="text-center">
            <XCircle className="mx-auto h-12 w-12 text-destructive mb-3" />
            <CardTitle className="text-xl">Invitation Problem</CardTitle>
          </CardHeader>
          <CardContent>
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Error</AlertTitle>
              <AlertDescription>{pageError}</AlertDescription>
            </Alert>
          </CardContent>
          <CardFooter>
            <Button className="w-full" onClick={() => router.push('/')}>Go to Homepage</Button>
          </CardFooter>
        </Card>
      </div>
    );
  }
  
  if (pageSuccess) {
     return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <Card className="w-full max-w-md shadow-lg">
          <CardHeader className="text-center">
            <CheckCircle className="mx-auto h-12 w-12 text-green-500 mb-3" />
            <CardTitle className="text-xl">Invitation Accepted!</CardTitle>
          </CardHeader>
          <CardContent>
            <Alert>
              <CheckCircle className="h-4 w-4" />
              <AlertTitle>Success</AlertTitle>
              <AlertDescription>{pageSuccess}</AlertDescription>
            </Alert>
          </CardContent>
        </Card>
      </div>
    );
  }


  if (!invitationDetails || !invitationDetails.invitation) {
    // This case should be caught by pageError from the effect hook if token is invalid.
    return (
      <div className="min-h-screen flex items-center justify-center p-4">
        <Card className="w-full max-w-md shadow-lg">
          <CardHeader className="text-center">
            <CardTitle>Invalid Invitation</CardTitle>
          </CardHeader>
          <CardContent>
            <p>This invitation link is no longer valid or has expired.</p>
          </CardContent>
        </Card>
      </div>
    );
  }

  const { invitation, enterprise, inviter } = invitationDetails;

  return (
    <div className="min-h-screen flex items-center justify-center bg-gradient-to-b from-slate-100 to-background p-4">
      <Card className="w-full max-w-lg shadow-xl">
        <CardHeader className="text-center">
          <Mail className="mx-auto h-12 w-12 text-gold mb-4" />
          <CardTitle className="text-2xl font-serif text-primary">You're Invited!</CardTitle>
          {inviter && enterprise && (
            <CardDescription>
              {inviter.name || 'Someone'} has invited you to join{' '}
              <span className="font-semibold text-primary">{enterprise.name}</span> on PactWise.
            </CardDescription>
          )}
        </CardHeader>
        <CardContent className="space-y-4">
          <div className="p-4 border rounded-md bg-muted/50">
            <p className="text-sm">
              <strong className="text-foreground">Invited Email:</strong> {invitation.email}
            </p>
            <p className="text-sm">
              <strong className="text-foreground">Role:</strong> {invitation.role.charAt(0).toUpperCase() + invitation.role.slice(1)}
            </p>
            <p className="text-sm">
              <strong className="text-foreground">Expires:</strong> {new Date(invitation.expiresAt).toLocaleDateString()}
            </p>
          </div>

          {!isSignedIn && (
            <Alert variant="default" className="border-primary/20 bg-primary/5">
              <UserCheck className="h-4 w-4 text-primary" />
              <AlertTitle className="text-primary">Sign In or Sign Up to Accept</AlertTitle>
              <AlertDescription>
                To accept this invitation, please sign in with your <strong className="text-primary">{invitation.email}</strong> account.
                If you don't have an account, you can sign up.
              </AlertDescription>
              <div className="mt-3 flex gap-2">
                 <Button size="sm" onClick={() => router.push(`/auth/sign-in?invitationToken=${token}`)}>Sign In</Button>
                 <Button size="sm" variant="outline" onClick={() => router.push(`/auth/sign-up?invitationToken=${token}`)}>Sign Up</Button>
              </div>
            </Alert>
          )}
          
           {isSignedIn && clerkUser?.primaryEmailAddress?.emailAddress.toLowerCase() !== invitation.email.toLowerCase() && (
            <Alert variant="destructive">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Email Mismatch</AlertTitle>
              <AlertDescription>
                This invitation is for <strong className="break-all">{invitation.email}</strong>. You are currently signed in as <strong className="break-all">{clerkUser?.primaryEmailAddress?.emailAddress}</strong>. 
                Please sign out and sign back in with the correct email address to accept this invitation.
              </AlertDescription>
            </Alert>
          )}

        </CardContent>
        <CardFooter>
          <Button 
            className="w-full" 
            onClick={handleAccept} 
            disabled={
              acceptInvitationMutation.isLoading || 
              !isSignedIn || 
              (isSignedIn && clerkUser?.primaryEmailAddress?.emailAddress.toLowerCase() !== invitation.email.toLowerCase())
            }
          >
            {acceptInvitationMutation.isLoading && <Loader2 className="mr-2 h-4 w-4 animate-spin" />}
            Accept Invitation & Join {enterprise?.name || 'Enterprise'}
          </Button>
        </CardFooter>
      </Card>
    </div>
  );
};

export default InvitationHandlerPage;
</file>

<file path="src/components/compound/DataTable.tsx">
import React, { createContext, useContext, ReactNode } from 'react';
import { Card } from '@/components/ui/card';
import { Button } from '@/components/ui/button';
import { Badge } from '@/components/ui/badge';
import { ChevronLeft, ChevronRight, ChevronsLeft, ChevronsRight } from 'lucide-react';
import { cn } from '@/lib/utils';

// Context for sharing table state
interface TableContextType {
  sortField?: string;
  sortDirection?: 'asc' | 'desc';
  onSort?: (field: string) => void;
}

const TableContext = createContext<TableContextType>({});

// Main DataTable component
interface DataTableProps {
  children: ReactNode;
  className?: string;
  sortField?: string;
  sortDirection?: 'asc' | 'desc';
  onSort?: (field: string) => void;
}

export function DataTable({ 
  children, 
  className, 
  sortField, 
  sortDirection, 
  onSort 
}: DataTableProps) {
  return (
    <TableContext.Provider value={{ sortField, sortDirection, onSort }}>
      <Card className={cn('overflow-hidden', className)}>
        {children}
      </Card>
    </TableContext.Provider>
  );
}

// Table Header component
interface TableHeaderProps {
  children: ReactNode;
  className?: string;
}

export function TableHeader({ children, className }: TableHeaderProps) {
  return (
    <div className={cn('bg-muted/50 border-b', className)}>
      <div className="grid gap-4 p-4">
        {children}
      </div>
    </div>
  );
}

// Table Body component
interface TableBodyProps {
  children: ReactNode;
  className?: string;
  emptyState?: ReactNode;
}

export function TableBody({ children, className, emptyState }: TableBodyProps) {
  const hasChildren = React.Children.count(children) > 0;
  
  return (
    <div className={cn('divide-y', className)}>
      {hasChildren ? children : emptyState}
    </div>
  );
}

// Table Row component
interface TableRowProps {
  children: ReactNode;
  className?: string;
  onClick?: () => void;
  isSelected?: boolean;
}

export function TableRow({ children, className, onClick, isSelected }: TableRowProps) {
  return (
    <div 
      className={cn(
        'grid gap-4 p-4 transition-colors',
        onClick && 'cursor-pointer hover:bg-muted/50',
        isSelected && 'bg-muted/30',
        className
      )}
      onClick={onClick}
    >
      {children}
    </div>
  );
}

// Table Cell component
interface TableCellProps {
  children: ReactNode;
  className?: string;
  sortable?: boolean;
  sortField?: string;
}

export function TableCell({ children, className, sortable, sortField }: TableCellProps) {
  const { sortField: currentSortField, sortDirection, onSort } = useContext(TableContext);
  
  const handleSort = () => {
    if (sortable && sortField && onSort) {
      onSort(sortField);
    }
  };
  
  const isSorted = sortField === currentSortField;
  
  return (
    <div 
      className={cn(
        'flex items-center',
        sortable && 'cursor-pointer select-none hover:text-foreground/80',
        className
      )}
      onClick={handleSort}
    >
      {children}
      {sortable && isSorted && (
        <span className="ml-1 text-xs">
          {sortDirection === 'asc' ? '' : ''}
        </span>
      )}
    </div>
  );
}

// Table Actions component
interface TableActionsProps {
  children: ReactNode;
  className?: string;
}

export function TableActions({ children, className }: TableActionsProps) {
  return (
    <div className={cn('flex items-center justify-end gap-2', className)}>
      {children}
    </div>
  );
}

// Table Pagination component
interface TablePaginationProps {
  currentPage: number;
  totalPages: number;
  totalItems: number;
  pageSize: number;
  onPageChange: (page: number) => void;
  className?: string;
}

export function TablePagination({ 
  currentPage, 
  totalPages, 
  totalItems, 
  pageSize,
  onPageChange, 
  className 
}: TablePaginationProps) {
  const startItem = (currentPage - 1) * pageSize + 1;
  const endItem = Math.min(currentPage * pageSize, totalItems);
  
  return (
    <div className={cn('flex items-center justify-between p-4 border-t bg-muted/25', className)}>
      <div className="text-sm text-muted-foreground">
        Showing {startItem} to {endItem} of {totalItems} results
      </div>
      
      <div className="flex items-center gap-2">
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(1)}
          disabled={currentPage === 1}
        >
          <ChevronsLeft className="h-4 w-4" />
        </Button>
        
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage - 1)}
          disabled={currentPage === 1}
        >
          <ChevronLeft className="h-4 w-4" />
        </Button>
        
        <div className="flex items-center gap-1">
          {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
            let pageNumber;
            if (totalPages <= 5) {
              pageNumber = i + 1;
            } else if (currentPage <= 3) {
              pageNumber = i + 1;
            } else if (currentPage >= totalPages - 2) {
              pageNumber = totalPages - 4 + i;
            } else {
              pageNumber = currentPage - 2 + i;
            }
            
            return (
              <Button
                key={pageNumber}
                variant={pageNumber === currentPage ? "default" : "outline"}
                size="sm"
                onClick={() => onPageChange(pageNumber)}
              >
                {pageNumber}
              </Button>
            );
          })}
        </div>
        
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(currentPage + 1)}
          disabled={currentPage === totalPages}
        >
          <ChevronRight className="h-4 w-4" />
        </Button>
        
        <Button
          variant="outline"
          size="sm"
          onClick={() => onPageChange(totalPages)}
          disabled={currentPage === totalPages}
        >
          <ChevronsRight className="h-4 w-4" />
        </Button>
      </div>
    </div>
  );
}

// Table Status Badge component
interface TableStatusBadgeProps {
  status: string;
  variant?: 'default' | 'secondary' | 'destructive' | 'outline';
  className?: string;
}

export function TableStatusBadge({ status, variant = 'default', className }: TableStatusBadgeProps) {
  const getVariantForStatus = (status: string) => {
    switch (status.toLowerCase()) {
      case 'active':
      case 'completed':
      case 'approved':
        return 'default';
      case 'pending':
      case 'processing':
        return 'secondary';
      case 'expired':
      case 'failed':
      case 'rejected':
        return 'destructive';
      default:
        return 'outline';
    }
  };

  const formatStatus = (status: string) => {
    return status.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
  };

  return (
    <Badge 
      variant={getVariantForStatus(status)} 
      className={className}
    >
      {formatStatus(status)}
    </Badge>
  );
}

// Table Loading component
interface TableLoadingProps {
  rows?: number;
  columns?: number;
}

export function TableLoading({ rows = 5, columns = 4 }: TableLoadingProps) {
  return (
    <div className="divide-y">
      {Array.from({ length: rows }, (_, rowIndex) => (
        <div key={rowIndex} className="grid gap-4 p-4" style={{ gridTemplateColumns: `repeat(${columns}, 1fr)` }}>
          {Array.from({ length: columns }, (_, colIndex) => (
            <div key={colIndex} className="h-4 bg-muted animate-pulse rounded" />
          ))}
        </div>
      ))}
    </div>
  );
}

// Table Empty State component
interface TableEmptyStateProps {
  title?: string;
  description?: string;
  action?: ReactNode;
  icon?: ReactNode;
}

export function TableEmptyState({ 
  title = 'No data found',
  description = 'There are no items to display',
  action,
  icon
}: TableEmptyStateProps) {
  return (
    <div className="text-center py-12 px-4">
      {icon && (
        <div className="flex justify-center mb-4">
          {icon}
        </div>
      )}
      <h3 className="text-lg font-medium text-foreground mb-2">{title}</h3>
      <p className="text-muted-foreground mb-4">{description}</p>
      {action && action}
    </div>
  );
}

// Export all components as named exports and compound component
export default Object.assign(DataTable, {
  Header: TableHeader,
  Body: TableBody,
  Row: TableRow,
  Cell: TableCell,
  Actions: TableActions,
  Pagination: TablePagination,
  StatusBadge: TableStatusBadge,
  Loading: TableLoading,
  EmptyState: TableEmptyState,
});
</file>

<file path="src/components/compound/Form.tsx">
import React, { createContext, useContext, ReactNode, FormHTMLAttributes } from 'react';
import { Label } from '@/components/ui/label';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { Button } from '@/components/ui/button';
import { Alert, AlertDescription } from '@/components/ui/alert';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/components/ui/select';
import { AlertCircle, CheckCircle2 } from 'lucide-react';
import { cn } from '@/lib/utils';

// Context for sharing form state
interface FormContextType {
  errors?: Record<string, string>;
  isSubmitting?: boolean;
  touched?: Record<string, boolean>;
}

const FormContext = createContext<FormContextType>({});

// Main Form component
interface FormProps extends FormHTMLAttributes<HTMLFormElement> {
  children: ReactNode;
  errors?: Record<string, string>;
  isSubmitting?: boolean;
  touched?: Record<string, boolean>;
  onSubmit: (event: React.FormEvent<HTMLFormElement>) => void;
}

export function Form({ 
  children, 
  errors = {}, 
  isSubmitting = false, 
  touched = {},
  onSubmit,
  className,
  ...props 
}: FormProps) {
  return (
    <FormContext.Provider value={{ errors, isSubmitting, touched }}>
      <form 
        onSubmit={onSubmit} 
        className={cn('space-y-6', className)}
        {...props}
      >
        {children}
      </form>
    </FormContext.Provider>
  );
}

// Form Section component
interface FormSectionProps {
  children: ReactNode;
  title?: string;
  description?: string;
  className?: string;
}

export function FormSection({ children, title, description, className }: FormSectionProps) {
  return (
    <div className={cn('space-y-4', className)}>
      {(title || description) && (
        <div className="space-y-1">
          {title && <h3 className="text-lg font-medium">{title}</h3>}
          {description && <p className="text-sm text-muted-foreground">{description}</p>}
        </div>
      )}
      <div className="space-y-4">
        {children}
      </div>
    </div>
  );
}

// Form Field component
interface FormFieldProps {
  children: ReactNode;
  name: string;
  className?: string;
}

export function FormField({ children, name, className }: FormFieldProps) {
  const { errors, touched } = useContext(FormContext);
  const hasError = errors?.[name] && touched?.[name];
  
  return (
    <div className={cn('space-y-2', className)}>
      {children}
      {hasError && (
        <div className="flex items-center gap-2 text-sm text-destructive">
          <AlertCircle className="h-4 w-4" />
          {errors[name]}
        </div>
      )}
    </div>
  );
}

// Form Label component
interface FormLabelProps {
  children: ReactNode;
  htmlFor: string;
  required?: boolean;
  className?: string;
}

export function FormLabel({ children, htmlFor, required, className }: FormLabelProps) {
  return (
    <Label htmlFor={htmlFor} className={cn('text-sm font-medium', className)}>
      {children}
      {required && <span className="text-destructive ml-1">*</span>}
    </Label>
  );
}

// Form Input component
interface FormInputProps extends React.InputHTMLAttributes<HTMLInputElement> {
  name: string;
}

export function FormInput({ name, className, ...props }: FormInputProps) {
  const { errors, touched } = useContext(FormContext);
  const hasError = errors?.[name] && touched?.[name];
  
  return (
    <Input
      id={name}
      name={name}
      className={cn(hasError && 'border-destructive focus-visible:ring-destructive', className)}
      {...props}
    />
  );
}

// Form Textarea component
interface FormTextareaProps extends React.TextareaHTMLAttributes<HTMLTextAreaElement> {
  name: string;
}

export function FormTextarea({ name, className, ...props }: FormTextareaProps) {
  const { errors, touched } = useContext(FormContext);
  const hasError = errors?.[name] && touched?.[name];
  
  return (
    <Textarea
      id={name}
      name={name}
      className={cn(hasError && 'border-destructive focus-visible:ring-destructive', className)}
      {...props}
    />
  );
}

// Form Select component
interface FormSelectProps {
  name: string;
  placeholder?: string;
  children: ReactNode;
  value?: string;
  onValueChange?: (value: string) => void;
  className?: string;
}

export function FormSelect({ name, placeholder, children, value, onValueChange, className }: FormSelectProps) {
  const { errors, touched } = useContext(FormContext);
  const hasError = errors?.[name] && touched?.[name];
  
  return (
    <Select value={value} onValueChange={onValueChange}>
      <SelectTrigger 
        id={name}
        className={cn(hasError && 'border-destructive focus:ring-destructive', className)}
      >
        <SelectValue placeholder={placeholder} />
      </SelectTrigger>
      <SelectContent>
        {children}
      </SelectContent>
    </Select>
  );
}

// Form Select Option component
interface FormSelectOptionProps {
  value: string;
  children: ReactNode;
}

export function FormSelectOption({ value, children }: FormSelectOptionProps) {
  return <SelectItem value={value}>{children}</SelectItem>;
}

// Form Help Text component
interface FormHelpTextProps {
  children: ReactNode;
  className?: string;
}

export function FormHelpText({ children, className }: FormHelpTextProps) {
  return (
    <p className={cn('text-sm text-muted-foreground', className)}>
      {children}
    </p>
  );
}

// Form Error component
interface FormErrorProps {
  name: string;
  className?: string;
}

export function FormError({ name, className }: FormErrorProps) {
  const { errors, touched } = useContext(FormContext);
  const hasError = errors?.[name] && touched?.[name];
  
  if (!hasError) return null;
  
  return (
    <div className={cn('flex items-center gap-2 text-sm text-destructive', className)}>
      <AlertCircle className="h-4 w-4" />
      {errors[name]}
    </div>
  );
}

// Form Success Message component
interface FormSuccessProps {
  children: ReactNode;
  className?: string;
}

export function FormSuccess({ children, className }: FormSuccessProps) {
  return (
    <Alert className={cn('border-success text-success', className)}>
      <CheckCircle2 className="h-4 w-4" />
      <AlertDescription>{children}</AlertDescription>
    </Alert>
  );
}

// Form Actions component
interface FormActionsProps {
  children: ReactNode;
  className?: string;
}

export function FormActions({ children, className }: FormActionsProps) {
  return (
    <div className={cn('flex items-center justify-end gap-3 pt-4', className)}>
      {children}
    </div>
  );
}

// Form Submit Button component
interface FormSubmitButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: ReactNode;
  loadingText?: string;
}

export function FormSubmitButton({ 
  children, 
  loadingText = 'Submitting...', 
  className,
  ...props 
}: FormSubmitButtonProps) {
  const { isSubmitting } = useContext(FormContext);
  
  return (
    <Button 
      type="submit" 
      disabled={isSubmitting}
      className={className}
      {...props}
    >
      {isSubmitting ? loadingText : children}
    </Button>
  );
}

// Form Reset Button component
interface FormResetButtonProps extends React.ButtonHTMLAttributes<HTMLButtonElement> {
  children: ReactNode;
  onReset?: () => void;
}

export function FormResetButton({ children, onReset, ...props }: FormResetButtonProps) {
  const { isSubmitting } = useContext(FormContext);
  
  return (
    <Button 
      type="button" 
      variant="outline"
      disabled={isSubmitting}
      onClick={onReset}
      {...props}
    >
      {children}
    </Button>
  );
}

// Form Group component (for inline fields)
interface FormGroupProps {
  children: ReactNode;
  className?: string;
}

export function FormGroup({ children, className }: FormGroupProps) {
  return (
    <div className={cn('grid gap-4 md:grid-cols-2', className)}>
      {children}
    </div>
  );
}

// Export all components as named exports and compound component
export default Object.assign(Form, {
  Section: FormSection,
  Field: FormField,
  Label: FormLabel,
  Input: FormInput,
  Textarea: FormTextarea,
  Select: FormSelect,
  SelectOption: FormSelectOption,
  HelpText: FormHelpText,
  Error: FormError,
  Success: FormSuccess,
  Actions: FormActions,
  SubmitButton: FormSubmitButton,
  ResetButton: FormResetButton,
  Group: FormGroup,
});
</file>

<file path="src/components/ui/alert.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const alertVariants = cva(
  "relative w-full rounded-lg border px-4 py-3 text-sm grid has-[>svg]:grid-cols-[calc(var(--spacing)*4)_1fr] grid-cols-[0_1fr] has-[>svg]:gap-x-3 gap-y-0.5 items-start [&>svg]:size-4 [&>svg]:translate-y-0.5 [&>svg]:text-current",
  {
    variants: {
      variant: {
        default: "bg-background text-foreground",
        destructive:
          "text-destructive-foreground [&>svg]:text-current *:data-[slot=alert-description]:text-destructive-foreground/80",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

function Alert({
  className,
  variant,
  ...props
}: React.ComponentProps<"div"> & VariantProps<typeof alertVariants>) {
  return (
    <div
      data-slot="alert"
      role="alert"
      className={cn(alertVariants({ variant }), className)}
      {...props}
    />
  )
}

function AlertTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-title"
      className={cn(
        "col-start-2 line-clamp-1 min-h-4 font-medium tracking-tight",
        className
      )}
      {...props}
    />
  )
}

function AlertDescription({
  className,
  ...props
}: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="alert-description"
      className={cn(
        "text-muted-foreground col-start-2 grid justify-items-start gap-1 text-sm [&_p]:leading-relaxed",
        className
      )}
      {...props}
    />
  )
}

export { Alert, AlertTitle, AlertDescription }
</file>

<file path="src/components/ui/avatar.tsx">
"use client"

import * as React from "react"
import * as AvatarPrimitive from "@radix-ui/react-avatar"

import { cn } from "@/lib/utils"

function Avatar({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Root>) {
  return (
    <AvatarPrimitive.Root
      data-slot="avatar"
      className={cn(
        "relative flex size-8 shrink-0 overflow-hidden rounded-full",
        className
      )}
      {...props}
    />
  )
}

function AvatarImage({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Image>) {
  return (
    <AvatarPrimitive.Image
      data-slot="avatar-image"
      className={cn("aspect-square size-full", className)}
      {...props}
    />
  )
}

function AvatarFallback({
  className,
  ...props
}: React.ComponentProps<typeof AvatarPrimitive.Fallback>) {
  return (
    <AvatarPrimitive.Fallback
      data-slot="avatar-fallback"
      className={cn(
        "bg-muted flex size-full items-center justify-center rounded-full",
        className
      )}
      {...props}
    />
  )
}

export { Avatar, AvatarImage, AvatarFallback }
</file>

<file path="src/components/ui/badge.tsx">
import * as React from "react"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const badgeVariants = cva(
  "inline-flex items-center rounded-full px-2.5 py-0.5 text-xs font-medium transition-colors focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground hover:bg-primary/80",
        secondary:
          "bg-secondary text-secondary-foreground hover:bg-secondary/80",
        destructive:
          "bg-destructive text-destructive-foreground hover:bg-destructive/80",
        outline:
          "text-foreground border border-input hover:bg-accent hover:text-accent-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

export interface BadgeProps
  extends React.HTMLAttributes<HTMLDivElement>,
    VariantProps<typeof badgeVariants> {}

function Badge({ className, variant, ...props }: BadgeProps) {
  return (
    <div className={cn(badgeVariants({ variant }), className)} {...props} />
  )
}

export { Badge, badgeVariants }
</file>

<file path="src/components/ui/calendar.tsx">
"use client"

import * as React from "react"
import { ChevronLeft, ChevronRight } from "lucide-react"
import { DayPicker } from "react-day-picker"

import { cn } from "@/lib/utils"
import { buttonVariants } from "@/components/ui/button"

function Calendar({
  className,
  classNames,
  showOutsideDays = true,
  ...props
}: React.ComponentProps<typeof DayPicker>) {
  return (
    <DayPicker
      showOutsideDays={showOutsideDays}
      className={cn("p-3", className)}
      classNames={{
        months: "flex flex-col sm:flex-row gap-2",
        month: "flex flex-col gap-4",
        caption: "flex justify-center pt-1 relative items-center w-full",
        caption_label: "text-sm font-medium",
        nav: "flex items-center gap-1",
        nav_button: cn(
          buttonVariants({ variant: "outline" }),
          "size-7 bg-transparent p-0 opacity-50 hover:opacity-100"
        ),
        nav_button_previous: "absolute left-1",
        nav_button_next: "absolute right-1",
        table: "w-full border-collapse space-x-1",
        head_row: "flex",
        head_cell:
          "text-muted-foreground rounded-md w-8 font-normal text-[0.8rem]",
        row: "flex w-full mt-2",
        cell: cn(
          "relative p-0 text-center text-sm focus-within:relative focus-within:z-20 [&:has([aria-selected])]:bg-accent [&:has([aria-selected].day-range-end)]:rounded-r-md",
          props.mode === "range"
            ? "[&:has(>.day-range-end)]:rounded-r-md [&:has(>.day-range-start)]:rounded-l-md first:[&:has([aria-selected])]:rounded-l-md last:[&:has([aria-selected])]:rounded-r-md"
            : "[&:has([aria-selected])]:rounded-md"
        ),
        day: cn(
          buttonVariants({ variant: "ghost" }),
          "size-8 p-0 font-normal aria-selected:opacity-100"
        ),
        day_range_start:
          "day-range-start aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_range_end:
          "day-range-end aria-selected:bg-primary aria-selected:text-primary-foreground",
        day_selected:
          "bg-primary text-primary-foreground hover:bg-primary hover:text-primary-foreground focus:bg-primary focus:text-primary-foreground",
        day_today: "bg-accent text-accent-foreground",
        day_outside:
          "day-outside text-muted-foreground aria-selected:text-muted-foreground",
        day_disabled: "text-muted-foreground opacity-50",
        day_range_middle:
          "aria-selected:bg-accent aria-selected:text-accent-foreground",
        day_hidden: "invisible",
        ...classNames,
      }}
      components={{
        IconLeft: ({ className, ...props }) => (
          <ChevronLeft className={cn("size-4", className)} {...props} />
        ),
        IconRight: ({ className, ...props }) => (
          <ChevronRight className={cn("size-4", className)} {...props} />
        ),
      }}
      {...props}
    />
  )
}

export { Calendar }
</file>

<file path="src/components/ui/card.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Card({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card"
      className={cn(
        "bg-card text-card-foreground flex flex-col gap-6 rounded-xl border py-6 shadow-sm",
        className
      )}
      {...props}
    />
  )
}

function CardHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-header"
      className={cn("flex flex-col gap-1.5 px-6", className)}
      {...props}
    />
  )
}

function CardTitle({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-title"
      className={cn("leading-none font-semibold", className)}
      {...props}
    />
  )
}

function CardDescription({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

function CardContent({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-content"
      className={cn("px-6", className)}
      {...props}
    />
  )
}

function CardFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="card-footer"
      className={cn("flex items-center px-6", className)}
      {...props}
    />
  )
}

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }
</file>

<file path="src/components/ui/command.tsx">
"use client"

import * as React from "react"
import { Command as CommandPrimitive } from "cmdk"
import { SearchIcon } from "lucide-react"

import { cn } from "@/lib/utils"
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
} from "@/components/ui/dialog"

function Command({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive>) {
  return (
    <CommandPrimitive
      data-slot="command"
      className={cn(
        "bg-popover text-popover-foreground flex h-full w-full flex-col overflow-hidden rounded-md",
        className
      )}
      {...props}
    />
  )
}

function CommandDialog({
  title = "Command Palette",
  description = "Search for a command to run...",
  children,
  ...props
}: React.ComponentProps<typeof Dialog> & {
  title?: string
  description?: string
}) {
  return (
    <Dialog {...props}>
      <DialogHeader className="sr-only">
        <DialogTitle>{title}</DialogTitle>
        <DialogDescription>{description}</DialogDescription>
      </DialogHeader>
      <DialogContent className="overflow-hidden p-0">
        <Command className="[&_[cmdk-group-heading]]:text-muted-foreground **:data-[slot=command-input-wrapper]:h-12 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:font-medium [&_[cmdk-group]]:px-2 [&_[cmdk-group]:not([hidden])_~[cmdk-group]]:pt-0 [&_[cmdk-input-wrapper]_svg]:h-5 [&_[cmdk-input-wrapper]_svg]:w-5 [&_[cmdk-input]]:h-12 [&_[cmdk-item]]:px-2 [&_[cmdk-item]]:py-3 [&_[cmdk-item]_svg]:h-5 [&_[cmdk-item]_svg]:w-5">
          {children}
        </Command>
      </DialogContent>
    </Dialog>
  )
}

function CommandInput({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Input>) {
  return (
    <div
      data-slot="command-input-wrapper"
      className="flex h-9 items-center gap-2 border-b px-3"
    >
      <SearchIcon className="size-4 shrink-0 opacity-50" />
      <CommandPrimitive.Input
        data-slot="command-input"
        className={cn(
          "placeholder:text-muted-foreground flex h-10 w-full rounded-md bg-transparent py-3 text-sm outline-hidden disabled:cursor-not-allowed disabled:opacity-50",
          className
        )}
        {...props}
      />
    </div>
  )
}

function CommandList({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.List>) {
  return (
    <CommandPrimitive.List
      data-slot="command-list"
      className={cn(
        "max-h-[300px] scroll-py-1 overflow-x-hidden overflow-y-auto",
        className
      )}
      {...props}
    />
  )
}

function CommandEmpty({
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Empty>) {
  return (
    <CommandPrimitive.Empty
      data-slot="command-empty"
      className="py-6 text-center text-sm"
      {...props}
    />
  )
}

function CommandGroup({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Group>) {
  return (
    <CommandPrimitive.Group
      data-slot="command-group"
      className={cn(
        "text-foreground [&_[cmdk-group-heading]]:text-muted-foreground overflow-hidden p-1 [&_[cmdk-group-heading]]:px-2 [&_[cmdk-group-heading]]:py-1.5 [&_[cmdk-group-heading]]:text-xs [&_[cmdk-group-heading]]:font-medium",
        className
      )}
      {...props}
    />
  )
}

function CommandSeparator({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Separator>) {
  return (
    <CommandPrimitive.Separator
      data-slot="command-separator"
      className={cn("bg-border -mx-1 h-px", className)}
      {...props}
    />
  )
}

function CommandItem({
  className,
  ...props
}: React.ComponentProps<typeof CommandPrimitive.Item>) {
  return (
    <CommandPrimitive.Item
      data-slot="command-item"
      className={cn(
        "data-[selected=true]:bg-accent data-[selected=true]:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled=true]:pointer-events-none data-[disabled=true]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function CommandShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="command-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

export {
  Command,
  CommandDialog,
  CommandInput,
  CommandList,
  CommandEmpty,
  CommandGroup,
  CommandItem,
  CommandShortcut,
  CommandSeparator,
}
</file>

<file path="src/components/ui/dialog.tsx">
"use client"

import * as React from "react"
import * as DialogPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Dialog({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Root>) {
  return <DialogPrimitive.Root data-slot="dialog" {...props} />
}

function DialogTrigger({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Trigger>) {
  return <DialogPrimitive.Trigger data-slot="dialog-trigger" {...props} />
}

function DialogPortal({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Portal>) {
  return <DialogPrimitive.Portal data-slot="dialog-portal" {...props} />
}

function DialogClose({
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Close>) {
  return <DialogPrimitive.Close data-slot="dialog-close" {...props} />
}

function DialogOverlay({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Overlay>) {
  return (
    <DialogPrimitive.Overlay
      data-slot="dialog-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function DialogContent({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Content>) {
  return (
    <DialogPortal data-slot="dialog-portal">
      <DialogOverlay />
      <DialogPrimitive.Content
        data-slot="dialog-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 fixed top-[50%] left-[50%] z-50 grid w-full max-w-[calc(100%-2rem)] translate-x-[-50%] translate-y-[-50%] gap-4 rounded-lg border p-6 shadow-lg duration-200 sm:max-w-lg",
          className
        )}
        {...props}
      >
        {children}
        <DialogPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-accent data-[state=open]:text-muted-foreground absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4">
          <XIcon />
          <span className="sr-only">Close</span>
        </DialogPrimitive.Close>
      </DialogPrimitive.Content>
    </DialogPortal>
  )
}

function DialogHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-header"
      className={cn("flex flex-col gap-2 text-center sm:text-left", className)}
      {...props}
    />
  )
}

function DialogFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="dialog-footer"
      className={cn(
        "flex flex-col-reverse gap-2 sm:flex-row sm:justify-end",
        className
      )}
      {...props}
    />
  )
}

function DialogTitle({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Title>) {
  return (
    <DialogPrimitive.Title
      data-slot="dialog-title"
      className={cn("text-lg leading-none font-semibold", className)}
      {...props}
    />
  )
}

function DialogDescription({
  className,
  ...props
}: React.ComponentProps<typeof DialogPrimitive.Description>) {
  return (
    <DialogPrimitive.Description
      data-slot="dialog-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Dialog,
  DialogClose,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogOverlay,
  DialogPortal,
  DialogTitle,
  DialogTrigger,
}
</file>

<file path="src/components/ui/dropdown-menu.tsx">
"use client"

import * as React from "react"
import * as DropdownMenuPrimitive from "@radix-ui/react-dropdown-menu"
import { CheckIcon, ChevronRightIcon, CircleIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function DropdownMenu({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Root>) {
  return <DropdownMenuPrimitive.Root data-slot="dropdown-menu" {...props} />
}

function DropdownMenuPortal({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Portal>) {
  return (
    <DropdownMenuPrimitive.Portal data-slot="dropdown-menu-portal" {...props} />
  )
}

function DropdownMenuTrigger({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Trigger>) {
  return (
    <DropdownMenuPrimitive.Trigger
      data-slot="dropdown-menu-trigger"
      {...props}
    />
  )
}

function DropdownMenuContent({
  className,
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Content>) {
  return (
    <DropdownMenuPrimitive.Portal>
      <DropdownMenuPrimitive.Content
        data-slot="dropdown-menu-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-md",
          className
        )}
        {...props}
      />
    </DropdownMenuPrimitive.Portal>
  )
}

function DropdownMenuGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Group>) {
  return (
    <DropdownMenuPrimitive.Group data-slot="dropdown-menu-group" {...props} />
  )
}

function DropdownMenuItem({
  className,
  inset,
  variant = "default",
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Item> & {
  inset?: boolean
  variant?: "default" | "destructive"
}) {
  return (
    <DropdownMenuPrimitive.Item
      data-slot="dropdown-menu-item"
      data-inset={inset}
      data-variant={variant}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[variant=destructive]:text-destructive-foreground data-[variant=destructive]:focus:bg-destructive/10 dark:data-[variant=destructive]:focus:bg-destructive/40 data-[variant=destructive]:focus:text-destructive-foreground data-[variant=destructive]:*:[svg]:!text-destructive-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex cursor-default items-center gap-2 rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 data-[inset]:pl-8 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuCheckboxItem({
  className,
  children,
  checked,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.CheckboxItem>) {
  return (
    <DropdownMenuPrimitive.CheckboxItem
      data-slot="dropdown-menu-checkbox-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      checked={checked}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.CheckboxItem>
  )
}

function DropdownMenuRadioGroup({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioGroup>) {
  return (
    <DropdownMenuPrimitive.RadioGroup
      data-slot="dropdown-menu-radio-group"
      {...props}
    />
  )
}

function DropdownMenuRadioItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.RadioItem>) {
  return (
    <DropdownMenuPrimitive.RadioItem
      data-slot="dropdown-menu-radio-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground relative flex cursor-default items-center gap-2 rounded-sm py-1.5 pr-2 pl-8 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      <span className="pointer-events-none absolute left-2 flex size-3.5 items-center justify-center">
        <DropdownMenuPrimitive.ItemIndicator>
          <CircleIcon className="size-2 fill-current" />
        </DropdownMenuPrimitive.ItemIndicator>
      </span>
      {children}
    </DropdownMenuPrimitive.RadioItem>
  )
}

function DropdownMenuLabel({
  className,
  inset,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Label> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.Label
      data-slot="dropdown-menu-label"
      data-inset={inset}
      className={cn(
        "px-2 py-1.5 text-sm font-medium data-[inset]:pl-8",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSeparator({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Separator>) {
  return (
    <DropdownMenuPrimitive.Separator
      data-slot="dropdown-menu-separator"
      className={cn("bg-border -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function DropdownMenuShortcut({
  className,
  ...props
}: React.ComponentProps<"span">) {
  return (
    <span
      data-slot="dropdown-menu-shortcut"
      className={cn(
        "text-muted-foreground ml-auto text-xs tracking-widest",
        className
      )}
      {...props}
    />
  )
}

function DropdownMenuSub({
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.Sub>) {
  return <DropdownMenuPrimitive.Sub data-slot="dropdown-menu-sub" {...props} />
}

function DropdownMenuSubTrigger({
  className,
  inset,
  children,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubTrigger> & {
  inset?: boolean
}) {
  return (
    <DropdownMenuPrimitive.SubTrigger
      data-slot="dropdown-menu-sub-trigger"
      data-inset={inset}
      className={cn(
        "focus:bg-accent focus:text-accent-foreground data-[state=open]:bg-accent data-[state=open]:text-accent-foreground flex cursor-default items-center rounded-sm px-2 py-1.5 text-sm outline-hidden select-none data-[inset]:pl-8",
        className
      )}
      {...props}
    >
      {children}
      <ChevronRightIcon className="ml-auto size-4" />
    </DropdownMenuPrimitive.SubTrigger>
  )
}

function DropdownMenuSubContent({
  className,
  ...props
}: React.ComponentProps<typeof DropdownMenuPrimitive.SubContent>) {
  return (
    <DropdownMenuPrimitive.SubContent
      data-slot="dropdown-menu-sub-content"
      className={cn(
        "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 min-w-[8rem] overflow-hidden rounded-md border p-1 shadow-lg",
        className
      )}
      {...props}
    />
  )
}

export {
  DropdownMenu,
  DropdownMenuPortal,
  DropdownMenuTrigger,
  DropdownMenuContent,
  DropdownMenuGroup,
  DropdownMenuLabel,
  DropdownMenuItem,
  DropdownMenuCheckboxItem,
  DropdownMenuRadioGroup,
  DropdownMenuRadioItem,
  DropdownMenuSeparator,
  DropdownMenuShortcut,
  DropdownMenuSub,
  DropdownMenuSubTrigger,
  DropdownMenuSubContent,
}
</file>

<file path="src/components/ui/input.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Input({ className, type, ...props }: React.ComponentProps<"input">) {
  return (
    <input
      type={type}
      data-slot="input"
      className={cn(
        "border-input file:text-foreground placeholder:text-muted-foreground selection:bg-primary selection:text-primary-foreground flex h-9 w-full min-w-0 rounded-md border bg-transparent px-3 py-1 text-base shadow-xs transition-[color,box-shadow] outline-none file:inline-flex file:h-7 file:border-0 file:bg-transparent file:text-sm file:font-medium disabled:pointer-events-none disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        "focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px]",
        "aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
        className
      )}
      {...props}
    />
  )
}

export { Input }
</file>

<file path="src/components/ui/label.tsx">
"use client"

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"

import { cn } from "@/lib/utils"

function Label({
  className,
  ...props
}: React.ComponentProps<typeof LabelPrimitive.Root>) {
  return (
    <LabelPrimitive.Root
      data-slot="label"
      className={cn(
        "flex items-center gap-2 text-sm leading-none font-medium select-none group-data-[disabled=true]:pointer-events-none group-data-[disabled=true]:opacity-50 peer-disabled:cursor-not-allowed peer-disabled:opacity-50",
        className
      )}
      {...props}
    />
  )
}

export { Label }
</file>

<file path="src/components/ui/popover.tsx">
"use client"

import * as React from "react"
import * as PopoverPrimitive from "@radix-ui/react-popover"

import { cn } from "@/lib/utils"

function Popover({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Root>) {
  return <PopoverPrimitive.Root data-slot="popover" {...props} />
}

function PopoverTrigger({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Trigger>) {
  return <PopoverPrimitive.Trigger data-slot="popover-trigger" {...props} />
}

function PopoverContent({
  className,
  align = "center",
  sideOffset = 4,
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Content>) {
  return (
    <PopoverPrimitive.Portal>
      <PopoverPrimitive.Content
        data-slot="popover-content"
        align={align}
        sideOffset={sideOffset}
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-72 origin-(--radix-popover-content-transform-origin) rounded-md border p-4 shadow-md outline-hidden",
          className
        )}
        {...props}
      />
    </PopoverPrimitive.Portal>
  )
}

function PopoverAnchor({
  ...props
}: React.ComponentProps<typeof PopoverPrimitive.Anchor>) {
  return <PopoverPrimitive.Anchor data-slot="popover-anchor" {...props} />
}

export { Popover, PopoverTrigger, PopoverContent, PopoverAnchor }
</file>

<file path="src/components/ui/progress.tsx">
"use client"

import * as React from "react"
import * as ProgressPrimitive from "@radix-ui/react-progress"

import { cn } from "@/lib/utils"

const Progress = React.forwardRef<
  React.ElementRef<typeof ProgressPrimitive.Root>,
  React.ComponentPropsWithoutRef<typeof ProgressPrimitive.Root>
>(({ className, value, ...props }, ref) => (
  <ProgressPrimitive.Root
    ref={ref}
    className={cn(
      "relative h-4 w-full overflow-hidden rounded-full bg-secondary",
      className
    )}
    {...props}
  >
    <ProgressPrimitive.Indicator
      className="h-full w-full flex-1 bg-primary transition-all"
      style={{ transform: `translateX(-${100 - (value || 0)}%)` }}
    />
  </ProgressPrimitive.Root>
))
Progress.displayName = ProgressPrimitive.Root.displayName

export { Progress }
</file>

<file path="src/components/ui/scroll-area.tsx">
"use client"

import * as React from "react"
import * as ScrollAreaPrimitive from "@radix-ui/react-scroll-area"

import { cn } from "@/lib/utils"

function ScrollArea({
  className,
  children,
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.Root>) {
  return (
    <ScrollAreaPrimitive.Root
      data-slot="scroll-area"
      className={cn("relative", className)}
      {...props}
    >
      <ScrollAreaPrimitive.Viewport
        data-slot="scroll-area-viewport"
        className="ring-ring/10 dark:ring-ring/20 dark:outline-ring/40 outline-ring/50 size-full rounded-[inherit] transition-[color,box-shadow] focus-visible:ring-4 focus-visible:outline-1"
      >
        {children}
      </ScrollAreaPrimitive.Viewport>
      <ScrollBar />
      <ScrollAreaPrimitive.Corner />
    </ScrollAreaPrimitive.Root>
  )
}

function ScrollBar({
  className,
  orientation = "vertical",
  ...props
}: React.ComponentProps<typeof ScrollAreaPrimitive.ScrollAreaScrollbar>) {
  return (
    <ScrollAreaPrimitive.ScrollAreaScrollbar
      data-slot="scroll-area-scrollbar"
      orientation={orientation}
      className={cn(
        "flex touch-none p-px transition-colors select-none",
        orientation === "vertical" &&
          "h-full w-2.5 border-l border-l-transparent",
        orientation === "horizontal" &&
          "h-2.5 flex-col border-t border-t-transparent",
        className
      )}
      {...props}
    >
      <ScrollAreaPrimitive.ScrollAreaThumb
        data-slot="scroll-area-thumb"
        className="bg-border relative flex-1 rounded-full"
      />
    </ScrollAreaPrimitive.ScrollAreaScrollbar>
  )
}

export { ScrollArea, ScrollBar }
</file>

<file path="src/components/ui/select.tsx">
"use client"

import * as React from "react"
import * as SelectPrimitive from "@radix-ui/react-select"
import { CheckIcon, ChevronDownIcon, ChevronUpIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Select({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Root>) {
  return <SelectPrimitive.Root data-slot="select" {...props} />
}

function SelectGroup({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Group>) {
  return <SelectPrimitive.Group data-slot="select-group" {...props} />
}

function SelectValue({
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Value>) {
  return <SelectPrimitive.Value data-slot="select-value" {...props} />
}

function SelectTrigger({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Trigger>) {
  return (
    <SelectPrimitive.Trigger
      data-slot="select-trigger"
      className={cn(
        "border-input data-[placeholder]:text-muted-foreground [&_svg:not([class*='text-'])]:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive flex h-9 w-full items-center justify-between gap-2 rounded-md border bg-transparent px-3 py-2 text-sm whitespace-nowrap shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 *:data-[slot=select-value]:line-clamp-1 *:data-[slot=select-value]:flex *:data-[slot=select-value]:items-center *:data-[slot=select-value]:gap-2 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    >
      {children}
      <SelectPrimitive.Icon asChild>
        <ChevronDownIcon className="size-4 opacity-50" />
      </SelectPrimitive.Icon>
    </SelectPrimitive.Trigger>
  )
}

function SelectContent({
  className,
  children,
  position = "popper",
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Content>) {
  return (
    <SelectPrimitive.Portal>
      <SelectPrimitive.Content
        data-slot="select-content"
        className={cn(
          "bg-popover text-popover-foreground data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 relative z-50 max-h-96 min-w-[8rem] overflow-hidden rounded-md border shadow-md",
          position === "popper" &&
            "data-[side=bottom]:translate-y-1 data-[side=left]:-translate-x-1 data-[side=right]:translate-x-1 data-[side=top]:-translate-y-1",
          className
        )}
        position={position}
        {...props}
      >
        <SelectScrollUpButton />
        <SelectPrimitive.Viewport
          className={cn(
            "p-1",
            position === "popper" &&
              "h-[var(--radix-select-trigger-height)] w-full min-w-[var(--radix-select-trigger-width)] scroll-my-1"
          )}
        >
          {children}
        </SelectPrimitive.Viewport>
        <SelectScrollDownButton />
      </SelectPrimitive.Content>
    </SelectPrimitive.Portal>
  )
}

function SelectLabel({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Label>) {
  return (
    <SelectPrimitive.Label
      data-slot="select-label"
      className={cn("px-2 py-1.5 text-sm font-medium", className)}
      {...props}
    />
  )
}

function SelectItem({
  className,
  children,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Item>) {
  return (
    <SelectPrimitive.Item
      data-slot="select-item"
      className={cn(
        "focus:bg-accent focus:text-accent-foreground [&_svg:not([class*='text-'])]:text-muted-foreground relative flex w-full cursor-default items-center gap-2 rounded-sm py-1.5 pr-8 pl-2 text-sm outline-hidden select-none data-[disabled]:pointer-events-none data-[disabled]:opacity-50 [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4 *:[span]:last:flex *:[span]:last:items-center *:[span]:last:gap-2",
        className
      )}
      {...props}
    >
      <span className="absolute right-2 flex size-3.5 items-center justify-center">
        <SelectPrimitive.ItemIndicator>
          <CheckIcon className="size-4" />
        </SelectPrimitive.ItemIndicator>
      </span>
      <SelectPrimitive.ItemText>{children}</SelectPrimitive.ItemText>
    </SelectPrimitive.Item>
  )
}

function SelectSeparator({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.Separator>) {
  return (
    <SelectPrimitive.Separator
      data-slot="select-separator"
      className={cn("bg-border pointer-events-none -mx-1 my-1 h-px", className)}
      {...props}
    />
  )
}

function SelectScrollUpButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollUpButton>) {
  return (
    <SelectPrimitive.ScrollUpButton
      data-slot="select-scroll-up-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronUpIcon className="size-4" />
    </SelectPrimitive.ScrollUpButton>
  )
}

function SelectScrollDownButton({
  className,
  ...props
}: React.ComponentProps<typeof SelectPrimitive.ScrollDownButton>) {
  return (
    <SelectPrimitive.ScrollDownButton
      data-slot="select-scroll-down-button"
      className={cn(
        "flex cursor-default items-center justify-center py-1",
        className
      )}
      {...props}
    >
      <ChevronDownIcon className="size-4" />
    </SelectPrimitive.ScrollDownButton>
  )
}

export {
  Select,
  SelectContent,
  SelectGroup,
  SelectItem,
  SelectLabel,
  SelectScrollDownButton,
  SelectScrollUpButton,
  SelectSeparator,
  SelectTrigger,
  SelectValue,
}
</file>

<file path="src/components/ui/separator.tsx">
"use client"

import * as React from "react"
import * as SeparatorPrimitive from "@radix-ui/react-separator"

import { cn } from "@/lib/utils"

function Separator({
  className,
  orientation = "horizontal",
  decorative = true,
  ...props
}: React.ComponentProps<typeof SeparatorPrimitive.Root>) {
  return (
    <SeparatorPrimitive.Root
      data-slot="separator-root"
      decorative={decorative}
      orientation={orientation}
      className={cn(
        "bg-border shrink-0 data-[orientation=horizontal]:h-px data-[orientation=horizontal]:w-full data-[orientation=vertical]:h-full data-[orientation=vertical]:w-px",
        className
      )}
      {...props}
    />
  )
}

export { Separator }
</file>

<file path="src/components/ui/sheet.tsx">
"use client"

import * as React from "react"
import * as SheetPrimitive from "@radix-ui/react-dialog"
import { XIcon } from "lucide-react"

import { cn } from "@/lib/utils"

function Sheet({ ...props }: React.ComponentProps<typeof SheetPrimitive.Root>) {
  return <SheetPrimitive.Root data-slot="sheet" {...props} />
}

function SheetTrigger({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Trigger>) {
  return <SheetPrimitive.Trigger data-slot="sheet-trigger" {...props} />
}

function SheetClose({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Close>) {
  return <SheetPrimitive.Close data-slot="sheet-close" {...props} />
}

function SheetPortal({
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Portal>) {
  return <SheetPrimitive.Portal data-slot="sheet-portal" {...props} />
}

function SheetOverlay({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Overlay>) {
  return (
    <SheetPrimitive.Overlay
      data-slot="sheet-overlay"
      className={cn(
        "data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 fixed inset-0 z-50 bg-black/80",
        className
      )}
      {...props}
    />
  )
}

function SheetContent({
  className,
  children,
  side = "right",
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Content> & {
  side?: "top" | "right" | "bottom" | "left"
}) {
  return (
    <SheetPortal>
      <SheetOverlay />
      <SheetPrimitive.Content
        data-slot="sheet-content"
        className={cn(
          "bg-background data-[state=open]:animate-in data-[state=closed]:animate-out fixed z-50 flex flex-col gap-4 shadow-lg transition ease-in-out data-[state=closed]:duration-300 data-[state=open]:duration-500",
          side === "right" &&
            "data-[state=closed]:slide-out-to-right data-[state=open]:slide-in-from-right inset-y-0 right-0 h-full w-3/4 border-l sm:max-w-sm",
          side === "left" &&
            "data-[state=closed]:slide-out-to-left data-[state=open]:slide-in-from-left inset-y-0 left-0 h-full w-3/4 border-r sm:max-w-sm",
          side === "top" &&
            "data-[state=closed]:slide-out-to-top data-[state=open]:slide-in-from-top inset-x-0 top-0 h-auto border-b",
          side === "bottom" &&
            "data-[state=closed]:slide-out-to-bottom data-[state=open]:slide-in-from-bottom inset-x-0 bottom-0 h-auto border-t",
          className
        )}
        {...props}
      >
        {children}
        <SheetPrimitive.Close className="ring-offset-background focus:ring-ring data-[state=open]:bg-secondary absolute top-4 right-4 rounded-xs opacity-70 transition-opacity hover:opacity-100 focus:ring-2 focus:ring-offset-2 focus:outline-hidden disabled:pointer-events-none">
          <XIcon className="size-4" />
          <span className="sr-only">Close</span>
        </SheetPrimitive.Close>
      </SheetPrimitive.Content>
    </SheetPortal>
  )
}

function SheetHeader({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-header"
      className={cn("flex flex-col gap-1.5 p-4", className)}
      {...props}
    />
  )
}

function SheetFooter({ className, ...props }: React.ComponentProps<"div">) {
  return (
    <div
      data-slot="sheet-footer"
      className={cn("mt-auto flex flex-col gap-2 p-4", className)}
      {...props}
    />
  )
}

function SheetTitle({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Title>) {
  return (
    <SheetPrimitive.Title
      data-slot="sheet-title"
      className={cn("text-foreground font-semibold", className)}
      {...props}
    />
  )
}

function SheetDescription({
  className,
  ...props
}: React.ComponentProps<typeof SheetPrimitive.Description>) {
  return (
    <SheetPrimitive.Description
      data-slot="sheet-description"
      className={cn("text-muted-foreground text-sm", className)}
      {...props}
    />
  )
}

export {
  Sheet,
  SheetTrigger,
  SheetClose,
  SheetContent,
  SheetHeader,
  SheetFooter,
  SheetTitle,
  SheetDescription,
}
</file>

<file path="src/components/ui/switch.tsx">
"use client"

import * as React from "react"
import * as SwitchPrimitive from "@radix-ui/react-switch"

import { cn } from "@/lib/utils"

function Switch({
  className,
  ...props
}: React.ComponentProps<typeof SwitchPrimitive.Root>) {
  return (
    <SwitchPrimitive.Root
      data-slot="switch"
      className={cn(
        "peer data-[state=checked]:bg-primary data-[state=unchecked]:bg-input focus-visible:border-ring focus-visible:ring-ring/50 dark:data-[state=unchecked]:bg-input/80 inline-flex h-[1.15rem] w-8 shrink-0 items-center rounded-full border border-transparent shadow-xs transition-all outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}
    >
      <SwitchPrimitive.Thumb
        data-slot="switch-thumb"
        className={cn(
          "bg-background dark:data-[state=unchecked]:bg-foreground dark:data-[state=checked]:bg-primary-foreground pointer-events-none block size-4 rounded-full ring-0 transition-transform data-[state=checked]:translate-x-[calc(100%-2px)] data-[state=unchecked]:translate-x-0"
        )}
      />
    </SwitchPrimitive.Root>
  )
}

export { Switch }
</file>

<file path="src/components/ui/table.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

const Table = React.forwardRef<
  HTMLTableElement,
  React.HTMLAttributes<HTMLTableElement>
>(({ className, ...props }, ref) => (
  <div className="relative w-full overflow-auto">
    <table
      ref={ref}
      className={cn("w-full caption-bottom text-sm", className)}
      {...props}
    />
  </div>
))
Table.displayName = "Table"

const TableHeader = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <thead ref={ref} className={cn("[&_tr]:border-b", className)} {...props} />
))
TableHeader.displayName = "TableHeader"

const TableBody = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tbody
    ref={ref}
    className={cn("[&_tr:last-child]:border-0", className)}
    {...props}
  />
))
TableBody.displayName = "TableBody"

const TableFooter = React.forwardRef<
  HTMLTableSectionElement,
  React.HTMLAttributes<HTMLTableSectionElement>
>(({ className, ...props }, ref) => (
  <tfoot
    ref={ref}
    className={cn(
      "border-t bg-muted/50 font-medium [&>tr]:last:border-b-0",
      className
    )}
    {...props}
  />
))
TableFooter.displayName = "TableFooter"

const TableRow = React.forwardRef<
  HTMLTableRowElement,
  React.HTMLAttributes<HTMLTableRowElement>
>(({ className, ...props }, ref) => (
  <tr
    ref={ref}
    className={cn(
      "border-b transition-colors hover:bg-muted/50 data-[state=selected]:bg-muted",
      className
    )}
    {...props}
  />
))
TableRow.displayName = "TableRow"

const TableHead = React.forwardRef<
  HTMLTableCellElement,
  React.ThHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <th
    ref={ref}
    className={cn(
      "h-12 px-4 text-left align-middle font-medium text-muted-foreground [&:has([role=checkbox])]:pr-0",
      className
    )}
    {...props}
  />
))
TableHead.displayName = "TableHead"

const TableCell = React.forwardRef<
  HTMLTableCellElement,
  React.TdHTMLAttributes<HTMLTableCellElement>
>(({ className, ...props }, ref) => (
  <td
    ref={ref}
    className={cn("p-4 align-middle [&:has([role=checkbox])]:pr-0", className)}
    {...props}
  />
))
TableCell.displayName = "TableCell"

const TableCaption = React.forwardRef<
  HTMLTableCaptionElement,
  React.HTMLAttributes<HTMLTableCaptionElement>
>(({ className, ...props }, ref) => (
  <caption
    ref={ref}
    className={cn("mt-4 text-sm text-muted-foreground", className)}
    {...props}
  />
))
TableCaption.displayName = "TableCaption"

export {
  Table,
  TableHeader,
  TableBody,
  TableFooter,
  TableHead,
  TableRow,
  TableCell,
  TableCaption,
}
</file>

<file path="src/components/ui/tabs.tsx">
"use client"

import * as React from "react"
import * as TabsPrimitive from "@radix-ui/react-tabs"

import { cn } from "@/lib/utils"

function Tabs({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Root>) {
  return (
    <TabsPrimitive.Root
      data-slot="tabs"
      className={cn("flex flex-col gap-2", className)}
      {...props}
    />
  )
}

function TabsList({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.List>) {
  return (
    <TabsPrimitive.List
      data-slot="tabs-list"
      className={cn(
        "bg-muted text-muted-foreground inline-flex h-9 w-fit items-center justify-center rounded-lg p-1",
        className
      )}
      {...props}
    />
  )
}

function TabsTrigger({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Trigger>) {
  return (
    <TabsPrimitive.Trigger
      data-slot="tabs-trigger"
      className={cn(
        "data-[state=active]:bg-background data-[state=active]:text-foreground focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:outline-ring inline-flex items-center justify-center gap-1.5 rounded-md px-2 py-1 text-sm font-medium whitespace-nowrap transition-[color,box-shadow] focus-visible:ring-[3px] focus-visible:outline-1 disabled:pointer-events-none disabled:opacity-50 data-[state=active]:shadow-sm [&_svg]:pointer-events-none [&_svg]:shrink-0 [&_svg:not([class*='size-'])]:size-4",
        className
      )}
      {...props}
    />
  )
}

function TabsContent({
  className,
  ...props
}: React.ComponentProps<typeof TabsPrimitive.Content>) {
  return (
    <TabsPrimitive.Content
      data-slot="tabs-content"
      className={cn("flex-1 outline-none", className)}
      {...props}
    />
  )
}

export { Tabs, TabsList, TabsTrigger, TabsContent }
</file>

<file path="src/components/ui/textarea.tsx">
import * as React from "react"

import { cn } from "@/lib/utils"

function Textarea({ className, ...props }: React.ComponentProps<"textarea">) {
  return (
    <textarea
      data-slot="textarea"
      className={cn(
        "border-input placeholder:text-muted-foreground focus-visible:border-ring focus-visible:ring-ring/50 aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive dark:bg-input/30 flex field-sizing-content min-h-16 w-full rounded-md border bg-transparent px-3 py-2 text-base shadow-xs transition-[color,box-shadow] outline-none focus-visible:ring-[3px] disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      {...props}
    />
  )
}

export { Textarea }
</file>

<file path="src/components/ui/tooltip.tsx">
"use client"

import * as React from "react"
import * as TooltipPrimitive from "@radix-ui/react-tooltip"

import { cn } from "@/lib/utils"

function TooltipProvider({
  delayDuration = 0,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Provider>) {
  return (
    <TooltipPrimitive.Provider
      data-slot="tooltip-provider"
      delayDuration={delayDuration}
      {...props}
    />
  )
}

function Tooltip({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Root>) {
  return (
    <TooltipProvider>
      <TooltipPrimitive.Root data-slot="tooltip" {...props} />
    </TooltipProvider>
  )
}

function TooltipTrigger({
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Trigger>) {
  return <TooltipPrimitive.Trigger data-slot="tooltip-trigger" {...props} />
}

function TooltipContent({
  className,
  sideOffset = 0,
  children,
  ...props
}: React.ComponentProps<typeof TooltipPrimitive.Content>) {
  return (
    <TooltipPrimitive.Portal>
      <TooltipPrimitive.Content
        data-slot="tooltip-content"
        sideOffset={sideOffset}
        className={cn(
          "bg-primary text-primary-foreground animate-in fade-in-0 zoom-in-95 data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=closed]:zoom-out-95 data-[side=bottom]:slide-in-from-top-2 data-[side=left]:slide-in-from-right-2 data-[side=right]:slide-in-from-left-2 data-[side=top]:slide-in-from-bottom-2 z-50 w-fit origin-(--radix-tooltip-content-transform-origin) rounded-md px-3 py-1.5 text-xs text-balance",
          className
        )}
        {...props}
      >
        {children}
        <TooltipPrimitive.Arrow className="bg-primary fill-primary z-50 size-2.5 translate-y-[calc(-50%_-_2px)] rotate-45 rounded-[2px]" />
      </TooltipPrimitive.Content>
    </TooltipPrimitive.Portal>
  )
}

export { Tooltip, TooltipTrigger, TooltipContent, TooltipProvider }
</file>

<file path="src/hooks/useConvexWithMonitoring.ts">
import { useCallback } from 'react';
import { useMutation, useQuery, Preloaded, usePreloadedQuery } from 'convex/react';
import { FunctionReference, FunctionReturnType, FunctionArgs } from 'convex/server';
import { measurePerformance } from '@/lib/monitoring';

/**
 * Enhanced Convex mutation hook with performance monitoring
 */
export function useMutationWithMonitoring<Mutation extends FunctionReference<'mutation'>>(
  mutationReference: Mutation
) {
  const mutation = useMutation(mutationReference);
  
  return useCallback(
    async (args: FunctionArgs<Mutation>): Promise<FunctionReturnType<Mutation>> => {
      const functionName = mutationReference._name || 'unknown_mutation';
      
      return measurePerformance.measureConvexCall(functionName, () => 
        mutation(args)
      );
    },
    [mutation, mutationReference]
  );
}

/**
 * Enhanced Convex query hook with performance monitoring
 */
export function useQueryWithMonitoring<Query extends FunctionReference<'query'>>(
  queryReference: Query,
  args: FunctionArgs<Query>
) {
  // Note: useQuery doesn't return a promise, so we can't directly measure it
  // Instead, we'll track when the query result changes
  const result = useQuery(queryReference, args);
  
  // Track query performance when result changes
  const functionName = queryReference._name || 'unknown_query';
  
  // Log query execution (this happens on every render when args change)
  if (result !== undefined) {
    // Query completed successfully
    if (typeof window !== 'undefined' && (window as any).convexAnalytics) {
      (window as any).convexAnalytics.logEvent('convex_query_completed', {
        function: functionName,
        hasResult: result !== null,
        resultType: Array.isArray(result) ? 'array' : typeof result,
      });
    }
  }
  
  return result;
}

/**
 * Enhanced preloaded query hook with monitoring
 */
export function usePreloadedQueryWithMonitoring<Query extends FunctionReference<'query'>>(
  queryReference: Query,
  preloadedQuery: Preloaded<Query>
): FunctionReturnType<Query> {
  const result = usePreloadedQuery(preloadedQuery);
  const functionName = queryReference._name || 'unknown_preloaded_query';
  
  // Track preloaded query usage
  if (typeof window !== 'undefined' && (window as any).convexAnalytics) {
    (window as any).convexAnalytics.logEvent('convex_preloaded_query_used', {
      function: functionName,
      hasResult: result !== null,
      resultType: Array.isArray(result) ? 'array' : typeof result,
    });
  }
  
  return result;
}

/**
 * Utility to measure any async operation with Convex context
 */
export function useMeasuredOperation() {
  return useCallback(
    async <T>(operationName: string, operation: () => Promise<T>): Promise<T> => {
      return measurePerformance.measureConvexCall(operationName, operation);
    },
    []
  );
}

export default {
  useMutationWithMonitoring,
  useQueryWithMonitoring,
  usePreloadedQueryWithMonitoring,
  useMeasuredOperation,
};
</file>

<file path="src/hooks/useDebounce.ts">
import { useState, useEffect } from 'react';

/**
 * Custom hook that debounces a value
 * @param value - The value to debounce
 * @param delay - The delay in milliseconds
 * @returns The debounced value
 */
export function useDebounce<T>(value: T, delay: number): T {
  const [debouncedValue, setDebouncedValue] = useState<T>(value);

  useEffect(() => {
    const handler = setTimeout(() => {
      setDebouncedValue(value);
    }, delay);

    return () => {
      clearTimeout(handler);
    };
  }, [value, delay]);

  return debouncedValue;
}

export default useDebounce;
</file>

<file path="src/hooks/useInfiniteScroll.ts">
import { useState, useEffect, useCallback, useRef } from 'react';

export interface InfiniteScrollConfig {
  threshold?: number;
  hasMore?: boolean;
  isLoading?: boolean;
  rootMargin?: string;
}

export interface InfiniteScrollResult {
  lastElementRef: (node: HTMLElement | null) => void;
  isLoading: boolean;
  hasMore: boolean;
}

/**
 * Custom hook for infinite scrolling with Intersection Observer
 * @param fetchMore - Function to call when more data is needed
 * @param config - Configuration options
 */
export function useInfiniteScroll(
  fetchMore: () => void | Promise<void>,
  {
    threshold = 1.0,
    hasMore = true,
    isLoading = false,
    rootMargin = '100px',
  }: InfiniteScrollConfig = {}
): InfiniteScrollResult {
  const [isFetching, setIsFetching] = useState(false);
  const observerRef = useRef<IntersectionObserver | null>(null);

  const lastElementRef = useCallback(
    (node: HTMLElement | null) => {
      if (isLoading || isFetching) return;
      
      if (observerRef.current) {
        observerRef.current.disconnect();
      }

      observerRef.current = new IntersectionObserver(
        (entries) => {
          if (entries[0]?.isIntersecting && hasMore && !isLoading && !isFetching) {
            setIsFetching(true);
            
            const result = fetchMore();
            
            if (result instanceof Promise) {
              result.finally(() => setIsFetching(false));
            } else {
              setIsFetching(false);
            }
          }
        },
        {
          threshold,
          rootMargin,
        }
      );

      if (node) {
        observerRef.current.observe(node);
      }
    },
    [isLoading, isFetching, hasMore, fetchMore, threshold, rootMargin]
  );

  useEffect(() => {
    return () => {
      if (observerRef.current) {
        observerRef.current.disconnect();
      }
    };
  }, []);

  return {
    lastElementRef,
    isLoading: isLoading || isFetching,
    hasMore,
  };
}

export default useInfiniteScroll;
</file>

<file path="src/hooks/useLocalStorage.ts">
import { useState, useEffect, useCallback } from 'react';

/**
 * Custom hook for managing localStorage with TypeScript support
 * @param key - The localStorage key
 * @param initialValue - The initial value if key doesn't exist
 * @returns [value, setValue, removeValue]
 */
export function useLocalStorage<T>(
  key: string,
  initialValue: T
): [T, (value: T | ((prevValue: T) => T)) => void, () => void] {
  // Get from local storage then parse stored json or return initialValue
  const [storedValue, setStoredValue] = useState<T>(() => {
    if (typeof window === 'undefined') {
      return initialValue;
    }

    try {
      const item = window.localStorage.getItem(key);
      return item ? JSON.parse(item) : initialValue;
    } catch (error) {
      console.warn(`Error reading localStorage key "${key}":`, error);
      return initialValue;
    }
  });

  // Return a wrapped version of useState's setter function that persists the new value to localStorage
  const setValue = useCallback(
    (value: T | ((prevValue: T) => T)) => {
      try {
        // Allow value to be a function so we have the same API as useState
        const valueToStore = value instanceof Function ? value(storedValue) : value;
        
        setStoredValue(valueToStore);
        
        if (typeof window !== 'undefined') {
          window.localStorage.setItem(key, JSON.stringify(valueToStore));
        }
      } catch (error) {
        console.warn(`Error setting localStorage key "${key}":`, error);
      }
    },
    [key, storedValue]
  );

  // Remove value from localStorage
  const removeValue = useCallback(() => {
    try {
      setStoredValue(initialValue);
      if (typeof window !== 'undefined') {
        window.localStorage.removeItem(key);
      }
    } catch (error) {
      console.warn(`Error removing localStorage key "${key}":`, error);
    }
  }, [key, initialValue]);

  // Listen for storage changes from other tabs/windows
  useEffect(() => {
    if (typeof window === 'undefined') {
      return;
    }

    const handleStorageChange = (e: StorageEvent) => {
      if (e.key === key && e.newValue !== null) {
        try {
          setStoredValue(JSON.parse(e.newValue));
        } catch (error) {
          console.warn(`Error parsing localStorage value for key "${key}":`, error);
        }
      }
    };

    window.addEventListener('storage', handleStorageChange);
    return () => window.removeEventListener('storage', handleStorageChange);
  }, [key]);

  return [storedValue, setValue, removeValue];
}

export default useLocalStorage;
</file>

<file path="src/hooks/useMediaQuery.ts">
import { useState, useEffect } from 'react';

/**
 * Custom hook for responsive design with media queries
 * @param query - The media query string
 * @returns boolean indicating if the query matches
 */
export function useMediaQuery(query: string): boolean {
  const [matches, setMatches] = useState(false);

  useEffect(() => {
    if (typeof window === 'undefined') {
      return;
    }

    const mediaQuery = window.matchMedia(query);
    
    // Set initial value
    setMatches(mediaQuery.matches);

    // Create listener function
    const listener = (event: MediaQueryListEvent) => {
      setMatches(event.matches);
    };

    // Add listener
    if (mediaQuery.addEventListener) {
      mediaQuery.addEventListener('change', listener);
    } else {
      // Fallback for older browsers
      mediaQuery.addListener(listener);
    }

    // Cleanup
    return () => {
      if (mediaQuery.removeEventListener) {
        mediaQuery.removeEventListener('change', listener);
      } else {
        // Fallback for older browsers
        mediaQuery.removeListener(listener);
      }
    };
  }, [query]);

  return matches;
}

// Predefined breakpoint hooks
export const useIsMobile = () => useMediaQuery('(max-width: 768px)');
export const useIsTablet = () => useMediaQuery('(min-width: 769px) and (max-width: 1024px)');
export const useIsDesktop = () => useMediaQuery('(min-width: 1025px)');
export const useIsLargeScreen = () => useMediaQuery('(min-width: 1200px)');

// Dark mode preference
export const usePrefersDarkMode = () => useMediaQuery('(prefers-color-scheme: dark)');

// Reduced motion preference
export const usePrefersReducedMotion = () => useMediaQuery('(prefers-reduced-motion: reduce)');

export default useMediaQuery;
</file>

<file path="src/hooks/usePagination.ts">
import { useState, useCallback, useMemo } from 'react';

export interface PaginationConfig {
  initialPage?: number;
  pageSize?: number;
  totalItems?: number;
}

export interface PaginationResult {
  currentPage: number;
  pageSize: number;
  totalItems: number;
  totalPages: number;
  hasNext: boolean;
  hasPrev: boolean;
  startIndex: number;
  endIndex: number;
  goToPage: (page: number) => void;
  nextPage: () => void;
  prevPage: () => void;
  setPageSize: (size: number) => void;
  setTotalItems: (total: number) => void;
}

/**
 * Custom hook for pagination logic
 */
export function usePagination({
  initialPage = 1,
  pageSize: initialPageSize = 20,
  totalItems: initialTotalItems = 0,
}: PaginationConfig = {}): PaginationResult {
  const [currentPage, setCurrentPage] = useState(initialPage);
  const [pageSize, setPageSize] = useState(initialPageSize);
  const [totalItems, setTotalItems] = useState(initialTotalItems);

  const totalPages = useMemo(() => {
    return Math.ceil(totalItems / pageSize);
  }, [totalItems, pageSize]);

  const hasNext = useMemo(() => {
    return currentPage < totalPages;
  }, [currentPage, totalPages]);

  const hasPrev = useMemo(() => {
    return currentPage > 1;
  }, [currentPage]);

  const startIndex = useMemo(() => {
    return (currentPage - 1) * pageSize;
  }, [currentPage, pageSize]);

  const endIndex = useMemo(() => {
    return Math.min(startIndex + pageSize, totalItems);
  }, [startIndex, pageSize, totalItems]);

  const goToPage = useCallback((page: number) => {
    if (page >= 1 && page <= totalPages) {
      setCurrentPage(page);
    }
  }, [totalPages]);

  const nextPage = useCallback(() => {
    if (hasNext) {
      setCurrentPage(prev => prev + 1);
    }
  }, [hasNext]);

  const prevPage = useCallback(() => {
    if (hasPrev) {
      setCurrentPage(prev => prev - 1);
    }
  }, [hasPrev]);

  const handleSetPageSize = useCallback((size: number) => {
    setPageSize(size);
    // Reset to first page when page size changes
    setCurrentPage(1);
  }, []);

  const handleSetTotalItems = useCallback((total: number) => {
    setTotalItems(total);
    // Ensure current page is valid
    const newTotalPages = Math.ceil(total / pageSize);
    if (currentPage > newTotalPages && newTotalPages > 0) {
      setCurrentPage(newTotalPages);
    }
  }, [currentPage, pageSize]);

  return {
    currentPage,
    pageSize,
    totalItems,
    totalPages,
    hasNext,
    hasPrev,
    startIndex,
    endIndex,
    goToPage,
    nextPage,
    prevPage,
    setPageSize: handleSetPageSize,
    setTotalItems: handleSetTotalItems,
  };
}

export default usePagination;
</file>

<file path="src/lib/auth-session.ts">
import { useAuth } from '@clerk/nextjs';
import { useEffect, useCallback, useRef } from 'react';
import { useRouter } from 'next/navigation';

// Session timeout configuration
const SESSION_TIMEOUT = 30 * 60 * 1000; // 30 minutes
const WARNING_TIME = 5 * 60 * 1000; // 5 minutes before timeout
const ACTIVITY_EVENTS = ['mousedown', 'mousemove', 'keypress', 'scroll', 'touchstart'];

interface SessionManager {
  lastActivity: number;
  timeoutId: NodeJS.Timeout | null;
  warningId: NodeJS.Timeout | null;
  isWarningShown: boolean;
}

// Global session manager
let sessionManager: SessionManager = {
  lastActivity: Date.now(),
  timeoutId: null,
  warningId: null,
  isWarningShown: false,
};

// Session timeout hook
export const useSessionTimeout = () => {
  const { signOut, isSignedIn } = useAuth();
  const router = useRouter();
  const sessionManagerRef = useRef(sessionManager);

  const resetSession = useCallback(() => {
    sessionManagerRef.current.lastActivity = Date.now();
    sessionManagerRef.current.isWarningShown = false;
    
    // Clear existing timeouts
    if (sessionManagerRef.current.timeoutId) {
      clearTimeout(sessionManagerRef.current.timeoutId);
    }
    if (sessionManagerRef.current.warningId) {
      clearTimeout(sessionManagerRef.current.warningId);
    }

    // Set warning timeout
    sessionManagerRef.current.warningId = setTimeout(() => {
      if (!sessionManagerRef.current.isWarningShown) {
        sessionManagerRef.current.isWarningShown = true;
        // Show warning modal/toast
        const shouldExtend = window.confirm(
          'Your session will expire in 5 minutes due to inactivity. Would you like to extend your session?'
        );
        
        if (shouldExtend) {
          resetSession();
        }
      }
    }, SESSION_TIMEOUT - WARNING_TIME);

    // Set logout timeout
    sessionManagerRef.current.timeoutId = setTimeout(async () => {
      await signOut();
      router.push('/auth/sign-in?reason=session_expired');
    }, SESSION_TIMEOUT);
  }, [signOut, router]);

  const handleActivity = useCallback(() => {
    if (isSignedIn) {
      resetSession();
    }
  }, [isSignedIn, resetSession]);

  useEffect(() => {
    if (!isSignedIn) return;

    // Initialize session
    resetSession();

    // Add activity listeners
    ACTIVITY_EVENTS.forEach(event => {
      document.addEventListener(event, handleActivity, true);
    });

    // Cleanup
    return () => {
      ACTIVITY_EVENTS.forEach(event => {
        document.removeEventListener(event, handleActivity, true);
      });
      
      if (sessionManagerRef.current.timeoutId) {
        clearTimeout(sessionManagerRef.current.timeoutId);
      }
      if (sessionManagerRef.current.warningId) {
        clearTimeout(sessionManagerRef.current.warningId);
      }
    };
  }, [isSignedIn, handleActivity, resetSession]);

  return {
    extendSession: resetSession,
    timeUntilTimeout: () => {
      const elapsed = Date.now() - sessionManagerRef.current.lastActivity;
      return Math.max(0, SESSION_TIMEOUT - elapsed);
    },
  };
};

// IP-based rate limiting utility
export const createIPRateLimit = () => {
  const attempts = new Map<string, { count: number; resetTime: number }>();
  const maxAttempts = 5;
  const windowMs = 15 * 60 * 1000; // 15 minutes

  return {
    isRateLimited: (ip: string): boolean => {
      const now = Date.now();
      const record = attempts.get(ip);

      if (!record || now > record.resetTime) {
        attempts.set(ip, { count: 1, resetTime: now + windowMs });
        return false;
      }

      if (record.count >= maxAttempts) {
        return true;
      }

      record.count++;
      return false;
    },

    getRemainingAttempts: (ip: string): number => {
      const record = attempts.get(ip);
      if (!record || Date.now() > record.resetTime) {
        return maxAttempts;
      }
      return Math.max(0, maxAttempts - record.count);
    },

    reset: (ip: string): void => {
      attempts.delete(ip);
    },
  };
};

// Enhanced permission checking
export const checkEnhancedPermissions = (
  userRole: string,
  requiredLevel: number,
  resourceOwner?: string,
  userId?: string,
  department?: string,
  resourceDepartment?: string
): boolean => {
  // Role hierarchy levels
  const roleLevels: Record<string, number> = {
    viewer: 1,
    user: 2,
    manager: 3,
    admin: 4,
    owner: 5,
  };

  const userLevel = roleLevels[userRole] || 0;

  // Basic role check
  if (userLevel >= requiredLevel) {
    return true;
  }

  // Resource ownership check
  if (resourceOwner && userId && resourceOwner === userId) {
    return userLevel >= 2; // Users can manage their own resources
  }

  // Department-level access for managers
  if (userRole === 'manager' && department && resourceDepartment) {
    return department === resourceDepartment;
  }

  return false;
};

// Audit logging utility
export const logSecurityEvent = (
  event: string,
  userId?: string,
  details?: Record<string, any>
) => {
  const logEntry = {
    timestamp: new Date().toISOString(),
    event,
    userId,
    details,
    userAgent: typeof window !== 'undefined' ? navigator.userAgent : undefined,
    ip: typeof window !== 'undefined' ? 
      // This would need to be passed from server-side
      details?.ip || 'unknown' : 'server',
  };

  // In production, send to logging service
  console.log('Security Event:', logEntry);
  
  // Store in local storage for client-side events (development only)
  if (typeof window !== 'undefined' && process.env.NODE_ENV === 'development') {
    const events = JSON.parse(localStorage.getItem('security_events') || '[]');
    events.push(logEntry);
    // Keep only last 100 events
    if (events.length > 100) {
      events.splice(0, events.length - 100);
    }
    localStorage.setItem('security_events', JSON.stringify(events));
  }
};
</file>

<file path="src/lib/AuthRedirectHandler.tsx">
'use client';

import { useEffect } from 'react';
import { useRouter } from 'next/navigation';
import { useAuth } from '@clerk/nextjs';

const AuthRedirectHandler = () => {
  const { isSignedIn, isLoaded } = useAuth();
  const router = useRouter();

  useEffect(() => {
    // Only redirect once auth is loaded and user is signed in
    if (isLoaded && isSignedIn) {
      console.log('User is authenticated, redirecting to dashboard...');
      router.push('/dashboard');
    }
  }, [isLoaded, isSignedIn, router]);

  // This component doesn't render anything
  return null;
};

export default AuthRedirectHandler;
</file>

<file path="src/lib/error-handler.ts">
// Global Error Handler for centralized error management
import { ConvexError } from 'convex/values';

// Error types and categories
export type ErrorSeverity = 'low' | 'medium' | 'high' | 'critical';
export type ErrorCategory = 'network' | 'auth' | 'validation' | 'permission' | 'api' | 'system' | 'user';

export interface AppError {
  id: string;
  message: string;
  code?: string;
  category: ErrorCategory;
  severity: ErrorSeverity;
  timestamp: Date;
  stack?: string;
  metadata?: Record<string, any>;
  userMessage?: string; // User-friendly message
  actionable?: boolean; // Can the user do something about it?
  retryable?: boolean; // Can this operation be retried?
}

export interface ErrorContext {
  userId?: string;
  enterpriseId?: string;
  route?: string;
  action?: string;
  component?: string;
  metadata?: Record<string, any>;
}

// Error reporting interface
export interface ErrorReporter {
  reportError(error: AppError, context?: ErrorContext): Promise<void>;
}

// Console error reporter (development)
class ConsoleErrorReporter implements ErrorReporter {
  async reportError(error: AppError, context?: ErrorContext): Promise<void> {
    console.group(` [${error.severity.toUpperCase()}] ${error.category} Error`);
    console.error('Message:', error.message);
    console.error('Code:', error.code);
    console.error('Time:', error.timestamp.toISOString());
    if (context) console.error('Context:', context);
    if (error.stack) console.error('Stack:', error.stack);
    if (error.metadata) console.error('Metadata:', error.metadata);
    console.groupEnd();
  }
}

// Production error reporter (would integrate with services like Sentry, LogRocket, etc.)
class ProductionErrorReporter implements ErrorReporter {
  async reportError(error: AppError, context?: ErrorContext): Promise<void> {
    // In production, send to error tracking service
    try {
      // Example integration with error tracking service
      // await sendToErrorService({
      //   errorId: error.id,
      //   message: error.message,
      //   severity: error.severity,
      //   category: error.category,
      //   context,
      //   timestamp: error.timestamp,
      //   stack: error.stack,
      //   metadata: error.metadata,
      // });

      // For now, still log to console in production for debugging
      if (error.severity === 'critical' || error.severity === 'high') {
        console.error(`[${error.severity}] ${error.message}`, { error, context });
      }
    } catch (reportingError) {
      console.error('Failed to report error:', reportingError);
    }
  }
}

// Global error handler class
class GlobalErrorHandler {
  private reporters: ErrorReporter[] = [];
  private errorHistory: AppError[] = [];
  private maxHistorySize = 100;

  constructor() {
    this.setupReporters();
    this.setupGlobalHandlers();
  }

  private setupReporters() {
    if (process.env.NODE_ENV === 'development') {
      this.reporters.push(new ConsoleErrorReporter());
    } else {
      this.reporters.push(new ProductionErrorReporter());
    }
  }

  private setupGlobalHandlers() {
    // Handle unhandled promise rejections
    if (typeof window !== 'undefined') {
      window.addEventListener('unhandledrejection', (event) => {
        this.handleError(event.reason, {
          action: 'unhandled_promise_rejection',
          metadata: { url: window.location.href }
        });
      });

      // Handle global JavaScript errors
      window.addEventListener('error', (event) => {
        this.handleError(new Error(event.message), {
          action: 'global_error',
          metadata: {
            filename: event.filename,
            lineno: event.lineno,
            colno: event.colno,
            url: window.location.href
          }
        });
      });
    }
  }

  // Convert various error types to AppError
  private normalizeError(error: any, context?: ErrorContext): AppError {
    const errorId = `error_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const timestamp = new Date();

    // Handle ConvexError
    if (error instanceof ConvexError) {
      return {
        id: errorId,
        message: error.message,
        code: 'CONVEX_ERROR',
        category: this.categorizeConvexError(error),
        severity: this.getSeverityForConvexError(error),
        timestamp,
        userMessage: this.getUserFriendlyMessage(error),
        actionable: true,
        retryable: this.isRetryableConvexError(error),
        metadata: { originalError: error.data }
      };
    }

    // Handle network errors
    if (error.name === 'TypeError' && error.message.includes('fetch')) {
      return {
        id: errorId,
        message: error.message,
        code: 'NETWORK_ERROR',
        category: 'network',
        severity: 'medium',
        timestamp,
        stack: error.stack,
        userMessage: 'Network connection error. Please check your internet connection.',
        actionable: true,
        retryable: true,
        metadata: { url: context?.metadata?.url }
      };
    }

    // Handle authentication errors
    if (error.message.includes('auth') || error.message.includes('unauthorized')) {
      return {
        id: errorId,
        message: error.message,
        code: 'AUTH_ERROR',
        category: 'auth',
        severity: 'high',
        timestamp,
        stack: error.stack,
        userMessage: 'Authentication error. Please log in again.',
        actionable: true,
        retryable: false,
      };
    }

    // Handle validation errors
    if (error.name === 'ValidationError' || error.message.includes('validation')) {
      return {
        id: errorId,
        message: error.message,
        code: 'VALIDATION_ERROR',
        category: 'validation',
        severity: 'medium',
        timestamp,
        userMessage: 'Please check your input and try again.',
        actionable: true,
        retryable: false,
        metadata: error.details || error.errors
      };
    }

    // Default error handling
    return {
      id: errorId,
      message: error.message || 'An unexpected error occurred',
      code: error.code || 'UNKNOWN_ERROR',
      category: 'system',
      severity: 'medium',
      timestamp,
      stack: error.stack,
      userMessage: 'Something went wrong. Please try again.',
      actionable: true,
      retryable: true,
      metadata: { originalError: error }
    };
  }

  private categorizeConvexError(error: ConvexError): ErrorCategory {
    const message = error.message.toLowerCase();
    if (message.includes('auth') || message.includes('unauthorized')) return 'auth';
    if (message.includes('permission') || message.includes('access')) return 'permission';
    if (message.includes('validation') || message.includes('invalid')) return 'validation';
    if (message.includes('network') || message.includes('timeout')) return 'network';
    return 'api';
  }

  private getSeverityForConvexError(error: ConvexError): ErrorSeverity {
    const message = error.message.toLowerCase();
    if (message.includes('critical') || message.includes('security')) return 'critical';
    if (message.includes('auth') || message.includes('permission')) return 'high';
    if (message.includes('validation') || message.includes('not found')) return 'medium';
    return 'low';
  }

  private isRetryableConvexError(error: ConvexError): boolean {
    const message = error.message.toLowerCase();
    // Don't retry auth, permission, or validation errors
    if (message.includes('auth') || message.includes('permission') || message.includes('validation')) {
      return false;
    }
    return true;
  }

  private getUserFriendlyMessage(error: any): string {
    const message = error.message?.toLowerCase() || '';
    
    if (message.includes('not found')) {
      return 'The requested item could not be found.';
    }
    if (message.includes('unauthorized') || message.includes('auth')) {
      return 'You are not authorized to perform this action.';
    }
    if (message.includes('validation') || message.includes('invalid')) {
      return 'Please check your input and try again.';
    }
    if (message.includes('network') || message.includes('timeout')) {
      return 'Network connection error. Please try again.';
    }
    if (message.includes('duplicate') || message.includes('already exists')) {
      return 'This item already exists. Please use a different name.';
    }
    
    return 'Something went wrong. Please try again or contact support if the problem persists.';
  }

  // Main error handling method
  public async handleError(error: any, context?: ErrorContext): Promise<AppError> {
    const appError = this.normalizeError(error, context);

    // Add to history
    this.addToHistory(appError);

    // Report to all configured reporters
    await Promise.all(
      this.reporters.map(reporter => 
        reporter.reportError(appError, context).catch(reportError => 
          console.error('Error reporter failed:', reportError)
        )
      )
    );

    return appError;
  }

  // Convenience methods for specific error types
  public async handleApiError(error: any, endpoint?: string, operation?: string): Promise<AppError> {
    return this.handleError(error, {
      action: 'api_call',
      metadata: { endpoint, operation }
    });
  }

  public async handleUserError(error: any, userId?: string, action?: string): Promise<AppError> {
    return this.handleError(error, {
      userId,
      action,
      category: 'user'
    });
  }

  public async handleComponentError(error: any, component: string, props?: any): Promise<AppError> {
    return this.handleError(error, {
      component,
      action: 'component_render',
      metadata: { props }
    });
  }

  // Error history management
  private addToHistory(error: AppError) {
    this.errorHistory.unshift(error);
    if (this.errorHistory.length > this.maxHistorySize) {
      this.errorHistory = this.errorHistory.slice(0, this.maxHistorySize);
    }
  }

  public getErrorHistory(): AppError[] {
    return [...this.errorHistory];
  }

  public getRecentErrors(count = 10): AppError[] {
    return this.errorHistory.slice(0, count);
  }

  public getErrorsByCategory(category: ErrorCategory): AppError[] {
    return this.errorHistory.filter(error => error.category === category);
  }

  public getErrorsBySeverity(severity: ErrorSeverity): AppError[] {
    return this.errorHistory.filter(error => error.severity === severity);
  }

  public clearHistory(): void {
    this.errorHistory = [];
  }

  // Error statistics
  public getErrorStats() {
    const total = this.errorHistory.length;
    const byCategory = this.errorHistory.reduce((acc, error) => {
      acc[error.category] = (acc[error.category] || 0) + 1;
      return acc;
    }, {} as Record<ErrorCategory, number>);

    const bySeverity = this.errorHistory.reduce((acc, error) => {
      acc[error.severity] = (acc[error.severity] || 0) + 1;
      return acc;
    }, {} as Record<ErrorSeverity, number>);

    const recentErrors = this.errorHistory.filter(
      error => error.timestamp > new Date(Date.now() - 24 * 60 * 60 * 1000)
    ).length;

    return {
      total,
      recentErrors,
      byCategory,
      bySeverity,
    };
  }
}

// Create global instance
export const globalErrorHandler = new GlobalErrorHandler();

// Export convenience functions
export const handleError = (error: any, context?: ErrorContext) => 
  globalErrorHandler.handleError(error, context);

export const handleApiError = (error: any, endpoint?: string, operation?: string) =>
  globalErrorHandler.handleApiError(error, endpoint, operation);

export const handleUserError = (error: any, userId?: string, action?: string) =>
  globalErrorHandler.handleUserError(error, userId, action);

export const handleComponentError = (error: any, component: string, props?: any) =>
  globalErrorHandler.handleComponentError(error, component, props);

// React hook for error handling
export const useErrorHandler = () => {
  return {
    handleError,
    handleApiError,
    handleUserError,
    handleComponentError,
    getErrorHistory: () => globalErrorHandler.getErrorHistory(),
    getErrorStats: () => globalErrorHandler.getErrorStats(),
  };
};

export default globalErrorHandler;
</file>

<file path="src/lib/utils.ts">
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}
</file>

<file path="src/lib/validation-utils.ts">
import DOMPurify from 'dompurify';
import { z } from 'zod';

// HTML sanitization utility
export const sanitizeHtml = (html: string): string => {
  if (typeof window === 'undefined') {
    // Server-side fallback
    return html.replace(/<[^>]*>/g, '');
  }
  
  return DOMPurify.sanitize(html, {
    ALLOWED_TAGS: ['b', 'i', 'u', 'em', 'strong', 'p', 'br'],
    ALLOWED_ATTR: [],
    KEEP_CONTENT: true,
  });
};

// Input sanitization for user data
export const sanitizeInput = (input: string): string => {
  if (!input) return '';
  
  return input
    .trim()
    .replace(/[<>]/g, '') // Remove angle brackets
    .replace(/['"]/g, '') // Remove quotes
    .replace(/javascript:/gi, '') // Remove javascript: protocol
    .replace(/data:/gi, '') // Remove data: protocol
    .slice(0, 1000); // Limit length
};

// File validation schemas
export const fileValidationSchema = z.object({
  name: z.string()
    .min(1, 'File name is required')
    .max(255, 'File name too long')
    .regex(/^[a-zA-Z0-9\-_. ]+$/, 'Invalid characters in file name'),
  type: z.enum([
    'application/pdf',
    'application/msword',
    'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
    'text/plain',
  ]),
  size: z.number()
    .min(1, 'File cannot be empty')
    .max(10 * 1024 * 1024, 'File size cannot exceed 10MB'), // 10MB limit
});

// URL validation
export const urlValidationSchema = z.string()
  .url('Invalid URL format')
  .refine((url) => {
    const parsedUrl = new URL(url);
    return ['http:', 'https:'].includes(parsedUrl.protocol);
  }, 'Only HTTP and HTTPS URLs are allowed')
  .refine((url) => {
    const parsedUrl = new URL(url);
    return !parsedUrl.hostname.includes('localhost') && !parsedUrl.hostname.includes('127.0.0.1');
  }, 'Localhost URLs are not allowed');

// Email validation
export const emailValidationSchema = z.string()
  .email('Invalid email format')
  .max(254, 'Email too long')
  .refine((email) => {
    // Additional email validation
    const parts = email.split('@');
    if (parts.length !== 2) return false;
    
    const [local, domain] = parts;
    return local.length <= 64 && domain.length <= 253;
  }, 'Invalid email structure');

// Phone number validation
export const phoneValidationSchema = z.string()
  .regex(/^[\+]?[1-9][\d]{0,15}$/, 'Invalid phone number format')
  .min(10, 'Phone number too short')
  .max(17, 'Phone number too long');

// Contract validation schemas
export const contractValidationSchema = z.object({
  title: z.string()
    .min(1, 'Title is required')
    .max(200, 'Title too long')
    .transform(sanitizeInput),
  
  notes: z.string()
    .max(2000, 'Notes too long')
    .optional()
    .transform((val) => val ? sanitizeHtml(val) : undefined),
  
  value: z.number()
    .min(0, 'Value cannot be negative')
    .max(1000000000, 'Value too large')
    .optional(),
    
  startDate: z.string()
    .datetime('Invalid start date format')
    .optional(),
    
  endDate: z.string()
    .datetime('Invalid end date format')
    .optional(),
});

// Vendor validation schema
export const vendorValidationSchema = z.object({
  name: z.string()
    .min(1, 'Name is required')
    .max(100, 'Name too long')
    .transform(sanitizeInput),
    
  contactEmail: emailValidationSchema.optional(),
  
  contactPhone: phoneValidationSchema.optional(),
  
  website: urlValidationSchema.optional(),
  
  address: z.string()
    .max(500, 'Address too long')
    .optional()
    .transform((val) => val ? sanitizeInput(val) : undefined),
    
  notes: z.string()
    .max(1000, 'Notes too long')
    .optional()
    .transform((val) => val ? sanitizeHtml(val) : undefined),
});

// User input validation
export const userInputValidationSchema = z.object({
  firstName: z.string()
    .min(1, 'First name is required')
    .max(50, 'First name too long')
    .regex(/^[a-zA-Z\s\-']+$/, 'Invalid characters in first name')
    .transform(sanitizeInput),
    
  lastName: z.string()
    .min(1, 'Last name is required')
    .max(50, 'Last name too long')
    .regex(/^[a-zA-Z\s\-']+$/, 'Invalid characters in last name')
    .transform(sanitizeInput),
    
  title: z.string()
    .max(100, 'Title too long')
    .optional()
    .transform((val) => val ? sanitizeInput(val) : undefined),
    
  department: z.string()
    .max(100, 'Department too long')
    .optional()
    .transform((val) => val ? sanitizeInput(val) : undefined),
    
  phoneNumber: phoneValidationSchema.optional(),
});

// Search query validation
export const searchValidationSchema = z.string()
  .max(100, 'Search query too long')
  .regex(/^[a-zA-Z0-9\s\-_.@]+$/, 'Invalid characters in search query')
  .transform(sanitizeInput);

// Generic text validation
export const textValidationSchema = z.string()
  .max(1000, 'Text too long')
  .transform(sanitizeInput);

// Validate file upload
export const validateFileUpload = (file: File): { valid: boolean; error?: string } => {
  try {
    fileValidationSchema.parse({
      name: file.name,
      type: file.type,
      size: file.size,
    });
    
    // Additional security checks
    if (file.name.includes('..')) {
      return { valid: false, error: 'Invalid file path' };
    }
    
    // Check for potentially dangerous file extensions
    const dangerousExtensions = ['.exe', '.bat', '.cmd', '.scr', '.com', '.pif', '.js', '.jar'];
    const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));
    
    if (dangerousExtensions.includes(fileExtension)) {
      return { valid: false, error: 'File type not allowed' };
    }
    
    return { valid: true };
  } catch (error) {
    if (error instanceof z.ZodError) {
      return { valid: false, error: error.errors[0].message };
    }
    return { valid: false, error: 'File validation failed' };
  }
};

// Rate limiting helpers
export const createRateLimitKey = (identifier: string, action: string): string => {
  return `rate_limit:${sanitizeInput(identifier)}:${sanitizeInput(action)}`;
};

// CSRF token validation
export const validateCSRFToken = (token: string, expectedToken: string): boolean => {
  if (!token || !expectedToken) return false;
  return token === expectedToken;
};
</file>

<file path="src/lib/validations.ts">
export const validatePassword = (password: string): string | null => {
  if (password.length < 8) return "Password must be at least 8 characters long";
  if (!/[A-Z]/.test(password))
    return "Password must contain at least one uppercase letter";
  if (!/[a-z]/.test(password))
    return "Password must contain at least one lowercase letter";
  if (!/\d/.test(password)) return "Password must contain at least one number";
  if (!/[!@#$%^&*(),.?":{}|<>]/.test(password))
    return "Password must contain at least one special character";
  return null;
};
</file>

<file path="src/lib/zod-schemas.ts">
import { z } from 'zod';

// Base schemas
export const idSchema = z.string().min(1);
export const timestampSchema = z.string().datetime();
export const emailSchema = z.string().email();
export const urlSchema = z.string().url();

// Pagination schemas
export const paginationSchema = z.object({
  limit: z.number().min(1).max(100).default(20),
  offset: z.number().min(0).default(0),
  cursor: z.string().optional(),
});

export const sortSchema = z.object({
  field: z.string(),
  direction: z.enum(['asc', 'desc']).default('desc'),
});

// User schemas
export const userRoleSchema = z.enum(['owner', 'admin', 'manager', 'user', 'viewer']);

export const userSchema = z.object({
  clerkId: z.string(),
  email: emailSchema,
  firstName: z.string().min(1).max(50).optional(),
  lastName: z.string().min(1).max(50).optional(),
  enterpriseId: idSchema,
  role: userRoleSchema,
  isActive: z.boolean().default(true),
  lastLoginAt: timestampSchema.optional(),
  phoneNumber: z.string().regex(/^[\+]?[1-9][\d]{0,15}$/).optional(),
  department: z.string().max(100).optional(),
  title: z.string().max(100).optional(),
  createdAt: timestampSchema,
  updatedAt: timestampSchema.optional(),
});

// Enterprise schemas
export const enterpriseSizeSchema = z.enum(['1-10', '11-50', '51-200', '201-500', '501-1000', '1000+']);
export const contractVolumeSchema = z.enum(['low', 'medium', 'high', 'enterprise']);

export const enterpriseSchema = z.object({
  name: z.string().min(1).max(100),
  domain: z.string().max(100).optional(),
  industry: z.string().max(100).optional(),
  size: enterpriseSizeSchema.optional(),
  contractVolume: contractVolumeSchema.optional(),
  primaryUseCase: z.array(z.string()).optional(),
});

// Vendor schemas
export const vendorCategorySchema = z.enum([
  'technology', 'marketing', 'legal', 'finance', 'hr', 
  'facilities', 'logistics', 'manufacturing', 'consulting', 'other'
]);

export const vendorStatusSchema = z.enum(['active', 'inactive']);

export const vendorSchema = z.object({
  enterpriseId: idSchema,
  name: z.string().min(1).max(100),
  contactEmail: emailSchema.optional(),
  contactPhone: z.string().regex(/^[\+]?[1-9][\d]{0,15}$/).optional(),
  address: z.string().max(500).optional(),
  notes: z.string().max(1000).optional(),
  website: urlSchema.optional(),
  category: vendorCategorySchema.optional(),
  status: vendorStatusSchema.default('active'),
  createdAt: timestampSchema,
});

// Contract schemas
export const contractStatusSchema = z.enum([
  'draft', 'pending_analysis', 'active', 'expired', 'terminated', 'archived'
]);

export const analysisStatusSchema = z.enum(['pending', 'processing', 'completed', 'failed']);

export const contractTypeSchema = z.enum([
  'nda', 'msa', 'sow', 'saas', 'lease', 'employment', 'partnership', 'other'
]);

export const contractSchema = z.object({
  enterpriseId: idSchema,
  vendorId: idSchema,
  title: z.string().min(1).max(200),
  status: contractStatusSchema,
  contractType: contractTypeSchema.optional(),
  storageId: idSchema,
  fileName: z.string().min(1).max(255),
  fileType: z.string().regex(/^[a-zA-Z0-9\/\-]+$/),
  value: z.number().min(0).optional(),
  startDate: timestampSchema.optional(),
  endDate: timestampSchema.optional(),
  extractedParties: z.array(z.string()).optional(),
  extractedStartDate: timestampSchema.optional(),
  extractedEndDate: timestampSchema.optional(),
  extractedPaymentSchedule: z.string().optional(),
  extractedPricing: z.string().optional(),
  extractedScope: z.string().optional(),
  analysisStatus: analysisStatusSchema.optional(),
  analysisError: z.string().optional(),
  notes: z.string().max(2000).optional(),
  createdAt: timestampSchema,
});

// Agent task schemas
export const taskPrioritySchema = z.enum(['low', 'medium', 'high', 'critical']);
export const taskStatusSchema = z.enum(['pending', 'processing', 'completed', 'failed']);
export const taskTypeSchema = z.enum([
  'contract_analysis', 'vendor_analysis', 'compliance_check', 
  'risk_assessment', 'financial_analysis', 'notification'
]);

export const agentTaskSchema = z.object({
  id: z.string(),
  type: taskTypeSchema,
  priority: taskPrioritySchema,
  status: taskStatusSchema,
  data: z.object({
    contractId: idSchema.optional(),
    vendorId: idSchema.optional(),
    enterpriseId: idSchema,
    userId: idSchema.optional(),
    parameters: z.record(z.unknown()).optional(),
    metadata: z.record(z.unknown()).optional(),
  }),
  result: z.object({
    success: z.boolean(),
    data: z.record(z.unknown()).optional(),
    insights: z.array(z.object({
      id: z.string(),
      type: z.enum(['risk', 'opportunity', 'compliance', 'financial', 'operational']),
      severity: z.enum(['low', 'medium', 'high', 'critical']),
      title: z.string(),
      description: z.string(),
      data: z.record(z.unknown()),
      source: z.string(),
      confidence: z.number().min(0).max(1),
      createdAt: timestampSchema,
    })).optional(),
    recommendations: z.array(z.object({
      id: z.string(),
      type: z.enum(['action', 'review', 'optimize', 'alert']),
      priority: z.enum(['low', 'medium', 'high', 'urgent']),
      title: z.string(),
      description: z.string(),
      impact: z.enum(['low', 'medium', 'high']),
      effort: z.enum(['low', 'medium', 'high']),
      source: z.string(),
      createdAt: timestampSchema,
    })).optional(),
    metadata: z.record(z.unknown()).optional(),
    executionTime: z.number().optional(),
  }).optional(),
  error: z.string().optional(),
  createdAt: timestampSchema,
  updatedAt: timestampSchema.optional(),
  retryCount: z.number().min(0).default(0),
  maxRetries: z.number().min(0).default(3),
});

// Search schemas
export const searchQuerySchema = z.object({
  query: z.string().min(1).max(200),
  filters: z.object({
    contractTypes: z.array(contractTypeSchema).optional(),
    statuses: z.array(contractStatusSchema).optional(),
    dateRange: z.object({
      start: timestampSchema.optional(),
      end: timestampSchema.optional(),
    }).optional(),
    vendorIds: z.array(idSchema).optional(),
    tags: z.array(z.string()).optional(),
  }).optional(),
  sort: sortSchema.optional(),
  pagination: paginationSchema.optional(),
  options: z.object({
    includeContent: z.boolean().default(false),
    highlightMatches: z.boolean().default(true),
    fuzzyMatch: z.boolean().default(false),
    boost: z.record(z.number()).optional(),
    debug: z.boolean().default(false),
  }).optional(),
});

// Analytics schemas
export const metricTypeSchema = z.enum([
  'contract_count', 'contract_value', 'vendor_count', 'compliance_score',
  'risk_score', 'renewal_rate', 'processing_time', 'user_activity'
]);

export const timeRangeSchema = z.enum(['1h', '1d', '7d', '30d', '90d', '1y', 'all']);

export const analyticsQuerySchema = z.object({
  metrics: z.array(metricTypeSchema),
  timeRange: timeRangeSchema,
  filters: z.object({
    enterpriseId: idSchema.optional(),
    vendorIds: z.array(idSchema).optional(),
    contractTypes: z.array(contractTypeSchema).optional(),
    departments: z.array(z.string()).optional(),
  }).optional(),
  groupBy: z.array(z.string()).optional(),
  aggregation: z.enum(['sum', 'avg', 'min', 'max', 'count']).default('sum'),
});

// Notification schemas
export const notificationTypeSchema = z.enum([
  'contract_expiring', 'contract_analysis_complete', 'vendor_risk_alert',
  'compliance_issue', 'task_assignment', 'system_alert'
]);

export const notificationPrioritySchema = z.enum(['low', 'medium', 'high', 'urgent']);

export const notificationSchema = z.object({
  enterpriseId: idSchema,
  userId: idSchema,
  type: notificationTypeSchema,
  priority: notificationPrioritySchema,
  title: z.string().min(1).max(200),
  message: z.string().min(1).max(1000),
  data: z.record(z.unknown()).optional(),
  isRead: z.boolean().default(false),
  actionUrl: z.string().optional(),
  expiresAt: timestampSchema.optional(),
  createdAt: timestampSchema,
});

// Error schemas
export const errorCodeSchema = z.enum([
  'VALIDATION_ERROR', 'AUTHORIZATION_ERROR', 'NOT_FOUND', 
  'CONFLICT', 'RATE_LIMIT_EXCEEDED', 'INTERNAL_ERROR',
  'EXTERNAL_SERVICE_ERROR', 'TIMEOUT_ERROR'
]);

export const errorSchema = z.object({
  code: errorCodeSchema,
  message: z.string(),
  details: z.record(z.unknown()).optional(),
  stack: z.string().optional(),
  timestamp: timestampSchema,
});

// API response schemas
export const paginatedResponseSchema = <T>(itemSchema: z.ZodType<T>) => z.object({
  data: z.array(itemSchema),
  pagination: z.object({
    total: z.number(),
    page: z.number(),
    pageSize: z.number(),
    hasNext: z.boolean(),
    hasPrev: z.boolean(),
    nextCursor: z.string().optional(),
    prevCursor: z.string().optional(),
  }),
  meta: z.record(z.unknown()).optional(),
});

export const apiResponseSchema = <T>(dataSchema: z.ZodType<T>) => z.object({
  success: z.boolean(),
  data: dataSchema.optional(),
  error: errorSchema.optional(),
  metadata: z.object({
    requestId: z.string(),
    timestamp: timestampSchema,
    executionTime: z.number(),
  }).optional(),
});

// Form validation schemas
export const createContractFormSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200, 'Title is too long'),
  vendorId: idSchema,
  contractType: contractTypeSchema,
  file: z.object({
    name: z.string().min(1),
    size: z.number().min(1).max(10 * 1024 * 1024), // 10MB limit
    type: z.enum([
      'application/pdf',
      'application/msword',
      'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
      'text/plain'
    ]),
  }),
  notes: z.string().max(2000).optional(),
  value: z.number().min(0).optional(),
  startDate: z.string().datetime().optional(),
  endDate: z.string().datetime().optional(),
});

export const createVendorFormSchema = z.object({
  name: z.string().min(1, 'Name is required').max(100, 'Name is too long'),
  contactEmail: emailSchema.optional(),
  contactPhone: z.string().regex(/^[\+]?[1-9][\d]{0,15}$/, 'Invalid phone number').optional(),
  website: urlSchema.optional(),
  address: z.string().max(500).optional(),
  category: vendorCategorySchema.optional(),
  notes: z.string().max(1000).optional(),
});

export const updateUserProfileSchema = z.object({
  firstName: z.string().min(1).max(50).optional(),
  lastName: z.string().min(1).max(50).optional(),
  phoneNumber: z.string().regex(/^[\+]?[1-9][\d]{0,15}$/).optional(),
  department: z.string().max(100).optional(),
  title: z.string().max(100).optional(),
});

// Query parameter schemas
export const getContractsQuerySchema = z.object({
  enterpriseId: idSchema,
  contractType: contractTypeSchema.optional(),
  status: contractStatusSchema.optional(),
  limit: z.number().min(1).max(100).default(20),
  cursor: z.string().optional(),
});

export const getVendorsQuerySchema = z.object({
  enterpriseId: idSchema,
  category: vendorCategorySchema.optional(),
  status: vendorStatusSchema.optional(),
  limit: z.number().min(1).max(100).default(20),
  cursor: z.string().optional(),
});

// Export utility types
export type UserRole = z.infer<typeof userRoleSchema>;
export type ContractStatus = z.infer<typeof contractStatusSchema>;
export type ContractType = z.infer<typeof contractTypeSchema>;
export type VendorCategory = z.infer<typeof vendorCategorySchema>;
export type TaskPriority = z.infer<typeof taskPrioritySchema>;
export type TaskStatus = z.infer<typeof taskStatusSchema>;
export type NotificationType = z.infer<typeof notificationTypeSchema>;
export type MetricType = z.infer<typeof metricTypeSchema>;
export type TimeRange = z.infer<typeof timeRangeSchema>;

export default {
  // Base schemas
  id: idSchema,
  timestamp: timestampSchema,
  email: emailSchema,
  url: urlSchema,
  pagination: paginationSchema,
  sort: sortSchema,
  
  // Entity schemas
  user: userSchema,
  enterprise: enterpriseSchema,
  vendor: vendorSchema,
  contract: contractSchema,
  agentTask: agentTaskSchema,
  notification: notificationSchema,
  
  // Query schemas
  searchQuery: searchQuerySchema,
  analyticsQuery: analyticsQuerySchema,
  getContractsQuery: getContractsQuerySchema,
  getVendorsQuery: getVendorsQuerySchema,
  
  // Form schemas
  createContractForm: createContractFormSchema,
  createVendorForm: createVendorFormSchema,
  updateUserProfile: updateUserProfileSchema,
  
  // Response schemas
  error: errorSchema,
  paginatedResponse: paginatedResponseSchema,
  apiResponse: apiResponseSchema,
};
</file>

<file path="src/stores/dashboard-store.ts">
import { create } from "zustand";
import { persist, createJSONStorage } from "zustand/middleware";
import { ContractType } from "@/types/contract.types";
import useContractStore from "@/stores/contract-store";

interface DashboardState {
  // Filter and search states
  selectedType: string;
  searchQuery: string;
  filteredContracts: ContractType[];

  // UI states
  expandedItems: string[];

  // Filter actions
  setSelectedType: (type: string) => void;
  setSearchQuery: (query: string) => void;
  filterContracts: () => void;

  // UI actions
  setExpandedItems: (updater: (prev: string[]) => string[]) => void;
  resetState: () => void;
}

const initialState = {
  selectedType: "All Contracts",
  searchQuery: "",
  expandedItems: [],
  filteredContracts: [],
};

export const useDashboardStore = create<DashboardState>()(
  persist(
    (set, get) => ({
      ...initialState,

      setSelectedType: (type) => {
        set((state) => ({ ...state, selectedType: type }));
        get().filterContracts();
      },

      setSearchQuery: (query) => {
        set((state) => ({ ...state, searchQuery: query }));
        get().filterContracts();
      },

      setExpandedItems: (updater) =>
        set((state) => ({
          ...state,
          expandedItems: updater(state.expandedItems),
        })),

      filterContracts: () => {
        const contracts = useContractStore.getState().contracts;
        const { selectedType, searchQuery } = get();

        let filtered = [...contracts];

        // Filter by type/status
        if (selectedType !== "All Contracts") {
          filtered = filtered.filter(
            (contract) => contract.status === selectedType.toLowerCase()
          );
        }

        // Filter by search
        if (searchQuery) {
          filtered = filtered.filter((contract) =>
            contract.title.toLowerCase().includes(searchQuery.toLowerCase())
          );
        }

        set({ filteredContracts: filtered });
      },

      resetState: () => set(initialState),
    }),
    {
      name: "dashboard-storage",
      storage: createJSONStorage(() => localStorage),
      partialize: (state) => ({
        selectedType: state.selectedType,
        searchQuery: state.searchQuery,
        expandedItems: state.expandedItems,
      }),
    }
  )
);
</file>

<file path="src/styles/tokens.ts">
// Design tokens for consistent styling across the application

export const colors = {
  // Primary palette
  primary: {
    50: '#f0f9ff',
    100: '#e0f2fe',
    200: '#bae6fd',
    300: '#7dd3fc',
    400: '#38bdf8',
    500: '#0ea5e9',
    600: '#0284c7',
    700: '#0369a1',
    800: '#075985',
    900: '#0c4a6e',
    950: '#082f49',
  },
  
  // Secondary palette
  secondary: {
    50: '#f8fafc',
    100: '#f1f5f9',
    200: '#e2e8f0',
    300: '#cbd5e1',
    400: '#94a3b8',
    500: '#64748b',
    600: '#475569',
    700: '#334155',
    800: '#1e293b',
    900: '#0f172a',
    950: '#020617',
  },
  
  // Semantic colors
  success: {
    50: '#f0fdf4',
    100: '#dcfce7',
    200: '#bbf7d0',
    300: '#86efac',
    400: '#4ade80',
    500: '#22c55e',
    600: '#16a34a',
    700: '#15803d',
    800: '#166534',
    900: '#14532d',
    950: '#052e16',
  },
  
  warning: {
    50: '#fffbeb',
    100: '#fef3c7',
    200: '#fde68a',
    300: '#fcd34d',
    400: '#fbbf24',
    500: '#f59e0b',
    600: '#d97706',
    700: '#b45309',
    800: '#92400e',
    900: '#78350f',
    950: '#451a03',
  },
  
  error: {
    50: '#fef2f2',
    100: '#fee2e2',
    200: '#fecaca',
    300: '#fca5a5',
    400: '#f87171',
    500: '#ef4444',
    600: '#dc2626',
    700: '#b91c1c',
    800: '#991b1b',
    900: '#7f1d1d',
    950: '#450a0a',
  },
  
  // Neutral colors
  gray: {
    50: '#fafafa',
    100: '#f4f4f5',
    200: '#e4e4e7',
    300: '#d4d4d8',
    400: '#a1a1aa',
    500: '#71717a',
    600: '#52525b',
    700: '#3f3f46',
    800: '#27272a',
    900: '#18181b',
    950: '#09090b',
  },
} as const;

export const spacing = {
  px: '1px',
  0: '0',
  0.5: '0.125rem',
  1: '0.25rem',
  1.5: '0.375rem',
  2: '0.5rem',
  2.5: '0.625rem',
  3: '0.75rem',
  3.5: '0.875rem',
  4: '1rem',
  5: '1.25rem',
  6: '1.5rem',
  7: '1.75rem',
  8: '2rem',
  9: '2.25rem',
  10: '2.5rem',
  11: '2.75rem',
  12: '3rem',
  14: '3.5rem',
  16: '4rem',
  20: '5rem',
  24: '6rem',
  28: '7rem',
  32: '8rem',
  36: '9rem',
  40: '10rem',
  44: '11rem',
  48: '12rem',
  52: '13rem',
  56: '14rem',
  60: '15rem',
  64: '16rem',
  72: '18rem',
  80: '20rem',
  96: '24rem',
} as const;

export const typography = {
  fontFamily: {
    sans: ['Inter', 'system-ui', 'sans-serif'],
    serif: ['Georgia', 'serif'],
    mono: ['Menlo', 'Monaco', 'Consolas', 'monospace'],
  },
  
  fontSize: {
    xs: ['0.75rem', { lineHeight: '1rem' }],
    sm: ['0.875rem', { lineHeight: '1.25rem' }],
    base: ['1rem', { lineHeight: '1.5rem' }],
    lg: ['1.125rem', { lineHeight: '1.75rem' }],
    xl: ['1.25rem', { lineHeight: '1.75rem' }],
    '2xl': ['1.5rem', { lineHeight: '2rem' }],
    '3xl': ['1.875rem', { lineHeight: '2.25rem' }],
    '4xl': ['2.25rem', { lineHeight: '2.5rem' }],
    '5xl': ['3rem', { lineHeight: '1' }],
    '6xl': ['3.75rem', { lineHeight: '1' }],
    '7xl': ['4.5rem', { lineHeight: '1' }],
    '8xl': ['6rem', { lineHeight: '1' }],
    '9xl': ['8rem', { lineHeight: '1' }],
  },
  
  fontWeight: {
    thin: '100',
    extralight: '200',
    light: '300',
    normal: '400',
    medium: '500',
    semibold: '600',
    bold: '700',
    extrabold: '800',
    black: '900',
  },
  
  lineHeight: {
    none: '1',
    tight: '1.25',
    snug: '1.375',
    normal: '1.5',
    relaxed: '1.625',
    loose: '2',
  },
  
  letterSpacing: {
    tighter: '-0.05em',
    tight: '-0.025em',
    normal: '0em',
    wide: '0.025em',
    wider: '0.05em',
    widest: '0.1em',
  },
} as const;

export const borderRadius = {
  none: '0',
  sm: '0.125rem',
  DEFAULT: '0.25rem',
  md: '0.375rem',
  lg: '0.5rem',
  xl: '0.75rem',
  '2xl': '1rem',
  '3xl': '1.5rem',
  full: '9999px',
} as const;

export const shadows = {
  sm: '0 1px 2px 0 rgb(0 0 0 / 0.05)',
  DEFAULT: '0 1px 3px 0 rgb(0 0 0 / 0.1), 0 1px 2px -1px rgb(0 0 0 / 0.1)',
  md: '0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1)',
  lg: '0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1)',
  xl: '0 20px 25px -5px rgb(0 0 0 / 0.1), 0 8px 10px -6px rgb(0 0 0 / 0.1)',
  '2xl': '0 25px 50px -12px rgb(0 0 0 / 0.25)',
  inner: 'inset 0 2px 4px 0 rgb(0 0 0 / 0.05)',
  none: 'none',
} as const;

export const animation = {
  duration: {
    75: '75ms',
    100: '100ms',
    150: '150ms',
    200: '200ms',
    300: '300ms',
    500: '500ms',
    700: '700ms',
    1000: '1000ms',
  },
  
  easing: {
    linear: 'linear',
    in: 'cubic-bezier(0.4, 0, 1, 1)',
    out: 'cubic-bezier(0, 0, 0.2, 1)',
    inOut: 'cubic-bezier(0.4, 0, 0.2, 1)',
  },
} as const;

export const breakpoints = {
  sm: '640px',
  md: '768px',
  lg: '1024px',
  xl: '1280px',
  '2xl': '1536px',
} as const;

export const zIndex = {
  auto: 'auto',
  0: '0',
  10: '10',
  20: '20',
  30: '30',
  40: '40',
  50: '50',
  dropdown: '1000',
  sticky: '1020',
  fixed: '1030',
  modal: '1040',
  popover: '1050',
  tooltip: '1060',
  toast: '1070',
} as const;

// Component-specific tokens
export const components = {
  button: {
    height: {
      sm: spacing[8],
      md: spacing[10],
      lg: spacing[12],
    },
    padding: {
      sm: `${spacing[2]} ${spacing[3]}`,
      md: `${spacing[2]} ${spacing[4]}`,
      lg: `${spacing[3]} ${spacing[6]}`,
    },
    borderRadius: borderRadius.md,
  },
  
  input: {
    height: spacing[10],
    padding: `${spacing[2]} ${spacing[3]}`,
    borderRadius: borderRadius.md,
    borderWidth: '1px',
  },
  
  card: {
    padding: spacing[6],
    borderRadius: borderRadius.lg,
    shadow: shadows.md,
  },
  
  modal: {
    borderRadius: borderRadius.xl,
    shadow: shadows['2xl'],
    backdropBlur: '8px',
  },
} as const;

// Theme configuration
export const lightTheme = {
  colors: {
    background: colors.gray[50],
    foreground: colors.gray[900],
    muted: colors.gray[100],
    mutedForeground: colors.gray[500],
    card: colors.gray[0],
    cardForeground: colors.gray[900],
    border: colors.gray[200],
    input: colors.gray[200],
    primary: colors.primary[600],
    primaryForeground: colors.gray[50],
    secondary: colors.secondary[100],
    secondaryForeground: colors.secondary[900],
    accent: colors.secondary[100],
    accentForeground: colors.secondary[900],
    destructive: colors.error[500],
    destructiveForeground: colors.gray[50],
    ring: colors.primary[600],
  },
} as const;

export const darkTheme = {
  colors: {
    background: colors.gray[950],
    foreground: colors.gray[50],
    muted: colors.gray[800],
    mutedForeground: colors.gray[400],
    card: colors.gray[900],
    cardForeground: colors.gray[50],
    border: colors.gray[800],
    input: colors.gray[800],
    primary: colors.primary[500],
    primaryForeground: colors.gray[900],
    secondary: colors.secondary[800],
    secondaryForeground: colors.secondary[50],
    accent: colors.secondary[800],
    accentForeground: colors.secondary[50],
    destructive: colors.error[600],
    destructiveForeground: colors.gray[50],
    ring: colors.primary[500],
  },
} as const;

// Utility functions for working with tokens
export const getColor = (colorPath: string, opacity?: number): string => {
  const parts = colorPath.split('.');
  let color: any = colors;
  
  for (const part of parts) {
    color = color[part];
  }
  
  if (typeof color !== 'string') {
    throw new Error(`Invalid color path: ${colorPath}`);
  }
  
  if (opacity !== undefined) {
    const rgb = hexToRgb(color);
    if (rgb) {
      return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${opacity})`;
    }
  }
  
  return color;
};

export const getSpacing = (size: keyof typeof spacing): string => {
  return spacing[size];
};

export const getFontSize = (size: keyof typeof typography.fontSize): string => {
  const [fontSize] = typography.fontSize[size];
  return fontSize;
};

export const getBreakpoint = (breakpoint: keyof typeof breakpoints): string => {
  return breakpoints[breakpoint];
};

// Helper function to convert hex to rgb
function hexToRgb(hex: string): { r: number; g: number; b: number } | null {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
  return result ? {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  } : null;
}

// Export all tokens as default
export default {
  colors,
  spacing,
  typography,
  borderRadius,
  shadows,
  animation,
  breakpoints,
  zIndex,
  components,
  lightTheme,
  darkTheme,
  getColor,
  getSpacing,
  getFontSize,
  getBreakpoint,
};
</file>

<file path="src/types/auth.types.ts">
export interface AuthResponse {
  access_token: string;
  refresh_token?: string;
  user_id: number;
  enterprise_id: number;
  is_superuser: boolean;
  token_type: string;
}

export interface LoginCredentials {
  email: string;
  password: string;
  user_agent?: string;
  mfa_code?: string | null;
}

export interface AuthError {
  error_type:
    | "INVALID_CREDENTIALS"
    | "ACCOUNT_LOCKED"
    | "MFA_REQUIRED"
    | "EMAIL_NOT_VERIFIED"
    | "ACCOUNT_INACTIVE";
  message: string;
}
</file>

<file path="src/types/convex.types.ts">
// Enhanced type definitions for Convex operations and data structures

import { QueryCtx, MutationCtx, ActionCtx } from "convex/server";
import { Id } from "../../convex/_generated/dataModel";

// Convex Context Types
export type ConvexQueryCtx = QueryCtx;
export type ConvexMutationCtx = MutationCtx;
export type ConvexActionCtx = ActionCtx;

// Agent Task Types
export interface AgentTask {
  id: string;
  type: string;
  priority: 'low' | 'medium' | 'high' | 'critical';
  status: 'pending' | 'processing' | 'completed' | 'failed';
  data: AgentTaskData;
  result?: AgentTaskResult;
  error?: string;
  createdAt: string;
  updatedAt?: string;
  retryCount?: number;
  maxRetries?: number;
}

export interface AgentTaskData {
  contractId?: Id<"contracts">;
  vendorId?: Id<"vendors">;
  enterpriseId: Id<"enterprises">;
  userId?: Id<"users">;
  parameters?: Record<string, unknown>;
  metadata?: TaskMetadata;
}

export interface TaskMetadata {
  source?: string;
  triggeredBy?: string;
  correlationId?: string;
  tags?: string[];
  [key: string]: unknown;
}

export interface AgentTaskResult {
  success: boolean;
  data?: Record<string, unknown>;
  insights?: Insight[];
  recommendations?: Recommendation[];
  metadata?: ResultMetadata;
  executionTime?: number;
}

export interface ResultMetadata {
  processedAt: string;
  version: string;
  confidence?: number;
  sources?: string[];
  [key: string]: unknown;
}

// Analytics Types
export interface AnalysisResult {
  type: string;
  confidence: number;
  value: unknown;
  metadata: Record<string, unknown>;
  extractedAt: string;
}

export interface ContractAnalysis {
  contractId: Id<"contracts">;
  status: 'pending' | 'processing' | 'completed' | 'failed';
  results: {
    parties?: AnalysisResult;
    terms?: AnalysisResult;
    dates?: AnalysisResult;
    financials?: AnalysisResult;
    risks?: AnalysisResult;
    compliance?: AnalysisResult;
  };
  summary?: string;
  recommendations?: Recommendation[];
  createdAt: string;
  updatedAt?: string;
}

export interface Insight {
  id: string;
  type: 'risk' | 'opportunity' | 'compliance' | 'financial' | 'operational';
  severity: 'low' | 'medium' | 'high' | 'critical';
  title: string;
  description: string;
  data: Record<string, unknown>;
  source: string;
  confidence: number;
  createdAt: string;
}

export interface Recommendation {
  id: string;
  type: 'action' | 'review' | 'optimize' | 'alert';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  title: string;
  description: string;
  actionItems?: ActionItem[];
  impact: 'low' | 'medium' | 'high';
  effort: 'low' | 'medium' | 'high';
  source: string;
  createdAt: string;
}

export interface ActionItem {
  id: string;
  description: string;
  assignee?: string;
  dueDate?: string;
  status: 'pending' | 'in_progress' | 'completed';
  metadata?: Record<string, unknown>;
}

// Search Types
export interface SearchQuery {
  query: string;
  filters?: SearchFilters;
  sort?: SearchSort;
  pagination?: SearchPagination;
  options?: SearchOptions;
}

export interface SearchFilters {
  contractTypes?: string[];
  statuses?: string[];
  dateRange?: {
    start?: string;
    end?: string;
  };
  vendorIds?: Id<"vendors">[];
  tags?: string[];
  [key: string]: unknown;
}

export interface SearchSort {
  field: string;
  direction: 'asc' | 'desc';
}

export interface SearchPagination {
  limit: number;
  offset?: number;
  cursor?: string;
}

export interface SearchOptions {
  includeContent?: boolean;
  highlightMatches?: boolean;
  fuzzyMatch?: boolean;
  boost?: Record<string, number>;
  debug?: boolean;
}

export interface SearchResult<T = unknown> {
  items: SearchResultItem<T>[];
  total: number;
  hasMore: boolean;
  nextCursor?: string;
  aggregations?: Record<string, SearchAggregation>;
  executionTime?: number;
  debug?: SearchDebugInfo;
}

export interface SearchResultItem<T = unknown> {
  id: string;
  type: string;
  score: number;
  data: T;
  highlights?: Record<string, string[]>;
  metadata?: Record<string, unknown>;
}

export interface SearchAggregation {
  buckets: Array<{
    key: string;
    count: number;
    data?: Record<string, unknown>;
  }>;
}

export interface SearchDebugInfo {
  query: string;
  parsedQuery?: Record<string, unknown>;
  executionPlan?: string[];
  performance?: Record<string, number>;
}

// Error Types
export interface ConvexError {
  code: string;
  message: string;
  details?: Record<string, unknown>;
  stack?: string;
  timestamp: string;
}

export interface ValidationError extends ConvexError {
  code: 'VALIDATION_ERROR';
  field?: string;
  value?: unknown;
  rule?: string;
}

export interface AuthorizationError extends ConvexError {
  code: 'AUTHORIZATION_ERROR';
  requiredRole?: string;
  userRole?: string;
  resource?: string;
}

export interface NotFoundError extends ConvexError {
  code: 'NOT_FOUND';
  resourceType?: string;
  resourceId?: string;
}

// Event Types
export interface RealtimeEvent {
  type: string;
  entityType: string;
  entityId: string;
  action: 'create' | 'update' | 'delete';
  data: Record<string, unknown>;
  metadata: EventMetadata;
  timestamp: string;
}

export interface EventMetadata {
  userId?: Id<"users">;
  enterpriseId: Id<"enterprises">;
  source: string;
  correlationId?: string;
  version: string;
  [key: string]: unknown;
}

// Configuration Types
export interface AgentConfig {
  enabled: boolean;
  maxConcurrency: number;
  timeout: number;
  retryPolicy: RetryPolicy;
  features: Record<string, FeatureConfig>;
  metadata?: Record<string, unknown>;
}

export interface RetryPolicy {
  maxRetries: number;
  backoffStrategy: 'linear' | 'exponential';
  baseDelay: number;
  maxDelay: number;
  jitter: boolean;
}

export interface FeatureConfig {
  enabled: boolean;
  parameters?: Record<string, unknown>;
  limits?: Record<string, number>;
}

// API Response Types
export interface PaginatedResponse<T> {
  data: T[];
  pagination: {
    total: number;
    page: number;
    pageSize: number;
    hasNext: boolean;
    hasPrev: boolean;
    nextCursor?: string;
    prevCursor?: string;
  };
  meta?: Record<string, unknown>;
}

export interface ApiResponse<T = unknown> {
  success: boolean;
  data?: T;
  error?: ConvexError;
  metadata?: {
    requestId: string;
    timestamp: string;
    executionTime: number;
    [key: string]: unknown;
  };
}

// Utility Types
export type DeepPartial<T> = {
  [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

export type RequiredFields<T, K extends keyof T> = T & Required<Pick<T, K>>;

export type OptionalFields<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

export type WithMetadata<T> = T & {
  metadata?: Record<string, unknown>;
};

export type WithTimestamps<T> = T & {
  createdAt: string;
  updatedAt?: string;
};

export type DatabaseEntity<T> = WithTimestamps<WithMetadata<T>> & {
  _id: Id<string>;
};

// Query Builder Types
export type QueryBuilder<T> = {
  where: (predicate: (item: T) => boolean) => QueryBuilder<T>;
  orderBy: (field: keyof T, direction?: 'asc' | 'desc') => QueryBuilder<T>;
  limit: (count: number) => QueryBuilder<T>;
  offset: (count: number) => QueryBuilder<T>;
  select: <K extends keyof T>(fields: K[]) => QueryBuilder<Pick<T, K>>;
  execute: () => Promise<T[]>;
  first: () => Promise<T | null>;
  count: () => Promise<number>;
};

// Event Emitter Types
export interface EventEmitter {
  on<T = unknown>(event: string, listener: (data: T) => void): void;
  off<T = unknown>(event: string, listener: (data: T) => void): void;
  emit<T = unknown>(event: string, data: T): void;
  once<T = unknown>(event: string, listener: (data: T) => void): void;
}

export default {};
</file>

<file path="src/types/homedashboard.types.ts">
import { LucideIcon } from "lucide-react";

export interface SubNavigationItem {
  label: string;
  href: string;
  icon?: LucideIcon;
}

export interface NavigationItem {
  icon: LucideIcon;
  label: string;
  href: string;
  badge?: number | string;
  subItems?: SubNavigationItem[];
}

export interface NavigationGroup {
  label?: string;
  items: NavigationItem[];
}

export type NavigationState = {
  expandedItems: string[];
  activeItem: string;
};

export interface NavLink {
  label: string;
  href: string;
  icon: LucideIcon;
}

export interface NavSection {
  label?: string;
  items: {
    label: string;
    href: string;
    icon: LucideIcon;
    subItems?: NavLink[];
  }[];
}
</file>

<file path="components.json">
{
  "$schema": "https://ui.shadcn.com/schema.json",
  "style": "new-york",
  "rsc": true,
  "tsx": true,
  "tailwind": {
    "config": "",
    "css": "src/app/globals.css",
    "baseColor": "neutral",
    "cssVariables": true,
    "prefix": ""
  },
  "aliases": {
    "components": "@/components",
    "utils": "@/lib/utils",
    "ui": "@/components/ui",
    "lib": "@/lib",
    "hooks": "@/hooks"
  },
  "iconLibrary": "lucide"
}
</file>

<file path="eslint.config.mjs">
import { dirname } from "path";
import { fileURLToPath } from "url";
import { FlatCompat } from "@eslint/eslintrc";

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const compat = new FlatCompat({
  baseDirectory: __dirname,
});

const eslintConfig = [
  ...compat.extends("next/core-web-vitals", "next/typescript"),
];

export default eslintConfig;
</file>

<file path="sentry.client.config.ts">
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  
  // Set tracesSampleRate to 1.0 to capture 100% of the transactions for performance monitoring.
  // We recommend adjusting this value in production
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  
  // Capture 100% of the sessions for user session replay
  replaysSessionSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,
  
  // Capture 100% of the sessions with an error for replay
  replaysOnErrorSampleRate: 1.0,

  // You can remove this option if you're not planning to use the Sentry Webpack Plugin
  // See: https://docs.sentry.io/platforms/javascript/guides/nextjs/manual-setup/
  debug: process.env.NODE_ENV === 'development',

  integrations: [
    new Sentry.Replay({
      // Mask all text content, images, and user input, except for UI text
      maskAllText: true,
      blockAllMedia: true,
      maskAllInputs: true,
    }),
    new Sentry.BrowserTracing({
      // Set up automatic route change tracking for Next.js App Router
      routingInstrumentation: Sentry.nextjsRouterInstrumentation(),
    }),
  ],

  // Environment configuration
  environment: process.env.NODE_ENV,
  
  // Release tracking
  release: process.env.NEXT_PUBLIC_APP_VERSION || 'development',

  // Performance monitoring
  beforeSend(event, hint) {
    // Filter out certain errors in production
    if (process.env.NODE_ENV === 'production') {
      // Filter out network errors that are likely user connectivity issues
      if (event.exception?.values?.[0]?.type === 'ChunkLoadError') {
        return null;
      }
      
      // Filter out cross-origin script errors
      if (event.message?.includes('Script error')) {
        return null;
      }
    }

    return event;
  },

  // User context
  initialScope: {
    tags: {
      component: 'client',
    },
  },
});

// Global error handler enhancement
if (typeof window !== 'undefined') {
  window.addEventListener('unhandledrejection', (event) => {
    Sentry.captureException(event.reason, {
      tags: {
        source: 'unhandledrejection',
      },
    });
  });
}

export default Sentry;
</file>

<file path="sentry.server.config.ts">
import * as Sentry from '@sentry/nextjs';

Sentry.init({
  dsn: process.env.NEXT_PUBLIC_SENTRY_DSN,
  
  // Adjust this value in production, or use tracesSampler for greater control
  tracesSampleRate: process.env.NODE_ENV === 'production' ? 0.1 : 1.0,

  // Setting this option to true will print useful information to the console while you're setting up Sentry.
  debug: process.env.NODE_ENV === 'development',

  // Environment configuration
  environment: process.env.NODE_ENV,
  
  // Release tracking
  release: process.env.NEXT_PUBLIC_APP_VERSION || 'development',

  // Server-specific integrations
  integrations: [
    new Sentry.HttpIntegration({
      // Capture HTTP requests
      tracing: true,
    }),
  ],

  // Performance monitoring for server-side
  beforeSend(event, hint) {
    // Server-side error filtering
    if (process.env.NODE_ENV === 'production') {
      // Filter out certain server errors
      if (event.exception?.values?.[0]?.type === 'AbortError') {
        return null;
      }
    }

    return event;
  },

  // Additional server context
  initialScope: {
    tags: {
      component: 'server',
    },
  },
});

export default Sentry;
</file>

<file path="convex/_generated/dataModel.d.ts">
/* eslint-disable */
/**
 * Generated data model types.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  DataModelFromSchemaDefinition,
  DocumentByName,
  TableNamesInDataModel,
  SystemTableNames,
} from "convex/server";
import type { GenericId } from "convex/values";
import schema from "../schema.js";

/**
 * The names of all of your Convex tables.
 */
export type TableNames = TableNamesInDataModel<DataModel>;

/**
 * The type of a document stored in Convex.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Doc<TableName extends TableNames> = DocumentByName<
  DataModel,
  TableName
>;

/**
 * An identifier for a document in Convex.
 *
 * Convex documents are uniquely identified by their `Id`, which is accessible
 * on the `_id` field. To learn more, see [Document IDs](https://docs.convex.dev/using/document-ids).
 *
 * Documents can be loaded using `db.get(id)` in query and mutation functions.
 *
 * IDs are just strings at runtime, but this type can be used to distinguish them from other
 * strings when type checking.
 *
 * @typeParam TableName - A string literal type of the table name (like "users").
 */
export type Id<TableName extends TableNames | SystemTableNames> =
  GenericId<TableName>;

/**
 * A type describing your Convex data model.
 *
 * This type includes information about what tables you have, the type of
 * documents stored in those tables, and the indexes defined on them.
 *
 * This type is used to parameterize methods like `queryGeneric` and
 * `mutationGeneric` to make them type-safe.
 */
export type DataModel = DataModelFromSchemaDefinition<typeof schema>;
</file>

<file path="convex/_generated/server.js">
/* eslint-disable */
/**
 * Generated utilities for implementing server-side Convex query and mutation functions.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import {
  actionGeneric,
  httpActionGeneric,
  queryGeneric,
  mutationGeneric,
  internalActionGeneric,
  internalMutationGeneric,
  internalQueryGeneric,
} from "convex/server";

/**
 * Define a query in this Convex app's public API.
 *
 * This function will be allowed to read your Convex database and will be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const query = queryGeneric;

/**
 * Define a query that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to read from your Convex database. It will not be accessible from the client.
 *
 * @param func - The query function. It receives a {@link QueryCtx} as its first argument.
 * @returns The wrapped query. Include this as an `export` to name it and make it accessible.
 */
export const internalQuery = internalQueryGeneric;

/**
 * Define a mutation in this Convex app's public API.
 *
 * This function will be allowed to modify your Convex database and will be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const mutation = mutationGeneric;

/**
 * Define a mutation that is only accessible from other Convex functions (but not from the client).
 *
 * This function will be allowed to modify your Convex database. It will not be accessible from the client.
 *
 * @param func - The mutation function. It receives a {@link MutationCtx} as its first argument.
 * @returns The wrapped mutation. Include this as an `export` to name it and make it accessible.
 */
export const internalMutation = internalMutationGeneric;

/**
 * Define an action in this Convex app's public API.
 *
 * An action is a function which can execute any JavaScript code, including non-deterministic
 * code and code with side-effects, like calling third-party services.
 * They can be run in Convex's JavaScript environment or in Node.js using the "use node" directive.
 * They can interact with the database indirectly by calling queries and mutations using the {@link ActionCtx}.
 *
 * @param func - The action. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped action. Include this as an `export` to name it and make it accessible.
 */
export const action = actionGeneric;

/**
 * Define an action that is only accessible from other Convex functions (but not from the client).
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument.
 * @returns The wrapped function. Include this as an `export` to name it and make it accessible.
 */
export const internalAction = internalActionGeneric;

/**
 * Define a Convex HTTP action.
 *
 * @param func - The function. It receives an {@link ActionCtx} as its first argument, and a `Request` object
 * as its second.
 * @returns The wrapped endpoint function. Route a URL path to this function in `convex/http.js`.
 */
export const httpAction = httpActionGeneric;
</file>

<file path="convex/security/auditLogging.ts">
import { QueryCtx, MutationCtx, ActionCtx, query, mutation, internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { defineTable } from "convex/server";
import { Id } from "../_generated/dataModel";
import { getSecurityContext } from "./rowLevelSecurity";

/**
 * Comprehensive Audit Logging System
 * 
 * Tracks all sensitive operations for compliance and security monitoring
 */

export const auditTables = {
  auditLogs: defineTable({
    userId: v.id("users"),
    enterpriseId: v.id("enterprises"),
    operation: v.string(),
    resourceType: v.string(),
    resourceId: v.optional(v.string()),
    action: v.union(
      v.literal("create"),
      v.literal("read"),
      v.literal("update"),
      v.literal("delete"),
      v.literal("export"),
      v.literal("share"),
      v.literal("approve"),
      v.literal("reject")
    ),
    changes: v.optional(v.any()), // Before/after for updates
    ipAddress: v.optional(v.string()),
    userAgent: v.optional(v.string()),
    sessionId: v.optional(v.string()),
    status: v.union(v.literal("success"), v.literal("failure")),
    errorMessage: v.optional(v.string()),
    timestamp: v.string(),
    metadata: v.optional(v.any()),
  })
  .index("by_user", ["userId"])
  .index("by_enterprise", ["enterpriseId"])
  .index("by_resource", ["resourceType", "resourceId"])
  .index("by_timestamp", ["timestamp"])
  .index("by_operation", ["operation"])
  .index("by_status", ["status"]),
  
  auditAlerts: defineTable({
    enterpriseId: v.id("enterprises"),
    alertType: v.union(
      v.literal("suspicious_activity"),
      v.literal("unauthorized_access"),
      v.literal("data_export"),
      v.literal("permission_change"),
      v.literal("bulk_operation"),
      v.literal("failed_attempts")
    ),
    severity: v.union(
      v.literal("low"),
      v.literal("medium"),
      v.literal("high"),
      v.literal("critical")
    ),
    description: v.string(),
    userId: v.optional(v.id("users")),
    ipAddress: v.optional(v.string()),
    resolved: v.boolean(),
    resolvedBy: v.optional(v.id("users")),
    resolvedAt: v.optional(v.string()),
    createdAt: v.string(),
    metadata: v.optional(v.any()),
  })
  .index("by_enterprise", ["enterpriseId"])
  .index("by_severity", ["severity"])
  .index("by_resolved", ["resolved"])
  .index("by_created", ["createdAt"]),
};

interface AuditContext {
  userId: Id<"users">;
  enterpriseId: Id<"enterprises">;
  ipAddress?: string;
  userAgent?: string;
  sessionId?: string;
}

/**
 * Log an audit event
 */
export async function logAuditEvent(
  ctx: MutationCtx,
  context: AuditContext,
  event: {
    operation: string;
    resourceType: string;
    resourceId?: string;
    action: "create" | "read" | "update" | "delete" | "export" | "share" | "approve" | "reject";
    changes?: any;
    status: "success" | "failure";
    errorMessage?: string;
    metadata?: any;
  }
): Promise<void> {
  await ctx.db.insert("auditLogs", {
    userId: context.userId,
    enterpriseId: context.enterpriseId,
    operation: event.operation,
    resourceType: event.resourceType,
    resourceId: event.resourceId,
    action: event.action,
    changes: event.changes,
    ipAddress: context.ipAddress,
    userAgent: context.userAgent,
    sessionId: context.sessionId,
    status: event.status,
    errorMessage: event.errorMessage,
    timestamp: new Date().toISOString(),
    metadata: event.metadata,
  });
  
  // Check for suspicious patterns
  await checkSuspiciousActivity(ctx, context, event);
}

/**
 * Check for suspicious activity patterns
 */
async function checkSuspiciousActivity(
  ctx: MutationCtx,
  context: AuditContext,
  event: any
): Promise<void> {
  const oneHourAgo = new Date(Date.now() - 60 * 60 * 1000).toISOString();
  
  // Check for multiple failed attempts
  const recentFailures = await ctx.db
    .query("auditLogs")
    .withIndex("by_user", (q) => q.eq("userId", context.userId))
    .filter((q) => 
      q.and(
        q.eq(q.field("status"), "failure"),
        q.gte(q.field("timestamp"), oneHourAgo)
      )
    )
    .collect();
  
  if (recentFailures.length >= 5) {
    await createAuditAlert(ctx, {
      enterpriseId: context.enterpriseId,
      alertType: "failed_attempts",
      severity: "high",
      description: `User has ${recentFailures.length} failed attempts in the last hour`,
      userId: context.userId,
      ipAddress: context.ipAddress,
      metadata: { failureCount: recentFailures.length }
    });
  }
  
  // Check for bulk operations
  if (event.action === "delete" || event.action === "export") {
    const recentSimilar = await ctx.db
      .query("auditLogs")
      .withIndex("by_user", (q) => q.eq("userId", context.userId))
      .filter((q) => 
        q.and(
          q.eq(q.field("action"), event.action),
          q.gte(q.field("timestamp"), oneHourAgo)
        )
      )
      .collect();
    
    if (recentSimilar.length >= 10) {
      await createAuditAlert(ctx, {
        enterpriseId: context.enterpriseId,
        alertType: "bulk_operation",
        severity: "medium",
        description: `User performed ${recentSimilar.length} ${event.action} operations in the last hour`,
        userId: context.userId,
        ipAddress: context.ipAddress,
        metadata: { operationCount: recentSimilar.length, action: event.action }
      });
    }
  }
  
  // Check for data exports
  if (event.action === "export") {
    await createAuditAlert(ctx, {
      enterpriseId: context.enterpriseId,
      alertType: "data_export",
      severity: "low",
      description: `Data export performed on ${event.resourceType}`,
      userId: context.userId,
      ipAddress: context.ipAddress,
      metadata: { resourceType: event.resourceType, resourceId: event.resourceId }
    });
  }
  
  // Check for permission changes
  if (event.resourceType === "users" && event.action === "update" && event.changes?.role) {
    await createAuditAlert(ctx, {
      enterpriseId: context.enterpriseId,
      alertType: "permission_change",
      severity: "medium",
      description: `User role changed from ${event.changes.role.old} to ${event.changes.role.new}`,
      userId: context.userId,
      metadata: { targetUserId: event.resourceId, roleChange: event.changes.role }
    });
  }
}

/**
 * Create an audit alert
 */
async function createAuditAlert(
  ctx: MutationCtx,
  alert: {
    enterpriseId: Id<"enterprises">;
    alertType: "suspicious_activity" | "unauthorized_access" | "data_export" | "permission_change" | "bulk_operation" | "failed_attempts";
    severity: "low" | "medium" | "high" | "critical";
    description: string;
    userId?: Id<"users">;
    ipAddress?: string;
    metadata?: any;
  }
): Promise<void> {
  // Check if similar alert already exists
  const existingAlert = await ctx.db
    .query("auditAlerts")
    .withIndex("by_enterprise", (q) => q.eq("enterpriseId", alert.enterpriseId))
    .filter((q) => 
      q.and(
        q.eq(q.field("alertType"), alert.alertType),
        q.eq(q.field("userId"), alert.userId),
        q.eq(q.field("resolved"), false)
      )
    )
    .first();
  
  if (!existingAlert) {
    await ctx.db.insert("auditAlerts", {
      ...alert,
      resolved: false,
      createdAt: new Date().toISOString(),
    });
    
    // TODO: Send notification to admins
  }
}

/**
 * Audit log query functions
 */
export const getAuditLogs = query({
  args: {
    filters: v.optional(v.object({
      userId: v.optional(v.id("users")),
      resourceType: v.optional(v.string()),
      resourceId: v.optional(v.string()),
      action: v.optional(v.string()),
      startDate: v.optional(v.string()),
      endDate: v.optional(v.string()),
      status: v.optional(v.union(v.literal("success"), v.literal("failure"))),
    })),
    limit: v.optional(v.number()),
    offset: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const securityContext = await getSecurityContext(ctx);
    
    // Only admins and owners can view audit logs
    if (!["owner", "admin"].includes(securityContext.role)) {
      throw new ConvexError("Access denied: Audit logs require admin access");
    }
    
    let query = ctx.db
      .query("auditLogs")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", securityContext.enterpriseId));
    
    // Apply filters
    let logs = await query.order("desc").collect();
    
    if (args.filters) {
      if (args.filters.userId) {
        logs = logs.filter(l => l.userId === args.filters!.userId);
      }
      if (args.filters.resourceType) {
        logs = logs.filter(l => l.resourceType === args.filters!.resourceType);
      }
      if (args.filters.resourceId) {
        logs = logs.filter(l => l.resourceId === args.filters!.resourceId);
      }
      if (args.filters.action) {
        logs = logs.filter(l => l.action === args.filters!.action);
      }
      if (args.filters.status) {
        logs = logs.filter(l => l.status === args.filters!.status);
      }
      if (args.filters.startDate) {
        logs = logs.filter(l => l.timestamp >= args.filters!.startDate!);
      }
      if (args.filters.endDate) {
        logs = logs.filter(l => l.timestamp <= args.filters!.endDate!);
      }
    }
    
    // Apply pagination
    const limit = args.limit || 50;
    const offset = args.offset || 0;
    const paginatedLogs = logs.slice(offset, offset + limit);
    
    // Enrich with user information
    const enrichedLogs = await Promise.all(
      paginatedLogs.map(async (log) => {
        const user = await ctx.db.get(log.userId);
        return {
          ...log,
          userName: user ? `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email : 'Unknown',
          userEmail: user?.email,
        };
      })
    );
    
    return {
      logs: enrichedLogs,
      total: logs.length,
      hasMore: offset + limit < logs.length,
    };
  },
});

/**
 * Get audit alerts
 */
export const getAuditAlerts = query({
  args: {
    resolved: v.optional(v.boolean()),
    severity: v.optional(v.union(
      v.literal("low"),
      v.literal("medium"),
      v.literal("high"),
      v.literal("critical")
    )),
  },
  handler: async (ctx, args) => {
    const securityContext = await getSecurityContext(ctx);
    
    // Only admins and owners can view audit alerts
    if (!["owner", "admin"].includes(securityContext.role)) {
      throw new ConvexError("Access denied: Audit alerts require admin access");
    }
    
    let query = ctx.db
      .query("auditAlerts")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", securityContext.enterpriseId));
    
    let alerts = await query.order("desc").collect();
    
    if (args.resolved !== undefined) {
      alerts = alerts.filter(a => a.resolved === args.resolved);
    }
    
    if (args.severity) {
      alerts = alerts.filter(a => a.severity === args.severity);
    }
    
    return alerts;
  },
});

/**
 * Resolve an audit alert
 */
export const resolveAuditAlert = mutation({
  args: {
    alertId: v.id("auditAlerts"),
  },
  handler: async (ctx, args) => {
    const securityContext = await getSecurityContext(ctx);
    
    // Only admins and owners can resolve alerts
    if (!["owner", "admin"].includes(securityContext.role)) {
      throw new ConvexError("Access denied: Only admins can resolve alerts");
    }
    
    const alert = await ctx.db.get(args.alertId);
    if (!alert) {
      throw new ConvexError("Alert not found");
    }
    
    if (alert.enterpriseId !== securityContext.enterpriseId) {
      throw new ConvexError("Access denied: Alert belongs to different enterprise");
    }
    
    await ctx.db.patch(args.alertId, {
      resolved: true,
      resolvedBy: securityContext.userId,
      resolvedAt: new Date().toISOString(),
    });
    
    // Log the resolution
    await logAuditEvent(ctx, securityContext, {
      operation: "resolveAuditAlert",
      resourceType: "auditAlerts",
      resourceId: args.alertId,
      action: "update",
      status: "success",
      metadata: { alertType: alert.alertType, severity: alert.severity }
    });
  },
});

/**
 * Log an audit event (mutation for external calls)
 */
export const logEvent = mutation({
  args: {
    userId: v.id("users"),
    operation: v.string(),
    resourceType: v.string(),
    resourceId: v.optional(v.string()),
    action: v.union(
      v.literal("create"),
      v.literal("read"),
      v.literal("update"),
      v.literal("delete"),
      v.literal("export"),
      v.literal("share"),
      v.literal("approve"),
      v.literal("reject")
    ),
    status: v.union(v.literal("success"), v.literal("failure")),
    errorMessage: v.optional(v.string()),
    metadata: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    // Get user to find enterpriseId
    const user = await ctx.db.get(args.userId);
    if (!user) {
      throw new ConvexError("User not found");
    }

    await ctx.db.insert("auditLogs", {
      userId: args.userId,
      enterpriseId: user.enterpriseId,
      operation: args.operation,
      resourceType: args.resourceType,
      resourceId: args.resourceId,
      action: args.action,
      status: args.status,
      errorMessage: args.errorMessage,
      metadata: args.metadata,
      timestamp: new Date().toISOString(),
      ipAddress: "unknown", // Actions don't have IP info
      userAgent: "system",
      sessionId: "action-session",
    });
  },
});
</file>

<file path="convex/security/secureContractOperations.ts">
import { v } from "convex/values";
import { Id } from "../_generated/dataModel";
import { ConvexError } from "convex/values";
import { createSecureQuery, createSecureMutation, createSecureAction } from "./secureWrapper";
import { SecureQuery } from "./rowLevelSecurity";
import { logAuditEvent } from "./auditLogging";
import { api } from "../_generated/api";

/**
 * Example implementation of secure contract operations
 * Shows how to use the security framework
 */

// Secure contract creation
export const createSecureContract = createSecureMutation(
  {
    vendorId: v.id("vendors"),
    title: v.string(),
    storageId: v.id("_storage"),
    fileName: v.string(),
    fileType: v.string(),
    contractType: v.optional(v.string()),
    notes: v.optional(v.string()),
  },
  {
    rateLimit: { operation: "mutation.create", cost: 2 },
    audit: {
      operation: "createContract",
      resourceType: "contracts",
      action: "create"
    },
    permission: "contracts.create"
  },
  async (ctx, args, security, secure) => {
    // Validate vendor belongs to enterprise
    const vendor = await secure.byId("vendors", args.vendorId);
    if (!vendor) {
      throw new ConvexError("Vendor not found");
    }
    
    // Create contract with automatic enterprise ID
    const contractId = await secure.insert("contracts", {
      vendorId: args.vendorId,
      title: args.title.trim(),
      status: "draft",
      contractType: args.contractType,
      storageId: args.storageId,
      fileName: args.fileName,
      fileType: args.fileType,
      analysisStatus: "pending",
      notes: args.notes?.trim(),
    }, "contracts.create");
    
    // Update audit log with created resource
    await logAuditEvent(ctx, security, {
      operation: "createContract",
      resourceType: "contracts",
      resourceId: contractId,
      action: "create",
      status: "success",
      metadata: { title: args.title, vendorId: args.vendorId }
    });
    
    return contractId;
  }
);

// Secure contract query with automatic filtering
export const getSecureContracts = createSecureQuery(
  {
    status: v.optional(v.string()),
    contractType: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  {
    rateLimit: { operation: "query.default" },
    permission: "contracts.read"
  },
  async (ctx, args, security) => {
    const secureQuery = new SecureQuery(ctx, "contracts", security);
    
    // Build filters
    const filters: Array<(q: any) => any> = [];
    if (args.status) {
      filters.push((q: any) => q.eq(q.field("status"), args.status));
    }
    if (args.contractType) {
      filters.push((q: any) => q.eq(q.field("contractType"), args.contractType));
    }
    
    // Query with automatic enterprise filtering
    const contracts = await secureQuery.where((q: any) => {
      if (filters.length === 0) return true;
      if (filters.length === 1) return filters[0](q);
      return q.and(...filters.map((f: any) => f(q)));
    });
    
    // Apply limit
    const limited = args.limit ? contracts.slice(0, args.limit) : contracts;
    
    // Enrich with vendor data
    const enriched = await Promise.all(
      limited.map(async (contract) => {
        const vendor = await ctx.db.get(contract.vendorId);
        return {
          ...contract,
          vendor: vendor ? {
            _id: vendor._id,
            name: vendor.name,
            category: vendor.category,
          } : null,
        };
      })
    );
    
    return enriched;
  }
);

// Secure contract update with change tracking
export const updateSecureContract = createSecureMutation(
  {
    contractId: v.id("contracts"),
    updates: v.object({
      title: v.optional(v.string()),
      status: v.optional(v.string()),
      contractType: v.optional(v.string()),
      notes: v.optional(v.string()),
    }),
  },
  {
    rateLimit: { operation: "mutation.update" },
    audit: {
      operation: "updateContract",
      resourceType: "contracts",
      action: "update"
    },
    permission: "contracts.update"
  },
  async (ctx, args, security, secure) => {
    // Get existing contract to track changes
    const existing = await secure.byId("contracts", args.contractId);
    if (!existing) {
      throw new ConvexError("Contract not found");
    }
    
    // Track changes for audit
    const changes: any = {};
    Object.entries(args.updates).forEach(([key, value]) => {
      if (value !== undefined && existing[key as keyof typeof existing] !== value) {
        changes[key] = {
          old: existing[key as keyof typeof existing],
          new: value
        };
      }
    });
    
    // Update contract
    await secure.update(args.contractId, args.updates, "contracts.update");
    
    // Log with changes
    await logAuditEvent(ctx, security, {
      operation: "updateContract",
      resourceType: "contracts",
      resourceId: args.contractId,
      action: "update",
      changes,
      status: "success",
      metadata: { title: existing.title }
    });
    
    return { success: true };
  }
);

// Secure contract deletion
export const deleteSecureContract = createSecureMutation(
  {
    contractId: v.id("contracts"),
  },
  {
    rateLimit: { operation: "mutation.delete", cost: 3 },
    audit: {
      operation: "deleteContract",
      resourceType: "contracts",
      action: "delete"
    },
    permission: "contracts.delete"
  },
  async (ctx, args, security, secure) => {
    // Get contract details for audit
    const contract = await secure.byId("contracts", args.contractId);
    if (!contract) {
      throw new ConvexError("Contract not found");
    }
    
    // Delete associated file
    try {
      await ctx.storage.delete(contract.storageId);
    } catch (error) {
      console.warn(`Failed to delete file for contract ${args.contractId}:`, error);
    }
    
    // Delete contract
    await secure.delete(args.contractId, "contracts.delete");
    
    // Log deletion with contract details
    await logAuditEvent(ctx, security, {
      operation: "deleteContract",
      resourceType: "contracts",
      resourceId: args.contractId,
      action: "delete",
      status: "success",
      metadata: { 
        title: contract.title,
        vendorId: contract.vendorId,
        value: contract.value || contract.extractedPricing
      }
    });
    
    return { success: true };
  }
);

// Secure bulk export with special auditing
// Note: Changed to mutation since actions require complex authentication setup
export const exportSecureContracts = createSecureMutation(
  {
    format: v.union(v.literal("csv"), v.literal("json"), v.literal("xlsx")),
    filters: v.optional(v.object({
      status: v.optional(v.string()),
      startDate: v.optional(v.string()),
      endDate: v.optional(v.string()),
    })),
  },
  {
    rateLimit: { operation: "mutation.export", cost: 5 },
    audit: {
      operation: "exportContracts",
      resourceType: "contracts",
      action: "export"
    },
    permission: "contracts.export"
  },
  async (ctx, args, security, secure) => {
    // Use SecureQuery to get contracts with proper enterprise filtering
    const secureQuery = new SecureQuery(ctx, "contracts", security);
    let contracts = await secureQuery.all();
    
    // Apply additional filters
    if (args.filters) {
      if (args.filters.status) {
        contracts = contracts.filter((c: any) => c.status === args.filters.status);
      }
      if (args.filters.startDate) {
        contracts = contracts.filter((c: any) => c._creationTime >= new Date(args.filters.startDate!).getTime());
      }
      if (args.filters.endDate) {
        contracts = contracts.filter((c: any) => c._creationTime <= new Date(args.filters.endDate!).getTime());
      }
    }
    
    // Generate export - initialize with empty string or add default case
    let exportData: string;
    switch (args.format) {
      case "csv":
        exportData = generateCSV(contracts);
        break;
      case "json":
        exportData = JSON.stringify(contracts, null, 2);
        break;
      case "xlsx":
        exportData = generateXLSX(contracts);
        break;
      default:
        // This should never happen due to validation, but TypeScript needs it
        throw new Error(`Unsupported format: ${args.format}`);
    }
    
    // Return download URL (would upload to storage in practice)
    return {
      format: args.format,
      count: contracts.length,
      data: exportData,
      timestamp: new Date().toISOString()
    };
  }
);

// Helper functions for export
function generateCSV(contracts: any[]): string {
  const headers = ["Title", "Status", "Type", "Vendor", "Value", "Start Date", "End Date"];
  const rows = contracts.map((c: any) => [
    c.title,
    c.status,
    c.contractType || "",
    c.vendor?.name || "",
    c.value || c.extractedPricing || "",
    c.startDate || c.extractedStartDate || "",
    c.endDate || c.extractedEndDate || ""
  ]);
  
  return [headers, ...rows].map((row: any) => row.join(",")).join("\n");
}

function generateXLSX(contracts: any[]): string {
  // Simplified - would use actual XLSX library
  return generateCSV(contracts);
}
</file>

<file path="convex/security/secureWrapper.ts">
import { query as baseQuery, mutation as baseMutation, action as baseAction, QueryCtx, MutationCtx, ActionCtx } from "../_generated/server";
import { ConvexError } from "convex/values";
import { getSecurityContext, SecurityContext, hasPermission, SecureQuery, SecureMutation } from "./rowLevelSecurity";
import { checkRateLimit } from "./rateLimiting";
import { logAuditEvent } from "./auditLogging";
import { api } from "../_generated/api";

/**
 * Validate Clerk JWT token
 */
async function validateClerkToken(token: string): Promise<{ sub: string } | null> {
  try {
    // In a real implementation, you would verify the JWT signature using Clerk's public key
    // For now, we'll use Clerk's API to validate the token
    const response = await fetch(`${process.env.CLERK_API_URL}/sessions/verify`, {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${process.env.CLERK_SECRET_KEY}`,
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({ token }),
    });
    
    if (!response.ok) {
      console.error('Clerk token validation failed:', response.statusText);
      return null;
    }
    
    const result = await response.json();
    return result.user ? { sub: result.user.id } : null;
  } catch (error) {
    console.error('Error validating Clerk token:', error);
    return null;
  }
}

// Role permissions for action authentication
const ROLE_PERMISSIONS = {
  owner: ["*"],
  admin: [
    "contracts.create", "contracts.read", "contracts.update", "contracts.delete",
    "vendors.create", "vendors.read", "vendors.update", "vendors.delete",
    "users.read", "users.update", "users.invite",
    "analytics.read", "settings.read", "settings.update"
  ],
  manager: [
    "contracts.create", "contracts.read", "contracts.update",
    "vendors.create", "vendors.read", "vendors.update",
    "users.read", "analytics.read"
  ],
  user: [
    "contracts.create", "contracts.read", "contracts.update",
    "vendors.create", "vendors.read", "vendors.update",
    "analytics.read"
  ],
  viewer: [
    "contracts.read", "vendors.read", "users.read", "analytics.read"
  ]
};

/**
 * Secure wrappers for Convex functions that automatically handle:
 * - Authentication and authorization
 * - Rate limiting
 * - Audit logging
 * - Row-level security
 */

interface SecureOptions {
  rateLimit?: {
    operation?: string;
    cost?: number;
  };
  audit?: {
    operation: string;
    resourceType: string;
    action: "create" | "read" | "update" | "delete" | "export" | "share" | "approve" | "reject";
  };
  permission?: string;
}

/**
 * Create a secure query with automatic security checks
 */
export function createSecureQuery<Args extends Record<string, any>, Output>(
  args: Args,
  options: SecureOptions,
  handler: (ctx: QueryCtx, args: Args, security: SecurityContext) => Promise<Output>
) {
  return baseQuery({
    args,
    handler: async (ctx, args: Args) => {
      // Get security context
      const securityContext = await getSecurityContext(ctx);
      
      // Check rate limit
      if (options.rateLimit) {
        const rateLimitResult = await checkRateLimit(ctx, 
          options.rateLimit.operation || "query.default",
          {
            userId: securityContext.userId,
            cost: options.rateLimit.cost
          }
        );
        
        if (!rateLimitResult.allowed) {
          throw new ConvexError(`Rate limit exceeded. Try again in ${rateLimitResult.resetIn} seconds.`);
        }
      }
      
      // Check permission
      if (options.permission && !hasPermission(securityContext, options.permission)) {
        throw new ConvexError(`Permission denied: ${options.permission}`);
      }
      
      try {
        // Execute handler with security context
        const result = await handler(ctx, args, securityContext);
        
        // Note: Audit logging in queries is optional since they don't modify data
        
        return result;
      } catch (error) {
        throw error;
      }
    },
  });
}

/**
 * Create a secure mutation with automatic security checks
 */
export function createSecureMutation<Args extends Record<string, any>, Output>(
  args: Args,
  options: SecureOptions,
  handler: (ctx: MutationCtx, args: Args, security: SecurityContext, secure: SecureMutation) => Promise<Output>
) {
  return baseMutation({
    args,
    handler: async (ctx, args: Args) => {
      // Get security context
      const securityContext = await getSecurityContext(ctx);
      
      // Check rate limit
      if (options.rateLimit) {
        const rateLimitResult = await checkRateLimit(ctx, 
          options.rateLimit.operation || "mutation.default",
          {
            userId: securityContext.userId,
            cost: options.rateLimit.cost
          }
        );
        
        if (!rateLimitResult.allowed) {
          throw new ConvexError(`Rate limit exceeded. Try again in ${rateLimitResult.resetIn} seconds.`);
        }
      }
      
      // Check permission
      if (options.permission && !hasPermission(securityContext, options.permission)) {
        throw new ConvexError(`Permission denied: ${options.permission}`);
      }
      
      // Create secure mutation helper
      const secureMutation = new SecureMutation(ctx, securityContext);
      
      try {
        // Execute handler
        const result = await handler(ctx, args, securityContext, secureMutation);
        
        // Log audit event
        if (options.audit) {
          await logAuditEvent(ctx, securityContext, {
            operation: options.audit.operation,
            resourceType: options.audit.resourceType,
            action: options.audit.action,
            status: "success",
          });
        }
        
        return result;
      } catch (error) {
        // Log failed attempt
        if (options.audit) {
          await logAuditEvent(ctx, securityContext, {
            operation: options.audit.operation,
            resourceType: options.audit.resourceType,
            action: options.audit.action,
            status: "failure",
            errorMessage: error instanceof Error ? error.message : String(error),
          });
        }
        throw error;
      }
    },
  });
}

/**
 * Create a secure action with authentication checks
 */
export function createSecureAction<Args extends Record<string, any>, Output>(
  args: Args,
  options: SecureOptions,
  handler: (ctx: ActionCtx, args: Args, security: SecurityContext) => Promise<Output>
) {
  return baseAction({
    args,
    handler: async (ctx, args: Args) => {
      // Actions require proper authentication via JWT token
      if (!args.authToken) {
        throw new ConvexError("Authentication required: Actions must include a valid authToken.");
      }
      
      // Validate JWT token and get user information
      let securityContext: SecurityContext;
      
      try {
        // Validate the JWT token using Clerk's API
        const clerkUser = await validateClerkToken(args.authToken);
        if (!clerkUser) {
          throw new ConvexError("Invalid authentication token");
        }
        
        // Get user from database
        const user = await ctx.runQuery(api.users.getByClerkId, { clerkId: clerkUser.sub });
        if (!user || !user.isActive) {
          throw new ConvexError("User not found or inactive");
        }
        
        securityContext = {
          userId: user._id,
          enterpriseId: user.enterpriseId,
          role: user.role,
          permissions: ROLE_PERMISSIONS[user.role as keyof typeof ROLE_PERMISSIONS] || []
        };
      } catch (error) {
        console.error("Action authentication failed:", error);
        throw new ConvexError("Authentication failed: Invalid or expired token");
      }
      
      // Check rate limit (with simplified tracking for actions)
      if (options.rateLimit) {
        // For actions, we'll implement a simpler rate limiting approach
        // In a production system, you might use Redis or external storage
        console.warn("Rate limiting not fully implemented for actions yet");
      }
      
      // Check permission
      if (options.permission && !hasPermission(securityContext, options.permission)) {
        throw new ConvexError(`Permission denied: ${options.permission}`);
      }
      
      try {
        // Execute handler
        const result = await handler(ctx, args, securityContext);
        
        // Log audit event if possible
        if (options.audit) {
          try {
            await ctx.runMutation(api.security.auditLogging.logEvent, {
              userId: securityContext.userId,
              operation: options.audit.operation,
              resourceType: options.audit.resourceType,
              action: options.audit.action,
              status: "success",
            });
          } catch (auditError) {
            console.error("Failed to log audit event:", auditError);
          }
        }
        
        return result;
      } catch (error) {
        // Log failed attempt
        if (options.audit) {
          try {
            await ctx.runMutation(api.security.auditLogging.logEvent, {
              userId: securityContext.userId,
              operation: options.audit.operation,
              resourceType: options.audit.resourceType,
              action: options.audit.action,
              status: "failure",
              errorMessage: error instanceof Error ? error.message : String(error),
            });
          } catch (auditError) {
            console.error("Failed to log audit event:", auditError);
          }
        }
        throw error;
      }
    },
  });
}

// Export the old names for backward compatibility, but mark as deprecated
export const secureQuery = createSecureQuery;
export const secureMutation = createSecureMutation;  
export const secureAction = createSecureAction;
</file>

<file path="convex/agent_schema.ts">
// convex/agent-schema.ts
import { defineTable } from "convex/server";
import { v } from "convex/values";

// Agent system status
const agentSystemStatusOptions = [ // Renamed for clarity with other options arrays
  "stopped", "starting", "running", "paused", "error"
] as const;

// Agent status options
const agentStatusOptions = [ // Renamed
  "inactive", "active", "busy", "error", "disabled"
] as const;

// Agent types - **MAKE THIS LIST COMPREHENSIVE based on agents.types.ts**
const agentTypeOptions = [ // Renamed and ensure this matches your full list
  "manager", "secretary", "financial", "notifications", "legal",
  "analytics", "workflow", "compliance", "risk", "audit",
  "integration", "scheduler", "backup", "monitor" // Added missing types
] as const;

// Insight types - **MAKE THIS LIST COMPREHENSIVE**
const insightTypeOptions = [ // Renamed and ensure this matches your full list
  "contract_analysis", "financial_risk", "expiration_warning",
  "legal_review", "compliance_alert", "performance_metric",
  "cost_optimization", "vendor_risk", "renewal_opportunity", // Added examples
  "negotiation_insight", "audit_finding", "anomaly_detection",
  "trend_analysis", "recommendation", "alert", "report"
] as const;

// Task status - **MAKE THIS LIST COMPREHENSIVE**
const taskStatusOptions = [ // Renamed and ensure this matches your full list
  "pending", "in_progress", "completed", "failed", "cancelled", "timeout" // Added timeout
] as const;

// Task priority
const taskPriorityOptions = [ // Renamed
  "low", "medium", "high", "critical"
] as const;

// Log levels - Add this if not already present, for agentLogs.level
const logLevelOptions = [
  "debug", "info", "warn", "error", "critical"
] as const;


export const agentTables = {
  // Agent system configuration and status
  agentSystem: defineTable({
    isRunning: v.boolean(),
    status: v.union(...agentSystemStatusOptions.map(s => v.literal(s))),
    lastStarted: v.optional(v.string()), // ISO 8601
    lastStopped: v.optional(v.string()), // ISO 8601
    errorMessage: v.optional(v.string()),
    // For more type safety than v.any():
    config: v.optional(v.object({
        maxConcurrentTasks: v.number(),
        taskTimeoutMinutes: v.number(),
        logRetentionDays: v.number(),
        insightRetentionDays: v.optional(v.number()),
        healthCheckIntervalMinutes: v.optional(v.number()),
        autoRestartOnFailure: v.optional(v.boolean()),
        maxRetryAttempts: v.optional(v.number()),
        enabledFeatures: v.optional(v.array(v.string())),
        notifications: v.optional(v.object({
            emailEnabled: v.boolean(),
            slackEnabled: v.boolean(),
            webhookEnabled: v.boolean(),
        })),
    })),
    metrics: v.optional(v.object({
        totalTasksProcessed: v.number(),
        totalInsightsGenerated: v.number(),
        systemUptime: v.number(), // in seconds
        averageTaskDuration: v.optional(v.number()), // in milliseconds
        errorRate: v.optional(v.number()), // 0-1
        lastHealthCheck: v.optional(v.string()), // ISO 8601
        performanceScore: v.optional(v.number()),
    })),
  }),

  // Individual agent configurations and status
  agents: defineTable({
    name: v.string(),
    type: v.union(...agentTypeOptions.map(t => v.literal(t))),
    status: v.union(...agentStatusOptions.map(s => v.literal(s))),
    description: v.optional(v.string()),
    isEnabled: v.boolean(),
    lastRun: v.optional(v.string()), // ISO 8601
    lastSuccess: v.optional(v.string()), // ISO 8601
    runCount: v.number(),
    errorCount: v.number(),
    lastError: v.optional(v.string()),
    // config: v.optional(v.any()), // Consider defining specific structures if possible
    // Example for a more typed config, AgentConfig base + allowing others via v.any() for extensions
    config: v.optional(v.object({
        runIntervalMinutes: v.optional(v.number()),
        retryAttempts: v.optional(v.number()),
        timeoutMinutes: v.optional(v.number()),
        enabled: v.optional(v.boolean()),
        priority: v.optional(v.union(...taskPriorityOptions.map(p => v.literal(p)))),
        dependencies: v.optional(v.array(v.id("agents"))),
        // Allow other fields for specific agent configs, though v.any() is simpler if highly variable
        // ... you can add specific known extended fields here or use a more generic approach with v.any() if needed
        // For truly extensible fields, v.any() or a v.record(v.string(), v.any()) might still be used for a sub-property.
    })),
    // metrics: v.optional(v.any()), // Consider defining specific structures
    metrics: v.optional(v.object({
        totalRuns: v.number(),
        successfulRuns: v.number(),
        failedRuns: v.number(),
        averageRunTime: v.number(), // in ms
        lastRunDuration: v.optional(v.number()), // in ms
        dataProcessed: v.optional(v.number()),
        insightsGenerated: v.optional(v.number()),
        // Allow other fields for specific agent metrics
    })),
    createdAt: v.string(), // Your defined ISO 8601 string
    updatedAt: v.optional(v.string()), // Your defined ISO 8601 string
  })
  .index("by_type", ["type"])
  .index("by_status", ["status"]),

  // Agent-generated insights and analysis
  agentInsights: defineTable({
    agentId: v.id("agents"),
    type: v.union(...insightTypeOptions.map(t => v.literal(t))),
    title: v.string(),
    description: v.string(),
    priority: v.union(...taskPriorityOptions.map(p => v.literal(p))),
    contractId: v.optional(v.id("contracts")),
    vendorId: v.optional(v.id("vendors")),
    data: v.optional(v.any()), // Structured insight data - can be v.object with known shapes
    actionRequired: v.boolean(),
    actionTaken: v.boolean(),
    actionDetails: v.optional(v.string()),
    isRead: v.boolean(),
    expiresAt: v.optional(v.string()), // ISO 8601
    createdAt: v.string(), // Your defined ISO 8601 string
    readAt: v.optional(v.string()), // ISO 8601
    tags: v.optional(v.array(v.string())), // Added from agents.types.ts
    confidence: v.optional(v.number()), // Added from agents.types.ts
  })
  .index("by_agent", ["agentId"])
  .index("by_type", ["type"])
  .index("by_priority", ["priority"])
  .index("by_contract", ["contractId"])
  .index("by_vendor", ["vendorId"]) // Added for consistency if you query by vendorId
  .index("by_unread_and_createdAt", ["isRead", "createdAt"]) // Composite for sorting unread
  .index("by_createdAt", ["createdAt"]), // For querying by your string createdAt

  // Task queue for agent coordination
  agentTasks: defineTable({
    assignedAgentId: v.id("agents"),
    createdByAgentId: v.optional(v.id("agents")),
    taskType: v.string(), // Could be a union if you have a known set of task types
    status: v.union(...taskStatusOptions.map(s => v.literal(s))),
    priority: v.union(...taskPriorityOptions.map(p => v.literal(p))),
    title: v.string(),
    description: v.optional(v.string()),
    contractId: v.optional(v.id("contracts")),
    vendorId: v.optional(v.id("vendors")),
    data: v.optional(v.any()), // Task-specific data
    result: v.optional(v.any()), // Task execution result
    errorMessage: v.optional(v.string()),
    scheduledFor: v.optional(v.string()), // ISO 8601
    startedAt: v.optional(v.string()), // ISO 8601
    completedAt: v.optional(v.string()), // ISO 8601
    createdAt: v.string(), // Your defined ISO 8601 string
    dependencies: v.optional(v.array(v.id("agentTasks"))), // Added from agents.types.ts
    retryCount: v.optional(v.number()), // Added from agents.types.ts
    maxRetries: v.optional(v.number()), // Added from agents.types.ts
    
  })
  .index("by_assigned_agent", ["assignedAgentId"])
  .index("by_status", ["status"])
  .index("by_priority", ["priority"])
  .index("by_scheduled_and_status", ["scheduledFor", "status"]) // For querying scheduled tasks by status
  .index("by_status_and_scheduled", ["status", "scheduledFor"]) // For filtering by status then sorting by scheduled time
  .index("by_createdAt", ["createdAt"]), // For querying by your string createdAt

  // Agent execution logs
  agentLogs: defineTable({
    agentId: v.id("agents"), // Or v.string() if it can be non-agent system ID
    level: v.union(...logLevelOptions.map(l => v.literal(l))), // Use the new comprehensive list
    message: v.string(),
    data: v.optional(v.any()), // Can be v.object with known shapes
    taskId: v.optional(v.id("agentTasks")),
    timestamp: v.string(), // Your defined ISO 8601 string for event time
    category: v.optional(v.string()), // Added from manager.ts usage
    source: v.optional(v.string()), // Added from agents.types.ts
    userId: v.optional(v.string()), // Added from agents.types.ts
  })
  .index("by_agent", ["agentId"])
  .index("by_level", ["level"])
  .index("by_timestamp", ["timestamp"]) // Index for your event timestamp
  .index("by_agent_and_level", ["agentId", "level"])
  .index("by_category", ["category"]), // Index if you query by category
};
</file>

<file path="convex/agent_types.ts">
// convex/agent-types.ts
import { Id, Doc } from "./_generated/dataModel";
import { MutationCtx, QueryCtx } from "./_generated/server";

// ============================================================================
// AGENT CONTEXT TYPES
// ============================================================================

export type AgentMutationCtx = MutationCtx;
export type AgentQueryCtx = QueryCtx;

// ============================================================================
// AGENT TASK AND INSIGHT TYPES
// ============================================================================

export interface AgentTask extends Doc<"agentTasks"> {
  
}

export interface AgentInsight extends Doc<"agentInsights"> {
  
}

// ============================================================================
// FINANCIAL ANALYSIS TYPES
// ============================================================================

export interface FinancialSummary {
  totalValue?: number;
  valueCategory?: string;
  monthlyValue?: number;
  annualizedValue?: number;
  costPerUnit?: number;
  paybackPeriod?: number;
  roi?: number;
  currency?: string;
  inflationAdjustment?: number;
}

export interface FinancialRisk {
  type: string;
  severity: "low" | "medium" | "high" | "critical";
  description: string;
  impact?: number;
  probability?: number;
  mitigationStrategy?: string;
}

export interface FinancialOpportunity {
  type: string;
  description: string;
  potentialSavings?: number;
  recommendation?: string;
  implementationCost?: number;
  timeToRealization?: number;
}

export interface FinancialMetrics {
  paymentTerms?: string;
  currency?: string;
  inflationAdjustment?: number;
  benchmarkComparison?: string;
  costAnalysis?: Record<string, number>;
  budgetVariance?: number;
}

export interface FinancialAnalysis {
  financialSummary: FinancialSummary;
  risks: FinancialRisk[];
  opportunities: FinancialOpportunity[];
  metrics: FinancialMetrics;
}

// ============================================================================
// LEGAL ANALYSIS TYPES
// ============================================================================

export interface LegalRisk {
  type: string;
  severity: "low" | "medium" | "high" | "critical";
  description: string;
  clause?: string;
  recommendation?: string;
}

export interface LegalClause {
  type: string;
  content: string;
  status: "present" | "missing" | "problematic";
  recommendation?: string;
}

export interface ComplianceViolation {
  type: string;
  severity: "low" | "medium" | "high" | "critical";
  description: string;
  regulation?: string;
  remediation?: string;
}

export interface LegalAnalysis {
  riskFactors: LegalRisk[];
  problematicClauses: LegalClause[];
  missingClauses: string[];
  complianceViolations: ComplianceViolation[];
  overallRiskScore: number;
  recommendations: string[];
}

// ============================================================================
// ANALYTICS TYPES
// ============================================================================

export interface KPIMetrics {
  contractRenewalRate: number;
  contractCycleTime: number;
  vendorConcentrationRisk: number;
  contractComplianceRate: number;
  identifiedSavings: number;
  savingsRate: number;
  totalActiveContractValue: number;
  contractsByType: Record<string, number>;
  averageContractValue: number;
  monthlySpend: number;
  quarterlyGrowthRate: number;
}

export interface VendorMetrics {
  vendorId: Id<"vendors">;
  name: string;
  activeContracts: number;
  totalValue: number;
  averageValue: number;
  performanceScore: number;
  riskLevel: "low" | "medium" | "high" | "critical";
  lastActivity: number;
}

export interface TrendAnalysis {
  direction: "increasing" | "decreasing" | "stable";
  magnitude: number;
  confidence: number;
  timeframe: string;
  dataPoints: number;
  significance: "low" | "medium" | "high";
}

export interface AnomalyDetection {
  type: string;
  severity: "low" | "medium" | "high" | "critical";
  description: string;
  value: number;
  expectedValue: number;
  deviationScore: number;
  timestamp: string;
}

// ============================================================================
// NOTIFICATION TYPES
// ============================================================================

export interface NotificationBatch {
  userId: Id<"users">;
  notifications: Doc<"notifications">[];
  batchType: "digest" | "immediate" | "scheduled";
  scheduledFor?: string;
}

export interface NotificationTemplate {
  type: string;
  title: string;
  messageTemplate: string;
  channels: ("in_app" | "email" | "sms")[];
  priority: "low" | "medium" | "high" | "critical";
  metadata?: Record<string, unknown>;
}

// ============================================================================
// REPORTING TYPES
// ============================================================================

export interface ReportData {
  title: string;
  type: "weekly" | "monthly" | "quarterly" | "annual";
  generatedAt: string;
  timeframe: {
    start: string;
    end: string;
  };
  metrics: Record<string, unknown>;
  insights: string[];
  recommendations: string[];
  attachments?: string[];
}

export interface ExecutiveSummary {
  keyMetrics: Record<string, number>;
  majorInsights: string[];
  criticalActions: string[];
  riskAreas: string[];
  opportunities: string[];
  performanceHighlights: string[];
}

// ============================================================================
// HELPER UTILITY TYPES
// ============================================================================

export interface DateRange {
  start: Date;
  end: Date;
}

export interface PaginationOptions {
  limit?: number;
  offset?: number;
}

export interface SortOptions {
  field: string;
  direction: "asc" | "desc";
}

export interface FilterOptions {
  status?: string[];
  type?: string[];
  priority?: string[];
  dateRange?: DateRange;
  searchQuery?: string;
}

// ============================================================================
// AGENT CONFIGURATION TYPES
// ============================================================================

export interface AgentConfig {
  checkIntervalMinutes: number;
  batchSize: number;
  maxRetries: number;
  retryDelaySeconds: number;
  taskTimeoutMinutes: number;
  isEnabled: boolean;
  logLevel: "debug" | "info" | "warn" | "error";
}

export interface AgentMetrics {
  totalRuns: number;
  successfulRuns: number;
  failedRuns: number;
  averageRunTime: number;
  lastRunDuration?: number;
  dataProcessed?: number;
  insightsGenerated?: number;
  errorsEncountered?: number;
  lastError?: string;
  lastErrorTimestamp?: string;
}

// ============================================================================
// TYPE GUARDS
// ============================================================================

export function isFinancialTask(task: Doc<"agentTasks">): boolean {
  return task.taskType === "financial_analysis" || 
         task.taskType === "cost_optimization" || 
         task.taskType === "budget_analysis";
}

export function isLegalTask(task: Doc<"agentTasks">): boolean {
  return task.taskType === "legal_review" || 
         task.taskType === "compliance_check" || 
         task.taskType === "risk_assessment";
}

export function isAnalyticsTask(task: Doc<"agentTasks">): boolean {
  return task.taskType === "analytics" || 
         task.taskType === "reporting" || 
         task.taskType === "trend_analysis";
}

export function isNotificationTask(task: Doc<"agentTasks">): boolean {
  return task.taskType === "notification" || 
         task.taskType === "alert" || 
         task.taskType === "digest";
}
</file>

<file path="convex/auth.config.ts">
export default {
  providers: [
    {
      domain: process.env.CLERK_JWT_ISSUER_DOMAIN || "https://gorgeous-zebra-74.clerk.accounts.dev/",
      applicationID: process.env.CONVEX_AUTH_APPLICATION_ID || "convex",
    },
  ]
}
</file>

<file path="convex/notification_schema.ts">
// convex/notification_schema.ts
import { defineTable } from "convex/server";
import { v } from "convex/values";

// Notification types
const notificationTypeOptions = [
  "contract_expiration",
  "contract_created",
  "approval_required",
  "payment_reminder",
  "vendor_risk_alert",
  "compliance_issue",
  "task_assigned",
  "system_alert",
  "digest", // For batched notifications
] as const;

// Notification priority levels
const notificationPriorityOptions = [
  "low",
  "medium",
  "high",
  "critical",
] as const;

// Notification delivery channels
const notificationChannelOptions = [
  "in_app",
  "email",
  "sms", // Future capability
] as const;

// Notification status
const notificationStatusOptions = [
  "pending",       // Just created, not yet processed
  "scheduled",     // Scheduled for future delivery
  "sending",       // Currently being sent
  "delivered",     // Successfully delivered
  "failed",        // Delivery failed, will retry
  "failed_permanently", // Exceeded retry limit
  "batched",       // Added to batch for digest
  "batched_sent",  // Sent as part of a batch
  "archived",      // Old notifications
] as const;

export const notificationTables = {
  // Main notifications table
  notifications: defineTable({
    // Recipient information
    recipientId: v.id("users"),
    
    // Notification details
    type: v.union(...notificationTypeOptions.map(t => v.literal(t))),
    title: v.string(),
    message: v.string(),
    priority: v.union(...notificationPriorityOptions.map(p => v.literal(p))),
    
    // Delivery information
    channels: v.array(v.union(...notificationChannelOptions.map(c => v.literal(c)))),
    status: v.union(...notificationStatusOptions.map(s => v.literal(s))),
    
    // Read status
    isRead: v.boolean(),
    readAt: v.optional(v.string()), // ISO 8601
    
    // Scheduling
    scheduledFor: v.optional(v.string()), // ISO 8601 - for delayed notifications
    
    // Delivery tracking
    deliveredAt: v.optional(v.string()), // ISO 8601
    lastAttemptAt: v.optional(v.string()), // ISO 8601
    retryCount: v.number(),
    lastError: v.optional(v.string()),
    
    // Batching
    batchId: v.optional(v.id("notifications")), // Reference to digest notification
    
    // Related entities
    contractId: v.optional(v.id("contracts")),
    vendorId: v.optional(v.id("vendors")),
    taskId: v.optional(v.id("agentTasks")),
    
    // Additional data
    metadata: v.optional(v.any()), // Flexible field for notification-specific data
    actionUrl: v.optional(v.string()), // Deep link or URL for action
    
    // Timestamps
    createdAt: v.string(), // ISO 8601
    archivedAt: v.optional(v.string()), // ISO 8601
  })
  .index("by_recipient", ["recipientId"])
  .index("by_recipient_and_status", ["recipientId", "status"])
  .index("by_recipient_and_read", ["recipientId", "isRead"])
  .index("by_status", ["status"])
  .index("by_scheduled", ["status", "scheduledFor"])
  .index("by_type", ["type"])
  .index("by_contract", ["contractId"])
  .index("by_vendor", ["vendorId"])
  // Performance-critical indexes for real-time features
  .index("by_recipient_created_desc", ["recipientId", "createdAt"])
  .index("by_recipient_unread_priority", ["recipientId", "isRead", "priority"])
  .index("by_recipient_type_created", ["recipientId", "type", "createdAt"]),

  // Notification templates for consistent messaging
  notificationTemplates: defineTable({
    key: v.string(), // Unique identifier (e.g., "contract_expiration")
    name: v.string(),
    description: v.optional(v.string()),
    
    // Template content
    titleTemplate: v.string(), // Can include variables like {{contractTitle}}
    messageTemplate: v.string(), // Can include variables
    
    // Default settings
    defaultPriority: v.union(...notificationPriorityOptions.map(p => v.literal(p))),
    defaultChannels: v.array(v.union(...notificationChannelOptions.map(c => v.literal(c)))),
    
    // Template metadata
    variables: v.optional(v.array(v.string())), // List of available variables
    isActive: v.boolean(),
    
    // Timestamps
    createdAt: v.string(), // ISO 8601
    updatedAt: v.optional(v.string()), // ISO 8601
  })
  .index("by_key", ["key"])
  .index("by_active", ["isActive"]),

  // User notification preferences
  userNotificationPreferences: defineTable({
    userId: v.id("users"),
    
    // Channel preferences
    inAppEnabled: v.boolean(),
    emailEnabled: v.boolean(),
    smsEnabled: v.optional(v.boolean()), // For future use
    
    // Type-specific preferences
    contractNotifications: v.boolean(),
    approvalNotifications: v.boolean(),
    paymentNotifications: v.boolean(),
    vendorNotifications: v.boolean(),
    complianceNotifications: v.boolean(),
    systemNotifications: v.boolean(),
    
    // Delivery preferences
    batchNotifications: v.boolean(), // Whether to batch non-urgent notifications
    quietHoursEnabled: v.boolean(),
    quietHoursStart: v.optional(v.number()), // Hour (0-23)
    quietHoursEnd: v.optional(v.number()), // Hour (0-23)
    timezone: v.optional(v.string()), // User's timezone
    
    // Email preferences
    emailFrequency: v.optional(v.union(
      v.literal("immediate"),
      v.literal("hourly"),
      v.literal("daily"),
      v.literal("weekly"),
    )),
    emailDigestTime: v.optional(v.number()), // Hour for daily digest (0-23)
    
    // Timestamps
    createdAt: v.string(), // ISO 8601
    updatedAt: v.optional(v.string()), // ISO 8601
  })
  .index("by_user", ["userId"]),

  // Notification activity log
  notificationEvents: defineTable({
    notificationId: v.id("notifications"),
    eventType: v.union(
      v.literal("created"),
      v.literal("scheduled"),
      v.literal("sent"),
      v.literal("delivered"),
      v.literal("failed"),
      v.literal("read"),
      v.literal("clicked"),
      v.literal("dismissed"),
      v.literal("batched"),
    ),
    channel: v.optional(v.union(...notificationChannelOptions.map(c => v.literal(c)))),
    timestamp: v.string(), // ISO 8601
    metadata: v.optional(v.any()), // Additional event data
  })
  .index("by_notification", ["notificationId"])
  .index("by_event_type", ["eventType"])
  .index("by_timestamp", ["timestamp"]),
};
</file>

<file path="convex/realtime.ts">
import { query } from "./_generated/server";
import { v } from "convex/values";
import { Id } from "./_generated/dataModel";
import { getSecurityContext } from "./security/rowLevelSecurity";

/**
 * Real-time Subscriptions for Contract Management Platform
 * 
 * These queries automatically update the frontend when data changes
 * All subscriptions are enterprise-scoped for security
 */

/**
 * Subscribe to contract changes for the user's enterprise
 * Updates when contracts are created, updated, or deleted
 */
export const subscribeToContracts = query({
  args: {
    filters: v.optional(v.object({
      status: v.optional(v.string()),
      vendorId: v.optional(v.id("vendors")),
      contractType: v.optional(v.string()),
    })),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Base query with enterprise filtering
    let contractsQuery = ctx.db
      .query("contracts")
      .withIndex("by_status_and_enterpriseId", (q) => 
        q.eq("enterpriseId", security.enterpriseId)
      );

    // Apply status filter if provided
    if (args.filters?.status) {
      contractsQuery = ctx.db
        .query("contracts")
        .withIndex("by_status_and_enterpriseId", (q) => 
          q.eq("enterpriseId", security.enterpriseId)
           .eq("status", args.filters!.status as any)
        );
    }

    let contracts = await contractsQuery
      .order("desc")
      .take(args.limit || 50);

    // Apply additional filters
    if (args.filters?.vendorId) {
      contracts = contracts.filter(c => c.vendorId === args.filters!.vendorId);
    }
    if (args.filters?.contractType) {
      contracts = contracts.filter(c => c.contractType === args.filters!.contractType);
    }

    // Enrich with vendor data
    const enrichedContracts = await Promise.all(
      contracts.map(async (contract) => {
        const vendor = await ctx.db.get(contract.vendorId);
        return {
          ...contract,
          vendor: vendor ? {
            _id: vendor._id,
            name: vendor.name,
            category: vendor.category,
          } : null,
        };
      })
    );

    return enrichedContracts;
  },
});

/**
 * Subscribe to a specific contract's details
 * Updates when the contract or its related data changes
 */
export const subscribeToContract = query({
  args: {
    contractId: v.id("contracts"),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    const contract = await ctx.db.get(args.contractId);
    if (!contract) {
      return null;
    }

    // Verify enterprise access
    if (contract.enterpriseId !== security.enterpriseId) {
      throw new Error("Access denied: Contract belongs to different enterprise");
    }

    // Enrich with vendor data
    const vendor = await ctx.db.get(contract.vendorId);
    
    return {
      ...contract,
      vendor: vendor ? {
        _id: vendor._id,
        name: vendor.name,
        category: vendor.category,
        contactEmail: vendor.contactEmail,
        contactPhone: vendor.contactPhone,
        website: vendor.website,
      } : null,
    };
  },
});

/**
 * Subscribe to unread notifications for the current user
 * Updates in real-time as notifications are created or marked as read
 */
export const subscribeToNotifications = query({
  args: {
    limit: v.optional(v.number()),
    unreadOnly: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    let notificationsQuery = ctx.db
      .query("notifications")
      .withIndex("by_recipient", (q) => q.eq("recipientId", security.userId));

    let notifications = await notificationsQuery
      .order("desc")
      .take(args.limit || 20);

    // Filter to unread only if specified
    if (args.unreadOnly) {
      notifications = notifications.filter(n => !n.readAt);
    }

    // Enrich with related data
    const enrichedNotifications = await Promise.all(
      notifications.map(async (notification) => {
        let enrichedData: any = { ...notification };

        // Add contract data if notification is contract-related
        if (notification.contractId) {
          const contract = await ctx.db.get(notification.contractId);
          if (contract) {
            enrichedData.contract = {
              _id: contract._id,
              title: contract.title,
              status: contract.status,
            };
          }
        }

        // Add vendor data if notification is vendor-related
        if (notification.vendorId) {
          const vendor = await ctx.db.get(notification.vendorId);
          if (vendor) {
            enrichedData.vendor = {
              _id: vendor._id,
              name: vendor.name,
            };
          }
        }

        return enrichedData;
      })
    );

    return enrichedNotifications;
  },
});

/**
 * Subscribe to notification count for badges/indicators
 * Updates immediately when new notifications arrive
 */
export const subscribeToNotificationCount = query({
  args: {},
  handler: async (ctx) => {
    const security = await getSecurityContext(ctx);
    
    const allNotifications = await ctx.db
      .query("notifications")
      .withIndex("by_recipient", (q) => q.eq("recipientId", security.userId))
      .collect();

    const unreadCount = allNotifications.filter(n => !n.readAt).length;
    const totalCount = allNotifications.length;

    return {
      unread: unreadCount,
      total: totalCount,
    };
  },
});

/**
 * Subscribe to vendors for the user's enterprise
 * Updates when vendors are created, updated, or deleted
 */
export const subscribeToVendors = query({
  args: {
    category: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    let vendorsQuery = ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId));

    // Apply category filter if provided
    if (args.category) {
      vendorsQuery = ctx.db
        .query("vendors")
        .withIndex("by_category_and_enterpriseId", (q) => 
          q.eq("enterpriseId", security.enterpriseId)
           .eq("category", args.category as any)
        );
    }

    const vendors = await vendorsQuery
      .order("desc")
      .take(args.limit || 100);

    // Enrich with contract counts
    const enrichedVendors = await Promise.all(
      vendors.map(async (vendor) => {
        const contractCount = await ctx.db
          .query("contracts")
          .withIndex("by_vendorId_and_enterpriseId", (q) => 
            q.eq("enterpriseId", security.enterpriseId)
             .eq("vendorId", vendor._id)
          )
          .collect()
          .then(contracts => contracts.length);

        const activeContractCount = await ctx.db
          .query("contracts")
          .withIndex("by_vendorId_and_enterpriseId", (q) => 
            q.eq("enterpriseId", security.enterpriseId)
             .eq("vendorId", vendor._id)
          )
          .collect()
          .then(contracts => contracts.filter(c => c.status === "active").length);

        return {
          ...vendor,
          contractCount,
          activeContractCount,
        };
      })
    );

    return enrichedVendors;
  },
});

/**
 * Subscribe to dashboard analytics that update in real-time
 * Updates when contracts or vendors change
 */
export const subscribeToDashboardStats = query({
  args: {},
  handler: async (ctx) => {
    const security = await getSecurityContext(ctx);
    
    // Get all contracts for the enterprise
    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_status_and_enterpriseId", (q) => 
        q.eq("enterpriseId", security.enterpriseId)
      )
      .collect();

    // Get all vendors for the enterprise
    const vendors = await ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .collect();

    // Calculate stats
    const totalContracts = contracts.length;
    const activeContracts = contracts.filter(c => c.status === "active").length;
    const pendingContracts = contracts.filter(c => c.status === "pending_analysis").length;
    const expiredContracts = contracts.filter(c => c.status === "expired").length;
    
    const totalVendors = vendors.length;
    const vendorsByCategory = vendors.reduce((acc, vendor) => {
      if (vendor.category) {
        acc[vendor.category] = (acc[vendor.category] || 0) + 1;
      }
      return acc;
    }, {} as Record<string, number>);

    // Recent activity (last 30 days)
    const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000).getTime();
    const recentContracts = contracts.filter(c => c._creationTime >= thirtyDaysAgo);

    return {
      contracts: {
        total: totalContracts,
        active: activeContracts,
        pending: pendingContracts,
        expired: expiredContracts,
        recentCount: recentContracts.length,
      },
      vendors: {
        total: totalVendors,
        byCategory: vendorsByCategory,
      },
      activity: {
        recentContractsCount: recentContracts.length,
        lastUpdated: new Date().toISOString(),
      }
    };
  },
});

/**
 * Subscribe to recent user activity across the enterprise
 * Updates when users perform actions (for activity feeds)
 */
export const subscribeToRecentActivity = query({
  args: {
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    // Only admins and owners can view enterprise activity
    if (!["owner", "admin"].includes(security.role)) {
      return [];
    }

    // Get recent audit logs
    const recentLogs = await ctx.db
      .query("auditLogs")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", security.enterpriseId))
      .order("desc")
      .take(args.limit || 20);

    // Enrich with user and resource data
    const enrichedActivity = await Promise.all(
      recentLogs.map(async (log) => {
        const user = await ctx.db.get(log.userId);
        
        let enrichedData: any = {
          ...log,
          user: user ? {
            _id: user._id,
            name: `${user.firstName || ''} ${user.lastName || ''}`.trim() || user.email,
            email: user.email,
          } : null,
        };

        // Add resource-specific data
        if (log.resourceType === "contracts" && log.resourceId) {
          const contract = await ctx.db.get(log.resourceId as Id<"contracts">);
          if (contract) {
            enrichedData.resource = {
              _id: contract._id,
              title: contract.title,
              status: contract.status,
            };
          }
        } else if (log.resourceType === "vendors" && log.resourceId) {
          const vendor = await ctx.db.get(log.resourceId as Id<"vendors">);
          if (vendor) {
            enrichedData.resource = {
              _id: vendor._id,
              name: vendor.name,
            };
          }
        }

        return enrichedData;
      })
    );

    return enrichedActivity;
  },
});

/**
 * Subscribe to contract analysis status updates
 * Updates in real-time as AI analysis progresses
 */
export const subscribeToContractAnalysis = query({
  args: {
    contractId: v.optional(v.id("contracts")),
  },
  handler: async (ctx, args) => {
    const security = await getSecurityContext(ctx);
    
    let query = ctx.db
      .query("contracts")
      .withIndex("by_analysisStatus_and_enterpriseId", (q) => 
        q.eq("enterpriseId", security.enterpriseId)
      );

    let contracts = await query.collect();

    // Filter to specific contract if provided
    if (args.contractId) {
      contracts = contracts.filter(c => c._id === args.contractId);
    }

    // Only return contracts with pending or processing analysis
    const analysisContracts = contracts.filter(c => 
      c.analysisStatus === "pending" || 
      c.analysisStatus === "processing"
    );

    return analysisContracts.map(contract => ({
      _id: contract._id,
      title: contract.title,
      analysisStatus: contract.analysisStatus,
      analysisError: contract.analysisError,
      _creationTime: contract._creationTime,
    }));
  },
});
</file>

<file path="convex/search.ts">
// convex/search.ts
import { query } from "./_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";

// ============================================================================
// SEARCH CONFIGURATION
// ============================================================================

const SEARCH_CONFIG = {
  minQueryLength: 2,
  maxResults: 50,
  defaultLimit: 20,
  searchFields: {
    contracts: ['title', 'fileName', 'notes', 'extractedParties', 'extractedScope'],
    vendors: ['name', 'contactEmail', 'website', 'notes', 'address'],
    users: ['firstName', 'lastName', 'email', 'department', 'title'],
  },
 
  fieldWeights: {
    // Contract fields
    'contracts.title': 3.0,
    'contracts.fileName': 2.0,
    'contracts.extractedParties': 2.5,
    'contracts.extractedScope': 1.5,
    'contracts.notes': 1.0,
    // Vendor fields
    'vendors.name': 3.0,
    'vendors.contactEmail': 2.0,
    'vendors.website': 1.5,
    'vendors.notes': 1.0,
    'vendors.address': 1.0,
    // User fields
    'users.firstName': 2.5,
    'users.lastName': 2.5,
    'users.email': 2.0,
    'users.department': 1.5,
    'users.title': 1.5,
  },
};

// ============================================================================
// UNIFIED SEARCH
// ============================================================================

/**
 * Search across all entities (contracts, vendors, users)
 */
export const searchAll = query({
  args: {
    query: v.string(),
    limit: v.optional(v.number()),
    includeArchived: v.optional(v.boolean()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    // Get current user and their enterprise
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    // Validate search query
    const searchQuery = args.query.trim().toLowerCase();
    if (searchQuery.length < SEARCH_CONFIG.minQueryLength) {
      return {
        contracts: [],
        vendors: [],
        users: [],
        totalResults: 0,
        query: searchQuery,
      };
    }

    const limit = Math.min(args.limit || SEARCH_CONFIG.defaultLimit, SEARCH_CONFIG.maxResults);

    // Search in parallel
    const [contractResults, vendorResults, userResults] = await Promise.all([
      searchContracts(ctx, currentUser.enterpriseId, searchQuery, limit, args.includeArchived),
      searchVendors(ctx, currentUser.enterpriseId, searchQuery, limit),
      searchUsers(ctx, currentUser.enterpriseId, searchQuery, limit, currentUser),
    ]);

    // Combine and sort by relevance
    const allResults = [
      ...contractResults.map(r => ({ ...r, type: 'contract' as const })),
      ...vendorResults.map(r => ({ ...r, type: 'vendor' as const })),
      ...userResults.map(r => ({ ...r, type: 'user' as const })),
    ].sort((a, b) => b.relevance - a.relevance);

    return {
      results: allResults.slice(0, limit),
      byType: {
        contracts: contractResults.slice(0, Math.floor(limit / 3)),
        vendors: vendorResults.slice(0, Math.floor(limit / 3)),
        users: userResults.slice(0, Math.floor(limit / 3)),
      },
      totalResults: allResults.length,
      query: searchQuery,
    };
  },
});

// ============================================================================
// CONTRACT SEARCH
// ============================================================================

/**
 * Search contracts with advanced filters
 */
export const searchContractsWithAdvancedFilters = query({
  args: {
    query: v.string(),
    filters: v.optional(v.object({
      status: v.optional(v.array(v.string())),
      contractType: v.optional(v.array(v.string())),
      vendorId: v.optional(v.id("vendors")),
      dateRange: v.optional(v.object({
        startDate: v.string(),
        endDate: v.string(),
        dateField: v.union(v.literal("created"), v.literal("start"), v.literal("end")),
      })),
      valueRange: v.optional(v.object({
        min: v.number(),
        max: v.number(),
      })),
    })),
    sort: v.optional(v.object({
      field: v.union(
        v.literal("relevance"),
        v.literal("title"),
        v.literal("createdAt"),
        v.literal("value"),
        v.literal("endDate")
      ),
      order: v.union(v.literal("asc"), v.literal("desc")),
    })),
    limit: v.optional(v.number()),
    offset: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    const searchQuery = args.query.trim().toLowerCase();
    const limit = Math.min(args.limit || SEARCH_CONFIG.defaultLimit, SEARCH_CONFIG.maxResults);
    const offset = args.offset || 0;

    // Get contracts with filters
    let contracts = await ctx.db
      .query("contracts")
      .withIndex("by_status_and_enterpriseId", (q) => 
        q.eq("enterpriseId", currentUser.enterpriseId)
      )
      .collect();

    // Apply filters
    if (args.filters) {
      contracts = await applyContractFilters(ctx, contracts, args.filters);
    }

    // Search and score
    let results = [];
    if (searchQuery.length >= SEARCH_CONFIG.minQueryLength) {
      results = await scoreContractResults(ctx, contracts, searchQuery);
    } else {
      // No search query, just return filtered results
      results = contracts.map(contract => ({
        ...contract,
        relevance: 1,
        matchedFields: [],
      }));
    }

    // Sort results
    results = sortResults(results, args.sort || { field: 'relevance', order: 'desc' });

    // Paginate
    const paginatedResults = results.slice(offset, offset + limit);

    // Enrich with vendor information
    const enrichedResults = await Promise.all(
      paginatedResults.map(async (result) => {
        const vendor = await ctx.db.get(result.vendorId);
        return {
          ...result,
          vendor: vendor ? {
            _id: vendor._id,
            name: (vendor as any).name,
            category: (vendor as any).category,
          } : null,
        };
      })
    );

    return {
      results: enrichedResults,
      total: results.length,
      hasMore: offset + limit < results.length,
      facets: await getContractFacets(ctx, contracts),
    };
  },
});

// ============================================================================
// VENDOR SEARCH
// ============================================================================

/**
 * Search vendors with filters
 */
export const searchVendorsWithFilters = query({
  args: {
    query: v.string(),
    filters: v.optional(v.object({
      category: v.optional(v.array(v.string())),
      hasActiveContracts: v.optional(v.boolean()),
    })),
    sort: v.optional(v.object({
      field: v.union(
        v.literal("relevance"),
        v.literal("name"),
        v.literal("contractCount"),
        v.literal("totalValue")
      ),
      order: v.union(v.literal("asc"), v.literal("desc")),
    })),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    const searchQuery = args.query.trim().toLowerCase();
    const limit = Math.min(args.limit || SEARCH_CONFIG.defaultLimit, SEARCH_CONFIG.maxResults);

    // Get vendors
    let vendors = await ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", currentUser.enterpriseId))
      .collect();

    // Apply category filter
    if (args.filters?.category && args.filters.category.length > 0) {
      vendors = vendors.filter(v => 
        v.category && args.filters!.category!.includes(v.category)
      );
    }

    // Search and score
    let results = [];
    if (searchQuery.length >= SEARCH_CONFIG.minQueryLength) {
      results = await scoreVendorResults(ctx, vendors, searchQuery);
    } else {
      results = vendors.map(vendor => ({
        ...vendor,
        relevance: 1,
        matchedFields: [],
      }));
    }

    // Enrich with contract data
    const enrichedResults = await Promise.all(
      results.map(async (vendor) => {
        const contracts = await ctx.db
          .query("contracts")
          .withIndex("by_vendorId_and_enterpriseId", (q) =>
            q.eq("enterpriseId", currentUser.enterpriseId).eq("vendorId", vendor._id)
          )
          .collect();

        const activeContracts = contracts.filter(c => c.status === "active");
        const totalValue = contracts.reduce((sum, c) => {
          const value = parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
          return sum + value;
        }, 0);

        return {
          ...vendor,
          contractCount: contracts.length,
          activeContractCount: activeContracts.length,
          totalValue,
        };
      })
    );

    // Apply hasActiveContracts filter
    let filteredResults = enrichedResults;
    if (args.filters?.hasActiveContracts === true) {
      filteredResults = enrichedResults.filter(v => v.activeContractCount > 0);
    } else if (args.filters?.hasActiveContracts === false) {
      filteredResults = enrichedResults.filter(v => v.activeContractCount === 0);
    }

    // Sort
    const sortedResults = sortResults(filteredResults, args.sort || { field: 'relevance', order: 'desc' });

    return {
      results: sortedResults.slice(0, limit),
      total: sortedResults.length,
      facets: {
        categories: getVendorCategoryFacets(vendors),
      },
    };
  },
});

// ============================================================================
// USER SEARCH
// ============================================================================

/**
 * Search users within the enterprise
 */
export const searchUsersWithinEnterprise = query({
  args: {
    query: v.string(),
    filters: v.optional(v.object({
      role: v.optional(v.array(v.string())),
      department: v.optional(v.array(v.string())),
      isActive: v.optional(v.boolean()),
    })),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    const searchQuery = args.query.trim().toLowerCase();
    const limit = Math.min(args.limit || SEARCH_CONFIG.defaultLimit, SEARCH_CONFIG.maxResults);

    // Get users in the same enterprise
    let users = await ctx.db
      .query("users")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", currentUser.enterpriseId))
      .collect();

    // Apply filters
    if (args.filters) {
      if (args.filters.role && args.filters.role.length > 0) {
        users = users.filter(u => args.filters!.role!.includes(u.role));
      }
      if (args.filters.department && args.filters.department.length > 0) {
        users = users.filter(u => u.department && args.filters!.department!.includes(u.department));
      }
      if (args.filters.isActive !== undefined) {
        users = users.filter(u => u.isActive === args.filters!.isActive);
      }
    }

    // Search and score
    let results = [];
    if (searchQuery.length >= SEARCH_CONFIG.minQueryLength) {
      results = scoreUserResults(users, searchQuery);
    } else {
      results = users.map(user => ({
        ...user,
        relevance: 1,
        matchedFields: [],
      }));
    }

    // Sort by relevance
    results.sort((a, b) => b.relevance - a.relevance);

    return {
      results: results.slice(0, limit),
      total: results.length,
      facets: {
        roles: getUserRoleFacets(users),
        departments: getUserDepartmentFacets(users),
      },
    };
  },
});

// ============================================================================
// AUTOCOMPLETE
// ============================================================================

/**
 * Quick autocomplete for search suggestions
 */
export const autocomplete = query({
  args: {
    query: v.string(),
    type: v.optional(v.union(
      v.literal("all"),
      v.literal("contracts"),
      v.literal("vendors"),
      v.literal("users")
    )),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    const searchQuery = args.query.trim().toLowerCase();
    if (searchQuery.length < 1) {
      return { suggestions: [] };
    }

    const limit = Math.min(args.limit || 10, 20);
    const type = args.type || "all";
    const suggestions: Array<{
      value: string;
      label: string;
      type: 'contract' | 'vendor' | 'user';
      id: string;
    }> = [];

    // Get suggestions based on type
    if (type === "all" || type === "contracts") {
      const contracts = await ctx.db
        .query("contracts")
        .withIndex("by_status_and_enterpriseId", (q) => 
          q.eq("enterpriseId", currentUser.enterpriseId)
        )
        .collect();

      contracts
        .filter(c => c.title.toLowerCase().includes(searchQuery))
        .slice(0, limit)
        .forEach(c => {
          suggestions.push({
            value: c.title,
            label: c.title,
            type: 'contract',
            id: c._id,
          });
        });
    }

    if (type === "all" || type === "vendors") {
      const vendors = await ctx.db
        .query("vendors")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", currentUser.enterpriseId))
        .collect();

      vendors
        .filter(v => v.name.toLowerCase().includes(searchQuery))
        .slice(0, limit)
        .forEach(v => {
          suggestions.push({
            value: v.name,
            label: v.name,
            type: 'vendor',
            id: v._id,
          });
        });
    }

    if (type === "all" || type === "users") {
      const users = await ctx.db
        .query("users")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", currentUser.enterpriseId))
        .collect();

      users
        .filter(u => {
          const fullName = `${u.firstName || ''} ${u.lastName || ''}`.toLowerCase();
          return fullName.includes(searchQuery) || u.email.toLowerCase().includes(searchQuery);
        })
        .slice(0, limit)
        .forEach(u => {
          const name = `${u.firstName || ''} ${u.lastName || ''}`.trim() || u.email;
          suggestions.push({
            value: name,
            label: name,
            type: 'user',
            id: u._id,
          });
        });
    }

    return { suggestions: suggestions.slice(0, limit) };
  },
});

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

async function searchContracts(
  ctx: any,
  enterpriseId: string,
  query: string,
  limit: number,
  includeArchived?: boolean
): Promise<any[]> {
  let contracts = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId", (q: any) => 
      q.eq("enterpriseId", enterpriseId)
    )
    .collect();

  if (!includeArchived) {
    contracts = contracts.filter((c: any) => c.status !== "archived");
  }

  return (await scoreContractResults(ctx, contracts, query)).slice(0, limit);
}

async function searchVendors(
  ctx: any,
  enterpriseId: string,
  query: string,
  limit: number
): Promise<any[]> {
  const vendors = await ctx.db
    .query("vendors")
    .withIndex("by_enterprise", (q: any) => q.eq("enterpriseId", enterpriseId))
    .collect();

  return (await scoreVendorResults(ctx, vendors, query)).slice(0, limit);
}

async function searchUsers(
  ctx: any,
  enterpriseId: string,
  query: string,
  limit: number,
  currentUser: any
): Promise<any[]> {
  let users = await ctx.db
    .query("users")
    .withIndex("by_enterprise", (q: any) => q.eq("enterpriseId", enterpriseId))
    .collect();

  // Only show active users by default
  users = users.filter((u: any) => u.isActive !== false);

  return scoreUserResults(users, query).slice(0, limit);
}

async function scoreContractResults(ctx: any, contracts: any[], query: string): Promise<any[]> {
  return contracts
    .map(contract => {
      let relevance = 0;
      const matchedFields: string[] = [];

      // Check each searchable field
      SEARCH_CONFIG.searchFields.contracts.forEach(field => {
        const value = contract[field];
        if (value) {
          const fieldValue = Array.isArray(value) ? value.join(' ') : String(value);
          if (fieldValue.toLowerCase().includes(query)) {
            const key = `contracts.${field}` as keyof typeof SEARCH_CONFIG.fieldWeights;
            const weight = SEARCH_CONFIG.fieldWeights[key] ?? 1;
            relevance += weight;
            matchedFields.push(field);
          }}
      });

      return { ...contract, relevance, matchedFields };
    })
    .filter(r => r.relevance > 0)
    .sort((a, b) => b.relevance - a.relevance);
}

async function scoreVendorResults(ctx: any, vendors: any[], query: string): Promise<any[]> {
  return vendors
    .map(vendor => {
      let relevance = 0;
      const matchedFields: string[] = [];

      SEARCH_CONFIG.searchFields.vendors.forEach(field => {
        const value = vendor[field];
        if (value) {
          const fieldValue = String(value);
          if (fieldValue.toLowerCase().includes(query)) {
            const key = `contracts.${field}` as keyof typeof SEARCH_CONFIG.fieldWeights;
            const weight = SEARCH_CONFIG.fieldWeights[key] ?? 1;
            relevance += weight;
            matchedFields.push(field);
          }
        }
      });

      return { ...vendor, relevance, matchedFields };
    })
    .filter(r => r.relevance > 0)
    .sort((a, b) => b.relevance - a.relevance);
}

function scoreUserResults(users: any[], query: string): any[] {
  return users
    .map(user => {
      let relevance = 0;
      const matchedFields: string[] = [];

      SEARCH_CONFIG.searchFields.users.forEach(field => {
        const value = user[field];
        if (value) {
          const fieldValue = String(value);
          if (fieldValue.toLowerCase().includes(query)) {
            const key = `contracts.${field}` as keyof typeof SEARCH_CONFIG.fieldWeights;
            const weight = SEARCH_CONFIG.fieldWeights[key] ?? 1;
            relevance += weight;
            matchedFields.push(field);
          }
        }
      });

      return { ...user, relevance, matchedFields };
    })
    .filter(r => r.relevance > 0)
    .sort((a, b) => b.relevance - a.relevance);
}

async function applyContractFilters(ctx: any, contracts: any[], filters: any): Promise<any[]> {
  let filtered = contracts;

  // Status filter
  if (filters.status && filters.status.length > 0) {
    filtered = filtered.filter(c => filters.status.includes(c.status));
  }

  // Contract type filter
  if (filters.contractType && filters.contractType.length > 0) {
    filtered = filtered.filter(c => filters.contractType.includes(c.contractType));
  }

  // Vendor filter
  if (filters.vendorId) {
    filtered = filtered.filter(c => c.vendorId === filters.vendorId);
  }

  // Date range filter
  if (filters.dateRange) {
    const { startDate, endDate, dateField } = filters.dateRange;
    filtered = filtered.filter(c => {
      let dateValue: string | undefined;
      
      if (dateField === 'created') {
        dateValue = c._creationTime ? new Date(c._creationTime).toISOString() : undefined;
      } else if (dateField === 'start') {
        dateValue = c.extractedStartDate;
      } else if (dateField === 'end') {
        dateValue = c.extractedEndDate;
      }

      if (!dateValue) return false;
      
      return dateValue >= startDate && dateValue <= endDate;
    });
  }

  // Value range filter
  if (filters.valueRange) {
    filtered = filtered.filter(c => {
      const value = parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
      return value >= filters.valueRange.min && value <= filters.valueRange.max;
    });
  }

  return filtered;
}

function sortResults(results: any[], sort: any): any[] {
  const sorted = [...results];
  
  sorted.sort((a, b) => {
    let aValue: any;
    let bValue: any;

    switch (sort.field) {
      case 'relevance':
        aValue = a.relevance || 0;
        bValue = b.relevance || 0;
        break;
      case 'title':
      case 'name':
        aValue = a.title || a.name || '';
        bValue = b.title || b.name || '';
        break;
      case 'createdAt':
        aValue = a._creationTime || 0;
        bValue = b._creationTime || 0;
        break;
      case 'value':
      case 'totalValue':
        aValue = a.totalValue || parseFloat(a.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
        bValue = b.totalValue || parseFloat(b.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
        break;
      case 'endDate':
        aValue = a.extractedEndDate || '';
        bValue = b.extractedEndDate || '';
        break;
      case 'contractCount':
        aValue = a.contractCount || 0;
        bValue = b.contractCount || 0;
        break;
      default:
        aValue = a[sort.field];
        bValue = b[sort.field];
    }

    if (sort.order === 'asc') {
      return aValue < bValue ? -1 : aValue > bValue ? 1 : 0;
    } else {
      return aValue > bValue ? -1 : aValue < bValue ? 1 : 0;
    }
  });

  return sorted;
}

async function getContractFacets(ctx: any, contracts: any[]): Promise<any> {
  const facets = {
    status: {} as Record<string, number>,
    contractType: {} as Record<string, number>,
    valueRanges: {
      '0-10k': 0,
      '10k-50k': 0,
      '50k-100k': 0,
      '100k-500k': 0,
      '500k+': 0,
    },
  };

  contracts.forEach(contract => {
    // Status facet
    facets.status[contract.status] = (facets.status[contract.status] || 0) + 1;

    // Contract type facet
    const type = contract.contractType || 'other';
    facets.contractType[type] = (facets.contractType[type] || 0) + 1;

    // Value range facet
    const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
    if (value < 10000) {
      facets.valueRanges['0-10k']++;
    } else if (value < 50000) {
      facets.valueRanges['10k-50k']++;
    } else if (value < 100000) {
      facets.valueRanges['50k-100k']++;
    } else if (value < 500000) {
      facets.valueRanges['100k-500k']++;
    } else {
      facets.valueRanges['500k+']++;
    }
  });

  return facets;
}

function getVendorCategoryFacets(vendors: any[]): Record<string, number> {
  const facets: Record<string, number> = {};
  
  vendors.forEach(vendor => {
    const category = vendor.category || 'other';
    facets[category] = (facets[category] || 0) + 1;
  });

  return facets;
}

function getUserRoleFacets(users: any[]): Record<string, number> {
  const facets: Record<string, number> = {};
  
  users.forEach(user => {
    facets[user.role] = (facets[user.role] || 0) + 1;
  });

  return facets;
}

function getUserDepartmentFacets(users: any[]): Record<string, number> {
  const facets: Record<string, number> = {};
  
  users.forEach(user => {
    if (user.department) {
      facets[user.department] = (facets[user.department] || 0) + 1;
    }
  });

  return facets;
}
</file>

<file path="convex/tsconfig.json">
{
  /* This TypeScript project config describes the environment that
   * Convex functions run in and is used to typecheck them.
   * You can modify it, but some settings required to use Convex.
   */
  "compilerOptions": {
    /* These settings are not required by Convex and can be modified. */
    "allowJs": true,
    "strict": true,
    "noImplicitAny": false,
    "moduleResolution": "Bundler",
    "jsx": "react-jsx",
    "skipLibCheck": true,
    "allowSyntheticDefaultImports": true,
    

    /* These compiler options are required by Convex */
    "target": "ESNext",
    "lib": ["ES2021", "dom"],
    "forceConsistentCasingInFileNames": true,
    "module": "ESNext",
    "isolatedModules": true,
    "noEmit": true
  },
  "include": ["./**/*"],
  "exclude": ["./_generated"]
}
</file>

<file path="src/app/_components/analytics/AdvancedKPICard.tsx">
'use client'

import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Progress } from "@/components/ui/progress";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import {
  TrendingUp,
  TrendingDown,
  Minus,
  MoreVertical,
  Target,
  AlertTriangle,
  CheckCircle,
  Info,
  Maximize2,
  RefreshCw,
} from "lucide-react";
import { cn } from "@/lib/utils";

export interface KPIData {
  id: string;
  title: string;
  value: number;
  previousValue?: number;
  target?: number;
  unit?: string;
  format?: "number" | "currency" | "percentage";
  trend?: {
    direction: "up" | "down" | "stable";
    percentage: number;
    period: string;
  };
  status?: "good" | "warning" | "critical" | "neutral";
  description?: string;
  lastUpdated?: string;
  drillDownData?: any[];
}

interface AdvancedKPICardProps {
  data: KPIData;
  onDrillDown?: (data: KPIData) => void;
  onRefresh?: (id: string) => void;
  loading?: boolean;
  className?: string;
  compact?: boolean;
}

export const AdvancedKPICard: React.FC<AdvancedKPICardProps> = ({
  data,
  onDrillDown,
  onRefresh,
  loading = false,
  className,
  compact = false,
}) => {
  const [isHovered, setIsHovered] = useState(false);

  const formatValue = (value: number, format?: string, unit?: string) => {
    let formatted = "";
    
    switch (format) {
      case "currency":
        formatted = new Intl.NumberFormat("en-US", {
          style: "currency",
          currency: "USD",
          minimumFractionDigits: 0,
          maximumFractionDigits: 0,
        }).format(value);
        break;
      case "percentage":
        formatted = `${value.toFixed(1)}%`;
        break;
      default:
        formatted = value.toLocaleString();
    }
    
    if (unit && format !== "currency" && format !== "percentage") {
      formatted += ` ${unit}`;
    }
    
    return formatted;
  };

  const getTrendIcon = () => {
    if (!data.trend) return null;
    
    switch (data.trend.direction) {
      case "up":
        return <TrendingUp className="h-4 w-4 text-green-600" />;
      case "down":
        return <TrendingDown className="h-4 w-4 text-red-600" />;
      default:
        return <Minus className="h-4 w-4 text-gray-600" />;
    }
  };

  const getTrendColor = () => {
    if (!data.trend) return "text-gray-600";
    
    switch (data.trend.direction) {
      case "up":
        return "text-green-600";
      case "down":
        return "text-red-600";
      default:
        return "text-gray-600";
    }
  };

  const getStatusIcon = () => {
    switch (data.status) {
      case "good":
        return <CheckCircle className="h-4 w-4 text-green-600" />;
      case "warning":
        return <AlertTriangle className="h-4 w-4 text-yellow-600" />;
      case "critical":
        return <AlertTriangle className="h-4 w-4 text-red-600" />;
      default:
        return <Info className="h-4 w-4 text-blue-600" />;
    }
  };

  const getStatusColor = () => {
    switch (data.status) {
      case "good":
        return "border-green-200 bg-green-50/50";
      case "warning":
        return "border-yellow-200 bg-yellow-50/50";
      case "critical":
        return "border-red-200 bg-red-50/50";
      default:
        return "border-gray-200";
    }
  };

  const getProgressValue = () => {
    if (!data.target) return undefined;
    return Math.min((data.value / data.target) * 100, 100);
  };

  const getProgressColor = () => {
    const progress = getProgressValue();
    if (!progress) return "";
    
    if (progress >= 90) return "bg-green-600";
    if (progress >= 70) return "bg-yellow-600";
    return "bg-red-600";
  };

  if (compact) {
    return (
      <Card 
        className={cn(
          "cursor-pointer transition-all duration-200 hover:shadow-md",
          getStatusColor(),
          className
        )}
        onClick={() => onDrillDown?.(data)}
        onMouseEnter={() => setIsHovered(true)}
        onMouseLeave={() => setIsHovered(false)}
      >
        <CardContent className="p-4">
          <div className="flex items-center justify-between">
            <div className="space-y-1">
              <p className="text-sm font-medium text-muted-foreground">
                {data.title}
              </p>
              <div className="flex items-center space-x-2">
                <p className="text-xl font-bold">
                  {loading ? (
                    <div className="animate-pulse bg-gray-200 h-6 w-16 rounded" />
                  ) : (
                    formatValue(data.value, data.format, data.unit)
                  )}
                </p>
                {data.trend && (
                  <div className="flex items-center space-x-1">
                    {getTrendIcon()}
                    <span className={cn("text-sm font-medium", getTrendColor())}>
                      {data.trend.percentage.toFixed(1)}%
                    </span>
                  </div>
                )}
              </div>
            </div>
            <div className="flex flex-col items-end space-y-2">
              {getStatusIcon()}
              {isHovered && onDrillDown && (
                <Maximize2 className="h-3 w-3 text-muted-foreground" />
              )}
            </div>
          </div>
        </CardContent>
      </Card>
    );
  }

  return (
    <Card 
      className={cn(
        "transition-all duration-200 hover:shadow-lg",
        getStatusColor(),
        onDrillDown && "cursor-pointer",
        className
      )}
      onClick={() => onDrillDown?.(data)}
    >
      <CardHeader className="pb-2">
        <div className="flex items-center justify-between">
          <CardTitle className="text-base font-medium flex items-center space-x-2">
            <span>{data.title}</span>
            {getStatusIcon()}
          </CardTitle>
          
          <DropdownMenu>
            <DropdownMenuTrigger asChild>
              <Button variant="ghost" size="sm" className="h-8 w-8 p-0">
                <MoreVertical className="h-4 w-4" />
              </Button>
            </DropdownMenuTrigger>
            <DropdownMenuContent align="end">
              {onDrillDown && (
                <DropdownMenuItem onClick={() => onDrillDown(data)}>
                  <Maximize2 className="h-4 w-4 mr-2" />
                  View Details
                </DropdownMenuItem>
              )}
              {onRefresh && (
                <DropdownMenuItem onClick={() => onRefresh(data.id)}>
                  <RefreshCw className="h-4 w-4 mr-2" />
                  Refresh
                </DropdownMenuItem>
              )}
            </DropdownMenuContent>
          </DropdownMenu>
        </div>
      </CardHeader>

      <CardContent className="space-y-4">
        {/* Main Value */}
        <div className="space-y-2">
          <div className="flex items-center space-x-3">
            <p className="text-3xl font-bold">
              {loading ? (
                <div className="animate-pulse bg-gray-200 h-8 w-24 rounded" />
              ) : (
                formatValue(data.value, data.format, data.unit)
              )}
            </p>
            
            {data.trend && (
              <Badge variant="outline" className="flex items-center space-x-1">
                {getTrendIcon()}
                <span className={getTrendColor()}>
                  {data.trend.percentage.toFixed(1)}%
                </span>
                <span className="text-muted-foreground text-xs">
                  {data.trend.period}
                </span>
              </Badge>
            )}
          </div>

          {data.description && (
            <p className="text-sm text-muted-foreground">
              {data.description}
            </p>
          )}
        </div>

        {/* Target Progress */}
        {data.target && (
          <div className="space-y-2">
            <div className="flex items-center justify-between">
              <div className="flex items-center space-x-2">
                <Target className="h-4 w-4 text-muted-foreground" />
                <span className="text-sm font-medium">Progress to Target</span>
              </div>
              <span className="text-sm text-muted-foreground">
                {formatValue(data.target, data.format, data.unit)}
              </span>
            </div>
            <div className="space-y-1">
              <Progress 
                value={getProgressValue()} 
                className="h-2"
              />
              <p className="text-xs text-muted-foreground">
                {getProgressValue()?.toFixed(1)}% of target achieved
              </p>
            </div>
          </div>
        )}

        {/* Previous Value Comparison */}
        {data.previousValue !== undefined && (
          <div className="flex items-center justify-between text-sm">
            <span className="text-muted-foreground">Previous:</span>
            <span className="font-medium">
              {formatValue(data.previousValue, data.format, data.unit)}
            </span>
          </div>
        )}

        {/* Last Updated */}
        {data.lastUpdated && (
          <div className="text-xs text-muted-foreground">
            Updated {new Date(data.lastUpdated).toLocaleString()}
          </div>
        )}

        {/* Drill Down Indicator */}
        {onDrillDown && data.drillDownData && (
          <div className="flex items-center justify-between pt-2 border-t">
            <span className="text-sm text-muted-foreground">
              {data.drillDownData.length} items available
            </span>
            <Maximize2 className="h-4 w-4 text-muted-foreground" />
          </div>
        )}
      </CardContent>
    </Card>
  );
};

export default React.memo(AdvancedKPICard);
</file>

<file path="src/app/_components/analytics/AnalyticsDashboard.tsx">
'use client'

import React, { useState, useMemo } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import {
  BarChart3,
  TrendingUp,
  DollarSign,
  FileText,
  Users,
  AlertTriangle,
  Calendar,
  Filter,
  Download,
  RefreshCw,
} from "lucide-react";
import { DateRange } from "./DateRangePicker";
import DateRangePicker from "./DateRangePicker";
import dynamic from "next/dynamic";
import LoadingSpinner from "../common/LoadingSpinner";
import { ChartDataPoint, ChartSeries } from "./InteractiveChart";
import { KPIData } from "./AdvancedKPICard";

// Lazy load heavy chart components
const InteractiveChart = dynamic(() => import("./InteractiveChart"), {
  loading: () => <LoadingSpinner />,
  ssr: false
});

const DrillDownModal = dynamic(() => import("./DrillDownModal"), {
  loading: () => <div>Loading...</div>,
  ssr: false
});

const AdvancedKPICard = dynamic(() => import("./AdvancedKPICard"), {
  loading: () => <div className="h-48 animate-pulse bg-gray-200 rounded-lg" />,
  ssr: false
});

interface AnalyticsDashboardProps {
  className?: string;
}

// Mock data generators
const generateMockKPIData = (): KPIData[] => [
  {
    id: "total-contracts",
    title: "Total Contract Value",
    value: 2450000,
    previousValue: 2100000,
    target: 3000000,
    format: "currency",
    trend: {
      direction: "up",
      percentage: 16.7,
      period: "vs last quarter",
    },
    status: "good",
    description: "Total value of all active contracts",
    lastUpdated: new Date().toISOString(),
    drillDownData: Array.from({ length: 25 }, (_, i) => ({
      id: `contract-${i}`,
      name: `Contract ${i + 1}`,
      value: Math.floor(Math.random() * 200000) + 50000,
      category: "contracts",
      status: ["active", "pending", "expired"][Math.floor(Math.random() * 3)],
      date: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
    })),
  },
  {
    id: "active-contracts",
    title: "Active Contracts",
    value: 156,
    previousValue: 142,
    target: 200,
    format: "number",
    trend: {
      direction: "up",
      percentage: 9.9,
      period: "vs last month",
    },
    status: "good",
    description: "Currently active contracts",
    lastUpdated: new Date().toISOString(),
  },
  {
    id: "compliance-score",
    title: "Compliance Score",
    value: 87.5,
    previousValue: 82.1,
    target: 95,
    format: "percentage",
    trend: {
      direction: "up",
      percentage: 6.6,
      period: "vs last quarter",
    },
    status: "warning",
    description: "Overall compliance across all contracts",
    lastUpdated: new Date().toISOString(),
  },
  {
    id: "vendor-count",
    title: "Active Vendors",
    value: 89,
    previousValue: 94,
    target: 100,
    format: "number",
    trend: {
      direction: "down",
      percentage: 5.3,
      period: "vs last month",
    },
    status: "neutral",
    description: "Number of active vendor relationships",
    lastUpdated: new Date().toISOString(),
  },
  {
    id: "renewal-rate",
    title: "Contract Renewal Rate",
    value: 92.3,
    previousValue: 88.7,
    target: 95,
    format: "percentage",
    trend: {
      direction: "up",
      percentage: 4.1,
      period: "vs last year",
    },
    status: "good",
    description: "Percentage of contracts successfully renewed",
    lastUpdated: new Date().toISOString(),
  },
  {
    id: "risk-contracts",
    title: "High-Risk Contracts",
    value: 12,
    previousValue: 8,
    target: 5,
    format: "number",
    trend: {
      direction: "up",
      percentage: 50,
      period: "vs last month",
    },
    status: "critical",
    description: "Contracts requiring immediate attention",
    lastUpdated: new Date().toISOString(),
  },
];

const generateMockChartData = (type: string): ChartDataPoint[] => {
  const months = ["Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"];
  
  switch (type) {
    case "contract-value":
      return months.map(month => ({
        name: month,
        value: Math.floor(Math.random() * 500000) + 200000,
        new_contracts: Math.floor(Math.random() * 100000) + 50000,
        renewals: Math.floor(Math.random() * 300000) + 100000,
        category: "financial",
      }));
    
    case "vendor-performance":
      return [
        { name: "Technology", value: 89, category: "vendor" },
        { name: "Consulting", value: 76, category: "vendor" },
        { name: "Manufacturing", value: 92, category: "vendor" },
        { name: "Services", value: 85, category: "vendor" },
        { name: "Legal", value: 94, category: "vendor" },
        { name: "Marketing", value: 81, category: "vendor" },
      ];
    
    case "risk-distribution":
      return [
        { name: "Low Risk", value: 134, category: "risk" },
        { name: "Medium Risk", value: 45, category: "risk" },
        { name: "High Risk", value: 12, category: "risk" },
        { name: "Critical", value: 3, category: "risk" },
      ];
    
    default:
      return [];
  }
};

export const AnalyticsDashboard: React.FC<AnalyticsDashboardProps> = ({
  className,
}) => {
  const [dateRange, setDateRange] = useState<DateRange>({
    from: new Date(Date.now() - 30 * 24 * 60 * 60 * 1000),
    to: new Date(),
  });
  const [selectedKPI, setSelectedKPI] = useState<string>("overview");
  const [drillDownData, setDrillDownData] = useState<any>(null);
  const [isDrillDownOpen, setIsDrillDownOpen] = useState(false);
  const [loading, setLoading] = useState(false);

  // Mock data
  const kpiData = useMemo(() => generateMockKPIData(), []);
  const contractValueData = useMemo(() => generateMockChartData("contract-value"), []);
  const vendorPerformanceData = useMemo(() => generateMockChartData("vendor-performance"), []);
  const riskDistributionData = useMemo(() => generateMockChartData("risk-distribution"), []);

  // Chart series configuration
  const contractValueSeries: ChartSeries[] = [
    { key: "new_contracts", name: "New Contracts", color: "#8884d8", visible: true },
    { key: "renewals", name: "Renewals", color: "#82ca9d", visible: true },
  ];

  const handleKPIDrillDown = (kpi: KPIData) => {
    if (kpi.drillDownData) {
      setDrillDownData({
        title: kpi.title,
        category: kpi.id,
        data: kpi.drillDownData,
      });
      setIsDrillDownOpen(true);
    }
  };

  const handleChartDrillDown = (category: string, value: any) => {
    // Generate mock drill-down data based on category
    const mockData = Array.from({ length: 20 }, (_, i) => ({
      id: `${category}-${i}`,
      name: `${category} Item ${i + 1}`,
      value: Math.floor(Math.random() * 100000) + 10000,
      category,
      status: ["active", "pending", "expired"][Math.floor(Math.random() * 3)],
      date: new Date(Date.now() - Math.random() * 365 * 24 * 60 * 60 * 1000).toISOString(),
      trend: (Math.random() - 0.5) * 20,
    }));

    setDrillDownData({
      title: "Detailed Analysis",
      category,
      data: mockData,
    });
    setIsDrillDownOpen(true);
  };

  const handleRefresh = async (kpiId?: string) => {
    setLoading(true);
    // Simulate API call
    await new Promise(resolve => setTimeout(resolve, 1000));
    setLoading(false);
  };

  const handleExportData = () => {
    // Export functionality
    const exportData = {
      dateRange,
      kpiData,
      chartData: {
        contractValue: contractValueData,
        vendorPerformance: vendorPerformanceData,
        riskDistribution: riskDistributionData,
      },
      generatedAt: new Date().toISOString(),
    };

    const dataStr = JSON.stringify(exportData, null, 2);
    const dataBlob = new Blob([dataStr], { type: 'application/json' });
    const url = URL.createObjectURL(dataBlob);
    const link = document.createElement('a');
    link.href = url;
    link.download = `analytics_export_${new Date().toISOString().split('T')[0]}.json`;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    URL.revokeObjectURL(url);
  };

  // Calculate alerts
  const alerts = useMemo(() => {
    const criticalKPIs = kpiData.filter(kpi => kpi.status === "critical");
    const warningKPIs = kpiData.filter(kpi => kpi.status === "warning");
    
    return {
      critical: criticalKPIs.length,
      warning: warningKPIs.length,
      items: [...criticalKPIs, ...warningKPIs],
    };
  }, [kpiData]);

  return (
    <div className={className}>
      <div className="space-y-6">
        {/* Header */}
        <div className="flex flex-col lg:flex-row lg:items-center lg:justify-between space-y-4 lg:space-y-0">
          <div>
            <h1 className="text-3xl font-bold">Advanced Analytics</h1>
            <p className="text-muted-foreground">
              Comprehensive insights into your contract and vendor performance
            </p>
          </div>
          
          <div className="flex items-center space-x-4">
            <DateRangePicker
              value={dateRange}
              onChange={setDateRange}
              presets={true}
            />
            
            <Button variant="outline" onClick={handleExportData}>
              <Download className="h-4 w-4 mr-2" />
              Export
            </Button>
            
            <Button variant="outline" onClick={() => handleRefresh()}>
              <RefreshCw className={`h-4 w-4 mr-2 ${loading ? 'animate-spin' : ''}`} />
              Refresh
            </Button>
          </div>
        </div>

        {/* Alerts */}
        {alerts.critical > 0 && (
          <Alert variant="destructive">
            <AlertTriangle className="h-4 w-4" />
            <AlertTitle>Critical Issues Detected</AlertTitle>
            <AlertDescription>
              {alerts.critical} critical and {alerts.warning} warning indicators require immediate attention.
            </AlertDescription>
          </Alert>
        )}

        {/* KPI Overview */}
        <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
          {kpiData.map((kpi) => (
            <AdvancedKPICard
              key={kpi.id}
              data={kpi}
              onDrillDown={handleKPIDrillDown}
              onRefresh={handleRefresh}
              loading={loading}
            />
          ))}
        </div>

        {/* Charts and Analysis */}
        <Tabs defaultValue="overview" className="w-full">
          <TabsList className="grid w-full grid-cols-4">
            <TabsTrigger value="overview">Overview</TabsTrigger>
            <TabsTrigger value="financial">Financial</TabsTrigger>
            <TabsTrigger value="performance">Performance</TabsTrigger>
            <TabsTrigger value="risk">Risk Analysis</TabsTrigger>
          </TabsList>

          <TabsContent value="overview" className="space-y-6">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <InteractiveChart
                title="Contract Value Over Time"
                subtitle="Monthly breakdown of new contracts and renewals"
                data={contractValueData}
                type="area"
                series={contractValueSeries}
                height={350}
                onDrillDown={handleChartDrillDown}
              />
              
              <InteractiveChart
                title="Risk Distribution"
                subtitle="Current risk levels across all contracts"
                data={riskDistributionData}
                type="pie"
                height={350}
                onDrillDown={handleChartDrillDown}
              />
            </div>
          </TabsContent>

          <TabsContent value="financial" className="space-y-6">
            <div className="grid grid-cols-1 gap-6">
              <InteractiveChart
                title="Financial Performance"
                subtitle="Contract values and financial metrics over time"
                data={contractValueData}
                type="bar"
                series={contractValueSeries}
                height={400}
                onDrillDown={handleChartDrillDown}
              />
              
              <div className="grid grid-cols-1 md:grid-cols-3 gap-4">
                <Card>
                  <CardHeader>
                    <CardTitle className="flex items-center space-x-2">
                      <DollarSign className="h-5 w-5" />
                      <span>Revenue Impact</span>
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">$2.4M</div>
                    <p className="text-sm text-muted-foreground">Total contract value</p>
                  </CardContent>
                </Card>
                
                <Card>
                  <CardHeader>
                    <CardTitle className="flex items-center space-x-2">
                      <TrendingUp className="h-5 w-5" />
                      <span>Growth Rate</span>
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold text-green-600">+16.7%</div>
                    <p className="text-sm text-muted-foreground">Quarter over quarter</p>
                  </CardContent>
                </Card>
                
                <Card>
                  <CardHeader>
                    <CardTitle className="flex items-center space-x-2">
                      <Calendar className="h-5 w-5" />
                      <span>Pipeline Value</span>
                    </CardTitle>
                  </CardHeader>
                  <CardContent>
                    <div className="text-2xl font-bold">$850K</div>
                    <p className="text-sm text-muted-foreground">Pending contracts</p>
                  </CardContent>
                </Card>
              </div>
            </div>
          </TabsContent>

          <TabsContent value="performance" className="space-y-6">
            <InteractiveChart
              title="Vendor Performance Scores"
              subtitle="Performance ratings by vendor category"
              data={vendorPerformanceData}
              type="bar"
              height={400}
              onDrillDown={handleChartDrillDown}
            />
          </TabsContent>

          <TabsContent value="risk" className="space-y-6">
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
              <InteractiveChart
                title="Risk Distribution"
                subtitle="Breakdown of contract risk levels"
                data={riskDistributionData}
                type="pie"
                height={350}
                onDrillDown={handleChartDrillDown}
              />
              
              <Card>
                <CardHeader>
                  <CardTitle>Risk Summary</CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                  <div className="space-y-2">
                    <div className="flex justify-between">
                      <span>Critical Risks</span>
                      <Badge variant="destructive">3</Badge>
                    </div>
                    <div className="flex justify-between">
                      <span>High Risks</span>
                      <Badge variant="secondary">12</Badge>
                    </div>
                    <div className="flex justify-between">
                      <span>Medium Risks</span>
                      <Badge variant="outline">45</Badge>
                    </div>
                    <div className="flex justify-between">
                      <span>Low Risks</span>
                      <Badge variant="outline">134</Badge>
                    </div>
                  </div>
                </CardContent>
              </Card>
            </div>
          </TabsContent>
        </Tabs>

        {/* Drill Down Modal */}
        <DrillDownModal
          open={isDrillDownOpen}
          onOpenChange={setIsDrillDownOpen}
          title={drillDownData?.title || ""}
          category={drillDownData?.category || ""}
          data={drillDownData?.data || []}
          onNavigateToDetail={(id) => {
            console.log("Navigate to detail:", id);
            // Handle navigation to detailed view
          }}
        />
      </div>
    </div>
  );
};

export default AnalyticsDashboard;
</file>

<file path="src/app/_components/common/Logo.tsx">
"use client";

import { useRouter } from 'next/navigation';

type LogoSize = "sm" | "md" | "lg" | "xl";

interface LogoProps {
  size?: LogoSize;
}

const sizeClasses: Record<LogoSize, { text: string; dot: string }> = {
  sm: { text: "text-xl", dot: "h-1.5 w-1.5" },
  md: { text: "text-2xl", dot: "h-2 w-2" },
  lg: { text: "text-3xl", dot: "h-2.5 w-2.5" },
  xl: { text: "text-4xl", dot: "h-3 w-3" },
};

export const Logo = ({ size = "md" }: LogoProps) => {
  const router = useRouter();
  const sizeClass = sizeClasses[size];

  const handleOnClick = () => {
    router.push("/");
  };

  return (
    <div
      className="inline-flex items-center gap-1 cursor-pointer"
      onClick={handleOnClick}
    >
      <span className={`font-serif font-bold ${sizeClass.text}`}>
        <span style={{ 
          backgroundImage: "linear-gradient(to right, #0A192F, #B8A369, #0A192F)", 
          WebkitBackgroundClip: "text",
          backgroundClip: "text",
          color: "transparent",
          animation: "gradient 8s ease infinite"
        }}>
          Pact
        </span>
        <span style={{ 
          backgroundImage: "linear-gradient(to right, #B8A369, #0A192F, #B8A369)", 
          WebkitBackgroundClip: "text",
          backgroundClip: "text",
          color: "transparent",
          animation: "gradient 8s ease infinite 2s"
        }}>
          Wise
        </span>
      </span>

      <div 
        className={`rounded-full ${sizeClass.dot}`} 
        style={{ 
          backgroundColor: "rgba(184, 163, 105, 0.8)", 
          animation: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite" 
        }} 
      />
    </div>
  );
};

export default Logo;
</file>

<file path="src/app/_components/common/MetricCard.tsx">
import React from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";

import { ChevronUp, ChevronDown } from "lucide-react";

interface MetricCardProps {
  title: string;
  value: string | number;
  icon: React.ElementType;
  trend?: number;
  description?: string;
  changeType?: "positive" | "negative" | "neutral";
}

export const MetricCard: React.FC<MetricCardProps> = React.memo(({
  title,
  value,
  icon: Icon,
  trend,
  description,
  changeType = "neutral",
}) => (
  <Card className="bg-background-glass backdrop-blur-sm border border-border/50 shadow-lg hover:shadow-xl transition-all duration-200">
    <CardHeader className="flex flex-row items-center justify-between pb-2">
      <CardTitle className="text-sm font-medium">{title}</CardTitle>
      <Icon className="h-4 w-4 text-primary" />
    </CardHeader>
    <CardContent>
      <div className="text-2xl font-bold text-primary">{value}</div>
      {trend && (
        <p
          className={`text-xs mt-1 flex items-center ${
            changeType === "positive"
              ? "text-success"
              : changeType === "negative"
              ? "text-destructive"
              : "text-muted-foreground"
          }`}
        >
          {changeType === "positive" ? (
            <ChevronUp className="h-4 w-4" />
          ) : changeType === "negative" ? (
            <ChevronDown className="h-4 w-4" />
          ) : null}
          {Math.abs(trend)}% from previous period
        </p>
      )}
      {description && (
        <p className="text-xs text-muted-foreground mt-2">{description}</p>
      )}
    </CardContent>
  </Card>
));
</file>

<file path="src/app/_components/common/MonitoringProvider.tsx">
'use client';

import React, { createContext, useContext, useEffect, useState, ReactNode } from 'react';
import { useAuth } from '@clerk/nextjs';
import { useMutation, useQuery } from 'convex/react';
import { api } from '../../../../convex/_generated/api';
import { 
  performanceTracker, 
  userAnalytics, 
  errorTracker, 
  healthMonitor,
  measurePerformance 
} from '@/lib/monitoring';

interface MonitoringContextType {
  trackEvent: (event: string, properties?: Record<string, any>) => void;
  captureError: (error: Error, context?: Record<string, any>) => void;
  measureRender: (componentName: string, renderFn: () => void) => void;
  healthStatus: Record<string, boolean>;
  isHealthy: boolean;
}

const MonitoringContext = createContext<MonitoringContextType | null>(null);

interface MonitoringProviderProps {
  children: ReactNode;
}

export const MonitoringProvider: React.FC<MonitoringProviderProps> = ({ children }) => {
  const { userId } = useAuth();
  const [healthStatus, setHealthStatus] = useState<Record<string, boolean>>({});
  const [isHealthy, setIsHealthy] = useState(true);

  // Convex mutations for monitoring
  const logAnalyticsEvent = useMutation(api.monitoring.logAnalyticsEvent);
  const logAnalyticsEventBatch = useMutation(api.monitoring.logAnalyticsEventBatch);
  const reportError = useMutation(api.monitoring.reportError);
  const healthQuery = useQuery(api.monitoring.getHealthStatus);

  // Set up global analytics bridge
  useEffect(() => {
    if (typeof window !== 'undefined') {
      (window as any).convexAnalytics = {
        logEvent: async (event: string, properties: Record<string, any> = {}) => {
          try {
            await logAnalyticsEvent({
              event,
              timestamp: Date.now(),
              url: window.location.href,
              userId: userId || undefined,
              properties,
              sessionId: userAnalytics.getSessionId(),
              userAgent: navigator.userAgent,
            });
          } catch (error) {
            console.warn('Failed to log analytics event:', error);
          }
        },
        
        logEventBatch: async (events: any[]) => {
          try {
            const formattedEvents = events.map(event => ({
              event: event.event,
              timestamp: event.timestamp,
              url: event.url,
              userId: event.userId,
              properties: event.properties,
              sessionId: event.sessionId,
              userAgent: navigator.userAgent,
            }));
            await logAnalyticsEventBatch({ events: formattedEvents });
          } catch (error) {
            console.warn('Failed to log analytics batch:', error);
          }
        },
        
        reportError: async (errorData: any) => {
          try {
            await reportError({
              message: errorData.message,
              stack: errorData.stack,
              timestamp: errorData.timestamp,
              url: errorData.url,
              userId: errorData.userId,
              sessionId: errorData.sessionId,
              userAgent: errorData.userAgent,
              context: errorData.context,
            });
          } catch (error) {
            console.warn('Failed to report error:', error);
          }
        },
        
        getHealthStatus: () => healthQuery,
      };
    }
  }, [logAnalyticsEvent, logAnalyticsEventBatch, reportError, healthQuery, userId]);

  useEffect(() => {
    // Update health status periodically
    const updateHealthStatus = () => {
      const status = healthMonitor.getHealthStatus();
      const healthy = healthMonitor.isHealthy();
      
      // Include Convex health status
      if (healthQuery) {
        status.convex = healthQuery.status === 'healthy';
      }
      
      setHealthStatus(status);
      setIsHealthy(Object.values(status).every(Boolean));
    };

    // Initial check
    updateHealthStatus();

    // Set up periodic health checks
    const interval = setInterval(updateHealthStatus, 60000); // Every minute

    return () => {
      clearInterval(interval);
    };
  }, [healthQuery]);

  const trackEvent = (event: string, properties?: Record<string, any>) => {
    userAnalytics.track(event, properties, userId || undefined);
  };

  const captureError = (error: Error, context?: Record<string, any>) => {
    errorTracker.captureError(error, context, userId || undefined);
  };

  const measureRender = (componentName: string, renderFn: () => void) => {
    measurePerformance.measureRender(componentName, renderFn);
  };

  const contextValue: MonitoringContextType = {
    trackEvent,
    captureError,
    measureRender,
    healthStatus,
    isHealthy,
  };

  return (
    <MonitoringContext.Provider value={contextValue}>
      {children}
    </MonitoringContext.Provider>
  );
};

export const useMonitoring = (): MonitoringContextType => {
  const context = useContext(MonitoringContext);
  if (!context) {
    throw new Error('useMonitoring must be used within a MonitoringProvider');
  }
  return context;
};

// HOC for automatic component performance tracking
export function withPerformanceTracking<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  componentName?: string
) {
  const WithPerformanceTrackingComponent = (props: P) => {
    const { measureRender } = useMonitoring();
    const name = componentName || WrappedComponent.displayName || WrappedComponent.name || 'Unknown';

    useEffect(() => {
      measureRender(name, () => {
        // Component rendered
      });
    });

    return <WrappedComponent {...props} />;
  };

  WithPerformanceTrackingComponent.displayName = `withPerformanceTracking(${componentName || WrappedComponent.displayName || WrappedComponent.name})`;

  return WithPerformanceTrackingComponent;
}

// Hook for tracking user interactions
export const useUserTracking = () => {
  const { trackEvent } = useMonitoring();

  const trackClick = (element: string, properties?: Record<string, any>) => {
    trackEvent('user_click', { element, ...properties });
  };

  const trackView = (page: string, properties?: Record<string, any>) => {
    trackEvent('page_view', { page, ...properties });
  };

  const trackSearch = (query: string, results: number, properties?: Record<string, any>) => {
    trackEvent('search', { query, results, ...properties });
  };

  const trackFormSubmit = (formName: string, properties?: Record<string, any>) => {
    trackEvent('form_submit', { form: formName, ...properties });
  };

  const trackFeatureUsage = (feature: string, properties?: Record<string, any>) => {
    trackEvent('feature_usage', { feature, ...properties });
  };

  return {
    trackClick,
    trackView,
    trackSearch,
    trackFormSubmit,
    trackFeatureUsage,
  };
};

// Health status indicator component
export const HealthIndicator: React.FC = () => {
  const { healthStatus, isHealthy } = useMonitoring();

  if (process.env.NODE_ENV !== 'development') {
    return null; // Only show in development
  }

  return (
    <div className={`fixed bottom-4 right-4 p-2 rounded-md text-xs ${
      isHealthy ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
    }`}>
      <div className="font-medium">System Health</div>
      {Object.entries(healthStatus).map(([check, healthy]) => (
        <div key={check} className="flex items-center gap-1">
          <div className={`w-2 h-2 rounded-full ${healthy ? 'bg-green-500' : 'bg-red-500'}`} />
          {check}
        </div>
      ))}
    </div>
  );
};

export default MonitoringProvider;
</file>

<file path="src/app/_components/contracts/ContractFormModal.tsx">
import React from 'react';
import dynamic from 'next/dynamic';
import LoadingSpinner from '../common/LoadingSpinner';

const ContractForm = dynamic(() => import('@/app/_components/contracts/ContractForm').then(mod => ({ default: mod.ContractForm })), {
  loading: () => <LoadingSpinner />,
  ssr: false
});
import { 
  Dialog, 
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogDescription
} from '@/components/ui/dialog';
import { Id } from '../../../../convex/_generated/dataModel';

interface ContractFormModalProps {
  isOpen: boolean;
  onClose: () => void;
  contractId?: Id<"contracts">;
  onSuccess?: (contractId: Id<"contracts">) => void;
}

export const ContractFormModal: React.FC<ContractFormModalProps> = ({
  isOpen,
  onClose,
  contractId,
  onSuccess
}) => {
  return (
    <Dialog open={isOpen} onOpenChange={(open) => !open && onClose()}>
      <DialogContent className="max-w-4xl max-h-[90vh] overflow-y-auto">
        <DialogHeader>
          <DialogTitle className="text-xl font-serif text-primary">
            {contractId ? 'Edit Contract' : 'Create New Contract'}
          </DialogTitle>
          <DialogDescription>
            {contractId 
              ? 'Make changes to the existing contract.' 
              : 'Fill out the details to create a new contract.'}
          </DialogDescription>
        </DialogHeader>
        
        <div className="mt-4">
          <ContractForm 
            isModal={true} 
            contractId={contractId} 
            onClose={onClose}
            onSuccess={onSuccess}
          />
        </div>
      </DialogContent>
    </Dialog>
  );
};

export default ContractFormModal;
</file>

<file path="src/app/_components/contracts/ContractTable.tsx">
'use client';

import React, { useState, useMemo } from 'react';
import { useRouter } from 'next/navigation';
import { format } from 'date-fns';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';
import type { ContractStatus, AnalysisStatus, ContractType } from '@/types/contract.types';
import { useUser } from '@clerk/nextjs';

// UI Components
import {
  Table,
  TableBody,
  TableCell,
  TableHead,
  TableHeader,
  TableRow,
} from "@/components/ui/table";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Input } from "@/components/ui/input";
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from "@/components/ui/select";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Alert, AlertDescription } from "@/components/ui/alert";

// Icons
import {
  Search,
  Filter,
  SortAsc,
  SortDesc,
  Eye,
  Edit,
  Download,
  FileText,
  Calendar,
  Building,
  AlertCircle,
  ChevronLeft,
  ChevronRight
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface ContractTableProps {
  onContractSelect?: (contractId: Id<"contracts">) => void;
  statusFilter?: ContractStatus;
  showSearch?: boolean;
  showFilters?: boolean;
  pageSize?: number;
}

type SortField = 'title' | 'status' | 'vendorName' | 'createdAt' | 'extractedEndDate';
type SortDirection = 'asc' | 'desc';

// Status color mapping
const statusColors: Record<ContractStatus, string> = {
  draft: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300',
  pending_analysis: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/70 dark:text-yellow-300',
  active: 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300',
  expired: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300',
  terminated: 'bg-orange-100 text-orange-800 dark:bg-orange-900/70 dark:text-orange-300',
  archived: 'bg-slate-100 text-slate-800 dark:bg-slate-700 dark:text-slate-300',
};

export const ContractTable = ({
  onContractSelect,
  statusFilter,
  showSearch = true,
  showFilters = true,
  pageSize = 10
}: ContractTableProps) => {
  const router = useRouter();
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();
  
  // State
  const [searchTerm, setSearchTerm] = useState('');
  const [selectedStatus, setSelectedStatus] = useState<ContractStatus | 'all'>(statusFilter || 'all');
  const [sortField, setSortField] = useState<SortField>('createdAt');
  const [sortDirection, setSortDirection] = useState<SortDirection>('desc');
  const [currentPage, setCurrentPage] = useState(1);

  // Get enterpriseId from user metadata
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch contracts
  const { data: contracts, isLoading, error } = useConvexQuery(
    api.contracts.getContracts,
    (enterpriseId) ? { enterpriseId } : "skip"
  );

  // Memoized filtered and sorted contracts
  const processedContracts = useMemo(() => {
    if (!contracts) return [];

    let filtered = contracts.filter((contract) => {
      // Search filter
      if (searchTerm) {
        const searchLower = searchTerm.toLowerCase();
        const matchesTitle = contract.title.toLowerCase().includes(searchLower);
        const matchesVendor = contract.vendor?.name.toLowerCase().includes(searchLower);
        const matchesType = contract.contractType?.toLowerCase().includes(searchLower);
        
        if (!matchesTitle && !matchesVendor && !matchesType) {
          return false;
        }
      }

      // Status filter
      if (selectedStatus !== 'all' && contract.status !== selectedStatus) {
        return false;
      }

      return true;
    });

    // Sort contracts
    filtered.sort((a, b) => {
      let aValue: any;
      let bValue: any;

      switch (sortField) {
        case 'title':
          aValue = a.title.toLowerCase();
          bValue = b.title.toLowerCase();
          break;
        case 'status':
          aValue = a.status;
          bValue = b.status;
          break;
        case 'vendorName':
          aValue = a.vendor?.name.toLowerCase() || '';
          bValue = b.vendor?.name.toLowerCase() || '';
          break;
        case 'createdAt':
          aValue = a._creationTime || 0;
          bValue = b._creationTime || 0;
          break;
        case 'extractedEndDate':
          aValue = a.extractedEndDate ? new Date(a.extractedEndDate).getTime() : 0;
          bValue = b.extractedEndDate ? new Date(b.extractedEndDate).getTime() : 0;
          break;
        default:
          aValue = 0;
          bValue = 0;
      }

      if (aValue < bValue) return sortDirection === 'asc' ? -1 : 1;
      if (aValue > bValue) return sortDirection === 'asc' ? 1 : -1;
      return 0;
    });

    return filtered;
  }, [contracts, searchTerm, selectedStatus, sortField, sortDirection]);

  // Pagination
  const totalPages = Math.ceil(processedContracts.length / pageSize);
  const paginatedContracts = processedContracts.slice(
    (currentPage - 1) * pageSize,
    currentPage * pageSize
  );

  // Handlers
  const handleSort = (field: SortField) => {
    if (sortField === field) {
      setSortDirection(sortDirection === 'asc' ? 'desc' : 'asc');
    } else {
      setSortField(field);
      setSortDirection('asc');
    }
  };

  const handleView = (contractId: Id<"contracts">) => {
    if (onContractSelect) {
      onContractSelect(contractId);
    } else {
      // Navigate to contract details page if no custom handler
      router.push(`/dashboard/contracts/${contractId}`);
    }
  };

  const handleEdit = (contractId: Id<"contracts">) => {
    router.push(`/dashboard/contracts/edit/${contractId}`);
  };

  const formatDate = (dateString?: string): string => {
    if (!dateString) return 'N/A';
    try {
      const date = new Date(isNaN(Number(dateString)) ? dateString : Number(dateString));
      if (isNaN(date.getTime())) return 'N/A';
      return format(date, 'MMM dd, yyyy');
    } catch {
      return 'N/A';
    }
  };

  const formatStatusLabel = (status: string): string => {
    return status.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
  };

  const SortIcon = ({ field }: { field: SortField }) => {
    if (sortField !== field) return null;
    return sortDirection === 'asc' ? 
      <SortAsc className="h-4 w-4 ml-1" /> : 
      <SortDesc className="h-4 w-4 ml-1" />;
  };

  if (!isClerkLoaded) {
    return (
      <div className="flex justify-center items-center min-h-[200px]">
        <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
      </div>
    );
  }

  if (!enterpriseId) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertDescription>
          Enterprise information is missing. Please contact support.
        </AlertDescription>
      </Alert>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertDescription>
          Failed to load contracts: {error.message}
        </AlertDescription>
      </Alert>
    );
  }

  return (
    <Card className="w-full">
      <CardHeader>
        <div className="flex flex-col sm:flex-row gap-4 items-start sm:items-center justify-between">
          <CardTitle className="flex items-center gap-2">
            <FileText className="h-5 w-5" />
            Contracts ({processedContracts.length})
          </CardTitle>
          
          {/* Search and Filters */}
          {(showSearch || showFilters) && (
            <div className="flex flex-col sm:flex-row gap-2 w-full sm:w-auto">
              {showSearch && (
                <div className="relative">
                  <Search className="absolute left-3 top-1/2 transform -translate-y-1/2 h-4 w-4 text-muted-foreground" />
                  <Input
                    placeholder="Search contracts..."
                    value={searchTerm}
                    onChange={(e) => setSearchTerm(e.target.value)}
                    className="pl-9 w-full sm:w-64"
                  />
                </div>
              )}
              
              {showFilters && (
                <Select value={selectedStatus} onValueChange={(value) => setSelectedStatus(value as ContractStatus | 'all')}>
                  <SelectTrigger className="w-full sm:w-40">
                    <Filter className="h-4 w-4 mr-2" />
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="all">All Status</SelectItem>
                    <SelectItem value="draft">Draft</SelectItem>
                    <SelectItem value="pending_analysis">Pending Analysis</SelectItem>
                    <SelectItem value="active">Active</SelectItem>
                    <SelectItem value="expired">Expired</SelectItem>
                    <SelectItem value="terminated">Terminated</SelectItem>
                    <SelectItem value="archived">Archived</SelectItem>
                  </SelectContent>
                </Select>
              )}
            </div>
          )}
        </div>
      </CardHeader>

      <CardContent>
        {isLoading ? (
          <div className="flex justify-center items-center min-h-[200px]">
            <div className="animate-spin rounded-full h-8 w-8 border-t-2 border-b-2 border-primary"></div>
            <span className="ml-3 text-muted-foreground">Loading contracts...</span>
          </div>
        ) : paginatedContracts.length === 0 ? (
          <div className="text-center py-8">
            <FileText className="h-16 w-16 text-muted-foreground mx-auto mb-4" />
            <p className="text-lg font-medium text-muted-foreground">No contracts found</p>
            <p className="text-sm text-muted-foreground mt-1">
              {searchTerm || selectedStatus !== 'all' 
                ? 'Try adjusting your search or filters' 
                : 'Get started by creating your first contract'}
            </p>
          </div>
        ) : (
          <>
            {/* Table */}
            <div className="rounded-md border">
              <Table>
                <TableHeader>
                  <TableRow>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('title')}
                    >
                      <div className="flex items-center">
                        Contract Title
                        <SortIcon field="title" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('vendorName')}
                    >
                      <div className="flex items-center">
                        Vendor
                        <SortIcon field="vendorName" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('status')}
                    >
                      <div className="flex items-center">
                        Status
                        <SortIcon field="status" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('extractedEndDate')}
                    >
                      <div className="flex items-center">
                        End Date
                        <SortIcon field="extractedEndDate" />
                      </div>
                    </TableHead>
                    <TableHead 
                      className="cursor-pointer hover:bg-muted/50 select-none"
                      onClick={() => handleSort('createdAt')}
                    >
                      <div className="flex items-center">
                        Created
                        <SortIcon field="createdAt" />
                      </div>
                    </TableHead>
                    <TableHead className="text-right">Actions</TableHead>
                  </TableRow>
                </TableHeader>
                <TableBody>
                  {paginatedContracts.map((contract) => (
                    <TableRow key={contract._id} className="hover:bg-muted/30">
                      <TableCell className="font-medium">
                        <div className="flex flex-col">
                          <span className="font-medium text-foreground truncate max-w-xs">
                            {contract.title}
                          </span>
                          {contract.contractType && (
                            <span className="text-xs text-muted-foreground">
                              {formatStatusLabel(contract.contractType)}
                            </span>
                          )}
                        </div>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2">
                          <Building className="h-4 w-4 text-muted-foreground" />
                          <span className="truncate max-w-xs">
                            {contract.vendor?.name || 'Unknown Vendor'}
                          </span>
                        </div>
                      </TableCell>
                      <TableCell>
                        <Badge className={cn(statusColors[contract.status], "text-xs")}>
                          {formatStatusLabel(contract.status)}
                        </Badge>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2 text-sm">
                          <Calendar className="h-4 w-4 text-muted-foreground" />
                          {formatDate(contract.extractedEndDate)}
                        </div>
                      </TableCell>
                      <TableCell>
                        <div className="flex items-center gap-2 text-sm text-muted-foreground">
                          <Calendar className="h-4 w-4" />
                          {formatDate(contract._creationTime?.toString())}
                        </div>
                      </TableCell>
                      <TableCell className="text-right">
                        <div className="flex items-center gap-1 justify-end">
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleView(contract._id)}
                            className="h-8 w-8 p-0"
                          >
                            <Eye className="h-4 w-4" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => handleEdit(contract._id)}
                            className="h-8 w-8 p-0"
                          >
                            <Edit className="h-4 w-4" />
                          </Button>
                        </div>
                      </TableCell>
                    </TableRow>
                  ))}
                </TableBody>
              </Table>
            </div>

            {/* Pagination */}
            {totalPages > 1 && (
              <div className="flex items-center justify-between mt-4">
                <div className="text-sm text-muted-foreground">
                  Showing {((currentPage - 1) * pageSize) + 1} to {Math.min(currentPage * pageSize, processedContracts.length)} of {processedContracts.length} contracts
                </div>
                <div className="flex items-center gap-2">
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setCurrentPage(currentPage - 1)}
                    disabled={currentPage === 1}
                  >
                    <ChevronLeft className="h-4 w-4" />
                    Previous
                  </Button>
                  <div className="flex items-center gap-1">
                    {Array.from({ length: Math.min(5, totalPages) }, (_, i) => {
                      const pageNum = i + 1;
                      return (
                        <Button
                          key={pageNum}
                          variant={currentPage === pageNum ? "default" : "outline"}
                          size="sm"
                          onClick={() => setCurrentPage(pageNum)}
                          className="w-8 h-8 p-0"
                        >
                          {pageNum}
                        </Button>
                      );
                    })}
                  </div>
                  <Button
                    variant="outline"
                    size="sm"
                    onClick={() => setCurrentPage(currentPage + 1)}
                    disabled={currentPage === totalPages}
                  >
                    Next
                    <ChevronRight className="h-4 w-4" />
                  </Button>
                </div>
              </div>
            )}
          </>
        )}
      </CardContent>
    </Card>
  );
};

export default React.memo(ContractTable);
</file>

<file path="src/app/_components/dashboard/GlobalSearch.tsx">
import React from "react";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Command, CommandInput } from "@/components/ui/command";
import { Search } from "lucide-react";

interface GlobalSearchProps {
  isOpen: boolean;
  onOpen: () => void;
  onClose: () => void;
}

export const GlobalSearch: React.FC<GlobalSearchProps> = ({
  isOpen,
  onOpen,
  onClose,
}) => {
  const quickFilters = [
    "Contracts",
    "Vendors",
    "Templates",
    "Recent",
    "Pending Signature",
  ];

  return (
    <>
      {/* Search Trigger */}
      <div className="flex-1 max-w-2xl mx-4">
        <Button
          variant="outline"
          className="w-full justify-start text-muted-foreground"
          onClick={onOpen}
        >
          <Search className="mr-2 h-4 w-4" />
          Search contracts, vendors, documents...
        </Button>
      </div>

      {/* Search Modal */}
      {isOpen && (
        <div
          className="fixed inset-0 bg-background/80 backdrop-blur-sm z-50"
          onClick={onClose}
        >
          <div
            className="fixed left-[50%] top-[20%] translate-x-[-50%] w-full max-w-2xl"
            onClick={(e) => e.stopPropagation()}
          >
            <Card>
              <CardContent className="p-4">
                <Command className="w-full">
                  <CommandInput
                    value=""
                    onValueChange={() => {}}
                    placeholder="Search contracts, vendors, documents..."
                    className="h-12"
                  />
                </Command>
                <div className="mt-4">
                  <div className="text-sm font-medium text-muted-foreground mb-2">
                    Quick Filters
                  </div>
                  <div className="flex flex-wrap gap-2">
                    {quickFilters.map((filter) => (
                      <Button
                        key={filter}
                        variant="outline"
                        size="sm"
                        className="text-xs"
                      >
                        {filter}
                      </Button>
                    ))}
                  </div>
                </div>
              </CardContent>
            </Card>
          </div>
        </div>
      )}
    </>
  );
};
</file>

<file path="src/app/_components/homepage/Benefits.tsx">
"use client";

import { CheckCircle, TrendingUp, LineChart } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Container } from "@/app/_components/common/Container";

const benefits = [
  "Reduce contract processing time by up to 80%",
  "Minimize risk with standardized templates and approval workflows",
  "Track and analyze contract metrics for better decision making",
  "Seamless external collaboration with secure sharing",
  "Automated compliance and audit trails",
];

export const Benefits = () => {
  return (
    <div id="benefits" className="py-24 sm:py-32 bg-muted/50">
      <Container>
        <div className="mb-16 flex flex-col items-center">
          <h2 className="text-3xl font-bold tracking-tight text-primary font-serif sm:text-4xl">
            Why Choose PactWise?
          </h2>
          <p className="mt-4 max-w-xl text-center text-muted-foreground">
            Discover how our platform transforms contract management and drives
            business value.
          </p>
        </div>

        <div className="grid gap-8 md:grid-cols-2">
          <Card className="hover:shadow-lg transition-shadow">
            <CardHeader>
              <CardTitle className="font-serif">Key Benefits</CardTitle>
            </CardHeader>
            <CardContent className="space-y-4">
              {benefits.map((benefit, index) => (
                <div key={index} className="flex items-start space-x-3">
                  <CheckCircle className="h-5 w-5 text-gold shrink-0 mt-0.5" />
                  <span className="text-muted-foreground">{benefit}</span>
                </div>
              ))}
            </CardContent>
          </Card>

          <Card className="hover:shadow-lg transition-shadow">
            <CardHeader>
              <CardTitle className="font-serif">Analytics & Insights</CardTitle>
            </CardHeader>
            <CardContent className="space-y-6">
              <div className="flex items-center space-x-4">
                <TrendingUp className="h-8 w-8 text-gold" />
                <div>
                  <h4 className="font-semibold">Performance Metrics</h4>
                  <p className="text-sm text-muted-foreground">
                    Track savings, processing times, and efficiency improvements
                  </p>
                </div>
              </div>

              <Separator />

              <div className="flex items-center space-x-4">
                <LineChart className="h-8 w-8 text-gold" />
                <div>
                  <h4 className="font-semibold">Insights Dashboard</h4>
                  <p className="text-sm text-muted-foreground">
                    Real-time analytics and reporting for better decision making
                  </p>
                </div>
              </div>

              {/* <div className="mt-6 rounded-lg bg-muted p-6 text-center">
                [Analytics Dashboard Preview]
              </div> */}
            </CardContent>
          </Card>
        </div>
      </Container>
    </div>
  );
};
</file>

<file path="src/app/auth/sign-in/page.tsx">
'use client';

import { SignIn } from "@clerk/clerk-react";

export default function SignInPage() {
  return (
    <div className="relative bg-gradient-to-b from-slate-50 to-transparent py-16 min-h-screen flex items-center justify-center">
      {/* Decorative elements */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-0 right-0 w-1/3 h-1/3 bg-gradient-to-br from-gold/10 to-transparent" />
        <div className="absolute bottom-0 left-0 w-1/4 h-1/4 bg-gradient-to-tr from-primary/5 to-transparent" />
        <div className="absolute top-1/4 left-1/3 w-1 h-16 bg-gold/30" />
        <div className="absolute top-1/2 right-1/4 w-24 h-1 bg-gold/20" />
      </div>
      
      <div className="max-w-md w-full relative z-10">
        <div className="mb-8 flex flex-col items-center text-center">
          <div className="mb-6 flex items-center justify-center">
            <span className="h-px w-8 bg-gold mx-3"></span>
            <span className="text-gold text-sm uppercase tracking-widest font-medium">Secure Access</span>
            <span className="h-px w-8 bg-gold mx-3"></span>
          </div>
          
          <h1 className="text-3xl font-bold tracking-tight text-primary font-serif sm:text-4xl">
            Sign 
            <span className="text-gold relative inline-block ml-2">
              In
              <span className="absolute -bottom-2 left-0 right-0 h-px bg-gradient-to-r from-transparent via-gold/70 to-transparent"></span>
            </span>
          </h1>
          
          <p className="mt-4 text-muted-foreground font-light">
            Access your contract management dashboard
          </p>
        </div>
        
        <div className="bg-white/90 backdrop-blur-sm shadow-luxury border border-gold/10 p-8 rounded-sm">
          <SignIn 
            routing="path" 
            path="/auth/sign-in" 
            signUpUrl="/auth/sign-up"
            forceRedirectUrl="/dashboard"
            fallbackRedirectUrl="/dashboard"
            appearance={{
              elements: {
                formButtonPrimary: 
                  "bg-primary hover:bg-primary/90 text-white group flex h-10 items-center justify-center rounded-sm px-4",
                formButtonIcon: "ml-2 h-4 w-4 transition-transform group-hover:translate-x-1",
                card: "shadow-none border-0",
                headerTitle: "hidden",
                headerSubtitle: "hidden",
                dividerLine: "bg-gold/20",
                dividerText: "text-gold",
                socialButtonsBlockButton: "border-gold/20 text-primary hover:bg-gold/5",
                formFieldInput: "border-gold/20 focus:border-gold focus:ring-gold/30",
                footerActionLink: "text-gold hover:text-gold-dark",
              }
            }}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/auth/sign-up/page.tsx">
'use client';

import { SignUp } from "@clerk/clerk-react";

export default function SignUpPage() {
  return (
    <div className="relative bg-gradient-to-b from-slate-50 to-transparent py-16 min-h-screen flex items-center justify-center">
      {/* Decorative elements */}
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute top-0 right-0 w-1/3 h-1/3 bg-gradient-to-br from-gold/10 to-transparent" />
        <div className="absolute bottom-0 left-0 w-1/4 h-1/4 bg-gradient-to-tr from-primary/5 to-transparent" />
        <div className="absolute top-1/4 left-1/3 w-1 h-16 bg-gold/30" />
        <div className="absolute top-1/2 right-1/4 w-24 h-1 bg-gold/20" />
      </div>
      
      <div className="max-w-md w-full relative z-10">
        <div className="mb-8 flex flex-col items-center text-center">
          <div className="mb-6 flex items-center justify-center">
            <span className="h-px w-8 bg-gold mx-3"></span>
            <span className="text-gold text-sm uppercase tracking-widest font-medium">Create Account</span>
            <span className="h-px w-8 bg-gold mx-3"></span>
          </div>
          
          <h1 className="text-3xl font-bold tracking-tight text-primary font-serif sm:text-4xl">
            Sign 
            <span className="text-gold relative inline-block ml-2">
              Up
              <span className="absolute -bottom-2 left-0 right-0 h-px bg-gradient-to-r from-transparent via-gold/70 to-transparent"></span>
            </span>
          </h1>
          
          <p className="mt-4 text-muted-foreground font-light">
            Join our contract management platform
          </p>
        </div>
        
        <div className="bg-white/90 backdrop-blur-sm shadow-luxury border border-gold/10 p-8 rounded-sm">
          <SignUp 
            routing="path" 
            path="/auth/sign-up" 
            signInUrl="/auth/sign-in"
            forceRedirectUrl="/dashboard"
            fallbackRedirectUrl="/dashboard"
            appearance={{
              elements: {
                formButtonPrimary: 
                  "bg-primary hover:bg-primary/90 text-white group flex h-10 items-center justify-center rounded-sm px-4",
                formButtonIcon: "ml-2 h-4 w-4 transition-transform group-hover:translate-x-1",
                card: "shadow-none border-0",
                headerTitle: "hidden",
                headerSubtitle: "hidden",
                dividerLine: "bg-gold/20",
                dividerText: "text-gold",
                socialButtonsBlockButton: "border-gold/20 text-primary hover:bg-gold/5",
                formFieldInput: "border-gold/20 focus:border-gold focus:ring-gold/30",
                footerActionLink: "text-gold hover:text-gold-dark",
              }
            }}
          />
        </div>
      </div>
    </div>
  );
}
</file>

<file path="src/app/dashboard/vendors/active/page.tsx">
'use client'

import React, { useMemo, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import useVendorStore from "@/stores/vendor-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { Button } from "@/components/ui/button";
import { PlusCircle } from "lucide-react";
import { VendorType } from "@/types/vendor.types";
import VendorForm from "@/app/_components/vendor/VendorForm";
import VendorDetailsModal from "@/app/_components/vendor/VendorDetailsModal";

const ActiveVendors = () => {
  const { vendors, addVendor, updateVendor } = useVendorStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();
  const [categoryFilter, setCategoryFilter] = useState<string>("all");
  const [isVendorFormOpen, setIsVendorFormOpen] = useState(false);
  const [selectedVendor, setSelectedVendor] = useState<VendorType | null>(null);
  const [isDetailsModalOpen, setIsDetailsModalOpen] = useState(false);
  const [loading, setLoading] = useState(false);

  // Filter only active vendors based on search and category
  const filteredVendors = useMemo(() => {
    return vendors.filter((vendor) => {
      // First filter for active status
      if (vendor.status !== "active") return false;

      const matchesSearch =
        !searchQuery ||
        vendor.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        vendor.vendor_number
          ?.toLowerCase()
          .includes(searchQuery.toLowerCase()) ||
        vendor.contactEmail?.toLowerCase().includes(searchQuery.toLowerCase());

      const matchesCategory =
        categoryFilter === "all" || vendor.category === categoryFilter;

      return matchesSearch && matchesCategory;
    });
  }, [vendors, searchQuery, categoryFilter]);

  // Calculate active vendor statistics
  const stats = useMemo(() => {
    const totalSpend = filteredVendors.reduce(
      (sum, vendor) => sum + (vendor.total_spend || 0),
      0
    );

    const averageComplianceScore =
      filteredVendors.reduce(
        (sum, vendor) => sum + (vendor.compliance_score || 0),
        0
      ) / (filteredVendors.length || 1);

    return {
      total: filteredVendors.length,
      totalSpend,
      averageCompliance: Math.round(averageComplianceScore),
      criticalCount: filteredVendors.filter((v) => v.risk_level === "high")
        .length,
      contractCount: filteredVendors.reduce(
        (sum, v) => sum + (v.active_contracts || 0),
        0
      ),
    };
  }, [filteredVendors]);

  const handleCreateVendor = async (vendorData: Partial<VendorType>) => {
    setLoading(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const newVendor: VendorType = {
        _id: `vendor-${Date.now()}` as any,
        enterpriseId: "enterprise-1" as any,
        name: vendorData.name || "",
        contactEmail: vendorData.contactEmail,
        contactPhone: vendorData.contactPhone,
        address: vendorData.address,
        website: vendorData.website,
        category: vendorData.category,
        status: "active",
        notes: vendorData.notes,
        vendor_number: `VND-${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`,
        total_spend: 0,
        active_contracts: 0,
        risk_level: "low",
        compliance_score: 85,
        _creationTime: Date.now(),
      };

      addVendor(newVendor);
    } finally {
      setLoading(false);
    }
  };

  const handleEditVendor = async (vendorData: Partial<VendorType>) => {
    if (!selectedVendor) return;
    
    setLoading(true);
    try {
      await new Promise(resolve => setTimeout(resolve, 1000));
      updateVendor(selectedVendor._id as any, vendorData);
      setSelectedVendor({ ...selectedVendor, ...vendorData } as VendorType);
    } finally {
      setLoading(false);
    }
  };

  const handleViewVendor = (vendor: VendorType) => {
    setSelectedVendor(vendor);
    setIsDetailsModalOpen(true);
  };

  const handleUpdateVendor = (updatedVendor: VendorType) => {
    setSelectedVendor(updatedVendor);
  };

  return (
    <div className="space-y-6 p-6">
      {/* Header with Stats */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold ">Active Vendors</h2>
        <Button 
          className='cursor-pointer'
          onClick={() => setIsVendorFormOpen(true)}
        >
          <PlusCircle className="mr-2 h-4 w-4" />
          New Vendor
        </Button>
      </div>

      {/* Active Vendor Statistics */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Active Vendors
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Active Spend</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${stats.totalSpend.toLocaleString()}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Active Contracts
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.contractCount}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Avg Compliance
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.averageCompliance}%</div>
          </CardContent>
        </Card>
      </div>

      {/* Filters */}
      <div className="flex items-center space-x-4">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search active vendors..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
        <Select value={categoryFilter} onValueChange={setCategoryFilter} >
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Filter by category" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Categories</SelectItem>
            <SelectItem value="technology">Technology</SelectItem>
            <SelectItem value="services">Services</SelectItem>
            <SelectItem value="manufacturing">Manufacturing</SelectItem>
            <SelectItem value="consulting">Consulting</SelectItem>
            <SelectItem value="supplies">Supplies</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Active Vendors Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {filteredVendors.map((vendor) => (
          <Card
            key={vendor._id}
            className="hover:shadow-lg transition-shadow cursor-pointer"
            onClick={() => handleViewVendor(vendor)}
          >
            <CardHeader>
              <CardTitle className="text-lg font-medium">
                {vendor.name}
              </CardTitle>
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">
                  #{vendor.vendor_number}
                </span>
                <span className="text-sm px-2 py-1 rounded-full bg-green-100 text-green-800">
                  Active
                </span>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Category:
                  </span>
                  <span className="font-medium">{vendor.category}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Active Contracts:
                  </span>
                  <span className="font-medium">
                    {vendor.active_contracts || 0}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Current Spend:
                  </span>
                  <span className="font-medium">
                    ${vendor.total_spend?.toLocaleString() || 0}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Compliance Score:
                  </span>
                  <span
                    className={`font-medium ${
                      (vendor.compliance_score || 0) >= 80
                        ? "text-green-600"
                        : (vendor.compliance_score || 0) >= 60
                        ? "text-yellow-600"
                        : "text-red-600"
                    }`}
                  >
                    {vendor.compliance_score || 0}%
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
        {filteredVendors.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No active vendors found
          </div>
        )}
      </div>

      {/* Vendor Form Modal */}
      <VendorForm
        open={isVendorFormOpen}
        onOpenChange={setIsVendorFormOpen}
        onSubmit={handleCreateVendor}
        loading={loading}
      />

      {/* Vendor Details Modal */}
      <VendorDetailsModal
        open={isDetailsModalOpen}
        onOpenChange={setIsDetailsModalOpen}
        vendor={selectedVendor}
        onEditVendor={handleEditVendor}
        onUpdateVendor={handleUpdateVendor}
      />
    </div>
  );
};

export default ActiveVendors;
</file>

<file path="src/app/dashboard/vendors/page.tsx">
'use client'

import React, { useMemo, useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import useVendorStore from "@/stores/vendor-store";
import { useDashboardStore } from "@/stores/dashboard-store";
import { Button } from "@/components/ui/button";
import { PlusCircle } from "lucide-react";
import { VendorType } from "@/types/vendor.types";
import VendorForm from "@/app/_components/vendor/VendorForm";
import VendorDetailsModal from "@/app/_components/vendor/VendorDetailsModal";

const AllVendors = () => {
  const { vendors, addVendor, updateVendor } = useVendorStore();
  const { searchQuery, setSearchQuery } = useDashboardStore();
  const [categoryFilter, setCategoryFilter] = useState<string>("all");
  const [isVendorFormOpen, setIsVendorFormOpen] = useState(false);
  const [selectedVendor, setSelectedVendor] = useState<VendorType | null>(null);
  const [isDetailsModalOpen, setIsDetailsModalOpen] = useState(false);
  const [loading, setLoading] = useState(false);

  // Filter vendors based on search and category
  const filteredVendors = useMemo(() => {
    return vendors.filter((vendor: VendorType) => {
      const matchesSearch =
        !searchQuery ||
        vendor.name.toLowerCase().includes(searchQuery.toLowerCase()) ||
        vendor.vendor_number
          ?.toLowerCase()
          .includes(searchQuery.toLowerCase()) ||
        vendor.email?.toLowerCase().includes(searchQuery.toLowerCase());

      const matchesCategory =
        categoryFilter === "all" || vendor.category === categoryFilter;

      return matchesSearch && matchesCategory;
    });
  }, [vendors, searchQuery, categoryFilter]);

  // Calculate vendor statistics
  const stats = useMemo(() => {
    const totalSpend = filteredVendors.reduce(
      (sum, vendor) => sum + (vendor.total_spend || 0),
      0
    );

    return {
      total: filteredVendors.length,
      totalSpend,
      activeCount: filteredVendors.filter((v) => v.status === "active").length,
      criticalCount: filteredVendors.filter((v) => v.risk_level === "high")
        .length,
      contractCount: filteredVendors.reduce(
        (sum, v) => sum + (v.active_contracts || 0),
        0
      ),
    };
  }, [filteredVendors]);

  const handleCreateVendor = async (vendorData: Partial<VendorType>) => {
    setLoading(true);
    try {
      // In a real app, this would make an API call to create the vendor
      // For now, we'll simulate it with a timeout and add to store
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      const newVendor: VendorType = {
        _id: `vendor-${Date.now()}` as any,
        enterpriseId: "enterprise-1" as any,
        name: vendorData.name || "",
        contactEmail: vendorData.contactEmail,
        contactPhone: vendorData.contactPhone,
        address: vendorData.address,
        website: vendorData.website,
        category: vendorData.category,
        status: vendorData.status || "active",
        notes: vendorData.notes,
        vendor_number: `VND-${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`,
        total_spend: 0,
        active_contracts: 0,
        risk_level: "low",
        compliance_score: 85,
        _creationTime: Date.now(),
      };

      addVendor(newVendor);
    } finally {
      setLoading(false);
    }
  };

  const handleEditVendor = async (vendorData: Partial<VendorType>) => {
    if (!selectedVendor) return;
    
    setLoading(true);
    try {
      // In a real app, this would make an API call to update the vendor
      await new Promise(resolve => setTimeout(resolve, 1000));
      
      updateVendor(selectedVendor._id as any, vendorData);
      setSelectedVendor({ ...selectedVendor, ...vendorData } as VendorType);
    } finally {
      setLoading(false);
    }
  };

  const handleViewVendor = (vendor: VendorType) => {
    setSelectedVendor(vendor);
    setIsDetailsModalOpen(true);
  };

  const handleUpdateVendor = (updatedVendor: VendorType) => {
    setSelectedVendor(updatedVendor);
  };

  return (
    <div className="space-y-6 p-6">
      {/* Header with Stats */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">All Vendors</h2>
        <Button 
          className='cursor-pointer'
          onClick={() => setIsVendorFormOpen(true)}
        >
          <PlusCircle className="mr-2 h-4 w-4" />
          New Vendor
        </Button>
      </div>

      {/* Vendor Statistics */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Vendors</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Spend</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">
              ${stats.totalSpend.toLocaleString()}
            </div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Active Contracts
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.contractCount}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">
              Critical Vendors
            </CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.criticalCount}</div>
          </CardContent>
        </Card>
      </div>

      {/* Filters */}
      <div className="flex items-center space-x-4">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search vendors..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
        <Select value={categoryFilter} onValueChange={setCategoryFilter}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Filter by category" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Categories</SelectItem>
            <SelectItem value="technology">Technology</SelectItem>
            <SelectItem value="services">Services</SelectItem>
            <SelectItem value="manufacturing">Manufacturing</SelectItem>
            <SelectItem value="consulting">Consulting</SelectItem>
            <SelectItem value="supplies">Supplies</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Vendors Grid */}
      <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
        {filteredVendors.map((vendor) => (
          <Card
            key={vendor._id}
            className="hover:shadow-lg transition-shadow cursor-pointer"
            onClick={() => handleViewVendor(vendor)}
          >
            <CardHeader>
              <CardTitle className="text-lg font-medium">
                {vendor.name}
              </CardTitle>
              <div className="flex justify-between items-center">
                <span className="text-sm text-muted-foreground">
                  #{vendor.vendor_number}
                </span>
                <span
                  className={`text-sm px-2 py-1 rounded-full ${
                    vendor.status === "active"
                      ? "bg-green-100 text-green-800"
                      : vendor.status === "pending"
                      ? "bg-yellow-100 text-yellow-800"
                      : "bg-gray-100 text-gray-800"
                  }`}
                >
                  {vendor.status}
                </span>
              </div>
            </CardHeader>
            <CardContent>
              <div className="space-y-2">
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Category:
                  </span>
                  <span className="font-medium">{vendor.category}</span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Active Contracts:
                  </span>
                  <span className="font-medium">
                    {vendor.active_contracts || 0}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Total Spend:
                  </span>
                  <span className="font-medium">
                    ${vendor.total_spend?.toLocaleString() || 0}
                  </span>
                </div>
                <div className="flex justify-between">
                  <span className="text-sm text-muted-foreground">
                    Risk Level:
                  </span>
                  <span
                    className={`font-medium ${
                      vendor.risk_level === "high"
                        ? "text-red-600"
                        : vendor.risk_level === "medium"
                        ? "text-yellow-600"
                        : "text-green-600"
                    }`}
                  >
                    {vendor.risk_level?.toUpperCase()}
                  </span>
                </div>
              </div>
            </CardContent>
          </Card>
        ))}
        {filteredVendors.length === 0 && (
          <div className="col-span-full text-center py-10 text-muted-foreground">
            No vendors found
          </div>
        )}
      </div>

      {/* Vendor Form Modal */}
      <VendorForm
        open={isVendorFormOpen}
        onOpenChange={setIsVendorFormOpen}
        onSubmit={handleCreateVendor}
        loading={loading}
      />

      {/* Vendor Details Modal */}
      <VendorDetailsModal
        open={isDetailsModalOpen}
        onOpenChange={setIsDetailsModalOpen}
        vendor={selectedVendor}
        onEditVendor={handleEditVendor}
        onUpdateVendor={handleUpdateVendor}
      />
    </div>
  );
};

export default AllVendors;
</file>

<file path="src/components/ui/button.tsx">
import * as React from "react"
import { Slot } from "@radix-ui/react-slot"
import { cva, type VariantProps } from "class-variance-authority"

import { cn } from "@/lib/utils"

const buttonVariants = cva(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-all disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg:not([class*='size-'])]:size-4 shrink-0 [&_svg]:shrink-0 outline-none focus-visible:border-ring focus-visible:ring-ring/50 focus-visible:ring-[3px] aria-invalid:ring-destructive/20 dark:aria-invalid:ring-destructive/40 aria-invalid:border-destructive",
  {
    variants: {
      variant: {
        default:
          "bg-primary text-primary-foreground shadow-xs hover:bg-primary/90",
        destructive:
          "bg-destructive text-white shadow-xs hover:bg-destructive/90 focus-visible:ring-destructive/20 dark:focus-visible:ring-destructive/40 dark:bg-destructive/60",
        outline:
          "border bg-background shadow-xs hover:bg-accent hover:text-accent-foreground dark:bg-input/30 dark:border-input dark:hover:bg-input/50",
        secondary:
          "bg-secondary text-secondary-foreground shadow-xs hover:bg-secondary/80",
        ghost:
          "hover:bg-accent hover:text-accent-foreground dark:hover:bg-accent/50",
        link: "text-primary underline-offset-4 hover:underline",
      },
      size: {
        default: "h-9 px-4 py-2 has-[>svg]:px-3",
        sm: "h-8 rounded-md gap-1.5 px-3 has-[>svg]:px-2.5",
        lg: "h-10 rounded-md px-6 has-[>svg]:px-4",
        icon: "size-9",
      },
    },
    defaultVariants: {
      variant: "default",
      size: "default",
    },
  }
)

function Button({
  className,
  variant,
  size,
  asChild = false,
  ...props
}: React.ComponentProps<"button"> &
  VariantProps<typeof buttonVariants> & {
    asChild?: boolean
  }) {
  const Comp = asChild ? Slot : "button"

  return (
    <Comp
      data-slot="button"
      className={cn(buttonVariants({ variant, size, className }))}
      {...props}
    />
  )
}

export { Button, buttonVariants }
</file>

<file path="src/lib/monitoring.ts">
'use client';

import { getCLS, getFID, getFCP, getLCP, getTTFB, onCLS, onFCP, onFID, onLCP, onTTFB } from 'web-vitals';

// Web Vitals tracking
interface WebVitalsMetric {
  name: string;
  value: number;
  rating: 'good' | 'needs-improvement' | 'poor';
  delta: number;
  id: string;
  navigationType: string;
}

// Performance tracking store
class PerformanceTracker {
  private metrics: Map<string, WebVitalsMetric> = new Map();
  private observers: Array<(metric: WebVitalsMetric) => void> = [];

  constructor() {
    if (typeof window !== 'undefined') {
      this.initializeWebVitals();
    }
  }

  private initializeWebVitals() {
    // Track Core Web Vitals
    onCLS((metric) => this.handleMetric({ ...metric, name: 'CLS' }));
    onFID((metric) => this.handleMetric({ ...metric, name: 'FID' }));
    onLCP((metric) => this.handleMetric({ ...metric, name: 'LCP' }));
    onFCP((metric) => this.handleMetric({ ...metric, name: 'FCP' }));
    onTTFB((metric) => this.handleMetric({ ...metric, name: 'TTFB' }));
  }

  private handleMetric(metric: WebVitalsMetric) {
    this.metrics.set(metric.name, metric);
    
    // Notify observers
    this.observers.forEach(callback => callback(metric));
    
    // Log to console in development
    if (process.env.NODE_ENV === 'development') {
      console.log(`Web Vital - ${metric.name}:`, metric);
    }
    
    // Send to analytics service
    this.sendToAnalytics(metric);
  }

  private sendToAnalytics(metric: WebVitalsMetric) {
    // In production, send to your analytics service
    // Example: Google Analytics, Mixpanel, or custom endpoint
    
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', metric.name, {
        custom_parameter_1: metric.value,
        custom_parameter_2: metric.rating,
      });
    }
    
    // Send to Convex analytics
    if (typeof window !== 'undefined') {
      this.sendEventToConvex('web_vital', {
        name: metric.name,
        value: metric.value,
        rating: metric.rating,
        delta: metric.delta,
        navigationType: metric.navigationType,
      });
    }
    
    // Store locally for development
    if (process.env.NODE_ENV === 'development') {
      const vitals = JSON.parse(localStorage.getItem('web_vitals') || '[]');
      vitals.push({
        ...metric,
        timestamp: Date.now(),
        url: window.location.href,
      });
      // Keep only last 50 metrics
      if (vitals.length > 50) {
        vitals.splice(0, vitals.length - 50);
      }
      localStorage.setItem('web_vitals', JSON.stringify(vitals));
    }
  }

  private sendEventToConvex(event: string, properties: Record<string, unknown>) {
    // This will be called by the ConvexClientProvider
    if (typeof window !== 'undefined' && (window as any).convexAnalytics) {
      (window as any).convexAnalytics.logEvent(event, properties);
    }
  }

  public subscribe(callback: (metric: WebVitalsMetric) => void) {
    this.observers.push(callback);
    return () => {
      const index = this.observers.indexOf(callback);
      if (index > -1) {
        this.observers.splice(index, 1);
      }
    };
  }

  public getMetrics(): Map<string, WebVitalsMetric> {
    return new Map(this.metrics);
  }

  public getMetric(name: string): WebVitalsMetric | undefined {
    return this.metrics.get(name);
  }
}

// Global performance tracker instance
export const performanceTracker = new PerformanceTracker();

// User behavior analytics
interface UserEvent {
  event: string;
  timestamp: number;
  url: string;
  userId?: string;
  properties?: Record<string, any>;
  sessionId: string;
}

class UserAnalytics {
  private sessionId: string;
  private events: UserEvent[] = [];
  private sessionStart: number;

  constructor() {
    this.sessionId = this.generateSessionId();
    this.sessionStart = Date.now();
    
    if (typeof window !== 'undefined') {
      this.initializeTracking();
    }
  }

  private generateSessionId(): string {
    return `session_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
  }

  private initializeTracking() {
    // Track page views
    this.track('page_view', {
      page: window.location.pathname,
      referrer: document.referrer,
    });

    // Track clicks on important elements
    document.addEventListener('click', (event) => {
      const target = event.target as HTMLElement;
      if (target.matches('button, a, [data-track]')) {
        this.track('click', {
          element: target.tagName.toLowerCase(),
          text: target.textContent?.slice(0, 100),
          dataTrack: target.getAttribute('data-track'),
        });
      }
    });

    // Track form submissions
    document.addEventListener('submit', (event) => {
      const form = event.target as HTMLFormElement;
      this.track('form_submit', {
        formId: form.id,
        formName: form.name,
        action: form.action,
      });
    });

    // Track navigation timing
    window.addEventListener('load', () => {
      setTimeout(() => {
        const navigation = performance.getEntriesByType('navigation')[0] as PerformanceNavigationTiming;
        this.track('page_load_complete', {
          loadTime: navigation.loadEventEnd - navigation.loadEventStart,
          domContentLoaded: navigation.domContentLoadedEventEnd - navigation.domContentLoadedEventStart,
          totalTime: navigation.loadEventEnd - navigation.fetchStart,
        });
      }, 0);
    });

    // Track session duration on page unload
    window.addEventListener('beforeunload', () => {
      this.track('session_end', {
        duration: Date.now() - this.sessionStart,
        eventsCount: this.events.length,
      });
      this.flush();
    });
  }

  public track(event: string, properties?: Record<string, any>, userId?: string) {
    const userEvent: UserEvent = {
      event,
      timestamp: Date.now(),
      url: typeof window !== 'undefined' ? window.location.href : '',
      userId,
      properties,
      sessionId: this.sessionId,
    };

    this.events.push(userEvent);

    // Log in development
    if (process.env.NODE_ENV === 'development') {
      console.log('User Event:', userEvent);
    }

    // Store events locally
    this.storeEvent(userEvent);

    // Send to analytics service (in production)
    this.sendEvent(userEvent);
  }

  private storeEvent(event: UserEvent) {
    if (typeof window === 'undefined') return;

    const events = JSON.parse(localStorage.getItem('user_events') || '[]');
    events.push(event);
    
    // Keep only last 100 events
    if (events.length > 100) {
      events.splice(0, events.length - 100);
    }
    
    localStorage.setItem('user_events', JSON.stringify(events));
  }

  private sendEvent(event: UserEvent) {
    // In production, send to your analytics service
    // Example implementations:
    
    // Google Analytics
    if (typeof window !== 'undefined' && window.gtag) {
      window.gtag('event', event.event, {
        custom_parameter_1: event.properties,
        user_id: event.userId,
      });
    }

    // Send to Convex
    if (typeof window !== 'undefined' && (window as any).convexAnalytics) {
      (window as any).convexAnalytics.logEvent(event.event, {
        ...event.properties,
        timestamp: event.timestamp,
        url: event.url,
        sessionId: event.sessionId,
        userId: event.userId,
      });
    }
  }

  public flush() {
    // Send any pending events
    if (this.events.length > 0) {
      const eventsToSend = [...this.events];
      this.events = [];
      
      // Send batch of events to Convex
      if (typeof window !== 'undefined' && (window as any).convexAnalytics) {
        (window as any).convexAnalytics.logEventBatch(eventsToSend);
      }
    }
  }

  public getSessionId(): string {
    return this.sessionId;
  }

  public getEvents(): UserEvent[] {
    return [...this.events];
  }
}

// Global user analytics instance
export const userAnalytics = new UserAnalytics();

// Error tracking
interface ErrorReport {
  error: Error;
  errorInfo?: any;
  timestamp: number;
  url: string;
  userId?: string;
  sessionId: string;
  userAgent: string;
  context?: Record<string, any>;
}

class ErrorTracker {
  private errors: ErrorReport[] = [];

  constructor() {
    if (typeof window !== 'undefined') {
      this.initializeErrorTracking();
    }
  }

  private initializeErrorTracking() {
    // Track unhandled errors
    window.addEventListener('error', (event) => {
      this.captureError(new Error(event.message), {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
      });
    });

    // Track unhandled promise rejections
    window.addEventListener('unhandledrejection', (event) => {
      this.captureError(
        event.reason instanceof Error ? event.reason : new Error(String(event.reason)),
        { type: 'unhandledrejection' }
      );
    });
  }

  public captureError(error: Error, context?: Record<string, any>, userId?: string) {
    const errorReport: ErrorReport = {
      error,
      timestamp: Date.now(),
      url: typeof window !== 'undefined' ? window.location.href : '',
      userId,
      sessionId: userAnalytics.getSessionId(),
      userAgent: typeof window !== 'undefined' ? navigator.userAgent : '',
      context,
    };

    this.errors.push(errorReport);

    // Log in development
    if (process.env.NODE_ENV === 'development') {
      console.error('Error captured:', errorReport);
    }

    // Send to error tracking service
    this.sendError(errorReport);
  }

  private sendError(errorReport: ErrorReport) {
    // Send to Sentry (if configured)
    this.sendToSentry(errorReport);

    // Send to Convex
    if (typeof window !== 'undefined' && (window as any).convexAnalytics) {
      (window as any).convexAnalytics.reportError({
        message: errorReport.error.message,
        stack: errorReport.error.stack,
        timestamp: errorReport.timestamp,
        url: errorReport.url,
        userId: errorReport.userId,
        sessionId: errorReport.sessionId,
        userAgent: errorReport.userAgent,
        context: errorReport.context,
      });
    }
  }

  private async sendToSentry(errorReport: ErrorReport) {
    if (typeof window === 'undefined') return;

    try {
      const Sentry = await import('@sentry/nextjs');
      
      // Set user context
      Sentry.setUser({
        id: errorReport.userId || 'anonymous',
        ip_address: '{{auto}}',
      });

      // Set additional context
      Sentry.setContext('error_report', {
        timestamp: errorReport.timestamp,
        sessionId: errorReport.sessionId,
        url: errorReport.url,
        userAgent: errorReport.userAgent,
      });

      // Set tags
      Sentry.setTags({
        source: 'error_tracker',
        environment: process.env.NODE_ENV || 'development',
      });

      // Capture exception with context
      Sentry.captureException(errorReport.error, {
        contexts: {
          errorReport: errorReport.context,
        },
        extra: {
          timestamp: errorReport.timestamp,
          sessionId: errorReport.sessionId,
          url: errorReport.url,
        },
        fingerprint: [
          errorReport.error.name,
          errorReport.error.message,
          errorReport.url,
        ],
      });
    } catch (sentryError) {
      console.error('Failed to send error to Sentry:', sentryError);
    }
  }

  public getErrors(): ErrorReport[] {
    return [...this.errors];
  }
}

// Global error tracker instance
export const errorTracker = new ErrorTracker();

// Health check monitoring
class HealthMonitor {
  private checks: Map<string, boolean> = new Map();
  private checkInterval: NodeJS.Timeout | null = null;

  constructor() {
    if (typeof window !== 'undefined') {
      this.startHealthChecks();
    }
  }

  private startHealthChecks() {
    // Run health checks every 5 minutes
    this.checkInterval = setInterval(() => {
      this.runHealthChecks();
    }, 5 * 60 * 1000);

    // Run initial health check
    this.runHealthChecks();
  }

  private async runHealthChecks() {
    // Check Convex connectivity
    try {
      if (typeof window !== 'undefined' && (window as any).convexAnalytics) {
        const healthStatus = await (window as any).convexAnalytics.getHealthStatus();
        this.checks.set('convex', healthStatus.status === 'healthy');
      } else {
        this.checks.set('convex', false);
      }
    } catch {
      this.checks.set('convex', false);
    }

    // Check local storage
    try {
      localStorage.setItem('health_check', Date.now().toString());
      const value = localStorage.getItem('health_check');
      this.checks.set('localStorage', value !== null);
    } catch {
      this.checks.set('localStorage', false);
    }

    // Check memory usage (if available)
    if ('memory' in performance) {
      const memory = (performance as { memory?: { usedJSHeapSize: number; jsHeapSizeLimit: number } }).memory;
      if (memory) {
        const memoryUsage = memory.usedJSHeapSize / memory.jsHeapSizeLimit;
        this.checks.set('memory', memoryUsage < 0.9); // Alert if > 90% memory usage
      }
    }

    // Report unhealthy checks
    const unhealthyChecks = Array.from(this.checks.entries())
      .filter(([_, healthy]) => !healthy)
      .map(([check]) => check);

    if (unhealthyChecks.length > 0) {
      errorTracker.captureError(
        new Error(`Health check failures: ${unhealthyChecks.join(', ')}`),
        { type: 'health_check', unhealthyChecks }
      );
    }
  }

  public getHealthStatus(): Record<string, boolean> {
    return Object.fromEntries(this.checks);
  }

  public isHealthy(): boolean {
    return Array.from(this.checks.values()).every(healthy => healthy);
  }

  public destroy() {
    if (this.checkInterval) {
      clearInterval(this.checkInterval);
    }
  }
}

// Global health monitor instance
export const healthMonitor = new HealthMonitor();

// Performance measurement utilities
export const measurePerformance = {
  // Measure component render time
  measureRender: (componentName: string, renderFn: () => void) => {
    const start = performance.now();
    renderFn();
    const end = performance.now();
    
    userAnalytics.track('component_render', {
      component: componentName,
      renderTime: end - start,
    });
  },

  // Measure async operation time
  measureAsync: async <T>(operationName: string, operation: () => Promise<T>): Promise<T> => {
    const start = performance.now();
    try {
      const result = await operation();
      const end = performance.now();
      
      userAnalytics.track('async_operation', {
        operation: operationName,
        duration: end - start,
        success: true,
      });
      
      return result;
    } catch (error) {
      const end = performance.now();
      
      userAnalytics.track('async_operation', {
        operation: operationName,
        duration: end - start,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      });
      
      throw error;
    }
  },

  // Measure Convex function call performance
  measureConvexCall: async <T>(functionName: string, operation: () => Promise<T>): Promise<T> => {
    const start = performance.now();
    
    try {
      const result = await operation();
      const end = performance.now();
      
      userAnalytics.track('convex_call', {
        function: functionName,
        duration: end - start,
        success: true,
      });
      
      return result;
    } catch (error) {
      const end = performance.now();
      
      userAnalytics.track('convex_call', {
        function: functionName,
        duration: end - start,
        success: false,
        error: error instanceof Error ? error.message : String(error),
      });
      
      throw error;
    }
  },
};

// Enhanced error reporting function with Sentry integration
export const reportError = async (
  error: Error | string,
  context?: {
    contexts?: Record<string, any>;
    tags?: Record<string, string>;
    extra?: Record<string, any>;
    user?: { id?: string; email?: string; username?: string };
    level?: 'fatal' | 'error' | 'warning' | 'info' | 'debug';
    fingerprint?: string[];
  }
) => {
  if (typeof window === 'undefined') return;

  const errorObj = typeof error === 'string' ? new Error(error) : error;

  try {
    const Sentry = await import('@sentry/nextjs');
    
    // Set user context if provided
    if (context?.user) {
      Sentry.setUser(context.user);
    }

    // Set additional contexts
    if (context?.contexts) {
      Object.entries(context.contexts).forEach(([key, value]) => {
        Sentry.setContext(key, value);
      });
    }

    // Set tags
    if (context?.tags) {
      Sentry.setTags(context.tags);
    }

    // Capture exception
    Sentry.captureException(errorObj, {
      level: context?.level || 'error',
      extra: context?.extra,
      fingerprint: context?.fingerprint,
    });
  } catch (sentryError) {
    console.error('Failed to report error to Sentry:', sentryError);
    // Fall back to error tracker
    errorTracker.captureError(errorObj, context?.extra);
  }
};

// Enhanced performance monitoring
export const reportPerformance = async (
  metric: {
    name: string;
    value: number;
    unit?: string;
    tags?: Record<string, string>;
  }
) => {
  if (typeof window === 'undefined') return;

  try {
    const Sentry = await import('@sentry/nextjs');
    
    // Send custom metric to Sentry
    Sentry.addBreadcrumb({
      category: 'performance',
      message: `${metric.name}: ${metric.value}${metric.unit || ''}`,
      level: 'info',
      data: metric.tags,
    });

    // Also track via user analytics
    userAnalytics.track('performance_metric', {
      metric_name: metric.name,
      metric_value: metric.value,
      metric_unit: metric.unit,
      ...metric.tags,
    });
  } catch (error) {
    console.error('Failed to report performance metric:', error);
  }
};

// Type declarations for global objects
declare global {
  interface Window {
    gtag?: (...args: unknown[]) => void;
    Sentry?: {
      captureException: (error: Error, context?: Record<string, unknown>) => void;
    };
  }
}
</file>

<file path="src/stores/vendor-store.ts">
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { VendorType } from "@/types/vendor.types";

interface VendorState {
  vendors: VendorType[];
  loading: boolean;
  error: string | null;

  // Vendor CRUD operations
  setVendors: (vendors: VendorType[]) => void;
  addVendor: (vendor: VendorType) => void;
  updateVendor: (id: string, vendor: Partial<VendorType>) => void;
  deleteVendor: (id: string) => void;
  fetchMoreVendors: (page: number) => Promise<void>;

  // Loading and error states
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;

  // Additional vendor-specific operations
  updateVendorStatus: (id: string, status: VendorType["status"]) => void;
  updateRiskLevel: (id: string, riskLevel: VendorType["risk_level"]) => void;
  updateComplianceScore: (id: string, score: number) => void;
  updateActiveContracts: (id: string, count: number) => void;
  addVendorSpend: (id: string, amount: number) => void;
}

const useVendorStore = create<VendorState>()(
  devtools(
    (set) => ({
      // Initial state
      vendors: [],
      loading: false,
      error: null,

      // Core actions
      setVendors: (vendors) => set({ vendors }),
      setLoading: (loading) => set({ loading }),
      setError: (error) => set({ error }),

      // CRUD operations
      addVendor: (vendor) => {
        set((state) => ({
          vendors: [...state.vendors, vendor],
        }));
      },

      updateVendor: (id, updatedVendor) => {
        set((state) => ({
          vendors: state.vendors.map((vendor) =>
            vendor._id === id ? { ...vendor, ...updatedVendor } : vendor
          ),
        }));
      },

      deleteVendor: (id) => {
        set((state) => ({
          vendors: state.vendors.filter((vendor) => vendor._id !== id),
        }));
      },

      fetchMoreVendors: async (page: number) => {
        try {
          set({ loading: true });
          const response = await fetch(`/api/vendors?page=${page}`);
          const newVendors = await response.json();
          set((state) => ({
            vendors: [...state.vendors, ...newVendors],
            loading: false,
          }));
        } catch (error) {
          set({ error: (error as Error).message, loading: false });
        }
      },

      // Additional vendor-specific operations
      updateVendorStatus: (id, status) => {
        set((state) => ({
          vendors: state.vendors.map((vendor) =>
            vendor._id === id ? { ...vendor, status } : vendor
          ),
        }));
      },

      updateRiskLevel: (id, riskLevel) => {
        set((state) => ({
          vendors: state.vendors.map((vendor) =>
            vendor._id === id ? { ...vendor, risk_level: riskLevel } : vendor
          ),
        }));
      },

      updateComplianceScore: (id, score) => {
        set((state) => ({
          vendors: state.vendors.map((vendor) =>
            vendor._id === id ? { ...vendor, compliance_score: score } : vendor
          ),
        }));
      },

      updateActiveContracts: (id, count) => {
        set((state) => ({
          vendors: state.vendors.map((vendor) =>
            vendor._id === id ? { ...vendor, active_contracts: count } : vendor
          ),
        }));
      },

      addVendorSpend: (id, amount) => {
        set((state) => ({
          vendors: state.vendors.map((vendor) =>
            vendor._id === id
              ? { ...vendor, total_spend: (vendor.total_spend || 0) + amount }
              : vendor
          ),
        }));
      },
    }),
    {
      name: "vendor-store",
    }
  )
);

export default useVendorStore;
</file>

<file path="src/types/agents.types.ts">
// src/types/agents.types.ts
import { Id } from "../../convex/_generated/dataModel"; // Assuming this path is correct

// ============================================================================
// CORE AGENT ENUMS AND CONSTANTS
// (Derived from your agent-schema.ts and discussion)
// ============================================================================

/** Agent system status options */
export const agentSystemStatusOptions = [
  "stopped", "starting", "running", "paused", "error"
] as const;
export type AgentSystemStatus = typeof agentSystemStatusOptions[number];

/** Individual agent status options */
export const agentStatusOptions = [
  "inactive", "active", "busy", "error", "disabled"
] as const;
export type AgentStatus = typeof agentStatusOptions[number];

/** Agent types/roles in the system - **Ensure this matches agent-schema.ts** */
export const agentTypeOptions = [
  "manager",        // System coordination and management
  "secretary",      // Administrative tasks and notifications
  "financial",      // Financial analysis and reporting
  "notifications",  // Communication and alerts
  "legal",          // Legal compliance and risk assessment
  "analytics",      // Data analysis and insights
  "workflow",       // Process automation and orchestration
  "compliance",     // Regulatory compliance monitoring
  "risk",           // Risk assessment and management
  "audit",          // Audit trail and reporting
  "integration",    // Third-party system integrations
  "scheduler",      // Task scheduling and timing
  "backup",         // Data backup and recovery
  "monitor",        // System health and performance monitoring
] as const;
export type AgentType = typeof agentTypeOptions[number];

/** Insight/analysis types - **Ensure this matches agent-schema.ts** */
export const insightTypeOptions = [
  "contract_analysis",    // Contract content analysis
  "financial_risk",       // Financial risk assessment
  "expiration_warning",   // Contract expiration alerts
  "legal_review",         // Legal compliance issues
  "compliance_alert",     // Regulatory compliance warnings
  "performance_metric",   // Performance and KPI insights
  "cost_optimization",    // Cost-saving opportunities
  "vendor_risk",          // Vendor risk assessment
  "renewal_opportunity",  // Contract renewal suggestions
  "negotiation_insight",  // Contract negotiation recommendations
  "audit_finding",        // Audit-related discoveries
  "anomaly_detection",    // Unusual patterns or outliers
  "trend_analysis",       // Historical trend insights
  "recommendation",       // General recommendations
  "alert",                // General system alerts
  "report",               // Automated reports
] as const;
export type InsightType = typeof insightTypeOptions[number];

/** Task status for agent task queue - **Ensure this matches agent-schema.ts** */
export const taskStatusOptions = [
  "pending", "in_progress", "completed", "failed", "cancelled", "timeout"
] as const;
export type TaskStatus = typeof taskStatusOptions[number];

/** Task priority levels - **Ensure this matches agent-schema.ts** */
export const taskPriorityOptions = [
  "low", "medium", "high", "critical"
] as const;
export type TaskPriority = typeof taskPriorityOptions[number];

/** Log levels - **Ensure this matches agent-schema.ts** */
export const logLevelOptions = [
  "debug", "info", "warn", "error", "critical"
] as const;
export type LogLevel = typeof logLevelOptions[number];

// ============================================================================
// CORE AGENT SYSTEM TYPES
// ============================================================================

/** Configuration settings for the agent system. */
export interface AgentSystemConfig {
  maxConcurrentTasks: number;
  taskTimeoutMinutes: number;
  logRetentionDays: number;
  insightRetentionDays?: number;
  healthCheckIntervalMinutes?: number;
  autoRestartOnFailure?: boolean;
  maxRetryAttempts?: number;
  enabledFeatures?: string[];
  notifications?: {
    emailEnabled: boolean;
    slackEnabled: boolean;
    webhookEnabled: boolean;
  };
}

/** Metrics related to the overall agent system performance. */
export interface AgentSystemMetrics {
  totalTasksProcessed: number;
  totalInsightsGenerated: number;
  systemUptime: number; // Duration in seconds
  averageTaskDuration?: number; // Duration in milliseconds
  errorRate?: number; // Percentage (0-1)
  lastHealthCheck?: string; // ISO 8601 date-time string
  performanceScore?: number; // Abstract score, e.g., 0-100
}

/** Represents the overall state and configuration of the agent system. */
export interface AgentSystem {
  _id: Id<"agentSystem">;
  _creationTime: number; // Convex automatic field (Unix timestamp ms)
  isRunning: boolean;
  status: AgentSystemStatus;
  lastStarted?: string; // ISO 8601 date-time string
  lastStopped?: string; // ISO 8601 date-time string
  errorMessage?: string;
  config?: AgentSystemConfig; // Reflects the more detailed structure
  metrics?: AgentSystemMetrics; // Reflects the more detailed structure
}


// ============================================================================
// INDIVIDUAL AGENT TYPES
// ============================================================================

/** Base agent configuration, intended to be extended by specific agent types. */
export interface AgentConfig {
  runIntervalMinutes?: number;
  retryAttempts?: number;
  timeoutMinutes?: number;
  enabled?: boolean;
  priority?: TaskPriority;
  dependencies?: Id<"agents">[];
  triggers?: AgentTrigger[];
  /** Allows for agent-specific configuration fields not explicitly defined. */
  [key: string]: any;
}

/** Base agent metrics, intended to be extended by specific agent types. */
export interface AgentMetrics {
  totalRuns: number;
  successfulRuns: number;
  failedRuns: number;
  averageRunTime: number; // Duration in milliseconds
  lastRunDuration?: number; // Duration in milliseconds
  dataProcessed?: number; // e.g., number of items, bytes
  insightsGenerated?: number;
  /** Allows for agent-specific metric fields not explicitly defined. */
  [key: string]: any;
}

/** Represents an individual agent within the system. */
export interface Agent {
  _id: Id<"agents">;
  // _creationTime: number; // Convex automatic field. Use 'createdAt' string as primary if that's the app logic.
  name: string;
  type: AgentType;
  status: AgentStatus;
  description?: string;
  isEnabled: boolean;
  lastRun?: string; // ISO 8601 date-time string
  lastSuccess?: string; // ISO 8601 date-time string
  runCount: number;
  errorCount: number;
  lastError?: string;
  config?: AgentConfig; // Reflects the more detailed base structure
  metrics?: AgentMetrics; // Reflects the more detailed base structure
  createdAt: string; // ISO 8601 date-time string, as per your schema
  updatedAt?: string; // ISO 8601 date-time string, as per your schema
}

/** Defines conditions that can trigger an agent's operation. */
export interface AgentTrigger {
  type: "schedule" | "event" | "condition" | "manual";
  schedule?: string; // Cron expression for 'schedule' type
  event?: string;    // Event name for 'event' type
  condition?: string; // Condition expression for 'condition' type
  enabled: boolean;
}


// ============================================================================
// SPECIFIC AGENT TYPE CONFIGURATIONS (Extending AgentConfig)
// ============================================================================

/** Configuration specific to Manager Agents. */
export interface ManagerAgentConfig extends AgentConfig {
  healthCheckIntervalMinutes: number;
  taskCleanupHours: number;
  logCleanupDays: number;
  agentRestartThreshold: number;
  systemMetricsCollectionInterval: number;
}

/** Configuration specific to Financial Agents. */
export interface FinancialAgentConfig extends AgentConfig {
  riskThresholds: {
    low: number;
    medium: number;
    high: number;
  };
  currencyConversion: boolean;
  costAnalysisDepth: "basic" | "detailed" | "comprehensive";
  reportingFrequency: "daily" | "weekly" | "monthly";
}

/** Configuration specific to Legal Agents. */
export interface LegalAgentConfig extends AgentConfig {
  jurisdictions: string[];
  complianceFrameworks: string[];
  riskAssessmentCriteria: string[];
  autoReviewEnabled: boolean;
  flaggedTerms: string[];
}

/** Configuration specific to Notification Agents. */
export interface NotificationAgentConfig extends AgentConfig {
  channels: {
    email: boolean;
    slack: boolean;
    webhook: boolean;
    inApp: boolean;
  };
  urgencyLevels: {
    [key in TaskPriority]: {
      delay: number;
      retries: number;
      escalation: boolean;
    };
  };
}

/** Configuration specific to Analytics Agents. */
export interface AnalyticsAgentConfig extends AgentConfig {
  reportTypes: string[]; // e.g., ["monthly_summary", "performance_dashboard"]
  dataRetentionDays: number;
  aggregationLevels: string[]; // e.g., ["daily", "weekly", "monthly"]
  realTimeAnalysis: boolean;
  machineLearningEnabled: boolean;
}

// ============================================================================
// AGENT INSIGHTS AND ANALYSIS
// ============================================================================

/** Represents an insight or piece of analysis generated by an agent. */
export interface AgentInsight {
  _id: Id<"agentInsights">;
  // _creationTime: number; // Convex automatic. Use 'createdAt' string as primary if that's app logic.
  agentId: Id<"agents">;
  type: InsightType;
  title: string;
  description: string;
  priority: TaskPriority;
  contractId?: Id<"contracts">; // Assuming 'contracts' table exists
  vendorId?: Id<"vendors">;   // Assuming 'vendors' table exists
  data?: InsightData;
  actionRequired: boolean;
  actionTaken: boolean;
  actionDetails?: string;
  isRead: boolean;
  expiresAt?: string; // ISO 8601 date-time string
  createdAt: string;  // ISO 8601 date-time string, as per your schema
  readAt?: string;    // ISO 8601 date-time string
  tags?: string[];    // Added field
  confidence?: number; // Added field (0-1 score)
}

/** Structured data payload for an AgentInsight, varying by insight type. */
export interface InsightData {
  contractRisk?: {
    score: number;
    factors: string[];
    recommendations: string[];
  };
  financialImpact?: {
    amount: number;
    currency: string;
    type: "cost" | "saving" | "risk";
    timeframe: string;
  };
  complianceIssues?: {
    framework: string;
    violations: string[];
    severity: "low" | "medium" | "high" | "critical";
    remediation: string[];
  };
  performanceData?: {
    metric: string;
    current: number;
    target: number;
    trend: "improving" | "declining" | "stable";
  };
  trendData?: {
    period: string;
    dataPoints: Array<{ date: string; value: number; }>;
    pattern: string;
    forecast?: number;
  };
  /** Allows for other types of structured insight data. */
  [key: string]: any;
}

// ============================================================================
// AGENT TASK MANAGEMENT
// ============================================================================

/** Represents a task to be performed by an agent. */
export interface AgentTask {
  _id: Id<"agentTasks">;
  // _creationTime: number; // Convex automatic. Use 'createdAt' string as primary if that's app logic.
  assignedAgentId: Id<"agents">;
  createdByAgentId?: Id<"agents">;
  taskType: string; // Consider a union type if a finite set of task types exists
  status: TaskStatus;
  priority: TaskPriority;
  title: string;
  description?: string;
  contractId?: Id<"contracts">;
  vendorId?: Id<"vendors">;
  data?: TaskData;
  result?: TaskResult;
  errorMessage?: string;
  scheduledFor?: string; // ISO 8601 date-time string
  startedAt?: string;    // ISO 8601 date-time string
  completedAt?: string;  // ISO 8601 date-time string
  createdAt: string;     // ISO 8601 date-time string, as per your schema
  dependencies?: Id<"agentTasks">[]; // Added field
  retryCount?: number;              // Added field
  maxRetries?: number;              // Added field
}

/** Data payload for an AgentTask. */
export interface TaskData {
  input?: any;
  parameters?: Record<string, any>;
  context?: Record<string, any>;
  metadata?: Record<string, any>;
}

/** Result payload from an AgentTask execution. */
export interface TaskResult {
  success: boolean;
  output?: any;
  metrics?: Record<string, number>;
  artifacts?: string[]; // URLs or IDs of generated files
  nextActions?: string[];
  warnings?: string[];
}

// ============================================================================
// AGENT LOGGING
// ============================================================================

/** Represents a log entry generated by an agent or the agent system. */
export interface AgentLog {
  _id: Id<"agentLogs">;
  // _creationTime: number; // Convex automatic. 'timestamp' string is the primary event time.
  agentId: Id<"agents">; // Or a system identifier if not from a specific agent
  level: LogLevel;
  message: string;
  data?: LogData;
  taskId?: Id<"agentTasks">;
  timestamp: string; // ISO 8601 date-time string of when the event occurred
  category?: string; // Added field (e.g., "task_execution", "system_health")
  source?: string;   // Added field (e.g., "FinancialAgent", "APIService")
  userId?: string;   // Added field (ID of user whose action might have initiated this)
}

/** Structured data for an AgentLog. */
export interface LogData {
  error?: Error | string;
  duration?: number; // Duration of an operation in milliseconds
  context?: Record<string, any>;
  stackTrace?: string;
  requestId?: string;
  sessionId?: string;
  metadata?: Record<string, any>;
}

// ============================================================================
// AGENT COMMUNICATION AND EVENTS
// ============================================================================

/** Represents an event within the agent system. */
export interface AgentEvent {
  type: string; // Consider a union type for known event types
  source: Id<"agents"> | "system";
  target?: Id<"agents"> | "system";
  data?: any;
  timestamp: string; // ISO 8601 date-time string
  priority: TaskPriority;
}

/** Represents a message passed between agents or system components. */
export interface AgentMessage {
  from: Id<"agents"> | "system";
  to: Id<"agents"> | "system";
  type: "request" | "response" | "notification" | "alert";
  payload: any;
  correlationId?: string;
  timestamp: string; // ISO 8601 date-time string
}

// ============================================================================
// AGENT WORKFLOW AND ORCHESTRATION (Managed outside Convex tables per discussion)
// ============================================================================

/** Defines a workflow consisting of multiple steps executed by agents. */
export interface AgentWorkflow {
  id: string; // User-defined unique identifier
  name: string;
  description?: string;
  steps: WorkflowStep[];
  triggers: AgentTrigger[];
  enabled: boolean;
  version: number;
  createdAt: string; // ISO 8601 date-time string, application-managed
  updatedAt?: string; // ISO 8601 date-time string, application-managed
}

/** A single step within an AgentWorkflow. */
export interface WorkflowStep {
  id: string; // Unique identifier for the step within the workflow
  agentId: Id<"agents">;
  action: string; // Specific action for the agent
  inputs?: Record<string, any>;
  conditions?: WorkflowCondition[];
  onSuccess?: string; // Next step ID
  onFailure?: string; // Next step ID
  timeout?: number;   // In seconds
  retries?: number;
}

/** A condition that can be evaluated within a workflow. */
export interface WorkflowCondition {
  field: string;
  operator: "eq" | "ne" | "gt" | "lt" | "gte" | "lte" | "in" | "contains";
  value: any;
}

// ============================================================================
// AGENT PERFORMANCE AND MONITORING
// ============================================================================

/** Report detailing the performance of a specific agent over a period. */
export interface AgentPerformanceReport {
  agentId: Id<"agents">;
  period: {
    start: string; // ISO 8601 date-time string
    end: string;   // ISO 8601 date-time string
  };
  metrics: {
    totalTasks: number;
    completedTasks: number;
    failedTasks: number;
    averageCompletionTime: number; // In milliseconds
    successRate: number; // 0-1
    errorRate: number;   // 0-1
    throughput: number;  // Tasks per hour
  };
  insights: {
    performance: "excellent" | "good" | "fair" | "poor";
    recommendations: string[];
    trends: string[];
  };
  generatedAt: string; // ISO 8601 date-time string
}

/** Overall health status of the agent system and its components. */
export interface SystemHealthStatus {
  overall: "healthy" | "warning" | "critical";
  agents: Array<{
    id: Id<"agents">;
    name: string;
    status: AgentStatus;
    health: "healthy" | "warning" | "critical";
    lastCheck: string; // ISO 8601 date-time string
  }>;
  resources: {
    cpuUsage: number;     // Percentage
    memoryUsage: number;  // Percentage
    storageAvailable: number; // Percentage or GB
    networkThroughput: number; // Mbps or similar
  };
  alerts: Array<{
    level: "info" | "warning" | "error" | "critical"; // Use LogLevel?
    message: string;
    timestamp: string; // ISO 8601 date-time string
    source?: string;
  }>;
}

// ============================================================================
// UTILITY TYPES AND INTERFACES (For UI or enriched data)
// ============================================================================

/** Enriched AgentInsight with denormalized agent and related entity information. */
export interface EnrichedAgentInsight extends AgentInsight {
  agentName: string;
  agentType?: AgentType; // Can be undefined if agent is not found
  relatedContractTitle?: string;
  relatedVendorName?: string;
}

/** Enriched AgentLog with denormalized agent and task information. */
export interface EnrichedAgentLog extends AgentLog {
  agentName: string;
  agentType?: AgentType; // Can be undefined if agent is not found
  taskTitle?: string;
}

/** Enriched AgentTask with denormalized agent and related entity information. */
export interface EnrichedAgentTask extends AgentTask {
  agentName: string;
  agentType?: AgentType; // Can be undefined if agent is not found
  creatorName?: string;
  relatedContractTitle?: string;
  relatedVendorName?: string;
}

// Form data types for creating/updating agents
export interface CreateAgentData {
  name: string;
  type: AgentType;
  description?: string;
  config?: AgentConfig;
  isEnabled?: boolean;
  // createdAt will be set by backend logic
}

export interface UpdateAgentData {
  name?: string;
  description?: string;
  config?: Partial<AgentConfig>; // Allow partial updates
  isEnabled?: boolean;
  type?: AgentType; // Usually not changed, but possible
  status?: AgentStatus;
  // updatedAt will be set by backend logic
}

// API response types
export interface AgentSystemStatusResponse {
  system: AgentSystem | null;
  agents: Agent[];
  stats: {
    totalAgents: number;
    activeAgents: number;
    recentInsights: number;
    pendingTasks: number;
    activeTasks: number;
  };
}

export interface AgentOperationResult {
  success: boolean;
  message: string;
  data?: any;
  error?: string;
}

// ============================================================================
// CONSTANTS AND MAPPINGS (Ensure these use the updated ...Options arrays)
// ============================================================================

/** Human-readable labels for AgentType enum values. */
export const AGENT_TYPE_LABELS: Record<AgentType, string> = {
  manager: "System Manager",
  secretary: "Administrative Assistant",
  financial: "Financial Analyst",
  notifications: "Notification Manager",
  legal: "Legal Compliance",
  analytics: "Data Analytics",
  workflow: "Workflow Orchestrator",
  compliance: "Compliance Monitor",
  risk: "Risk Assessor",
  audit: "Audit Manager",
  integration: "Integration Handler",
  scheduler: "Task Scheduler",
  backup: "Backup Manager",
  monitor: "System Monitor",
};

/** Human-readable labels for InsightType enum values. */
export const INSIGHT_TYPE_LABELS: Record<InsightType, string> = {
  contract_analysis: "Contract Analysis",
  financial_risk: "Financial Risk",
  expiration_warning: "Expiration Warning",
  legal_review: "Legal Review",
  compliance_alert: "Compliance Alert",
  performance_metric: "Performance Metric",
  cost_optimization: "Cost Optimization",
  vendor_risk: "Vendor Risk",
  renewal_opportunity: "Renewal Opportunity",
  negotiation_insight: "Negotiation Insight",
  audit_finding: "Audit Finding",
  anomaly_detection: "Anomaly Detection",
  trend_analysis: "Trend Analysis",
  recommendation: "Recommendation",
  alert: "Alert",
  report: "Report",
};

/** Color mappings for TaskPriority (e.g., for Tailwind CSS classes). */
export const PRIORITY_COLORS: Record<TaskPriority, string> = {
  low: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200",
  medium: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200",
  high: "bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200", // Or bg-amber-100 etc.
  critical: "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200",
};

/** Color mappings for AgentStatus (e.g., for Tailwind CSS classes). */
export const STATUS_COLORS: Record<AgentStatus, string> = {
  inactive: "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200",
  active: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200",
  busy: "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200",
  error: "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200",
  disabled: "bg-neutral-200 text-neutral-600 dark:bg-neutral-600 dark:text-neutral-300",
};

/** Color mappings for LogLevel (e.g., for Tailwind CSS classes). */
export const LOG_LEVEL_COLORS: Record<LogLevel, string> = {
    debug: "bg-purple-100 text-purple-800 dark:bg-purple-900 dark:text-purple-200",
    info: "bg-sky-100 text-sky-800 dark:bg-sky-900 dark:text-sky-200", // Or blue
    warn: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200",
    error: "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200",
    critical: "bg-pink-100 text-pink-800 dark:bg-pink-900 dark:text-pink-200", // Or a more intense red
};

/** Color mappings for TaskStatus (e.g., for Tailwind CSS classes). */
export const TASK_STATUS_COLORS: Record<TaskStatus, string> = {
    pending: "bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-200",
    in_progress: "bg-blue-100 text-blue-800 dark:bg-blue-900 dark:text-blue-200",
    completed: "bg-green-100 text-green-800 dark:bg-green-900 dark:text-green-200",
    failed: "bg-red-100 text-red-800 dark:bg-red-900 dark:text-red-200",
    cancelled: "bg-yellow-100 text-yellow-800 dark:bg-yellow-900 dark:text-yellow-200",
    timeout: "bg-orange-100 text-orange-800 dark:bg-orange-900 dark:text-orange-200",
};
</file>

<file path=".gitignore">
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.*
.yarn/*
!.yarn/patches
!.yarn/plugins
!.yarn/releases
!.yarn/versions

# testing
/coverage

# next.js
/.next/
/out/

# production
/build

# misc
.DS_Store
*.pem

# debug
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.pnpm-debug.log*

# env files (can opt-in for committing if needed)
.env*

# vercel
.vercel

# typescript
*.tsbuildinfo
next-env.d.ts

# clerk configuration (can include secrets)
/.clerk/
</file>

<file path="instructions.md">
# Production Readiness Report - Critical Issues and Fixes

##  Critical Issues for Production

### 1. **Authentication Security Vulnerability** (CRITICAL)
The security wrapper bypasses authentication for actions:
```typescript
// convex/security/secureWrapper.ts
const mockSecurityContext = {
  userId: "action-user" as any,
  enterpriseId: "action-enterprise" as any,
  role: "user" as any,
  permissions: ["*"]
};
```
**Fix Required:** Implement proper authentication using Clerk webhooks or API tokens for action authentication.

### 2. **Missing Database Indexes** (HIGH)
Performance will degrade significantly without proper indexes:
- `contracts` table: Need composite index on `enterpriseId + _creationTime`
- `auditLogs` table: Need index on `timestamp`
- `agentTasks` table: Need composite index on `status + scheduledFor`

### 3. **No Input Validation** (HIGH)
Limited validation on critical operations:
- File uploads lack comprehensive validation
- Contract values aren't properly validated
- User inputs missing sanitization
- SQL injection vulnerability potential

### 4. **Missing Error Boundaries** (MEDIUM)
No React error boundaries implemented, causing potential white screens on errors.

### 5. **Missing Core Frontend Pages** (HIGH)
Critical pages not implemented:
- `/dashboard/contracts/[id]/page.tsx` - Can't view contract details
- `/dashboard/contracts/[id]/edit/page.tsx` - Can't edit contracts
- `/dashboard/vendors/[id]/page.tsx` - Can't view vendor details
- User management interface
- Enterprise settings

##  Required Fixes by Priority

### Priority 1: Security (Week 1)
1. **Fix Authentication in Actions**
   - Implement Clerk webhook authentication
   - Remove mock security context
   - Add proper JWT validation

2. **Add Input Validation**
   - Implement Zod schemas for all mutations
   - Add file upload security checks
   - Sanitize all user inputs

### Priority 2: Database Performance (Week 1)
1. **Add Missing Indexes**
   ```typescript
   // convex/schema.ts
   contracts: defineTable({
     // ... existing fields
   })
   .index("by_enterprise_creation", ["enterpriseId", "_creationTime"])
   .index("by_status_enterprise", ["status", "enterpriseId"]),
   ```

2. **Optimize Query Patterns**
   - Replace sequential queries with parallel execution
   - Implement proper pagination
   - Add query result caching

### Priority 3: Frontend Completeness (Week 2)
1. **Implement Missing Pages**
   - Contract detail/edit views
   - Vendor management pages
   - User management interface
   - Settings pages

2. **Add Error Handling**
   - Implement error boundaries
   - Add loading states
   - Create fallback UI components

### Priority 4: Code Quality (Week 3)
1. **Reduce Code Duplication**
   - Extract common utilities
   - Create shared validation functions
   - Consolidate parsing logic

2. **Add Testing**
   - Unit tests for utilities
   - Integration tests for API
   - Component testing

##  Production Checklist

### Must-Have Before Launch:
- [ ] Fix authentication security hole
- [ ] Add database indexes
- [ ] Implement input validation
- [ ] Add error boundaries
- [ ] Complete missing frontend pages
- [ ] Set up error logging (Sentry)
- [ ] Add rate limiting
- [ ] Configure environment variables
- [ ] Set up monitoring/alerts
- [ ] Implement backup strategy

### Nice-to-Have:
- [ ] Comprehensive test suite
- [ ] Performance monitoring
- [ ] A/B testing framework
- [ ] Advanced analytics
- [ ] Feature flags

##  Recommended Implementation Order

1. **Week 1**: Security fixes + Database optimization
2. **Week 2**: Complete frontend pages + Error handling
3. **Week 3**: Testing + Code quality improvements
4. **Week 4**: Performance optimization + Monitoring setup

##  Risk Assessment

### High Risk Areas:
1. **Security**: Authentication bypass could expose all user data
2. **Performance**: Missing indexes will cause exponential slowdown with data growth
3. **User Experience**: Missing pages prevent core functionality
4. **Data Integrity**: Lack of validation could corrupt database

### Mitigation Strategy:
1. Implement security fixes immediately
2. Add indexes before any production data migration
3. Complete MVP frontend before soft launch
4. Add comprehensive logging for debugging

##  Technical Debt Summary

### Current State:
- **Security Score**: 3/10 (Critical vulnerabilities)
- **Performance Score**: 6/10 (Good architecture, missing optimizations)
- **Code Quality**: 7/10 (Well-structured, some duplication)
- **Test Coverage**: 0% (No tests implemented)
- **Documentation**: 8/10 (Good inline docs, missing API docs)

### Target State for Production:
- **Security Score**: 9/10
- **Performance Score**: 8/10
- **Code Quality**: 8/10
- **Test Coverage**: 70%+
- **Documentation**: 9/10

##  Quick Wins

1. **Add Loading Skeletons**: Replace all `<LoadingSpinner />` with proper skeleton loaders
2. **Fix TypeScript Errors**: Run `tsc --noEmit` and fix all type errors
3. **Add Missing Indexes**: Update `schema.ts` with performance-critical indexes
4. **Implement Error Boundaries**: Add at least 3 strategic error boundaries
5. **Create Shared Utils**: Extract duplicate parsing/formatting logic

##  Go/No-Go Criteria

### Minimum Viable Production:
-  Security vulnerabilities patched
-  Core functionality complete
-  Basic error handling implemented
-  Performance indexes added
-  Authentication fully functional
-  Input validation on all forms

### Current Status: **NOT READY FOR PRODUCTION**

The codebase has a solid foundation but requires these critical fixes before production deployment. The security vulnerability in actions is the most urgent issue to address.
</file>

<file path="next.config.ts">
import type { NextConfig } from "next";

const nextConfig: NextConfig = {
  async headers() {
    return [
      {
        source: '/(.*)',
        headers: [
          // Content Security Policy
          {
            key: 'Content-Security-Policy',
            value: [
              "default-src 'self'",
              "script-src 'self' 'unsafe-eval' 'unsafe-inline' https://clerk.dev https://*.clerk.accounts.dev https://challenges.cloudflare.com https://www.google.com https://www.gstatic.com",
              "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com",
              "font-src 'self' https://fonts.gstatic.com",
              "img-src 'self' data: https: blob:",
              "media-src 'self' blob:",
              "connect-src 'self' https://clerk.dev https://*.clerk.accounts.dev https://*.convex.cloud wss://*.convex.cloud https://api.openai.com",
              "frame-src 'self' https://challenges.cloudflare.com",
              "worker-src 'self' blob:",
              "object-src 'none'",
              "base-uri 'self'",
              "form-action 'self'",
              "frame-ancestors 'none'",
              "upgrade-insecure-requests"
            ].join('; ')
          },
          // CSRF Protection
          {
            key: 'X-Frame-Options',
            value: 'DENY'
          },
          {
            key: 'X-Content-Type-Options',
            value: 'nosniff'
          },
          {
            key: 'Referrer-Policy',
            value: 'strict-origin-when-cross-origin'
          },
          {
            key: 'X-XSS-Protection',
            value: '1; mode=block'
          },
          // HSTS
          {
            key: 'Strict-Transport-Security',
            value: 'max-age=31536000; includeSubDomains; preload'
          },
          // Permissions Policy
          {
            key: 'Permissions-Policy',
            value: 'camera=(), microphone=(), geolocation=(), payment=()'
          }
        ]
      }
    ];
  },
  
  // Webpack optimizations for production
  webpack: (config, { isServer, dev }) => {
    if (!dev && !isServer) {
      config.optimization.splitChunks = {
        chunks: 'all',
        cacheGroups: {
          vendor: {
            test: /[\\/]node_modules[\\/]/,
            name: 'vendors',
            priority: 10,
            reuseExistingChunk: true,
          },
          common: {
            name: 'common',
            minChunks: 2,
            priority: 5,
            reuseExistingChunk: true,
          }
        }
      };
    }
    return config;
  },
  
  // Experimental features for performance
  experimental: {
    optimizeCss: true,
    optimizePackageImports: ['@radix-ui/react-icons', 'lucide-react'],
  },
  
  // Image optimization
  images: {
    domains: [],
    formats: ['image/webp', 'image/avif'],
  },
  
  // Compression
  compress: true,
  
  // Enable static optimization
  trailingSlash: false,
  
  // Bundle analyzer (enable in development)
  ...(process.env.ANALYZE === 'true' && {
    webpack: (config: any) => {
      if (typeof require !== 'undefined') {
        const { BundleAnalyzerPlugin } = require('webpack-bundle-analyzer');
        config.plugins.push(
          new BundleAnalyzerPlugin({
            analyzerMode: 'static',
            openAnalyzer: false,
          })
        );
      }
      return config;
    }
  }),
};

export default nextConfig;
</file>

<file path="ROLE_PERMISSIONS.md">
# User Role Permissions Guide

## Role Hierarchy (highest to lowest)

1. **Owner** (Level 5)
2. **Admin** (Level 4) 
3. **Manager** (Level 3)
4. **User** (Level 2)  **Normal users who can add contracts/vendors**
5. **Viewer** (Level 1)

## Detailed Permissions

###  Owner
- **Full system access**
- Manage enterprise settings
- Add/remove users
- Change user roles (including other owners)
- All contract and vendor operations
- Access agent system controls
- View all analytics and reports
- Delete enterprise data

###  Admin  
- **Almost full access** (cannot modify owners)
- Add/remove users (except owners)
- Change user roles (except owners)
- All contract and vendor operations
- Access agent system controls
- View all analytics and reports
- Cannot delete enterprise

###  Manager
- **Operational management**
- View enterprise users (cannot modify)
- All contract and vendor operations
- Create/manage agent tasks
- View analytics and reports
- Approve/reject contracts
- Export data

###  User (Normal User)
- **Standard business user**
-  **Create contracts and vendors**
-  **Edit contracts and vendors they created**
-  **Upload contract files**
-  **Add notes and updates**
-  **View contracts and vendors**
-  **Basic reporting**
-  Cannot manage other users
-  Cannot access agent system
-  Cannot delete others' data
-  Cannot change enterprise settings

###  Viewer
- **Read-only access**
- View contracts and vendors
- View basic reports
- Cannot create, edit, or delete anything
- Cannot access user management
- Cannot access agent system

## Permission Levels for Operations

### Contract Operations
| Operation | Owner | Admin | Manager | User | Viewer |
|-----------|-------|-------|---------|------|--------|
| View contracts |  |  |  |  |  |
| Create contracts |  |  |  |  |  |
| Edit own contracts |  |  |  |  |  |
| Edit others' contracts |  |  |  |  |  |
| Delete contracts |  |  |  |  |  |
| Approve contracts |  |  |  |  |  |

### Vendor Operations  
| Operation | Owner | Admin | Manager | User | Viewer |
|-----------|-------|-------|---------|------|--------|
| View vendors |  |  |  |  |  |
| Create vendors |  |  |  |  |  |
| Edit own vendors |  |  |  |  |  |
| Edit others' vendors |  |  |  |  |  |
| Delete vendors |  |  |  |  |  |

### User Management
| Operation | Owner | Admin | Manager | User | Viewer |
|-----------|-------|-------|---------|------|--------|
| View users |  |  |  |  |  |
| Add users |  |  |  |  |  |
| Edit user roles |  | * |  |  |  |
| Remove users |  | * |  |  |  |

*Admin cannot modify Owner roles

### Agent System
| Operation | Owner | Admin | Manager | User | Viewer |
|-----------|-------|-------|---------|------|--------|
| View agent status |  |  |  |  |  |
| Control agents |  |  |  |  |  |
| View insights |  |  |  |  |  |
| Create tasks |  |  |  |  |  |



## Default Role Assignment

- **New users default to "user" role** - allows them to immediately start working with contracts and vendors
- **First user in an enterprise becomes "owner"**
- **Additional users can be promoted by owners/admins as needed**

## Quick Reference

###  Who Can Do What?

**Create Contracts/Vendors:** Owner, Admin, Manager, User  
**Manage Users:** Owner, Admin  
**Control Agents:** Owner, Admin  
**View Everything:** Owner, Admin, Manager  
**Basic Operations:** Owner, Admin, Manager, User  
**Read Only:** Viewer  

###  Security Notes

- Users can only access data within their enterprise
- Users can only edit resources they created (unless they're Manager+)
- Role changes require Admin+ privileges
- Owner role changes require Owner privileges
- All operations are logged for audit purposes
</file>

<file path="convex/agents/analytics.ts">
// convex/agents/analytics.ts
import { internalMutation, internalQuery } from "../_generated/server";
import { v } from "convex/values";
import { Id, Doc } from "../_generated/dataModel";
import { ContractAnalytics, VendorAnalytics, MonthlyTrend, VendorMetric, ContractStatus, VendorCategory } from "../types";

/**
 * Analytics Agent
 * 
 * Responsibilities:
 * - Generate comprehensive analytics reports
 * - Track KPIs and business metrics
 * - Identify trends and patterns in contract data
 * - Monitor vendor performance and relationships
 * - Calculate financial metrics and projections
 * - Detect anomalies and opportunities
 * - Generate executive dashboards
 * - Provide predictive analytics
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const ANALYTICS_CONFIG = {
  // Processing settings
  checkIntervalMinutes: 60, // Run hourly
  batchSize: 50,
  analysisTimeoutMinutes: 30,
  
  // Time periods for analysis
  timePeriods: {
    daily: 1,
    weekly: 7,
    monthly: 30,
    quarterly: 90,
    yearly: 365,
  },
  
  // KPI thresholds
  kpiThresholds: {
    contractRenewalRate: 0.80, // 80% target
    vendorSatisfaction: 0.85,
    costSavingsTarget: 0.10, // 10% annual savings
    complianceRate: 0.95,
    contractCycleTime: 14, // days
    approvalTime: 3, // days
  },
  
  // Analytics categories
  categories: {
    contract: ["volume", "value", "types", "status", "lifecycle"],
    vendor: ["performance", "spend", "risk", "concentration"],
    financial: ["spend", "savings", "roi", "budget", "forecast"],
    compliance: ["adherence", "violations", "audits", "certifications"],
    operational: ["efficiency", "bottlenecks", "automation", "workload"],
  },
  
  // Insight generation rules
  insightRules: {
    spendIncreaseThreshold: 0.20, // 20% increase triggers alert
    vendorConcentrationLimit: 0.30, // 30% of spend with one vendor
    contractExpiryWarningDays: 90,
    unusualActivityStdDev: 2.5,
    trendsMinDataPoints: 5,
  },
  
  // Report templates
  reportTemplates: {
    executive: ["overview", "kpis", "risks", "opportunities", "forecast"],
    operational: ["workload", "bottlenecks", "efficiency", "team_performance"],
    financial: ["spend_analysis", "savings", "budget_variance", "forecast"],
    vendor: ["performance", "risk", "spend_distribution", "compliance"],
    compliance: ["adherence", "violations", "upcoming_audits", "certifications"],
  },
};

// Extended metrics for analytics agent
interface AnalyticsAgentMetrics {
  totalRuns: number;
  successfulRuns: number;
  failedRuns: number;
  averageRunTime: number;
  lastRunDuration?: number;
  dataProcessed?: number;
  insightsGenerated?: number;
  // Analytics-specific metrics
  reportsGenerated?: number;
  kpisCalculated?: number;
  trendsIdentified?: number;
  anomaliesDetected?: number;
  forecastsCreated?: number;
  dataPointsAnalyzed?: number;
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

export const run = internalMutation({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const startTime = Date.now();
    
    try {
      await ctx.db.insert("agentLogs", {
        agentId: args.agentId,
        level: "info",
        message: "Analytics agent starting run",
        timestamp: new Date().toISOString(),
        category: "agent_execution",
      });

      await ctx.db.patch(args.agentId, {
        status: "busy",
        lastRun: new Date().toISOString(),
      });

      // Calculate KPIs
      const kpisCalculated = await calculateKPIs(ctx, args.agentId);
      
      // Analyze contract metrics
      const contractInsights = await analyzeContractMetrics(ctx, args.agentId);
      
      // Analyze vendor performance
      const vendorInsights = await analyzeVendorPerformance(ctx, args.agentId);
      
      // Analyze financial trends
      const financialInsights = await analyzeFinancialTrends(ctx, args.agentId);
      
      // Detect anomalies
      const anomaliesDetected = await detectAnomalies(ctx, args.agentId);
      
      // Generate predictive analytics
      const forecastsCreated = await generatePredictiveAnalytics(ctx, args.agentId);
      
      // Create executive dashboard data
      await createExecutiveDashboard(ctx, args.agentId);
      
      // Generate automated reports
      const reportsGenerated = await generateAutomatedReports(ctx, args.agentId);

      // Update metrics
      await updateAgentMetrics(ctx, args.agentId, {
        runTime: Date.now() - startTime,
        kpisCalculated,
        contractInsights,
        vendorInsights,
        financialInsights,
        anomaliesDetected,
        forecastsCreated,
        reportsGenerated,
      });

      return { 
        success: true, 
        kpisCalculated,
        totalInsights: contractInsights + vendorInsights + financialInsights + anomaliesDetected,
        reportsGenerated,
      };

    } catch (error) {
      await handleAgentError(ctx, args.agentId, error);
      throw error;
    }
  },
});

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

interface KPIMetrics {
  contractRenewalRate: number;
  contractCycleTime: number;
  vendorConcentrationRisk: number;
  contractComplianceRate: number;
  identifiedSavings: number;
  savingsRate: number;
  totalActiveContractValue: number;
  contractsByType: Record<string, number>;
}

async function calculateKPIs(
  ctx: MutationCtx,
  agentId: Id<"agents">
): Promise<number> {
  const kpis: KPIMetrics = {
    contractRenewalRate: 0,
    contractCycleTime: 0,
    vendorConcentrationRisk: 0,
    contractComplianceRate: 0,
    identifiedSavings: 0,
    savingsRate: 0,
    totalActiveContractValue: 0,
    contractsByType: {},
  };
  const now = new Date();
  const oneYearAgo = new Date(now.getTime() - 365 * 24 * 60 * 60 * 1000);
  
  // Get all contracts for analysis
  const contracts = await ctx.db
    .query("contracts")
    .collect();
    
  const activeContracts = contracts.filter((c: Doc<"contracts">) => c.status === "active");
  const expiredLastYear = contracts.filter((c: Doc<"contracts">) => 
    c.status === "expired" && 
    c._creationTime && 
    c._creationTime > oneYearAgo.getTime()
  );

  // 1. Contract Renewal Rate
  const renewalEligible = expiredLastYear.length;
  const renewed = contracts.filter((c: Doc<"contracts">) => 
    c.metadata?.renewedFrom && 
    c._creationTime && 
    c._creationTime > oneYearAgo.getTime()
  ).length;
  kpis.contractRenewalRate = renewalEligible > 0 ? renewed / renewalEligible : 0;

  // 2. Contract Cycle Time (from creation to active)
  const recentActiveContracts = activeContracts.filter((c: Doc<"contracts">) => 
    c._creationTime && c._creationTime > oneYearAgo.getTime()
  );
  
  let totalCycleTime = 0;
  let cycleTimeCount = 0;
  
  for (const contract of recentActiveContracts) {
    if (contract._creationTime && contract.analysisStatus === "completed") {
      // Estimate cycle time (in practice, you'd track actual status changes)
      const cycleTime = 7; // Placeholder - would calculate from status change logs
      totalCycleTime += cycleTime;
      cycleTimeCount++;
    }
  }
  
  kpis.averageContractCycleTime = cycleTimeCount > 0 ? totalCycleTime / cycleTimeCount : 0;

  // 3. Vendor Concentration
  const vendorSpend: Record<string, number> = {};
  let totalSpend = 0;
  
  for (const contract of activeContracts) {
    const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
    if (value > 0) {
      const vendorId = contract.vendorId.toString();
      vendorSpend[vendorId] = (vendorSpend[vendorId] || 0) + value;
      totalSpend += value;
    }
  }
  
  const topVendorSpend = Math.max(...Object.values(vendorSpend), 0);
  kpis.vendorConcentrationRisk = totalSpend > 0 ? topVendorSpend / totalSpend : 0;

  // 4. Contract Compliance Rate
  const compliantContracts = activeContracts.filter((c: Doc<"contracts">) => 
    c.analysisStatus === "completed" && !c.analysisError
  ).length;
  kpis.contractComplianceRate = activeContracts.length > 0 
    ? compliantContracts / activeContracts.length 
    : 1;

  // 5. Cost Savings
  // Calculate based on renegotiated contracts or identified savings opportunities
  const savingsInsights = await ctx.db
    .query("agentInsights")
    .filter((q) => 
      q.and(
        q.eq(q.field("type"), "cost_optimization"),
        q.gte(q.field("createdAt"), oneYearAgo.toISOString())
      )
    )
    .collect();
  
  const totalSavings = savingsInsights.reduce((sum: number, insight: Doc<"agentInsights">) => 
    sum + (insight.data?.potentialSavings || 0), 0
  );
  kpis.identifiedSavings = totalSavings;
  kpis.savingsRate = totalSpend > 0 ? totalSavings / totalSpend : 0;

  // 6. Active Contract Value
  kpis.totalActiveContractValue = activeContracts.reduce((sum: number, c: Doc<"contracts">) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  
  // 7. Contract Distribution
  kpis.contractsByType = activeContracts.reduce((acc: Record<string, number>, c: Doc<"contracts">) => {
    const type = c.contractType || "other";
    acc[type] = (acc[type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);

  // Store KPIs
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "report",
    title: "Key Performance Indicators Update",
    description: "Latest KPI calculations for contract management",
    priority: "low",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: {
      kpis,
      calculatedAt: new Date().toISOString(),
      period: "last_365_days",
    },
  });

  // Check for KPI threshold violations
  let alertsCreated = 0;
  
  if (kpis.contractRenewalRate < ANALYTICS_CONFIG.kpiThresholds.contractRenewalRate) {
    alertsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "alert",
      title: "Low Contract Renewal Rate",
      description: `Contract renewal rate (${(kpis.contractRenewalRate * 100).toFixed(1)}%) is below target (${(ANALYTICS_CONFIG.kpiThresholds.contractRenewalRate * 100)}%)`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: {
        currentRate: kpis.contractRenewalRate,
        targetRate: ANALYTICS_CONFIG.kpiThresholds.contractRenewalRate,
        gap: ANALYTICS_CONFIG.kpiThresholds.contractRenewalRate - kpis.contractRenewalRate,
      },
    });
  }

  if (kpis.vendorConcentrationRisk > ANALYTICS_CONFIG.insightRules.vendorConcentrationLimit) {
    alertsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "vendor_risk",
      title: "High Vendor Concentration Risk",
      description: `${(kpis.vendorConcentrationRisk * 100).toFixed(1)}% of spend is concentrated with a single vendor`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: {
        concentrationRate: kpis.vendorConcentrationRisk,
        threshold: ANALYTICS_CONFIG.insightRules.vendorConcentrationLimit,
      },
    });
  }

  return Object.keys(kpis).length + alertsCreated;
}

async function analyzeContractMetrics(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let insightsCreated = 0;
  
  // Get contracts grouped by time periods
  const contracts = await ctx.db
    .query("contracts")
    .collect();
  
  // Analyze contract volume trends
  const volumeTrends = analyzeVolumeTrends(contracts);
  
  if (volumeTrends.trend !== "stable") {
    insightsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "trend_analysis",
      title: `Contract Volume ${volumeTrends.trend === "increasing" ? "Increasing" : "Decreasing"}`,
      description: `Contract creation volume has ${volumeTrends.trend === "increasing" ? "increased" : "decreased"} by ${(volumeTrends.changeRate * 100).toFixed(1)}% over the last quarter`,
      priority: "medium",
      actionRequired: false,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: volumeTrends,
    });
  }

  // Analyze contract value distribution
  const valueDistribution = analyzeValueDistribution(contracts);
  
  if (valueDistribution.skewness > 2) {
    insightsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "anomaly_detection",
      title: "Uneven Contract Value Distribution",
      description: `Contract values are heavily skewed - ${valueDistribution.top20PercentValue}% of value comes from top 20% of contracts`,
      priority: "medium",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: valueDistribution,
    });
  }

  // Analyze contract lifecycle
  const lifecycleMetrics = await analyzeContractLifecycle(ctx, contracts);
  
  if (lifecycleMetrics.averageTimeToExpiry < 90) {
    insightsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "alert",
      title: "Multiple Contracts Expiring Soon",
      description: `${lifecycleMetrics.expiringIn90Days} contracts are expiring within 90 days, representing ${formatCurrency(lifecycleMetrics.expiringValue)} in value`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: lifecycleMetrics,
    });
  }

  return insightsCreated;
}

async function analyzeVendorPerformance(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let insightsCreated = 0;
  
  const vendors = await ctx.db
    .query("vendors")
    .collect();
    
  const contracts = await ctx.db
    .query("contracts")
    .collect();

  // Calculate vendor performance metrics
  const vendorMetrics = new Map<string, any>();
  
  for (const vendor of vendors) {
    const vendorContracts = contracts.filter(c => c.vendorId === vendor._id);
    
    if (vendorContracts.length === 0) continue;
    
    const metrics = {
      vendorId: vendor._id,
      vendorName: vendor.name,
      contractCount: vendorContracts.length,
      activeContracts: vendorContracts.filter(c => c.status === "active").length,
      totalValue: vendorContracts.reduce((sum, c) => 
        sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
      ),
      averageContractValue: 0,
      onTimeRenewalRate: 0, // Would need actual renewal tracking
      complianceScore: 0, // Would need compliance tracking
      riskScore: 0, // Would need risk assessment data
    };
    
    metrics.averageContractValue = metrics.contractCount > 0 
      ? metrics.totalValue / metrics.contractCount 
      : 0;
    
    // Simple risk scoring based on concentration
    if (metrics.totalValue > 1000000) {
      metrics.riskScore += 20;
    }
    if (metrics.activeContracts > 5) {
      metrics.riskScore += 10;
    }
    
    vendorMetrics.set(vendor._id.toString(), metrics);
  }

  // Identify top performers and risks
  const sortedByValue = Array.from(vendorMetrics.values())
    .sort((a, b) => b.totalValue - a.totalValue);
  
  const top5Vendors = sortedByValue.slice(0, 5);
  const totalValue = sortedByValue.reduce((sum, v) => sum + v.totalValue, 0);
  
  // Create vendor performance insight
  insightsCreated++;
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "report",
    title: "Top Vendor Performance Analysis",
    description: `Analysis of top ${top5Vendors.length} vendors representing ${((top5Vendors.reduce((sum, v) => sum + v.totalValue, 0) / totalValue) * 100).toFixed(1)}% of total spend`,
    priority: "low",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: {
      topVendors: top5Vendors,
      totalVendors: vendors.length,
      totalValue,
      metrics: Array.from(vendorMetrics.values()),
    },
  });

  // Check for vendor risks
  const highRiskVendors = Array.from(vendorMetrics.values())
    .filter(v => v.riskScore > 25);
  
  if (highRiskVendors.length > 0) {
    insightsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "vendor_risk",
      title: "High Risk Vendor Relationships Identified",
      description: `${highRiskVendors.length} vendor(s) have elevated risk scores due to high concentration or value`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: {
        highRiskVendors,
        totalAtRisk: highRiskVendors.reduce((sum, v) => sum + v.totalValue, 0),
      },
    });
  }

  return insightsCreated;
}

async function analyzeFinancialTrends(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let insightsCreated = 0;
  
  const contracts = await ctx.db
    .query("contracts")
    .collect();
  
  // Group spending by month
  const monthlySpend = calculateMonthlySpend(contracts);
  const quarters = groupByQuarter(monthlySpend);
  
  // Calculate year-over-year growth
  const yoyGrowth = calculateYoYGrowth(monthlySpend);
  
  if (Math.abs(yoyGrowth) > ANALYTICS_CONFIG.insightRules.spendIncreaseThreshold) {
    insightsCreated++;
    const isIncrease = yoyGrowth > 0;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "financial_risk",
      title: `Significant Spend ${isIncrease ? "Increase" : "Decrease"} Detected`,
      description: `Contract spending has ${isIncrease ? "increased" : "decreased"} by ${(Math.abs(yoyGrowth) * 100).toFixed(1)}% year-over-year`,
      priority: isIncrease ? "high" : "medium",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: {
        yoyGrowth,
        monthlyTrend: monthlySpend,
        quarterlyTrend: quarters,
      },
    });
  }

  // Analyze spending patterns
  const spendingPatterns = analyzeSpendingPatterns(contracts);
  
  if (spendingPatterns.seasonality.isSeaonal) {
    insightsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "trend_analysis",
      title: "Seasonal Spending Pattern Detected",
      description: `Contract spending shows seasonal patterns with peak in ${spendingPatterns.seasonality.peakMonth}`,
      priority: "low",
      actionRequired: false,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: spendingPatterns,
    });
  }

  // Budget variance analysis
  const budgetVariance = await analyzeBudgetVariance(ctx, contracts);
  
  if (budgetVariance && Math.abs(budgetVariance.variancePercent) > 10) {
    insightsCreated++;
    const isOver = budgetVariance.variancePercent > 0;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "financial_risk",
      title: `Budget ${isOver ? "Overrun" : "Underutilization"} Alert`,
      description: `Current spending is ${Math.abs(budgetVariance.variancePercent).toFixed(1)}% ${isOver ? "over" : "under"} budget`,
      priority: isOver ? "high" : "medium",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: budgetVariance,
    });
  }

  return insightsCreated;
}

async function detectAnomalies(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let anomaliesDetected = 0;
  
  const contracts = await ctx.db
    .query("contracts")
    .collect();
  
  // Detect pricing anomalies
  const pricingAnomalies = detectPricingAnomalies(contracts);
  
  for (const anomaly of pricingAnomalies) {
    anomaliesDetected++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "anomaly_detection",
      title: `Unusual Pricing Detected: ${anomaly.contractTitle}`,
      description: `Contract value (${formatCurrency(anomaly.value)}) is ${anomaly.standardDeviations.toFixed(1)} standard deviations from the mean for ${anomaly.contractType} contracts`,
      priority: "medium",
      contractId: anomaly.contractId,
      vendorId: anomaly.vendorId,
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: anomaly,
    });
  }

  // Detect unusual vendor activity
  const vendorActivityAnomalies = await detectVendorActivityAnomalies(ctx);
  
  for (const anomaly of vendorActivityAnomalies) {
    anomaliesDetected++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "anomaly_detection",
      title: "Unusual Vendor Activity Pattern",
      description: anomaly.description,
      priority: "medium",
      vendorId: anomaly.vendorId,
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: anomaly,
    });
  }

  // Detect contract term anomalies
  const termAnomalies = detectContractTermAnomalies(contracts);
  
  for (const anomaly of termAnomalies) {
    anomaliesDetected++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "anomaly_detection",
      title: "Unusual Contract Terms",
      description: anomaly.description,
      priority: "high",
      contractId: anomaly.contractId,
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: anomaly,
    });
  }

  return anomaliesDetected;
}

async function generatePredictiveAnalytics(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let forecastsCreated = 0;
  
  const contracts = await ctx.db
    .query("contracts")
    .collect();
  
  // Forecast contract volume
  const volumeForecast = forecastContractVolume(contracts);
  
  forecastsCreated++;
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "trend_analysis",
    title: "Contract Volume Forecast",
    description: `Projected ${volumeForecast.nextQuarter} new contracts in the next quarter based on historical trends`,
    priority: "low",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: volumeForecast,
  });

  // Forecast spending
  const spendForecast = forecastSpending(contracts);
  
  forecastsCreated++;
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "trend_analysis",
    title: "Spending Forecast",
    description: `Projected spending of ${formatCurrency(spendForecast.nextQuarterSpend)} in the next quarter (${spendForecast.confidence}% confidence)`,
    priority: "medium",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: spendForecast,
  });

  // Predict renewal opportunities
  const renewalOpportunities = await predictRenewalOpportunities(ctx, contracts);
  
  if (renewalOpportunities.highValueRenewals.length > 0) {
    forecastsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "renewal_opportunity",
      title: "High-Value Renewal Opportunities",
      description: `${renewalOpportunities.highValueRenewals.length} high-value contracts worth ${formatCurrency(renewalOpportunities.totalValue)} are up for renewal`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: renewalOpportunities,
    });
  }

  // Predict risk events
  const riskPredictions = predictRiskEvents(contracts);
  
  if (riskPredictions.highRiskContracts.length > 0) {
    forecastsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "financial_risk",
      title: "Predicted Contract Risks",
      description: `${riskPredictions.highRiskContracts.length} contracts show indicators of potential issues`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: riskPredictions,
    });
  }

  return forecastsCreated;
}

async function createExecutiveDashboard(
  ctx: any,
  agentId: Id<"agents">
): Promise<void> {
  const contracts = await ctx.db
    .query("contracts")
    .collect();
    
  const vendors = await ctx.db
    .query("vendors")
    .collect();

  const dashboard = {
    overview: {
      totalContracts: contracts.length,
      activeContracts: contracts.filter(c => c.status === "active").length,
      totalVendors: vendors.length,
      activeVendors: vendors.filter(v => 
        contracts.some(c => c.vendorId === v._id && c.status === "active")
      ).length,
    },
    financial: {
      totalContractValue: contracts.reduce((sum, c) => 
        sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
      ),
      monthlyBurn: 0, // Would calculate from payment schedules
      annualProjection: 0, // Would calculate from active contracts
    },
    kpis: {
      contractRenewalRate: 0, // Would fetch from latest KPI calculation
      vendorSatisfaction: 0,
      complianceRate: 0,
      avgContractCycleTime: 0,
    },
    alerts: {
      expiringContracts: contracts.filter(c => {
        if (!c.extractedEndDate) return false;
        const daysUntil = Math.ceil(
          (new Date(c.extractedEndDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
        );
        return daysUntil <= 90 && daysUntil > 0;
      }).length,
      pendingApprovals: 0, // Would need approval tracking
      complianceIssues: 0, // Would need compliance tracking
      budgetAlerts: 0, // Would need budget tracking
    },
    trends: {
      contractVolumeChange: 0, // Month-over-month
      spendingChange: 0, // Month-over-month
      vendorCountChange: 0, // Month-over-month
    },
    lastUpdated: new Date().toISOString(),
  };

  // Store dashboard data
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "report",
    title: "Executive Dashboard Update",
    description: "Real-time executive dashboard metrics",
    priority: "low",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: dashboard,
  });
}

async function generateAutomatedReports(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let reportsGenerated = 0;
  const now = new Date();
  
  // Check if it's time for weekly report (Monday)
  if (now.getDay() === 1) {
    await generateWeeklyReport(ctx, agentId);
    reportsGenerated++;
  }
  
  // Check if it's time for monthly report (1st of month)
  if (now.getDate() === 1) {
    await generateMonthlyReport(ctx, agentId);
    reportsGenerated++;
  }
  
  // Check if it's time for quarterly report
  if (now.getDate() === 1 && [0, 3, 6, 9].includes(now.getMonth())) {
    await generateQuarterlyReport(ctx, agentId);
    reportsGenerated++;
  }
  
  return reportsGenerated;
}

// ============================================================================
// ANALYTICS HELPER FUNCTIONS
// ============================================================================

function analyzeVolumeTrends(contracts: any[]): any {
  const monthlyVolume: Record<string, number> = {};
  
  contracts.forEach(contract => {
    if (contract._creationTime) {
      const date = new Date(contract._creationTime);
      const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
      monthlyVolume[monthKey] = (monthlyVolume[monthKey] || 0) + 1;
    }
  });
  
  const months = Object.keys(monthlyVolume).sort();
  if (months.length < 3) {
    return { trend: "insufficient_data", changeRate: 0 };
  }
  
  // Calculate trend over last 3 months
  const recentMonths = months.slice(-3);
  const recentVolumes = recentMonths.map(m => monthlyVolume[m]);
  
  const avgFirst = recentVolumes[0];
  const avgLast = recentVolumes[recentVolumes.length - 1];
  const changeRate = avgFirst > 0 ? (avgLast - avgFirst) / avgFirst : 0;
  
  return {
    trend: changeRate > 0.1 ? "increasing" : changeRate < -0.1 ? "decreasing" : "stable",
    changeRate,
    monthlyVolume,
    recentTrend: recentVolumes,
  };
}

function analyzeValueDistribution(contracts: any[]): any {
  const values = contracts
    .map(c => parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'))
    .filter(v => v > 0)
    .sort((a, b) => b - a);
  
  if (values.length === 0) {
    return { skewness: 0, top20PercentValue: 0 };
  }
  
  const totalValue = values.reduce((sum, v) => sum + v, 0);
  const top20Count = Math.ceil(values.length * 0.2);
  const top20Value = values.slice(0, top20Count).reduce((sum, v) => sum + v, 0);
  
  // Calculate statistical measures
  const mean = totalValue / values.length;
  const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
  const stdDev = Math.sqrt(variance);
  
  // Simple skewness calculation
  const skewness = values.reduce((sum, v) => sum + Math.pow((v - mean) / stdDev, 3), 0) / values.length;
  
  return {
    totalValue,
    meanValue: mean,
    medianValue: values[Math.floor(values.length / 2)],
    stdDev,
    skewness,
    top20PercentValue: (top20Value / totalValue * 100).toFixed(1),
    distribution: {
      under10k: values.filter(v => v < 10000).length,
      "10k-50k": values.filter(v => v >= 10000 && v < 50000).length,
      "50k-100k": values.filter(v => v >= 50000 && v < 100000).length,
      "100k-500k": values.filter(v => v >= 100000 && v < 500000).length,
      over500k: values.filter(v => v >= 500000).length,
    },
  };
}

async function analyzeContractLifecycle(ctx: any, contracts: any[]): Promise<any> {
  const activeContracts = contracts.filter(c => c.status === "active");
  const now = new Date();
  
  let totalDaysToExpiry = 0;
  let expiringIn90Days = 0;
  let expiringValue = 0;
  let contractsWithEndDate = 0;
  
  for (const contract of activeContracts) {
    if (contract.extractedEndDate) {
      contractsWithEndDate++;
      const endDate = new Date(contract.extractedEndDate);
      const daysToExpiry = Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
      
      if (daysToExpiry > 0) {
        totalDaysToExpiry += daysToExpiry;
        
        if (daysToExpiry <= 90) {
          expiringIn90Days++;
          expiringValue += parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
        }
      }
    }
  }
  
  return {
    averageTimeToExpiry: contractsWithEndDate > 0 ? totalDaysToExpiry / contractsWithEndDate : 0,
    expiringIn90Days,
    expiringValue,
    contractsWithoutEndDate: activeContracts.length - contractsWithEndDate,
    expiryDistribution: {
      expired: contracts.filter(c => c.status === "expired").length,
      within30Days: activeContracts.filter(c => {
        if (!c.extractedEndDate) return false;
        const days = Math.ceil((new Date(c.extractedEndDate).getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        return days > 0 && days <= 30;
      }).length,
      within90Days: expiringIn90Days,
      beyond90Days: activeContracts.filter(c => {
        if (!c.extractedEndDate) return false;
        const days = Math.ceil((new Date(c.extractedEndDate).getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
        return days > 90;
      }).length,
    },
  };
}

function calculateMonthlySpend(contracts: any[]): Record<string, number> {
  const monthlySpend: Record<string, number> = {};
  
  contracts.forEach(contract => {
    if (contract._creationTime && contract.status === "active") {
      const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
      if (value > 0) {
        const date = new Date(contract._creationTime);
        const monthKey = `${date.getFullYear()}-${(date.getMonth() + 1).toString().padStart(2, '0')}`;
        monthlySpend[monthKey] = (monthlySpend[monthKey] || 0) + value;
      }
    }
  });
  
  return monthlySpend;
}

function groupByQuarter(monthlyData: Record<string, number>): Record<string, number> {
  const quarters: Record<string, number> = {};
  
  Object.entries(monthlyData).forEach(([month, value]) => {
    const [year, monthNum] = month.split('-');
    const quarter = Math.ceil(parseInt(monthNum) / 3);
    const quarterKey = `${year}-Q${quarter}`;
    quarters[quarterKey] = (quarters[quarterKey] || 0) + value;
  });
  
  return quarters;
}

function calculateYoYGrowth(monthlySpend: Record<string, number>): number {
  const now = new Date();
  const currentYear = now.getFullYear();
  const lastYear = currentYear - 1;
  
  let currentYearTotal = 0;
  let lastYearTotal = 0;
  
  Object.entries(monthlySpend).forEach(([month, value]) => {
    const year = parseInt(month.split('-')[0]);
    if (year === currentYear) {
      currentYearTotal += value;
    } else if (year === lastYear) {
      lastYearTotal += value;
    }
  });
  
  if (lastYearTotal === 0) return 0;
  
  return (currentYearTotal - lastYearTotal) / lastYearTotal;
}

function analyzeSpendingPatterns(contracts: any[]): any {
  const monthlySpend = calculateMonthlySpend(contracts);
  const monthlyValues = Object.values(monthlySpend);
  
  if (monthlyValues.length < 12) {
    return { seasonality: { isSeasonal: false }, patterns: [] };
  }
  
  // Simple seasonality detection
  const monthlyAverages: number[] = new Array(12).fill(0);
  const monthlyCounts: number[] = new Array(12).fill(0);
  
  Object.entries(monthlySpend).forEach(([month, value]) => {
    const monthNum = parseInt(month.split('-')[1]) - 1;
    monthlyAverages[monthNum] += value;
    monthlyCounts[monthNum]++;
  });
  
  for (let i = 0; i < 12; i++) {
    if (monthlyCounts[i] > 0) {
      monthlyAverages[i] /= monthlyCounts[i];
    }
  }
  
  const avgSpend = monthlyAverages.reduce((sum, v) => sum + v, 0) / 12;
  const maxMonth = monthlyAverages.indexOf(Math.max(...monthlyAverages));
  const maxVariance = Math.max(...monthlyAverages) / avgSpend;
  
  return {
    seasonality: {
      isSeasonal: maxVariance > 1.3,
      peakMonth: new Date(2024, maxMonth).toLocaleString('default', { month: 'long' }),
      variance: maxVariance,
    },
    monthlyAverages,
    trend: monthlyValues.length > 1 && monthlyValues[monthlyValues.length - 1] > monthlyValues[0] 
      ? "increasing" : "decreasing",
  };
}

async function analyzeBudgetVariance(ctx: any, contracts: any[]): Promise<any> {
  // This would typically fetch budget data from a budgets table
  // For now, we'll use a placeholder
  const annualBudget = 1000000; // Example budget
  
  const currentYearSpend = contracts
    .filter(c => {
      if (!c._creationTime) return false;
      const year = new Date(c._creationTime).getFullYear();
      return year === new Date().getFullYear() && c.status === "active";
    })
    .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0);
  
  const monthsElapsed = new Date().getMonth() + 1;
  const expectedSpend = (annualBudget / 12) * monthsElapsed;
  const variance = currentYearSpend - expectedSpend;
  const variancePercent = expectedSpend > 0 ? (variance / expectedSpend) * 100 : 0;
  
  return {
    budget: annualBudget,
    actualSpend: currentYearSpend,
    expectedSpend,
    variance,
    variancePercent,
    projectedAnnualSpend: (currentYearSpend / monthsElapsed) * 12,
  };
}

function detectPricingAnomalies(contracts: any[]): any[] {
  const anomalies: any[] = [];
  
  // Group contracts by type for comparison
  const contractsByType: Record<string, any[]> = {};
  
  contracts.forEach(contract => {
    const type = contract.contractType || "other";
    if (!contractsByType[type]) {
      contractsByType[type] = [];
    }
    contractsByType[type].push(contract);
  });
  
  // Detect anomalies within each type
  Object.entries(contractsByType).forEach(([type, typeContracts]) => {
    if (typeContracts.length < 5) return; // Need enough data
    
    const values = typeContracts
      .map(c => parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'))
      .filter(v => v > 0);
    
    if (values.length < 5) return;
    
    const mean = values.reduce((sum, v) => sum + v, 0) / values.length;
    const variance = values.reduce((sum, v) => sum + Math.pow(v - mean, 2), 0) / values.length;
    const stdDev = Math.sqrt(variance);
    
    typeContracts.forEach(contract => {
      const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
      if (value > 0) {
        const zScore = Math.abs((value - mean) / stdDev);
        
        if (zScore > ANALYTICS_CONFIG.insightRules.unusualActivityStdDev) {
          anomalies.push({
            contractId: contract._id,
            contractTitle: contract.title,
            contractType: type,
            vendorId: contract.vendorId,
            value,
            mean,
            stdDev,
            standardDeviations: zScore,
            percentageDifference: ((value - mean) / mean * 100).toFixed(1),
          });
        }
      }
    });
  });
  
  return anomalies;
}

async function detectVendorActivityAnomalies(ctx: any): Promise<any[]> {
  const anomalies: any[] = [];
  
  // Get recent vendor activity
  const thirtyDaysAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  
  const recentContracts = await ctx.db
    .query("contracts")
    .filter((q: any) => q.gte(q.field("_creationTime"), thirtyDaysAgo.getTime()))
    .collect();
  
  // Count contracts per vendor
  const vendorActivity: Record<string, number> = {};
  recentContracts.forEach(contract => {
    const vendorId = contract.vendorId.toString();
    vendorActivity[vendorId] = (vendorActivity[vendorId] || 0) + 1;
  });
  
  // Detect unusual activity
  const activityCounts = Object.values(vendorActivity);
  if (activityCounts.length > 0) {
    const mean = activityCounts.reduce((sum, v) => sum + v, 0) / activityCounts.length;
    
    Object.entries(vendorActivity).forEach(([vendorId, count]) => {
      if (count > mean * 3) {
        anomalies.push({
          vendorId,
          activityCount: count,
          averageActivity: mean,
          description: `Vendor has ${count} new contracts in 30 days (average is ${mean.toFixed(1)})`,
        });
      }
    });
  }
  
  return anomalies;
}

function detectContractTermAnomalies(contracts: any[]): any[] {
  const anomalies: any[] = [];
  
  contracts.forEach(contract => {
    // Check for unusual contract duration
    if (contract.extractedStartDate && contract.extractedEndDate) {
      const startDate = new Date(contract.extractedStartDate);
      const endDate = new Date(contract.extractedEndDate);
      const durationDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
      
      if (durationDays > 1825) { // More than 5 years
        anomalies.push({
          contractId: contract._id,
          type: "long_duration",
          description: `Unusually long contract duration: ${Math.round(durationDays / 365)} years`,
          durationDays,
        });
      } else if (durationDays < 30) { // Less than 30 days
        anomalies.push({
          contractId: contract._id,
          type: "short_duration",
          description: `Unusually short contract duration: ${durationDays} days`,
          durationDays,
        });
      }
    }
    
    // Check for missing critical dates
    if (contract.status === "active" && !contract.extractedEndDate) {
      anomalies.push({
        contractId: contract._id,
        type: "missing_end_date",
        description: "Active contract without specified end date",
      });
    }
  });
  
  return anomalies;
}

function forecastContractVolume(contracts: any[]): any {
  const monthlyVolume = analyzeVolumeTrends(contracts).monthlyVolume;
  const months = Object.keys(monthlyVolume).sort();
  
  if (months.length < 6) {
    return { nextQuarter: 0, confidence: 0 };
  }
  
  // Simple moving average forecast
  const recentMonths = months.slice(-6);
  const recentVolumes = recentMonths.map(m => monthlyVolume[m]);
  const avgMonthlyVolume = recentVolumes.reduce((sum, v) => sum + v, 0) / recentVolumes.length;
  
  // Calculate trend
  const firstHalf = recentVolumes.slice(0, 3).reduce((sum, v) => sum + v, 0) / 3;
  const secondHalf = recentVolumes.slice(3).reduce((sum, v) => sum + v, 0) / 3;
  const trend = (secondHalf - firstHalf) / firstHalf;
  
  const nextQuarterVolume = Math.round(avgMonthlyVolume * 3 * (1 + trend));
  
  return {
    nextQuarter: nextQuarterVolume,
    confidence: 70, // Simple forecast, moderate confidence
    basis: "6-month moving average with trend adjustment",
    historicalAverage: avgMonthlyVolume,
    trend: (trend * 100).toFixed(1) + "%",
  };
}

function forecastSpending(contracts: any[]): any {
  const monthlySpend = calculateMonthlySpend(contracts);
  const months = Object.keys(monthlySpend).sort();
  
  if (months.length < 6) {
    return { nextQuarterSpend: 0, confidence: 0 };
  }
  
  // Calculate average monthly spend
  const recentMonths = months.slice(-6);
  const recentSpend = recentMonths.map(m => monthlySpend[m]);
  const avgMonthlySpend = recentSpend.reduce((sum, v) => sum + v, 0) / recentSpend.length;
  
  // Add seasonality adjustment
  const currentMonth = new Date().getMonth();
  const seasonalFactor = 1; // Would calculate based on historical patterns
  
  const nextQuarterSpend = avgMonthlySpend * 3 * seasonalFactor;
  
  return {
    nextQuarterSpend,
    confidence: 75,
    monthlyAverage: avgMonthlySpend,
    seasonalAdjustment: seasonalFactor,
    basis: "6-month average with seasonal adjustment",
  };
}

async function predictRenewalOpportunities(ctx: any, contracts: any[]): Promise<any> {
  const next180Days = new Date(Date.now() + 180 * 24 * 60 * 60 * 1000);
  
  const expiringContracts = contracts.filter(c => {
    if (c.status !== "active" || !c.extractedEndDate) return false;
    const endDate = new Date(c.extractedEndDate);
    return endDate <= next180Days && endDate > new Date();
  });
  
  const renewalOpportunities = expiringContracts.map(contract => ({
    contractId: contract._id,
    title: contract.title,
    vendorId: contract.vendorId,
    value: parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'),
    expiryDate: contract.extractedEndDate,
    daysUntilExpiry: Math.ceil(
      (new Date(contract.extractedEndDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
    ),
    renewalProbability: 0.75, // Would calculate based on historical data
  }));
  
  const highValueThreshold = 50000;
  const highValueRenewals = renewalOpportunities.filter(r => r.value >= highValueThreshold);
  
  return {
    totalOpportunities: renewalOpportunities.length,
    highValueRenewals,
    totalValue: renewalOpportunities.reduce((sum, r) => sum + r.value, 0),
    expectedRenewalValue: renewalOpportunities.reduce((sum, r) => sum + (r.value * r.renewalProbability), 0),
    timeline: {
      within30Days: renewalOpportunities.filter(r => r.daysUntilExpiry <= 30).length,
      within90Days: renewalOpportunities.filter(r => r.daysUntilExpiry <= 90).length,
      within180Days: renewalOpportunities.length,
    },
  };
}

function predictRiskEvents(contracts: any[]): any {
  const riskIndicators: any[] = [];
  
  contracts.forEach(contract => {
    let riskScore = 0;
    const risks: string[] = [];
    
    // High value without end date
    if (contract.status === "active" && !contract.extractedEndDate) {
      const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
      if (value > 100000) {
        riskScore += 30;
        risks.push("High value contract without end date");
      }
    }
    
    // Expiring soon without renewal plan
    if (contract.extractedEndDate) {
      const daysUntilExpiry = Math.ceil(
        (new Date(contract.extractedEndDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );
      if (daysUntilExpiry <= 30 && daysUntilExpiry > 0) {
        riskScore += 20;
        risks.push("Expiring soon without renewal plan");
      }
    }
    
    // Missing critical information
    if (!contract.extractedPaymentSchedule) {
      riskScore += 10;
      risks.push("Missing payment schedule");
    }
    
    if (riskScore >= 30) {
      riskIndicators.push({
        contractId: contract._id,
        title: contract.title,
        riskScore,
        risks,
        recommendedActions: generateRiskMitigationActions(risks),
      });
    }
  });
  
  return {
    totalRisks: riskIndicators.length,
    highRiskContracts: riskIndicators.filter(r => r.riskScore >= 40),
    mediumRiskContracts: riskIndicators.filter(r => r.riskScore >= 20 && r.riskScore < 40),
    riskDistribution: {
      missingInfo: riskIndicators.filter(r => r.risks.some((risk: string) => risk.includes("Missing"))).length,
      expirationRisk: riskIndicators.filter(r => r.risks.some((risk: string) => risk.includes("Expiring"))).length,
      valueRisk: riskIndicators.filter(r => r.risks.some((risk: string) => risk.includes("High value"))).length,
    },
  };
}

function generateRiskMitigationActions(risks: string[]): string[] {
  const actions: string[] = [];
  
  risks.forEach(risk => {
    if (risk.includes("end date")) {
      actions.push("Define contract end date and renewal terms");
    }
    if (risk.includes("Expiring")) {
      actions.push("Initiate renewal discussions with vendor");
      actions.push("Prepare contract renewal or replacement");
    }
    if (risk.includes("payment")) {
      actions.push("Document payment terms and schedule");
    }
  });
  
  return [...new Set(actions)];
}

// ============================================================================
// REPORT GENERATION FUNCTIONS
// ============================================================================

async function generateWeeklyReport(ctx: any, agentId: Id<"agents">): Promise<void> {
  const oneWeekAgo = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
  
  // Gather weekly metrics
  const weeklyMetrics = await gatherWeeklyMetrics(ctx, oneWeekAgo);
  
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "report",
    title: "Weekly Analytics Report",
    description: `Weekly summary: ${weeklyMetrics.newContracts} new contracts, ${formatCurrency(weeklyMetrics.totalValue)} in value`,
    priority: "low",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: weeklyMetrics,
  });
}

async function generateMonthlyReport(ctx: any, agentId: Id<"agents">): Promise<void> {
  const oneMonthAgo = new Date(Date.now() - 30 * 24 * 60 * 60 * 1000);
  
  const monthlyMetrics = await gatherMonthlyMetrics(ctx, oneMonthAgo);
  
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "report",
    title: "Monthly Analytics Report",
    description: `Monthly performance summary with ${monthlyMetrics.highlights.length} key highlights`,
    priority: "medium",
    actionRequired: monthlyMetrics.actionItems.length > 0,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: monthlyMetrics,
  });
}

async function generateQuarterlyReport(ctx: any, agentId: Id<"agents">): Promise<void> {
  const threeMonthsAgo = new Date(Date.now() - 90 * 24 * 60 * 60 * 1000);
  
  const quarterlyMetrics = await gatherQuarterlyMetrics(ctx, threeMonthsAgo);
  
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "report",
    title: "Quarterly Business Review",
    description: "Comprehensive quarterly analysis with strategic recommendations",
    priority: "high",
    actionRequired: true,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: quarterlyMetrics,
  });
}

async function gatherWeeklyMetrics(ctx: any, since: Date): Promise<any> {
  const contracts = await ctx.db
    .query("contracts")
    .filter((q: any) => q.gte(q.field("_creationTime"), since.getTime()))
    .collect();
  
  return {
    period: "weekly",
    startDate: since.toISOString(),
    endDate: new Date().toISOString(),
    newContracts: contracts.length,
    totalValue: contracts.reduce((sum, c) => 
      sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
    ),
    byStatus: contracts.reduce((acc, c) => {
      acc[c.status] = (acc[c.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>),
    topVendors: [], // Would calculate
    expiringNext7Days: 0, // Would calculate
  };
}

async function gatherMonthlyMetrics(ctx: any, since: Date): Promise<any> {
  const now = new Date();
  
  // Get all relevant data
  const [contracts, vendors, insights, tasks] = await Promise.all([
    ctx.db.query("contracts").collect(),
    ctx.db.query("vendors").collect(),
    ctx.db.query("agentInsights")
      .filter((q: any) => q.gte(q.field("createdAt"), since.toISOString()))
      .collect(),
    ctx.db.query("agentTasks")
      .filter((q: any) => q.gte(q.field("createdAt"), since.toISOString()))
      .collect(),
  ]);

  // Filter contracts by period
  const periodContracts = contracts.filter(c => 
    c._creationTime && c._creationTime >= since.getTime()
  );
  const previousPeriodStart = new Date(since.getTime() - 30 * 24 * 60 * 60 * 1000);
  const previousPeriodContracts = contracts.filter(c => 
    c._creationTime && 
    c._creationTime >= previousPeriodStart.getTime() && 
    c._creationTime < since.getTime()
  );

  // Calculate comprehensive metrics
  const activeContracts = contracts.filter(c => c.status === "active");
  const expiredThisPeriod = periodContracts.filter(c => c.status === "expired");
  const newActiveContracts = periodContracts.filter(c => c.status === "active");

  // Financial metrics
  const totalValue = activeContracts.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  const periodValue = periodContracts.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  const previousPeriodValue = previousPeriodContracts.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  const valueGrowth = previousPeriodValue > 0 
    ? ((periodValue - previousPeriodValue) / previousPeriodValue) * 100 
    : 0;

  // Vendor metrics
  const activeVendors = new Set(activeContracts.map(c => c.vendorId.toString())).size;
  const newVendors = vendors.filter(v => 
    v._creationTime && v._creationTime >= since.getTime()
  ).length;

  // Contract cycle time (simplified - would track actual status changes in production)
  const completedContracts = periodContracts.filter(c => 
    c.analysisStatus === "completed" && c._creationTime
  );
  const avgCycleTime = completedContracts.length > 0
    ? completedContracts.reduce((sum, c) => sum + 7, 0) / completedContracts.length // Placeholder
    : 0;

  // Risk metrics
  const highRiskInsights = insights.filter(i => 
    i.priority === "critical" || (i.priority === "high" && i.actionRequired)
  );
  const resolvedRisks = insights.filter(i => i.actionTaken).length;

  // Compliance metrics
  const complianceIssues = insights.filter(i => 
    i.type === "compliance_alert" || i.type === "legal_review"
  );
  const complianceRate = activeContracts.length > 0
    ? (activeContracts.length - complianceIssues.length) / activeContracts.length
    : 1;

  // Cost savings
  const savingsInsights = insights.filter(i => i.type === "cost_optimization");
  const identifiedSavings = savingsInsights.reduce((sum, i) => 
    sum + (i.data?.potentialSavings || 0), 0
  );

  // Upcoming expirations
  const next30Days = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
  const expiringNext30Days = activeContracts.filter(c => {
    if (!c.extractedEndDate) return false;
    const endDate = new Date(c.extractedEndDate);
    return endDate <= next30Days && endDate > now;
  });

  // Generate highlights
  const highlights: string[] = [];
  
  if (valueGrowth > 10) {
    highlights.push(`${valueGrowth.toFixed(1)}% increase in contract value month-over-month`);
  } else if (valueGrowth < -10) {
    highlights.push(`${Math.abs(valueGrowth).toFixed(1)}% decrease in contract value - review needed`);
  }
  
  if (periodContracts.length > previousPeriodContracts.length * 1.2) {
    highlights.push(`${periodContracts.length} new contracts created (20%+ increase)`);
  }
  
  if (identifiedSavings > 0) {
    highlights.push(`${formatCurrency(identifiedSavings)} in potential cost savings identified`);
  }
  
  if (avgCycleTime > 0 && avgCycleTime < 7) {
    highlights.push(`Average contract cycle time improved to ${avgCycleTime.toFixed(1)} days`);
  }
  
  if (complianceRate < 0.9) {
    highlights.push(`Compliance rate at ${(complianceRate * 100).toFixed(1)}% - attention needed`);
  }

  // Generate action items
  const actionItems: string[] = [];
  
  if (expiringNext30Days.length > 0) {
    actionItems.push(`Review ${expiringNext30Days.length} contracts expiring in next 30 days`);
  }
  
  if (highRiskInsights.length > resolvedRisks) {
    actionItems.push(`Address ${highRiskInsights.length - resolvedRisks} unresolved high-priority issues`);
  }
  
  const vendorConcentration = calculateVendorConcentration(activeContracts);
  if (vendorConcentration.topVendorPercentage > 30) {
    actionItems.push(`Reduce vendor concentration risk - ${vendorConcentration.topVendorPercentage.toFixed(1)}% with single vendor`);
  }
  
  if (newVendors === 0 && periodContracts.length > 10) {
    actionItems.push("Consider vendor diversification - no new vendors added this month");
  }

  return {
    period: "monthly",
    startDate: since.toISOString(),
    endDate: now.toISOString(),
    highlights,
    actionItems,
    
    summary: {
      totalActiveContracts: activeContracts.length,
      newContractsThisPeriod: periodContracts.length,
      contractsExpiredThisPeriod: expiredThisPeriod.length,
      totalActiveValue: totalValue,
      periodValue: periodValue,
      valueGrowth: valueGrowth,
      activeVendors: activeVendors,
      newVendors: newVendors,
      complianceRate: (complianceRate * 100).toFixed(1) + "%",
      identifiedSavings: identifiedSavings,
    },
    
    contractMetrics: {
      byStatus: periodContracts.reduce((acc, c) => {
        acc[c.status] = (acc[c.status] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      byType: periodContracts.reduce((acc, c) => {
        const type = c.contractType || "other";
        acc[type] = (acc[type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
      averageCycleTime: avgCycleTime,
      averageValue: periodContracts.length > 0 ? periodValue / periodContracts.length : 0,
    },
    
    vendorMetrics: {
      topVendorsByValue: getTopVendorsByValue(activeContracts, vendors, 5),
      vendorConcentration: vendorConcentration,
      newVendorOnboarding: newVendors,
      vendorPerformance: calculateVendorPerformanceScores(contracts, vendors, insights),
    },
    
    riskMetrics: {
      totalRisksIdentified: highRiskInsights.length,
      risksResolved: resolvedRisks,
      openRisks: highRiskInsights.length - resolvedRisks,
      risksByType: highRiskInsights.reduce((acc, i) => {
        acc[i.type] = (acc[i.type] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
    },
    
    upcomingEvents: {
      contractsExpiringNext30Days: expiringNext30Days.length,
      expiringValue: expiringNext30Days.reduce((sum, c) => 
        sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
      ),
      upcomingRenewals: expiringNext30Days.filter(c => 
        c.metadata?.autoRenewal || c.contractType === "saas"
      ).length,
      paymentsDueNext30Days: calculateUpcomingPayments(activeContracts, 30),
    },
    
    performanceIndicators: {
      taskCompletionRate: tasks.length > 0 
        ? (tasks.filter(t => t.status === "completed").length / tasks.length) * 100 
        : 100,
      insightActionRate: insights.length > 0
        ? (insights.filter(i => i.actionTaken).length / insights.filter(i => i.actionRequired).length) * 100
        : 100,
      systemUptime: 99.9, // Would calculate from agent logs
      dataQuality: calculateDataQualityScore(activeContracts),
    },
  };
}

async function gatherQuarterlyMetrics(ctx: any, since: Date): Promise<any> {
  const now = new Date();
  const quarterStart = since;
  const previousQuarterStart = new Date(quarterStart.getTime() - 90 * 24 * 60 * 60 * 1000);
  const yearAgoStart = new Date(quarterStart.getTime() - 365 * 24 * 60 * 60 * 1000);
  
  // Get comprehensive data
  const [contracts, vendors, insights, tasks, users, agentLogs] = await Promise.all([
    ctx.db.query("contracts").collect(),
    ctx.db.query("vendors").collect(),
    ctx.db.query("agentInsights").collect(),
    ctx.db.query("agentTasks").collect(),
    ctx.db.query("users").collect(),
    ctx.db.query("agentLogs")
      .filter((q: any) => q.gte(q.field("timestamp"), quarterStart.toISOString()))
      .collect(),
  ]);

  // Period filtering
  const quarterContracts = contracts.filter(c => 
    c._creationTime && c._creationTime >= quarterStart.getTime()
  );
  const previousQuarterContracts = contracts.filter(c => 
    c._creationTime && 
    c._creationTime >= previousQuarterStart.getTime() && 
    c._creationTime < quarterStart.getTime()
  );
  const yearAgoQuarterContracts = contracts.filter(c => 
    c._creationTime && 
    c._creationTime >= yearAgoStart.getTime() && 
    c._creationTime < (yearAgoStart.getTime() + 90 * 24 * 60 * 60 * 1000)
  );

  // Active contracts analysis
  const activeContracts = contracts.filter(c => c.status === "active");
  const activeContractValue = activeContracts.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );

  // Quarter-over-quarter analysis
  const qoqGrowth = calculateQuarterGrowth(quarterContracts, previousQuarterContracts);
  const yoyGrowth = calculateQuarterGrowth(quarterContracts, yearAgoQuarterContracts);

  // Vendor analysis
  const vendorMetrics = analyzeVendorQuarterlyPerformance(contracts, vendors, insights);
  
  // Financial analysis
  const financialAnalysis = performQuarterlyFinancialAnalysis(
    contracts, quarterContracts, previousQuarterContracts, yearAgoQuarterContracts
  );

  // Risk and compliance
  const riskAnalysis = performQuarterlyRiskAnalysis(contracts, insights);
  const complianceAnalysis = performQuarterlyComplianceAnalysis(contracts, insights);

  // Operational efficiency
  const operationalMetrics = calculateOperationalEfficiency(
    contracts, tasks, agentLogs, users, quarterStart
  );

  // Strategic recommendations
  const strategicRecommendations = generateStrategicRecommendations(
    qoqGrowth, yoyGrowth, vendorMetrics, financialAnalysis, riskAnalysis
  );

  // Executive summary
  const executiveSummary = generateExecutiveSummary(
    quarterContracts, activeContracts, financialAnalysis, vendorMetrics, operationalMetrics
  );

  return {
    period: "quarterly",
    quarter: `Q${Math.ceil((quarterStart.getMonth() + 1) / 3)} ${quarterStart.getFullYear()}`,
    startDate: quarterStart.toISOString(),
    endDate: now.toISOString(),
    
    executiveSummary,
    
    growth: {
      quarterOverQuarter: qoqGrowth,
      yearOverYear: yoyGrowth,
      contractVolume: {
        thisQuarter: quarterContracts.length,
        lastQuarter: previousQuarterContracts.length,
        yearAgoQuarter: yearAgoQuarterContracts.length,
        trend: calculateTrend(
          yearAgoQuarterContracts.length,
          previousQuarterContracts.length,
          quarterContracts.length
        ),
      },
    },
    
    financialAnalysis,
    vendorAnalysis: vendorMetrics,
    riskAnalysis,
    complianceAnalysis,
    operationalMetrics,
    
    contractPortfolio: {
      totalActive: activeContracts.length,
      totalValue: activeContractValue,
      byType: groupContractsByType(activeContracts),
      byStatus: groupContractsByStatus(contracts),
      avgContractValue: activeContracts.length > 0 
        ? activeContractValue / activeContracts.length 
        : 0,
      valueDistribution: analyzeValueDistribution(activeContracts),
      expirationSchedule: analyzeExpirationSchedule(activeContracts),
    },
    
    savingsAndOptimization: {
      identifiedSavings: calculateQuarterlySavings(insights),
      implementedSavings: calculateImplementedSavings(insights, contracts),
      optimizationOpportunities: identifyOptimizationOpportunities(
        contracts, vendors, financialAnalysis
      ),
      costAvoidance: calculateCostAvoidance(contracts, insights),
    },
    
    keyAchievements: generateKeyAchievements(
      quarterContracts, insights, tasks, operationalMetrics
    ),
    
    challenges: identifyChallenges(
      riskAnalysis, complianceAnalysis, operationalMetrics, vendorMetrics
    ),
    
    strategicRecommendations,
    
    nextQuarterPriorities: generateNextQuarterPriorities(
      riskAnalysis, vendorMetrics, financialAnalysis, activeContracts
    ),
    
    appendix: {
      detailedVendorList: vendorMetrics.allVendors,
      contractExpirationDetails: generateExpirationReport(activeContracts),
      complianceDetails: complianceAnalysis.details,
      systemPerformance: operationalMetrics.systemMetrics,
    },
  };
}

// Helper functions for quarterly metrics
function calculateQuarterGrowth(current: any[], previous: any[]): any {
  const currentValue = current.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  const previousValue = previous.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  
  const volumeGrowth = previous.length > 0 
    ? ((current.length - previous.length) / previous.length) * 100 
    : 0;
  const valueGrowth = previousValue > 0 
    ? ((currentValue - previousValue) / previousValue) * 100 
    : 0;

  return {
    volumeGrowth: volumeGrowth.toFixed(1) + "%",
    valueGrowth: valueGrowth.toFixed(1) + "%",
    absoluteVolumeChange: current.length - previous.length,
    absoluteValueChange: currentValue - previousValue,
    currentVolume: current.length,
    previousVolume: previous.length,
    currentValue,
    previousValue,
  };
}

function analyzeVendorQuarterlyPerformance(contracts: any[], vendors: any[], insights: any[]): any {
  const vendorMetrics = new Map<string, any>();
  
  vendors.forEach(vendor => {
    const vendorContracts = contracts.filter(c => c.vendorId === vendor._id);
    const activeContracts = vendorContracts.filter(c => c.status === "active");
    const totalValue = vendorContracts.reduce((sum, c) => 
      sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
    );
    
    const vendorInsights = insights.filter(i => i.vendorId === vendor._id);
    const riskScore = vendorInsights.filter(i => 
      i.type === "vendor_risk" || i.type === "financial_risk"
    ).length * 10;
    
    vendorMetrics.set(vendor._id.toString(), {
      vendor,
      totalContracts: vendorContracts.length,
      activeContracts: activeContracts.length,
      totalValue,
      riskScore,
      performanceScore: calculateVendorPerformanceScore(vendorContracts, vendorInsights),
      insights: vendorInsights.length,
    });
  });
  
  const sortedVendors = Array.from(vendorMetrics.values())
    .sort((a, b) => b.totalValue - a.totalValue);
  
  return {
    totalVendors: vendors.length,
    activeVendors: sortedVendors.filter(v => v.activeContracts > 0).length,
    topVendorsByValue: sortedVendors.slice(0, 10),
    vendorConcentration: calculateDetailedVendorConcentration(sortedVendors),
    highRiskVendors: sortedVendors.filter(v => v.riskScore >= 30),
    performanceDistribution: groupVendorsByPerformance(sortedVendors),
    allVendors: sortedVendors,
  };
}

function performQuarterlyFinancialAnalysis(
  allContracts: any[], 
  quarter: any[], 
  previousQuarter: any[], 
  yearAgoQuarter: any[]
): any {
  const activeContracts = allContracts.filter(c => c.status === "active");
  
  // Calculate various financial metrics
  const totalCommitted = activeContracts.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  
  const quarterSpend = quarter.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  
  const monthlyBurn = calculateMonthlyBurn(activeContracts);
  const annualProjection = monthlyBurn * 12;
  
  return {
    totalCommittedValue: totalCommitted,
    quarterlySpend: quarterSpend,
    monthlyBurnRate: monthlyBurn,
    annualProjection,
    
    spendByCategory: groupSpendByCategory(quarter),
    spendByDepartment: groupSpendByDepartment(quarter),
    spendTrend: analyzeSpendTrend(allContracts),
    
    budgetAnalysis: {
      projectedVsBudget: "Within budget", // Would compare with actual budget
      variancePercentage: 0,
      recommendations: [],
    },
    
    costStructure: {
      fixedCosts: calculateFixedCosts(activeContracts),
      variableCosts: calculateVariableCosts(activeContracts),
      oneTimeCosts: calculateOneTimeCosts(quarter),
    },
    
    roi: calculateQuarterlyROI(quarter, previousQuarter),
    paymentSchedule: analyzePaymentSchedule(activeContracts),
  };
}

function performQuarterlyRiskAnalysis(contracts: any[], insights: any[]): any {
  const activeContracts = contracts.filter(c => c.status === "active");
  const riskInsights = insights.filter(i => 
    i.type === "financial_risk" || 
    i.type === "vendor_risk" || 
    i.type === "legal_review" ||
    i.type === "compliance_alert"
  );
  
  return {
    overallRiskScore: calculateOverallRiskScore(activeContracts, riskInsights),
    risksByCategory: {
      financial: riskInsights.filter(i => i.type === "financial_risk").length,
      vendor: riskInsights.filter(i => i.type === "vendor_risk").length,
      legal: riskInsights.filter(i => i.type === "legal_review").length,
      compliance: riskInsights.filter(i => i.type === "compliance_alert").length,
    },
    highRiskContracts: identifyHighRiskContracts(activeContracts, riskInsights),
    mitigationStatus: {
      identified: riskInsights.length,
      addressed: riskInsights.filter(i => i.actionTaken).length,
      pending: riskInsights.filter(i => !i.actionTaken && i.actionRequired).length,
    },
    emergingRisks: identifyEmergingRisks(contracts, insights),
    riskTrends: analyzeRiskTrends(insights),
  };
}

function performQuarterlyComplianceAnalysis(contracts: any[], insights: any[]): any {
  const complianceInsights = insights.filter(i => 
    i.type === "compliance_alert" || i.type === "legal_review"
  );
  
  const activeContracts = contracts.filter(c => c.status === "active");
  const compliantContracts = activeContracts.filter(c => 
    !complianceInsights.some(i => i.contractId === c._id && !i.actionTaken)
  );
  
  return {
    overallComplianceRate: activeContracts.length > 0 
      ? (compliantContracts.length / activeContracts.length) * 100 
      : 100,
    
    complianceByType: groupComplianceByContractType(contracts, complianceInsights),
    
    violations: {
      total: complianceInsights.length,
      resolved: complianceInsights.filter(i => i.actionTaken).length,
      pending: complianceInsights.filter(i => !i.actionTaken).length,
      critical: complianceInsights.filter(i => i.priority === "critical").length,
    },
    
    regulatoryUpdates: [], // Would track actual regulatory changes
    
    auditReadiness: calculateAuditReadiness(contracts, complianceInsights),
    
    details: complianceInsights.map(i => ({
      type: i.type,
      title: i.title,
      contractId: i.contractId,
      severity: i.priority,
      status: i.actionTaken ? "resolved" : "pending",
      createdAt: i.createdAt,
    })),
  };
}

function calculateOperationalEfficiency(
  contracts: any[], 
  tasks: any[], 
  logs: any[], 
  users: any[],
  since: Date
): any {
  const periodTasks = tasks.filter(t => 
    t.createdAt && new Date(t.createdAt) >= since
  );
  
  const completedTasks = periodTasks.filter(t => t.status === "completed");
  const avgTaskCompletionTime = calculateAverageTaskCompletionTime(completedTasks);
  
  return {
    contractProcessingTime: calculateAverageContractProcessingTime(contracts),
    taskCompletionRate: periodTasks.length > 0 
      ? (completedTasks.length / periodTasks.length) * 100 
      : 100,
    averageTaskCompletionTime: avgTaskCompletionTime,
    
    userProductivity: {
      contractsPerUser: contracts.length / users.length,
      activeUsers: users.filter(u => u.lastLoginAt && 
        new Date(u.lastLoginAt) >= new Date(Date.now() - 30 * 24 * 60 * 60 * 1000)
      ).length,
    },
    
    automationMetrics: {
      automatedTasks: periodTasks.filter(t => t.createdByAgentId).length,
      manualTasks: periodTasks.filter(t => !t.createdByAgentId).length,
      automationRate: periodTasks.length > 0
        ? (periodTasks.filter(t => t.createdByAgentId).length / periodTasks.length) * 100
        : 0,
    },
    
    systemMetrics: {
      uptime: calculateSystemUptime(logs),
      errorRate: calculateErrorRate(logs),
      averageResponseTime: calculateAverageResponseTime(logs),
      agentPerformance: calculateAgentPerformance(logs),
    },
  };
}

function generateStrategicRecommendations(
  qoqGrowth: any,
  yoyGrowth: any,
  vendorMetrics: any,
  financialAnalysis: any,
  riskAnalysis: any
): string[] {
  const recommendations: string[] = [];
  
  // Growth recommendations
  if (parseFloat(qoqGrowth.valueGrowth) > 20) {
    recommendations.push("Rapid growth detected - consider scaling contract management resources");
  } else if (parseFloat(qoqGrowth.valueGrowth) < -10) {
    recommendations.push("Contract value declining - investigate causes and develop retention strategy");
  }
  
  // Vendor recommendations
  if (vendorMetrics.vendorConcentration.top3Percentage > 60) {
    recommendations.push("High vendor concentration risk - develop vendor diversification strategy");
  }
  
  if (vendorMetrics.highRiskVendors.length > 5) {
    recommendations.push("Multiple high-risk vendor relationships - implement vendor risk management program");
  }
  
  // Financial recommendations
  if (financialAnalysis.annualProjection > financialAnalysis.totalCommittedValue * 1.2) {
    recommendations.push("Projected spend exceeds commitments - review contract terms and negotiate better rates");
  }
  
  // Risk recommendations
  if (riskAnalysis.overallRiskScore > 70) {
    recommendations.push("Elevated risk profile - prioritize risk mitigation initiatives");
  }
  
  if (riskAnalysis.mitigationStatus.pending > 10) {
    recommendations.push(`${riskAnalysis.mitigationStatus.pending} unaddressed risks - allocate resources for risk resolution`);
  }
  
  // Operational recommendations
  const savingsPercentage = (financialAnalysis.quarterlySpend > 0) 
    ? (parseFloat(yoyGrowth.absoluteValueChange) / financialAnalysis.quarterlySpend) * 100 
    : 0;
    
  if (savingsPercentage < 5) {
    recommendations.push("Limited cost savings achieved - implement systematic cost optimization program");
  }
  
  return recommendations;
}

function generateExecutiveSummary(
  quarterContracts: any[],
  activeContracts: any[],
  financial: any,
  vendor: any,
  operational: any
): any {
  const totalValue = activeContracts.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  
  return {
    keyMessage: generateKeyMessage(quarterContracts, financial, vendor),
    
    highlights: [
      `${quarterContracts.length} new contracts worth ${formatCurrency(financial.quarterlySpend)}`,
      `${activeContracts.length} active contracts with total value of ${formatCurrency(totalValue)}`,
      `${vendor.activeVendors} active vendor relationships`,
      `${operational.automationMetrics.automationRate.toFixed(1)}% task automation rate`,
    ],
    
    criticalMetrics: {
      contractGrowth: `${((quarterContracts.length / activeContracts.length) * 100).toFixed(1)}%`,
      spendEfficiency: financial.roi || "N/A",
      vendorConcentration: `${vendor.vendorConcentration.topVendorPercentage.toFixed(1)}%`,
      operationalEfficiency: `${operational.taskCompletionRate.toFixed(1)}%`,
    },
    
    executiveActions: generateExecutiveActions(financial, vendor, operational),
  };
}

// Additional helper functions
function calculateVendorConcentration(contracts: any[]): any {
  const vendorSpend: Record<string, number> = {};
  let totalSpend = 0;
  
  contracts.forEach(contract => {
    const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
    if (value > 0) {
      const vendorId = contract.vendorId.toString();
      vendorSpend[vendorId] = (vendorSpend[vendorId] || 0) + value;
      totalSpend += value;
    }
  });
  
  const sortedVendors = Object.entries(vendorSpend)
    .sort(([, a], [, b]) => b - a);
  
  const topVendorSpend = sortedVendors[0]?.[1] || 0;
  const top3Spend = sortedVendors.slice(0, 3)
    .reduce((sum, [, value]) => sum + value, 0);
  
  return {
    topVendorPercentage: totalSpend > 0 ? (topVendorSpend / totalSpend) * 100 : 0,
    top3Percentage: totalSpend > 0 ? (top3Spend / totalSpend) * 100 : 0,
    vendorCount: Object.keys(vendorSpend).length,
    herfindahlIndex: calculateHerfindahlIndex(vendorSpend, totalSpend),
  };
}

function calculateHerfindahlIndex(vendorSpend: Record<string, number>, totalSpend: number): number {
  if (totalSpend === 0) return 0;
  
  return Object.values(vendorSpend)
    .reduce((sum, spend) => {
      const marketShare = spend / totalSpend;
      return sum + (marketShare * marketShare);
    }, 0) * 10000; // Scale to 0-10000
}

function getTopVendorsByValue(contracts: any[], vendors: any[], limit: number): any[] {
  const vendorMap = new Map(vendors.map(v => [v._id.toString(), v]));
  const vendorValues: Record<string, number> = {};
  
  contracts.forEach(contract => {
    const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
    const vendorId = contract.vendorId.toString();
    vendorValues[vendorId] = (vendorValues[vendorId] || 0) + value;
  });
  
  return Object.entries(vendorValues)
    .sort(([, a], [, b]) => b - a)
    .slice(0, limit)
    .map(([vendorId, value]) => ({
      vendor: vendorMap.get(vendorId),
      totalValue: value,
      contractCount: contracts.filter(c => c.vendorId.toString() === vendorId).length,
    }));
}

function calculateVendorPerformanceScores(contracts: any[], vendors: any[], insights: any[]): any {
  const scores: Record<string, any> = {};
  
  vendors.forEach(vendor => {
    const vendorContracts = contracts.filter(c => c.vendorId === vendor._id);
    const vendorInsights = insights.filter(i => i.vendorId === vendor._id);
    
    const riskInsights = vendorInsights.filter(i => 
      i.type === "vendor_risk" || i.type === "financial_risk"
    );
    
    const complianceScore = vendorInsights.filter(i => 
      i.type === "compliance_alert"
    ).length === 0 ? 100 : 50;
    
    const valueScore = vendorContracts.reduce((sum, c) => 
      sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
    );
    
    scores[vendor._id.toString()] = {
      vendorName: vendor.name,
      overallScore: (complianceScore + (riskInsights.length === 0 ? 100 : 50)) / 2,
      complianceScore,
      riskScore: riskInsights.length === 0 ? 100 : Math.max(0, 100 - (riskInsights.length * 20)),
      valueScore,
      contractCount: vendorContracts.length,
    };
  });
  
  return scores;
}

function calculateUpcomingPayments(contracts: any[], days: number): any {
  const upcomingPayments: any[] = [];
  const cutoffDate = new Date(Date.now() + days * 24 * 60 * 60 * 1000);
  
  contracts.forEach(contract => {
    if (contract.extractedPaymentSchedule) {
      // Simple parsing - in production would be more sophisticated
      const monthlyValue = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0') / 12;
      
      if (contract.extractedPaymentSchedule.toLowerCase().includes('monthly')) {
        upcomingPayments.push({
          contractId: contract._id,
          amount: monthlyValue,
          frequency: 'monthly',
          nextDue: new Date(Date.now() + 30 * 24 * 60 * 60 * 1000),
        });
      }
    }
  });
  
  return {
    count: upcomingPayments.length,
    totalAmount: upcomingPayments.reduce((sum, p) => sum + p.amount, 0),
    payments: upcomingPayments,
  };
}

function calculateDataQualityScore(contracts: any[]): number {
  if (contracts.length === 0) return 100;
  
  let totalScore = 0;
  
  contracts.forEach(contract => {
    let contractScore = 0;
    let fields = 0;
    
    // Check required fields
    if (contract.title) { contractScore++; fields++; }
    if (contract.contractType) { contractScore++; fields++; }
    if (contract.extractedStartDate) { contractScore++; fields++; }
    if (contract.extractedEndDate) { contractScore++; fields++; }
    if (contract.extractedPricing) { contractScore++; fields++; }
    if (contract.extractedPaymentSchedule) { contractScore++; fields++; }
    if (contract.extractedParties?.length > 0) { contractScore++; fields++; }
    
    totalScore += (fields > 0 ? (contractScore / fields) : 0) * 100;
  });
  
  return totalScore / contracts.length;
}

function calculateVendorPerformanceScore(contracts: any[], insights: any[]): number {
  if (contracts.length === 0) return 0;
  
  const issues = insights.filter(i => 
    i.type === "vendor_risk" || 
    i.type === "compliance_alert" || 
    i.priority === "critical"
  ).length;
  
  const baseScore = 100;
  const deduction = Math.min(issues * 10, 50);
  
  return Math.max(baseScore - deduction, 0);
}

function calculateTrend(oldest: number, middle: number, newest: number): string {
  const firstGrowth = middle > 0 ? ((middle - oldest) / oldest) : 0;
  const secondGrowth = newest > 0 ? ((newest - middle) / middle) : 0;
  
  if (firstGrowth > 0.1 && secondGrowth > 0.1) return "accelerating";
  if (firstGrowth > 0 && secondGrowth > 0) return "growing";
  if (firstGrowth < -0.1 && secondGrowth < -0.1) return "declining";
  if (firstGrowth < 0 && secondGrowth < 0) return "contracting";
  return "stable";
}

function groupContractsByType(contracts: any[]): Record<string, number> {
  return contracts.reduce((acc, c) => {
    const type = c.contractType || "other";
    acc[type] = (acc[type] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}

function groupContractsByStatus(contracts: any[]): Record<string, number> {
  return contracts.reduce((acc, c) => {
    acc[c.status] = (acc[c.status] || 0) + 1;
    return acc;
  }, {} as Record<string, number>);
}

function analyzeExpirationSchedule(contracts: any[]): any {
  const schedule: Record<string, number> = {
    expired: 0,
    within30Days: 0,
    within90Days: 0,
    within180Days: 0,
    within1Year: 0,
    beyond1Year: 0,
    noEndDate: 0,
  };
  
  const now = new Date();
  
  contracts.forEach(contract => {
    if (!contract.extractedEndDate) {
      schedule.noEndDate++;
      return;
    }
    
    const endDate = new Date(contract.extractedEndDate);
    const daysUntil = Math.ceil((endDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24));
    
    if (daysUntil < 0) schedule.expired++;
    else if (daysUntil <= 30) schedule.within30Days++;
    else if (daysUntil <= 90) schedule.within90Days++;
    else if (daysUntil <= 180) schedule.within180Days++;
    else if (daysUntil <= 365) schedule.within1Year++;
    else schedule.beyond1Year++;
  });
  
  return schedule;
}

function calculateQuarterlySavings(insights: any[]): number {
  return insights
    .filter(i => i.type === "cost_optimization")
    .reduce((sum, i) => sum + (i.data?.potentialSavings || 0), 0);
}

function calculateImplementedSavings(insights: any[], contracts: any[]): number {
  return insights
    .filter(i => i.type === "cost_optimization" && i.actionTaken)
    .reduce((sum, i) => sum + (i.data?.potentialSavings || 0), 0) * 0.7; // Assume 70% realization
}

function identifyOptimizationOpportunities(
  contracts: any[], 
  vendors: any[], 
  financial: any
): any[] {
  const opportunities: any[] = [];
  
  // Bundle opportunities
  const vendorCounts = contracts.reduce((acc, c) => {
    if (c.status === "active") {
      acc[c.vendorId.toString()] = (acc[c.vendorId.toString()] || 0) + 1;
    }
    return acc;
  }, {} as Record<string, number>);
  
  Object.entries(vendorCounts).forEach(([vendorId, count]) => {
    if (count >= 3) {
      opportunities.push({
        type: "bundling",
        vendorId,
        description: `${count} contracts with same vendor - potential bundling opportunity`,
        estimatedSavings: financial.quarterlySpend * 0.05, // 5% estimate
      });
    }
  });
  
  // Early payment discounts
  if (financial.quarterlySpend > 100000) {
    opportunities.push({
      type: "payment_terms",
      description: "Negotiate early payment discounts on high-value contracts",
      estimatedSavings: financial.quarterlySpend * 0.02, // 2% estimate
    });
  }
  
  return opportunities;
}

function calculateCostAvoidance(contracts: any[], insights: any[]): number {
  // Calculate costs avoided through proactive actions
  const avoidedRenewals = insights
    .filter(i => i.type === "renewal_opportunity" && i.actionTaken)
    .length;
  
  const avgContractValue = contracts.length > 0
    ? contracts.reduce((sum, c) => 
        sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
      ) / contracts.length
    : 0;
  
  return avoidedRenewals * avgContractValue * 0.15; // Assume 15% savings on renegotiation
}

function generateKeyAchievements(
  contracts: any[], 
  insights: any[], 
  tasks: any[], 
  operational: any
): string[] {
  const achievements: string[] = [];
  
  if (operational.taskCompletionRate > 95) {
    achievements.push(`Achieved ${operational.taskCompletionRate.toFixed(1)}% task completion rate`);
  }
  
  const criticalIssuesResolved = insights.filter(i => 
    i.priority === "critical" && i.actionTaken
  ).length;
  
  if (criticalIssuesResolved > 0) {
    achievements.push(`Resolved ${criticalIssuesResolved} critical issues`);
  }
  
  if (operational.automationMetrics.automationRate > 70) {
    achievements.push(`${operational.automationMetrics.automationRate.toFixed(1)}% process automation achieved`);
  }
  
  return achievements;
}

function identifyChallenges(
  risk: any, 
  compliance: any, 
  operational: any, 
  vendor: any
): string[] {
  const challenges: string[] = [];
  
  if (risk.mitigationStatus.pending > 10) {
    challenges.push(`${risk.mitigationStatus.pending} unresolved risk items require attention`);
  }
  
  if (compliance.overallComplianceRate < 90) {
    challenges.push(`Compliance rate at ${compliance.overallComplianceRate.toFixed(1)}% - below target`);
  }
  
  if (vendor.highRiskVendors.length > 3) {
    challenges.push(`${vendor.highRiskVendors.length} vendors identified as high risk`);
  }
  
  if (operational.systemMetrics.errorRate > 5) {
    challenges.push("System error rate exceeds acceptable threshold");
  }
  
  return challenges;
}

function generateNextQuarterPriorities(
  risk: any, 
  vendor: any, 
  financial: any, 
  contracts: any[]
): string[] {
  const priorities: string[] = [];
  
  // Risk priorities
  if (risk.mitigationStatus.pending > 5) {
    priorities.push("Complete pending risk mitigation actions");
  }
  
  // Vendor priorities
  if (vendor.vendorConcentration.topVendorPercentage > 40) {
    priorities.push("Implement vendor diversification strategy");
  }
  
  // Contract priorities
  const expiringNext90 = contracts.filter(c => {
    if (!c.extractedEndDate || c.status !== "active") return false;
    const daysUntil = Math.ceil(
      (new Date(c.extractedEndDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
    );
    return daysUntil > 0 && daysUntil <= 90;
  });
  
  if (expiringNext90.length > 10) {
    priorities.push(`Process ${expiringNext90.length} contract renewals`);
  }
  
  // Financial priorities
  if (financial.costStructure.variableCosts > financial.costStructure.fixedCosts * 1.5) {
    priorities.push("Optimize variable cost contracts");
  }
  
  return priorities;
}

function generateExpirationReport(contracts: any[]): any[] {
  const now = new Date();
  
  return contracts
    .filter(c => c.extractedEndDate && c.status === "active")
    .map(c => ({
      contractId: c._id,
      title: c.title,
      vendorId: c.vendorId,
      value: parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'),
      endDate: c.extractedEndDate,
      daysUntilExpiry: Math.ceil(
        (new Date(c.extractedEndDate).getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      ),
    }))
    .sort((a, b) => a.daysUntilExpiry - b.daysUntilExpiry)
    .slice(0, 20); // Top 20 expiring contracts
}

function calculateDetailedVendorConcentration(vendors: any[]): any {
  const totalValue = vendors.reduce((sum, v) => sum + v.totalValue, 0);
  
  if (totalValue === 0 || vendors.length === 0) {
    return {
      topVendorPercentage: 0,
      top3Percentage: 0,
      top5Percentage: 0,
      herfindahlIndex: 0,
    };
  }
  
  const top1 = vendors[0]?.totalValue || 0;
  const top3 = vendors.slice(0, 3).reduce((sum, v) => sum + v.totalValue, 0);
  const top5 = vendors.slice(0, 5).reduce((sum, v) => sum + v.totalValue, 0);
  
  const hhi = vendors.reduce((sum, v) => {
    const share = v.totalValue / totalValue;
    return sum + (share * share);
  }, 0) * 10000;
  
  return {
    topVendorPercentage: (top1 / totalValue) * 100,
    top3Percentage: (top3 / totalValue) * 100,
    top5Percentage: (top5 / totalValue) * 100,
    herfindahlIndex: hhi,
  };
}

function groupVendorsByPerformance(vendors: any[]): any {
  return {
    excellent: vendors.filter(v => v.performanceScore >= 90).length,
    good: vendors.filter(v => v.performanceScore >= 70 && v.performanceScore < 90).length,
    average: vendors.filter(v => v.performanceScore >= 50 && v.performanceScore < 70).length,
    poor: vendors.filter(v => v.performanceScore < 50).length,
  };
}

function groupSpendByCategory(contracts: any[]): Record<string, number> {
  return contracts.reduce((acc, c) => {
    const category = c.contractType || "other";
    const value = parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
    acc[category] = (acc[category] || 0) + value;
    return acc;
  }, {} as Record<string, number>);
}

function groupSpendByDepartment(contracts: any[]): Record<string, number> {
  // In production, would map contracts to departments
  return {
    "IT": contracts.filter(c => ["saas", "technology"].includes(c.contractType))
      .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0),
    "Legal": contracts.filter(c => c.contractType === "legal")
      .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0),
    "Operations": contracts.filter(c => ["lease", "facilities"].includes(c.contractType))
      .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0),
    "Other": contracts.filter(c => !["saas", "technology", "legal", "lease", "facilities"].includes(c.contractType || ""))
      .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0),
  };
}

function analyzeSpendTrend(contracts: any[]): any {
  const monthlySpend = calculateMonthlySpend(contracts);
  const months = Object.keys(monthlySpend).sort();
  
  if (months.length < 3) return { trend: "insufficient_data" };
  
  const recentMonths = months.slice(-12);
  const values = recentMonths.map(m => monthlySpend[m]);
  
  // Simple linear regression
  const n = values.length;
  const sumX = n * (n - 1) / 2;
  const sumY = values.reduce((a, b) => a + b, 0);
  const sumXY = values.reduce((sum, val, i) => sum + (val * i), 0);
  const sumXX = n * (n - 1) * (2 * n - 1) / 6;
  
  const slope = (n * sumXY - sumX * sumY) / (n * sumXX - sumX * sumX);
  const intercept = (sumY - slope * sumX) / n;
  
  return {
    trend: slope > 0 ? "increasing" : "decreasing",
    monthlyGrowthRate: slope,
    projection: {
      nextMonth: intercept + slope * n,
      next3Months: intercept + slope * (n + 2),
    },
  };
}

function calculateMonthlyBurn(contracts: any[]): number {
  const activeContracts = contracts.filter(c => c.status === "active");
  let totalMonthlyBurn = 0;
  
  activeContracts.forEach(contract => {
    const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
    
    if (contract.extractedPaymentSchedule) {
      const schedule = contract.extractedPaymentSchedule.toLowerCase();
      if (schedule.includes('monthly')) {
        totalMonthlyBurn += value;
      } else if (schedule.includes('annual') || schedule.includes('yearly')) {
        totalMonthlyBurn += value / 12;
      } else if (schedule.includes('quarterly')) {
        totalMonthlyBurn += value / 3;
      } else {
        // Default to annual if unclear
        totalMonthlyBurn += value / 12;
      }
    } else {
      // Assume annual if no schedule
      totalMonthlyBurn += value / 12;
    }
  });
  
  return totalMonthlyBurn;
}

function calculateFixedCosts(contracts: any[]): number {
  return contracts
    .filter(c => {
      const type = c.contractType || "";
      return ["lease", "saas", "employment"].includes(type);
    })
    .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0);
}

function calculateVariableCosts(contracts: any[]): number {
  return contracts
    .filter(c => {
      const type = c.contractType || "";
      return ["consulting", "services", "logistics"].includes(type);
    })
    .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0);
}

function calculateOneTimeCosts(contracts: any[]): number {
  return contracts
    .filter(c => {
      const schedule = (c.extractedPaymentSchedule || "").toLowerCase();
      return schedule.includes("one-time") || schedule.includes("lump sum");
    })
    .reduce((sum, c) => sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0);
}

function calculateQuarterlyROI(current: any[], previous: any[]): string {
  // Simplified ROI calculation
  const currentValue = current.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  const previousValue = previous.reduce((sum, c) => 
    sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
  );
  
  if (previousValue === 0) return "N/A";
  
  const roi = ((currentValue - previousValue) / previousValue) * 100;
  return `${roi.toFixed(1)}%`;
}

function analyzePaymentSchedule(contracts: any[]): any {
  const schedules = {
    monthly: 0,
    quarterly: 0,
    annual: 0,
    oneTime: 0,
    other: 0,
  };
  
  contracts.forEach(contract => {
    const schedule = (contract.extractedPaymentSchedule || "").toLowerCase();
    if (schedule.includes("monthly")) schedules.monthly++;
    else if (schedule.includes("quarterly")) schedules.quarterly++;
    else if (schedule.includes("annual") || schedule.includes("yearly")) schedules.annual++;
    else if (schedule.includes("one-time") || schedule.includes("lump")) schedules.oneTime++;
    else schedules.other++;
  });
  
  return schedules;
}

function calculateOverallRiskScore(contracts: any[], insights: any[]): number {
  const baseScore = 50;
  let adjustments = 0;
  
  // High-value contracts without end dates
  const riskyContracts = contracts.filter(c => 
    c.status === "active" && 
    !c.extractedEndDate && 
    parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0') > 50000
  );
  adjustments += riskyContracts.length * 5;
  
  // Unresolved risk insights
  const unresolved = insights.filter(i => 
    (i.type === "financial_risk" || i.type === "vendor_risk") && 
    !i.actionTaken
  );
  adjustments += unresolved.length * 3;
  
  return Math.min(baseScore + adjustments, 100);
}

function identifyHighRiskContracts(contracts: any[], insights: any[]): any[] {
  const riskMap = new Map<string, number>();
  
  // Add risk scores from insights
  insights.forEach(insight => {
    if (insight.contractId && (insight.type.includes("risk") || insight.priority === "critical")) {
      const current = riskMap.get(insight.contractId.toString()) || 0;
      riskMap.set(insight.contractId.toString(), current + 10);
    }
  });
  
  return contracts
    .filter(c => c.status === "active")
    .map(contract => {
      let riskScore = riskMap.get(contract._id.toString()) || 0;
      
      // Add risk factors
      if (!contract.extractedEndDate) riskScore += 15;
      if (parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0') > 100000) riskScore += 10;
      if (!contract.extractedPaymentSchedule) riskScore += 5;
      
      return { contract, riskScore };
    })
    .filter(item => item.riskScore >= 20)
    .sort((a, b) => b.riskScore - a.riskScore)
    .slice(0, 10);
}

function identifyEmergingRisks(contracts: any[], insights: any[]): string[] {
  const risks: string[] = [];
  const recentInsights = insights.filter(i => {
    const daysSince = (Date.now() - new Date(i.createdAt).getTime()) / (1000 * 60 * 60 * 24);
    return daysSince <= 30;
  });
  
  // Pattern detection
  const riskTypes = recentInsights.reduce((acc, i) => {
    if (i.type.includes("risk")) {
      acc[i.type] = (acc[i.type] || 0) + 1;
    }
    return acc;
  }, {} as Record<string, number>);
  
  Object.entries(riskTypes).forEach(([type, count]) => {
    if (count >= 5) {
      risks.push(`Increasing ${type.replace("_", " ")} incidents (${count} in last 30 days)`);
    }
  });
  
  return risks;
}

function analyzeRiskTrends(insights: any[]): any {
  const monthlyRisks: Record<string, number> = {};
  
  insights
    .filter(i => i.type.includes("risk"))
    .forEach(insight => {
      const month = new Date(insight.createdAt).toISOString().slice(0, 7);
      monthlyRisks[month] = (monthlyRisks[month] || 0) + 1;
    });
  
  const months = Object.keys(monthlyRisks).sort();
  const trend = months.length >= 3 && 
    monthlyRisks[months[months.length - 1]] > monthlyRisks[months[0]]
    ? "increasing" : "stable";
  
  return { monthlyRisks, trend };
}

function groupComplianceByContractType(contracts: any[], insights: any[]): any {
  const compliance: Record<string, any> = {};
  
  const types = [...new Set(contracts.map(c => c.contractType || "other"))];
  
  types.forEach(type => {
    const typeContracts = contracts.filter(c => 
      (c.contractType || "other") === type && c.status === "active"
    );
    const typeIssues = insights.filter(i => 
      i.type === "compliance_alert" && 
      typeContracts.some(c => c._id === i.contractId)
    );
    
    compliance[type] = {
      total: typeContracts.length,
      compliant: typeContracts.length - typeIssues.length,
      rate: typeContracts.length > 0 
        ? ((typeContracts.length - typeIssues.length) / typeContracts.length) * 100 
        : 100,
    };
  });
  
  return compliance;
}

function calculateAuditReadiness(contracts: any[], insights: any[]): number {
  const activeContracts = contracts.filter(c => c.status === "active");
  if (activeContracts.length === 0) return 100;
  
  let readinessScore = 100;
  
  // Deduct for missing data
  const missingEndDates = activeContracts.filter(c => !c.extractedEndDate).length;
  readinessScore -= (missingEndDates / activeContracts.length) * 20;
  
  // Deduct for compliance issues
  const complianceIssues = insights.filter(i => 
    i.type === "compliance_alert" && !i.actionTaken
  ).length;
  readinessScore -= complianceIssues * 5;
  
  return Math.max(readinessScore, 0);
}

function calculateAverageContractProcessingTime(contracts: any[]): number {
  // In production, would track actual time from creation to active status
  // For now, return a placeholder
  return 7; // days
}

function calculateAverageTaskCompletionTime(tasks: any[]): number {
  if (tasks.length === 0) return 0;
  
  let totalTime = 0;
  let count = 0;
  
  tasks.forEach(task => {
    if (task.startedAt && task.completedAt) {
      const duration = new Date(task.completedAt).getTime() - new Date(task.startedAt).getTime();
      totalTime += duration;
      count++;
    }
  });
  
  return count > 0 ? totalTime / count / (1000 * 60 * 60) : 0; // Return in hours
}

function calculateSystemUptime(logs: any[]): number {
  const errors = logs.filter(l => l.level === "error" || l.level === "critical");
  const totalLogs = logs.length;
  
  if (totalLogs === 0) return 100;
  
  return ((totalLogs - errors.length) / totalLogs) * 100;
}

function calculateErrorRate(logs: any[]): number {
  const errors = logs.filter(l => l.level === "error" || l.level === "critical");
  return logs.length > 0 ? (errors.length / logs.length) * 100 : 0;
}

function calculateAverageResponseTime(logs: any[]): number {
  // In production, would measure actual response times
  return 250; // milliseconds placeholder
}

function calculateAgentPerformance(logs: any[]): any {
  const agentLogs: Record<string, any> = {};
  
  logs.forEach(log => {
    const agentId = log.agentId?.toString() || "unknown";
    if (!agentLogs[agentId]) {
      agentLogs[agentId] = {
        total: 0,
        errors: 0,
        runs: 0,
      };
    }
    
    agentLogs[agentId].total++;
    if (log.level === "error" || log.level === "critical") {
      agentLogs[agentId].errors++;
    }
    if (log.message?.includes("starting run")) {
      agentLogs[agentId].runs++;
    }
  });
  
  return Object.entries(agentLogs).map(([agentId, stats]) => ({
    agentId,
    errorRate: stats.total > 0 ? (stats.errors / stats.total) * 100 : 0,
    totalRuns: stats.runs,
  }));
}

function generateKeyMessage(contracts: any[], financial: any, vendor: any): string {
  const growth = contracts.length > 10 ? "strong" : "moderate";
  const efficiency = financial.roi && parseFloat(financial.roi) > 10 ? "improved" : "stable";
  
  return `The quarter showed ${growth} growth with ${contracts.length} new contracts. ` +
         `Financial efficiency ${efficiency}, with vendor concentration at ${vendor.vendorConcentration.topVendorPercentage.toFixed(1)}%.`;
}

function generateExecutiveActions(financial: any, vendor: any, operational: any): string[] {
  const actions: string[] = [];
  
  if (vendor.vendorConcentration.topVendorPercentage > 40) {
    actions.push("Approve vendor diversification initiative");
  }
  
  if (financial.budgetAnalysis.variancePercentage > 10) {
    actions.push("Review and adjust budget allocations");
  }
  
  if (operational.taskCompletionRate < 90) {
    actions.push("Allocate additional resources to contract processing");
  }
  
  return actions;
}

function formatCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value);
}

// ============================================================================
// METRICS UPDATE FUNCTION
// ============================================================================

async function updateAgentMetrics(
  ctx: any,
  agentId: Id<"agents">,
  runData: {
    runTime: number;
    kpisCalculated: number;
    contractInsights: number;
    vendorInsights: number;
    financialInsights: number;
    anomaliesDetected: number;
    forecastsCreated: number;
    reportsGenerated: number;
  }
): Promise<void> {
  const agent = await ctx.db.get(agentId);
  if (!agent) return;

  const existingMetrics = (agent.metrics as AnalyticsAgentMetrics) || {
    totalRuns: 0,
    successfulRuns: 0,
    failedRuns: 0,
    averageRunTime: 0,
    reportsGenerated: 0,
    kpisCalculated: 0,
    trendsIdentified: 0,
    anomaliesDetected: 0,
    forecastsCreated: 0,
    dataPointsAnalyzed: 0,
  };

  const totalInsights = runData.contractInsights + runData.vendorInsights + 
                       runData.financialInsights + runData.anomaliesDetected;

  const newMetrics: AnalyticsAgentMetrics = {
    ...existingMetrics,
    totalRuns: existingMetrics.totalRuns + 1,
    successfulRuns: existingMetrics.successfulRuns + 1,
    averageRunTime: 
      ((existingMetrics.averageRunTime * existingMetrics.totalRuns) + runData.runTime) / 
      (existingMetrics.totalRuns + 1),
    lastRunDuration: runData.runTime,
    reportsGenerated: (existingMetrics.reportsGenerated || 0) + runData.reportsGenerated,
    kpisCalculated: (existingMetrics.kpisCalculated || 0) + runData.kpisCalculated,
    trendsIdentified: (existingMetrics.trendsIdentified || 0) + runData.financialInsights,
    anomaliesDetected: (existingMetrics.anomaliesDetected || 0) + runData.anomaliesDetected,
    forecastsCreated: (existingMetrics.forecastsCreated || 0) + runData.forecastsCreated,
    insightsGenerated: (existingMetrics.insightsGenerated || 0) + totalInsights,
  };

  await ctx.db.patch(agentId, {
    status: "active",
    lastSuccess: new Date().toISOString(),
    runCount: (agent.runCount || 0) + 1,
    metrics: newMetrics,
  });
}

async function handleAgentError(ctx: any, agentId: Id<"agents">, error: any): Promise<void> {
  await ctx.db.insert("agentLogs", {
    agentId,
    level: "error",
    message: "Analytics agent failed",
    data: { error: error instanceof Error ? error.message : String(error) },
    timestamp: new Date().toISOString(),
    category: "agent_execution",
  });

  const agent = await ctx.db.get(agentId);
  if (agent) {
    const existingMetrics = (agent.metrics as AnalyticsAgentMetrics) || {
      totalRuns: 0,
      successfulRuns: 0,
      failedRuns: 0,
      averageRunTime: 0,
    };

    await ctx.db.patch(agentId, {
      status: "error",
      errorCount: (agent.errorCount || 0) + 1,
      lastError: error instanceof Error ? error.message : String(error),
      metrics: {
        ...existingMetrics,
        totalRuns: existingMetrics.totalRuns + 1,
        failedRuns: existingMetrics.failedRuns + 1,
      },
    });
  }
}

// ============================================================================
// QUERY FUNCTIONS
// ============================================================================

export const getAnalyticsReport = internalQuery({
  args: {
    reportType: v.union(
      v.literal("executive"),
      v.literal("financial"),
      v.literal("vendor"),
      v.literal("operational"),
      v.literal("compliance")
    ),
    timeRange: v.optional(v.union(
      v.literal("daily"),
      v.literal("weekly"),
      v.literal("monthly"),
      v.literal("quarterly"),
      v.literal("yearly")
    )),
  },
  handler: async (ctx, args) => {
    const timeRange = args.timeRange || "monthly";
    const daysMap = {
      daily: 1,
      weekly: 7,
      monthly: 30,
      quarterly: 90,
      yearly: 365,
    };
    
    const since = new Date(Date.now() - daysMap[timeRange] * 24 * 60 * 60 * 1000);
    
    // Get latest report of the specified type
    const reports = await ctx.db
      .query("agentInsights")
      .filter((q: any) => 
        q.and(
          q.eq(q.field("type"), "report"),
          q.gte(q.field("createdAt"), since.toISOString())
        )
      )
      .order("desc")
      .collect();
    
    // Filter by report type based on title
    const reportTypeMap = {
      executive: "Executive",
      financial: "Financial",
      vendor: "Vendor",
      operational: "Operational",
      compliance: "Compliance",
    };
    
    const filteredReports = reports.filter(r => 
      r.title.toLowerCase().includes(reportTypeMap[args.reportType].toLowerCase())
    );
    
    return filteredReports[0] || null;
  },
});

export const getKPIs = internalQuery({
  args: {},
  handler: async (ctx) => {
    // Get the latest KPI insight
    const kpiInsight = await ctx.db
      .query("agentInsights")
      .filter((q: any) => 
        q.and(
          q.eq(q.field("type"), "report"),
          q.eq(q.field("title"), "Key Performance Indicators Update")
        )
      )
      .order("desc")
      .first();
    
    return kpiInsight?.data?.kpis || null;
  },
});

export const getTrends = internalQuery({
  args: {
    trendType: v.optional(v.union(
      v.literal("contract_volume"),
      v.literal("spending"),
      v.literal("vendor_activity"),
      v.literal("risk")
    )),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let query = ctx.db
      .query("agentInsights")
      .filter((q: any) => q.eq(q.field("type"), "trend_analysis"));
    
    const insights = await query
      .order("desc")
      .take(args.limit || 10);
    
    if (args.trendType) {
      return insights.filter(i => 
        i.title.toLowerCase().includes(args.trendType.replace("_", " "))
      );
    }
    
    return insights;
  },
});

export const getAnomalies = internalQuery({
  args: {
    status: v.optional(v.union(
      v.literal("unresolved"),
      v.literal("resolved"),
      v.literal("all")
    )),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    let insights = await ctx.db
      .query("agentInsights")
      .filter((q: any) => q.eq(q.field("type"), "anomaly_detection"))
      .order("desc")
      .take(args.limit || 20);
    
    if (args.status === "unresolved") {
      insights = insights.filter(i => !i.actionTaken && i.actionRequired);
    } else if (args.status === "resolved") {
      insights = insights.filter(i => i.actionTaken);
    }
    
    return insights;
  },
});

export const getFinancialMetrics = internalQuery({
  args: {
    timeRange: v.optional(v.union(
      v.literal("30days"),
      v.literal("90days"),
      v.literal("1year")
    )),
  },
  handler: async (ctx, args) => {
    const contracts = await ctx.db
      .query("contracts")
      .collect();
    
    const timeRange = args.timeRange || "30days";
    const daysMap = { "30days": 30, "90days": 90, "1year": 365 };
    const since = new Date(Date.now() - daysMap[timeRange] * 24 * 60 * 60 * 1000);
    
    const periodContracts = contracts.filter(c => 
      c._creationTime && c._creationTime >= since.getTime()
    );
    
    const activeContracts = contracts.filter(c => c.status === "active");
    
    const metrics = {
      totalContractValue: activeContracts.reduce((sum, c) => 
        sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
      ),
      periodSpend: periodContracts.reduce((sum, c) => 
        sum + parseFloat(c.extractedPricing?.replace(/[^0-9.-]/g, '') || '0'), 0
      ),
      averageContractValue: 0,
      monthlyBurn: calculateMonthlyBurn(activeContracts),
      contractCount: {
        total: contracts.length,
        active: activeContracts.length,
        period: periodContracts.length,
      },
    };
    
    metrics.averageContractValue = activeContracts.length > 0 
      ? metrics.totalContractValue / activeContracts.length 
      : 0;
    
    return metrics;
  },
});
</file>

<file path="convex/agents/financial.ts">
// convex/agents/financial.ts
import { internalMutation, internalQuery, internalAction, MutationCtx, QueryCtx } from "../_generated/server";
import { v } from "convex/values";
import { Id, Doc } from "../_generated/dataModel";
import { internal } from "../_generated/api";
import { 
  AgentMutationCtx, 
  FinancialAnalysis, 
  FinancialRisk, 
  FinancialOpportunity, 
  AgentMetrics,
  isFinancialTask 
} from "../agent_types";

/**
 * Financial Agent
 * 
 * Responsibilities:
 * - Analyze contract financial terms and pricing structures
 * - Assess financial risks and opportunities
 * - Track spending patterns and budget impact
 * - Identify cost optimization opportunities
 * - Monitor payment schedules and financial obligations
 * - Generate financial insights and recommendations
 * - Detect pricing anomalies and negotiate opportunities
 * - Calculate ROI and value metrics
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const FINANCIAL_CONFIG = {
  // Processing settings
  checkIntervalMinutes: 5,
  batchSize: 10,
  analysisTimeoutMinutes: 10,
  
  // Financial thresholds
  thresholds: {
    highValue: 100000,
    mediumValue: 25000,
    lowValue: 5000,
    criticalSpend: 500000,
    budgetWarningPercent: 80,
    priceVariancePercent: 15,
    unusualIncreasePercent: 20,
  },
  
  // Risk scoring weights
  riskWeights: {
    contractValue: 0.3,
    vendorHistory: 0.2,
    paymentTerms: 0.2,
    priceVolatility: 0.15,
    marketComparison: 0.15,
  },
  
  // Analysis parameters
  analysis: {
    historicalPeriodDays: 365,
    forecastPeriodDays: 90,
    benchmarkSampleSize: 5,
    minDataPointsForTrend: 3,
  },
  
  // Alert thresholds
  alerts: {
    paymentDueDays: 7,
    budgetExceededPercent: 100,
    savingsOpportunityMin: 1000,
    contractStackingThreshold: 3, // Multiple contracts with same vendor
  },
};

// Extended metrics type for financial agent
interface FinancialAgentMetrics {
  totalRuns: number;
  successfulRuns: number;
  failedRuns: number;
  averageRunTime: number;
  lastRunDuration?: number;
  dataProcessed?: number;
  insightsGenerated?: number;
  // Financial-specific metrics
  contractsAnalyzed?: number;
  totalValueAnalyzed?: number;
  risksIdentified?: number;
  savingsIdentified?: number;
  paymentsTracked?: number;
  anomaliesDetected?: number;
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

export const run = internalMutation({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const startTime = Date.now();
    
    try {
      await ctx.db.insert("agentLogs", {
        agentId: args.agentId,
        level: "info",
        message: "Financial agent starting run",
        timestamp: new Date().toISOString(),
        category: "agent_execution",
      });

      await ctx.db.patch(args.agentId, {
        status: "busy",
        lastRun: new Date().toISOString(),
      });

      // Process assigned analysis tasks
      const tasksProcessed = await processFinancialTasks(ctx, args.agentId);
      
      // Analyze contract portfolio
      const portfolioInsights = await analyzeContractPortfolio(ctx, args.agentId);
      
      // Check payment schedules
      const paymentAlerts = await checkPaymentSchedules(ctx, args.agentId);
      
      // Identify cost optimization opportunities
      const savingsFound = await findCostOptimizations(ctx, args.agentId);
      
      // Detect pricing anomalies
      const anomaliesDetected = await detectPricingAnomalies(ctx, args.agentId);
      
      // Generate financial forecast
      await generateFinancialForecast(ctx, args.agentId);

      // Update metrics
      await updateAgentMetrics(ctx, args.agentId, {
        runTime: Date.now() - startTime,
        tasksProcessed,
        portfolioInsights,
        paymentAlerts,
        savingsFound,
        anomaliesDetected,
      });

      return { 
        success: true, 
        tasksProcessed,
        insightsGenerated: portfolioInsights + paymentAlerts + savingsFound + anomaliesDetected,
      };

    } catch (error) {
      await handleAgentError(ctx, args.agentId, error);
      throw error;
    }
  },
});

// ============================================================================
// CORE FUNCTIONS
// ============================================================================

async function processFinancialTasks(
  ctx: AgentMutationCtx,
  agentId: Id<"agents">
): Promise<number> {
  // Get pending tasks assigned to this agent
  const tasks = await ctx.db
    .query("agentTasks")
    .withIndex("by_assigned_agent", (q) => q.eq("assignedAgentId", agentId))
    .filter((q) => q.eq(q.field("status"), "pending"))
    .take(FINANCIAL_CONFIG.batchSize);

  let processed = 0;

  for (const task of tasks) {
    try {
      // Update task status
      await ctx.db.patch(task._id, {
        status: "in_progress",
        startedAt: new Date().toISOString(),
      });

      // Process based on task type
      let result;
      switch (task.taskType) {
        case "contract_analysis":
          result = await analyzeContract(ctx, agentId, task);
          break;
        case "risk_assessment":
          result = await assessFinancialRisk(ctx, agentId, task);
          break;
        case "payment_verification":
          result = await verifyPaymentTerms(ctx, agentId, task);
          break;
        case "cost_comparison":
          result = await compareCosts(ctx, agentId, task);
          break;
        default:
          throw new Error(`Unknown task type: ${task.taskType}`);
      }

      // Complete task
      await ctx.db.patch(task._id, {
        status: "completed",
        completedAt: new Date().toISOString(),
        result,
      });

      processed++;

    } catch (error) {
      await ctx.db.patch(task._id, {
        status: "failed",
        errorMessage: error instanceof Error ? error.message : String(error),
        completedAt: new Date().toISOString(),
      });

      await ctx.db.insert("agentLogs", {
        agentId,
        level: "error",
        message: `Failed to process task ${task._id}`,
        data: { taskId: task._id, error: error instanceof Error ? error.message : String(error) },
        timestamp: new Date().toISOString(),
        category: "task_processing",
      });
    }
  }

  return processed;
}

async function analyzeContract(
  ctx: AgentMutationCtx,
  agentId: Id<"agents">,
  task: Doc<"agentTasks">
): Promise<FinancialAnalysis> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found");
  }

  const analysis: FinancialAnalysis = {
    financialSummary: {},
    risks: [],
    opportunities: [],
    metrics: {},
  };

  // Extract and analyze pricing
  if (contract.extractedPricing) {
    const value = parseContractValue(contract.extractedPricing);
    analysis.financialSummary.totalValue = value;
    analysis.financialSummary.valueCategory = categorizeValue(value);
    
    // Check if high value
    if (value > FINANCIAL_CONFIG.thresholds.highValue) {
      analysis.risks.push({
        type: "high_value_exposure",
        severity: "medium",
        description: `High value contract (${formatCurrency(value)}) represents significant financial commitment`,
        mitigation: "Ensure proper approval chain and payment milestones",
      });
    }
  }

  // Analyze payment terms
  if (contract.extractedPaymentSchedule) {
    const paymentAnalysis = analyzePaymentTerms(contract.extractedPaymentSchedule);
    analysis.financialSummary.paymentStructure = paymentAnalysis;
    
    if (paymentAnalysis.hasUnfavorableTerms) {
      analysis.risks.push({
        type: "unfavorable_payment_terms",
        severity: "low",
        description: paymentAnalysis.concern,
        mitigation: "Consider negotiating payment terms",
      });
    }
  }

  // Compare with similar contracts
  const comparison = await compareWithSimilarContracts(ctx, contract);
  if (comparison.priceVariance > FINANCIAL_CONFIG.thresholds.priceVariancePercent) {
    analysis.opportunities.push({
      type: "pricing_negotiation",
      potential: comparison.potentialSavings,
      description: `Price is ${comparison.priceVariance}% higher than similar contracts`,
      action: "Review pricing and consider renegotiation",
    });
  }

  // Calculate key metrics
  analysis.metrics = {
    annualizedValue: calculateAnnualizedValue(contract),
    costPerUnit: calculateCostPerUnit(contract),
    paybackPeriod: calculatePaybackPeriod(contract),
    totalCostOfOwnership: calculateTCO(contract),
  };

  // Create insights based on analysis
  if (analysis.risks.length > 0) {
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "financial_risk",
      title: `Financial Risks Identified: ${contract.title}`,
      description: `${analysis.risks.length} financial risk(s) identified requiring attention`,
      priority: analysis.risks.some(r => r.severity === "high") ? "high" : "medium",
      contractId: contract._id,
      vendorId: contract.vendorId,
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: analysis,
    });
  }

  // Update contract with analysis results
  await ctx.db.patch(contract._id, {
    analysisStatus: "completed",
  });

  return analysis;
}

async function analyzeContractPortfolio(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let insightsCreated = 0;

  // Get all active contracts
  const activeContracts = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => q.eq(q.field("status"), "active"))
    .collect();

  if (activeContracts.length === 0) return 0;

  // Calculate portfolio metrics
  const portfolioMetrics = {
    totalValue: 0,
    totalAnnualValue: 0,
    contractsByType: {} as Record<string, number>,
    contractsByVendor: {} as Record<string, number>,
    valueByCategory: {} as Record<string, number>,
    expiringNext90Days: 0,
    averageContractValue: 0,
  };

  // Analyze each contract
  for (const contract of activeContracts) {
    const value = parseContractValue(contract.extractedPricing || "0");
    const annualValue = calculateAnnualizedValue(contract);
    
    portfolioMetrics.totalValue += value;
    portfolioMetrics.totalAnnualValue += annualValue;
    
    // Group by type
    const type = contract.contractType || "other";
    portfolioMetrics.contractsByType[type] = (portfolioMetrics.contractsByType[type] || 0) + 1;
    
    // Group by vendor
    const vendorId = contract.vendorId.toString();
    portfolioMetrics.contractsByVendor[vendorId] = (portfolioMetrics.contractsByVendor[vendorId] || 0) + 1;
    
    // Check expiration
    if (contract.extractedEndDate) {
      const daysUntilExpiry = Math.ceil(
        (new Date(contract.extractedEndDate).getTime() - Date.now()) / (1000 * 60 * 60 * 24)
      );
      if (daysUntilExpiry <= 90 && daysUntilExpiry > 0) {
        portfolioMetrics.expiringNext90Days++;
      }
    }
  }

  portfolioMetrics.averageContractValue = portfolioMetrics.totalValue / activeContracts.length;

  // Check for concentration risk
  const vendorConcentration = Object.entries(portfolioMetrics.contractsByVendor)
    .filter(([_, count]) => count >= FINANCIAL_CONFIG.alerts.contractStackingThreshold);

  if (vendorConcentration.length > 0) {
    insightsCreated++;
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "vendor_risk",
      title: "Vendor Concentration Risk Detected",
      description: `${vendorConcentration.length} vendor(s) have multiple active contracts, creating dependency risk`,
      priority: "medium",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: {
        vendorConcentration,
        totalVendors: Object.keys(portfolioMetrics.contractsByVendor).length,
      },
    });
  }

  // Generate portfolio summary insight
  insightsCreated++;
  await ctx.db.insert("agentInsights", {
    agentId,
    type: "report",
    title: "Contract Portfolio Financial Summary",
    description: `Total portfolio value: ${formatCurrency(portfolioMetrics.totalAnnualValue)}/year across ${activeContracts.length} contracts`,
    priority: "low",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: portfolioMetrics,
  });

  return insightsCreated;
}

async function checkPaymentSchedules(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let alertsCreated = 0;
  
  const contracts = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => q.eq(q.field("status"), "active"))
    .collect();

  const upcomingPayments: any[] = [];

  for (const contract of contracts) {
    if (!contract.extractedPaymentSchedule) continue;

    const payments = parsePaymentSchedule(contract.extractedPaymentSchedule);
    const now = new Date();
    
    for (const payment of payments) {
      const daysUntilDue = Math.ceil(
        (payment.dueDate.getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
      );
      
      if (daysUntilDue <= FINANCIAL_CONFIG.alerts.paymentDueDays && daysUntilDue > 0) {
        upcomingPayments.push({
          contractId: contract._id,
          contractTitle: contract.title,
          vendorId: contract.vendorId,
          amount: payment.amount,
          dueDate: payment.dueDate,
          daysUntilDue,
        });
      }
    }
  }

  if (upcomingPayments.length > 0) {
    alertsCreated++;
    
    const totalDue = upcomingPayments.reduce((sum, p) => sum + p.amount, 0);
    
    await ctx.db.insert("agentInsights", {
      agentId,
      type: "alert",
      title: "Upcoming Payment Obligations",
      description: `${upcomingPayments.length} payment(s) totaling ${formatCurrency(totalDue)} due within ${FINANCIAL_CONFIG.alerts.paymentDueDays} days`,
      priority: "high",
      actionRequired: true,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(),
      data: {
        payments: upcomingPayments,
        totalAmount: totalDue,
      },
    });

    // Create notification task
    const notificationsAgent = await ctx.db
      .query("agents")
      .withIndex("by_type", (q: any) => q.eq("type", "notifications"))
      .first();

    if (notificationsAgent) {
      await ctx.db.insert("agentTasks", {
        assignedAgentId: notificationsAgent._id,
        createdByAgentId: agentId,
        taskType: "send_notification",
        status: "pending",
        priority: "high",
        title: "Notify: Upcoming payment obligations",
        data: {
          notificationType: "payment_reminder",
          urgency: "high",
          payments: upcomingPayments,
        },
        createdAt: new Date().toISOString(),
      });
    }
  }

  return alertsCreated;
}

async function findCostOptimizations(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let opportunitiesFound = 0;

  // Analyze contracts by vendor for bundling opportunities
  const contractsByVendor = await ctx.db
    .query("contracts")
    .withIndex("by_status_and_enterpriseId")
    .filter((q: any) => q.eq(q.field("status"), "active"))
    .collect();

  const vendorGroups: Record<string, any[]> = {};
  
  for (const contract of contractsByVendor) {
    const vendorId = contract.vendorId.toString();
    if (!vendorGroups[vendorId]) {
      vendorGroups[vendorId] = [];
    }
    vendorGroups[vendorId].push(contract);
  }

  // Check for bundling opportunities
  for (const [vendorId, contracts] of Object.entries(vendorGroups)) {
    if (contracts.length >= 2) {
      const totalValue = contracts.reduce((sum, c) => sum + parseContractValue(c.extractedPricing || "0"), 0);
      const potentialSavings = totalValue * 0.1; // Assume 10% bundling discount
      
      if (potentialSavings >= FINANCIAL_CONFIG.alerts.savingsOpportunityMin) {
        opportunitiesFound++;
        
        await ctx.db.insert("agentInsights", {
          agentId,
          type: "cost_optimization",
          title: "Contract Bundling Opportunity",
          description: `Potential savings of ${formatCurrency(potentialSavings)} by bundling ${contracts.length} contracts with the same vendor`,
          priority: "medium",
          vendorId: contracts[0].vendorId,
          actionRequired: true,
          actionTaken: false,
          isRead: false,
          createdAt: new Date().toISOString(),
          data: {
            vendorId,
            contractCount: contracts.length,
            totalValue,
            potentialSavings,
            contractIds: contracts.map(c => c._id),
          },
        });
      }
    }
  }

  // Check for duplicate services
  const contractsByType: Record<string, any[]> = {};
  
  for (const contract of contractsByVendor) {
    const type = contract.contractType || "other";
    if (!contractsByType[type]) {
      contractsByType[type] = [];
    }
    contractsByType[type].push(contract);
  }

  // Look for potential redundancies
  for (const [type, contracts] of Object.entries(contractsByType)) {
    if (contracts.length >= 3 && type !== "other") {
      opportunitiesFound++;
      
      const totalValue = contracts.reduce((sum, c) => sum + parseContractValue(c.extractedPricing || "0"), 0);
      
      await ctx.db.insert("agentInsights", {
        agentId,
        type: "cost_optimization",
        title: `Multiple ${type} Contracts Detected`,
        description: `${contracts.length} active ${type} contracts worth ${formatCurrency(totalValue)}. Review for potential consolidation.`,
        priority: "low",
        actionRequired: true,
        actionTaken: false,
        isRead: false,
        createdAt: new Date().toISOString(),
        data: {
          contractType: type,
          contractCount: contracts.length,
          totalValue,
          averageValue: totalValue / contracts.length,
        },
      });
    }
  }

  return opportunitiesFound;
}

async function detectPricingAnomalies(
  ctx: any,
  agentId: Id<"agents">
): Promise<number> {
  let anomaliesFound = 0;

  // Get contracts grouped by type for comparison
  const contractsByType = await ctx.db
    .query("contracts")
    .withIndex("by_contractType_and_enterpriseId")
    .collect();

  const typeGroups: Record<string, any[]> = {};
  
  for (const contract of contractsByType) {
    if (!contract.extractedPricing) continue;
    
    const type = contract.contractType || "other";
    if (!typeGroups[type]) {
      typeGroups[type] = [];
    }
    typeGroups[type].push(contract);
  }

  // Analyze each type group for anomalies
  for (const [type, contracts] of Object.entries(typeGroups)) {
    if (contracts.length < FINANCIAL_CONFIG.analysis.minDataPointsForTrend) continue;

    const values = contracts
      .map(c => parseContractValue(c.extractedPricing))
      .filter(v => v > 0);

    if (values.length === 0) continue;

    const stats = calculateStatistics(values);
    
    // Check each contract for anomalies
    for (const contract of contracts) {
      const value = parseContractValue(contract.extractedPricing);
      const zScore = Math.abs((value - stats.mean) / stats.stdDev);
      
      if (zScore > 2) { // More than 2 standard deviations from mean
        anomaliesFound++;
        
        await ctx.db.insert("agentInsights", {
          agentId,
          type: "anomaly_detection",
          title: `Unusual Pricing Detected: ${contract.title}`,
          description: `Contract value (${formatCurrency(value)}) is ${zScore.toFixed(1)} standard deviations from typical ${type} contracts`,
          priority: "medium",
          contractId: contract._id,
          vendorId: contract.vendorId,
          actionRequired: true,
          actionTaken: false,
          isRead: false,
          createdAt: new Date().toISOString(),
          data: {
            contractValue: value,
            typeAverage: stats.mean,
            typeStdDev: stats.stdDev,
            zScore,
            percentageDifference: ((value - stats.mean) / stats.mean * 100).toFixed(1),
          },
        });
      }
    }
  }

  return anomaliesFound;
}

async function generateFinancialForecast(
  ctx: any,
  agentId: Id<"agents">
): Promise<void> {
  // Get historical contract data
  const historicalContracts = await ctx.db
    .query("contracts")
    .collect();

  if (historicalContracts.length < 10) return; // Need sufficient data

  // Calculate monthly spend trends
  const monthlySpend: Record<string, number> = {};
  const now = new Date();
  
  for (const contract of historicalContracts) {
    if (!contract._creationTime) continue;
    
    const contractDate = new Date(contract._creationTime);
    const monthKey = `${contractDate.getFullYear()}-${(contractDate.getMonth() + 1).toString().padStart(2, '0')}`;
    const value = parseContractValue(contract.extractedPricing || "0");
    
    monthlySpend[monthKey] = (monthlySpend[monthKey] || 0) + value;
  }

  // Calculate trend
  const months = Object.keys(monthlySpend).sort();
  if (months.length < 3) return;

  const recentMonths = months.slice(-6); // Last 6 months
  const recentValues = recentMonths.map(m => monthlySpend[m]);
  const averageMonthlySpend = recentValues.reduce((a, b) => a + b, 0) / recentValues.length;
  
  // Simple linear projection for next 3 months
  const growthRate = calculateGrowthRate(recentValues);
  const projectedSpend = [];
  
  for (let i = 1; i <= 3; i++) {
    const projected = averageMonthlySpend * Math.pow(1 + growthRate, i);
    projectedSpend.push({
      month: i,
      amount: projected,
    });
  }

  const totalProjected = projectedSpend.reduce((sum, p) => sum + p.amount, 0);

  await ctx.db.insert("agentInsights", {
    agentId,
    type: "trend_analysis",
    title: "Quarterly Spend Forecast",
    description: `Projected contract spend for next quarter: ${formatCurrency(totalProjected)} based on ${growthRate > 0 ? 'increasing' : 'decreasing'} trend`,
    priority: "low",
    actionRequired: false,
    actionTaken: false,
    isRead: false,
    createdAt: new Date().toISOString(),
    data: {
      historicalAverage: averageMonthlySpend,
      growthRate: (growthRate * 100).toFixed(1) + '%',
      projectedMonths: projectedSpend,
      totalProjected,
      confidence: 0.7, // Simple model, moderate confidence
    },
  });
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function parseContractValue(priceString: string): number {
  if (!priceString) return 0;
  
  // Remove currency symbols and clean the string
  const cleaned = priceString.replace(/[^0-9.,]/g, '');
  
  // Handle different number formats
  let normalized = cleaned;
  
  // If there's both comma and period, assume comma is thousands separator
  if (cleaned.includes(',') && cleaned.includes('.')) {
    normalized = cleaned.replace(/,/g, '');
  } else if (cleaned.includes(',')) {
    // Check if comma is decimal separator (European format)
    const parts = cleaned.split(',');
    if (parts.length === 2 && parts[1].length <= 2) {
      normalized = cleaned.replace(',', '.');
    } else {
      normalized = cleaned.replace(/,/g, '');
    }
  }
  
  const value = parseFloat(normalized);
  return isNaN(value) ? 0 : value;
}

function categorizeValue(value: number): string {
  if (value >= FINANCIAL_CONFIG.thresholds.criticalSpend) return "critical";
  if (value >= FINANCIAL_CONFIG.thresholds.highValue) return "high";
  if (value >= FINANCIAL_CONFIG.thresholds.mediumValue) return "medium";
  if (value >= FINANCIAL_CONFIG.thresholds.lowValue) return "low";
  return "minimal";
}

function formatCurrency(value: number): string {
  return new Intl.NumberFormat('en-US', {
    style: 'currency',
    currency: 'USD',
    minimumFractionDigits: 0,
    maximumFractionDigits: 0,
  }).format(value);
}

function analyzePaymentTerms(scheduleText: string): any {
  const analysis = {
    structure: "unknown",
    frequency: "unknown",
    hasUnfavorableTerms: false,
    concern: "",
  };

  const lowerText = scheduleText.toLowerCase();

  // Detect payment structure
  if (lowerText.includes("monthly")) {
    analysis.structure = "recurring";
    analysis.frequency = "monthly";
  } else if (lowerText.includes("quarterly")) {
    analysis.structure = "recurring";
    analysis.frequency = "quarterly";
  } else if (lowerText.includes("annual") || lowerText.includes("yearly")) {
    analysis.structure = "recurring";
    analysis.frequency = "annual";
  } else if (lowerText.includes("one-time") || lowerText.includes("lump sum")) {
    analysis.structure = "one-time";
  }

  // Check for unfavorable terms
  if (lowerText.includes("advance") || lowerText.includes("prepay")) {
    analysis.hasUnfavorableTerms = true;
    analysis.concern = "Requires advance payment";
  } else if (lowerText.includes("penalty") || lowerText.includes("late fee")) {
    analysis.hasUnfavorableTerms = true;
    analysis.concern = "Contains penalty clauses";
  }

  return analysis;
}

async function compareWithSimilarContracts(ctx: any, contract: any): Promise<any> {
  // Get similar contracts
  const similarContracts = await ctx.db
    .query("contracts")
    .withIndex("by_contractType_and_enterpriseId")
    .filter((q: any) => 
      q.and(
        q.eq(q.field("contractType"), contract.contractType),
        q.neq(q.field("_id"), contract._id)
      )
    )
    .take(FINANCIAL_CONFIG.analysis.benchmarkSampleSize);

  if (similarContracts.length === 0) {
    return { priceVariance: 0, potentialSavings: 0 };
  }

  const currentValue = parseContractValue(contract.extractedPricing || "0");
  const similarValues = similarContracts
    .map((c:any) => parseContractValue(c.extractedPricing || "0"))
    .filter((v:any) => v > 0);

  if (similarValues.length === 0 || currentValue === 0) {
    return { priceVariance: 0, potentialSavings: 0 };
  }

  const averageSimilar = similarValues.reduce((a:any, b:any) => a + b, 0) / similarValues.length;
  const variance = ((currentValue - averageSimilar) / averageSimilar) * 100;
  const savings = variance > 0 ? currentValue - averageSimilar : 0;

  return {
    priceVariance: variance,
    potentialSavings: savings,
    averageMarketPrice: averageSimilar,
    sampleSize: similarValues.length,
  };
}

async function assessFinancialRisk(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for risk assessment");
  }

  const riskFactors = [];
  let riskScore = 0;

  // Assess contract value risk
  const value = parseContractValue(contract.extractedPricing || "0");
  if (value > FINANCIAL_CONFIG.thresholds.criticalSpend) {
    riskFactors.push("Very high contract value");
    riskScore += 30;
  } else if (value > FINANCIAL_CONFIG.thresholds.highValue) {
    riskFactors.push("High contract value");
    riskScore += 15;
  }

  // Assess payment terms risk
  if (contract.extractedPaymentSchedule) {
    const paymentAnalysis = analyzePaymentTerms(contract.extractedPaymentSchedule);
    if (paymentAnalysis.hasUnfavorableTerms) {
      riskFactors.push("Unfavorable payment terms");
      riskScore += 10;
    }
  }

  // Assess duration risk
  if (contract.extractedStartDate && contract.extractedEndDate) {
    const duration = Math.ceil(
      (new Date(contract.extractedEndDate).getTime() - new Date(contract.extractedStartDate).getTime()) / 
      (1000 * 60 * 60 * 24)
    );
    if (duration > 1095) { // More than 3 years
      riskFactors.push("Long-term commitment");
      riskScore += 15;
    }
  }

  const riskLevel = riskScore > 40 ? "high" : riskScore > 20 ? "medium" : "low";

  return {
    riskScore,
    riskLevel,
    riskFactors,
    recommendations: generateRiskRecommendations(riskFactors, riskLevel),
  };
}

async function verifyPaymentTerms(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for payment verification");
  }

  const verification = {
    isValid: true,
    issues: [] as string[],
    recommendations: [] as string[],
  };

  if (!contract.extractedPaymentSchedule) {
    verification.isValid = false;
    verification.issues.push("No payment schedule found in contract");
    verification.recommendations.push("Review contract for payment terms");
    return verification;
  }

  const paymentAnalysis = analyzePaymentTerms(contract.extractedPaymentSchedule);
  
  if (paymentAnalysis.hasUnfavorableTerms) {
    verification.issues.push(paymentAnalysis.concern);
    verification.recommendations.push("Consider renegotiating payment terms");
  }

  // Check for reasonable payment frequency
  if (paymentAnalysis.frequency === "unknown") {
    verification.issues.push("Payment frequency unclear");
    verification.recommendations.push("Clarify payment schedule with vendor");
  }

  return verification;
}

async function compareCosts(ctx: any, agentId: Id<"agents">, task: any): Promise<any> {
  const contract = await ctx.db.get(task.contractId);
  if (!contract) {
    throw new Error("Contract not found for cost comparison");
  }

  const comparison = await compareWithSimilarContracts(ctx, contract);
  
  return {
    currentValue: parseContractValue(contract.extractedPricing || "0"),
    marketAverage: comparison.averageMarketPrice || 0,
    variance: comparison.priceVariance,
    potentialSavings: comparison.potentialSavings,
    recommendation: comparison.priceVariance > 15 
      ? "Consider renegotiation - price significantly above market"
      : "Price appears competitive",
  };
}

async function updateAgentMetrics(
  ctx: any,
  agentId: Id<"agents">,
  runData: {
    runTime: number;
    tasksProcessed: number;
    portfolioInsights: number;
    paymentAlerts: number;
    savingsFound: number;
    anomaliesDetected: number;
  }
): Promise<void> {
  const agent = await ctx.db.get(agentId);
  if (!agent) return;

  const existingMetrics = (agent.metrics as FinancialAgentMetrics) || {
    totalRuns: 0,
    successfulRuns: 0,
    failedRuns: 0,
    averageRunTime: 0,
    contractsAnalyzed: 0,
    totalValueAnalyzed: 0,
    risksIdentified: 0,
    savingsIdentified: 0,
    paymentsTracked: 0,
    anomaliesDetected: 0,
  };

  const newMetrics: FinancialAgentMetrics = {
    ...existingMetrics,
    totalRuns: existingMetrics.totalRuns + 1,
    successfulRuns: existingMetrics.successfulRuns + 1,
    averageRunTime: 
      ((existingMetrics.averageRunTime * existingMetrics.totalRuns) + runData.runTime) / 
      (existingMetrics.totalRuns + 1),
    lastRunDuration: runData.runTime,
    contractsAnalyzed: (existingMetrics.contractsAnalyzed || 0) + runData.tasksProcessed,
    anomaliesDetected: (existingMetrics.anomaliesDetected || 0) + runData.anomaliesDetected,
    insightsGenerated: (existingMetrics.insightsGenerated || 0) + 
      runData.portfolioInsights + runData.paymentAlerts + runData.savingsFound + runData.anomaliesDetected,
  };

  await ctx.db.patch(agentId, {
    status: "active",
    lastSuccess: new Date().toISOString(),
    runCount: (agent.runCount || 0) + 1,
    metrics: newMetrics,
  });
}

async function handleAgentError(ctx: any, agentId: Id<"agents">, error: any): Promise<void> {
  await ctx.db.insert("agentLogs", {
    agentId,
    level: "error",
    message: "Financial agent failed",
    data: { error: error instanceof Error ? error.message : String(error) },
    timestamp: new Date().toISOString(),
    category: "agent_execution",
  });

  const agent = await ctx.db.get(agentId);
  if (agent) {
    const existingMetrics = (agent.metrics as FinancialAgentMetrics) || {
      totalRuns: 0,
      successfulRuns: 0,
      failedRuns: 0,
      averageRunTime: 0,
    };

    await ctx.db.patch(agentId, {
      status: "error",
      errorCount: (agent.errorCount || 0) + 1,
      lastError: error instanceof Error ? error.message : String(error),
      metrics: {
        ...existingMetrics,
        totalRuns: existingMetrics.totalRuns + 1,
        failedRuns: existingMetrics.failedRuns + 1,
      },
    });
  }
}

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================



function calculateAnnualizedValue(contract: any): number {
  const totalValue = parseContractValue(contract.extractedPricing || "0");
  
  if (!contract.extractedStartDate || !contract.extractedEndDate) {
    return totalValue; // Assume annual if no dates
  }

  try {
    const startDate = new Date(contract.extractedStartDate);
    const endDate = new Date(contract.extractedEndDate);
    const durationDays = Math.ceil((endDate.getTime() - startDate.getTime()) / (1000 * 60 * 60 * 24));
    
    if (durationDays <= 0) return totalValue;
    
    const annualizedValue = (totalValue / durationDays) * 365;
    return annualizedValue;
  } catch (error) {
    return totalValue; // Fallback if date parsing fails
  }
}

function calculateCostPerUnit(contract: any): number {
  const totalValue = parseContractValue(contract.extractedPricing || "0");
  
  // Extract potential unit information from scope or pricing
  const scope = contract.extractedScope || "";
  const pricing = contract.extractedPricing || "";
  
  // Simple heuristics to find units
  const unitMatches = [...scope.matchAll(/(\d+)\s*(users?|licenses?|seats?|months?)/gi)];
  
  if (unitMatches.length > 0) {
    const units = parseInt(unitMatches[0][1]);
    if (units > 0) {
      return totalValue / units;
    }
  }
  
  return totalValue; // Return total if no units found
}

function calculatePaybackPeriod(contract: any): number {
  // Simple payback calculation - would need more business logic
  const value = parseContractValue(contract.extractedPricing || "0");
  const estimatedMonthlySavings = value * 0.1; // Assume 10% monthly benefit
  
  if (estimatedMonthlySavings <= 0) return Infinity;
  
  return value / estimatedMonthlySavings; // Months to payback
}

function calculateTCO(contract: any): number {
  const baseValue = parseContractValue(contract.extractedPricing || "0");
  
  // Add estimated additional costs (implementation, training, maintenance)
  const implementationCost = baseValue * 0.15; // 15% for setup
  const maintenanceCost = baseValue * 0.1; // 10% annual maintenance
  
  return baseValue + implementationCost + maintenanceCost;
}

function calculateStatistics(values: number[]): { mean: number; stdDev: number; median: number } {
  if (values.length === 0) return { mean: 0, stdDev: 0, median: 0 };
  
  const mean = values.reduce((a, b) => a + b, 0) / values.length;
  
  const variance = values.reduce((sum, val) => sum + Math.pow(val - mean, 2), 0) / values.length;
  const stdDev = Math.sqrt(variance);
  
  const sorted = [...values].sort((a, b) => a - b);
  const median = sorted.length % 2 === 0 
    ? (sorted[sorted.length / 2 - 1] + sorted[sorted.length / 2]) / 2
    : sorted[Math.floor(sorted.length / 2)];
  
  return { mean, stdDev, median };
}

function calculateGrowthRate(values: number[]): number {
  if (values.length < 2) return 0;
  
  // Simple linear regression to find growth trend
  const n = values.length;
  const xSum = n * (n - 1) / 2; // Sum of indices 0, 1, 2, ...
  const ySum = values.reduce((a, b) => a + b, 0);
  const xySum = values.reduce((sum, val, index) => sum + (val * index), 0);
  const xxSum = n * (n - 1) * (2 * n - 1) / 6; // Sum of squares
  
  const slope = (n * xySum - xSum * ySum) / (n * xxSum - xSum * xSum);
  const avgValue = ySum / n;
  
  return avgValue > 0 ? slope / avgValue : 0; // Growth rate as percentage
}

function parsePaymentSchedule(scheduleText: string): Array<{ amount: number; dueDate: Date }> {
  const payments: Array<{ amount: number; dueDate: Date }> = [];
  
  // Simple parsing - in reality, this would be much more sophisticated
  const lines = scheduleText.split('\n');
  
  for (const line of lines) {
    // Look for patterns like "$1,000 due on 2024-01-15"
    const match = line.match(/\$?([\d,]+)\s*(?:due\s*(?:on|by))?\s*(\d{4}-\d{2}-\d{2}|\d{1,2}\/\d{1,2}\/\d{4})/i);
    
    if (match) {
      const amount = parseFloat(match[1].replace(/,/g, ''));
      let dateStr = match[2];
      
      // Convert MM/DD/YYYY to YYYY-MM-DD
      if (dateStr.includes('/')) {
        const parts = dateStr.split('/');
        if (parts.length === 3) {
          dateStr = `${parts[2]}-${parts[0].padStart(2, '0')}-${parts[1].padStart(2, '0')}`;
        }
      }
      
      try {
        const dueDate = new Date(dateStr);
        if (!isNaN(dueDate.getTime())) {
          payments.push({ amount, dueDate });
        }
      } catch (error) {
        console.warn('Failed to parse payment date:', dateStr);
      }
    }
  }
  
  return payments;
}

function generateRiskRecommendations(riskFactors: string[], riskLevel: string): string[] {
  const recommendations = [];
  
  if (riskLevel === "high") {
    recommendations.push("Require additional approval levels for this contract");
    recommendations.push("Consider breaking contract into smaller phases");
  }
  
  if (riskFactors.includes("Very high contract value")) {
    recommendations.push("Implement milestone-based payments");
    recommendations.push("Require performance bonds or guarantees");
  }
  
  if (riskFactors.includes("Unfavorable payment terms")) {
    recommendations.push("Negotiate more favorable payment schedule");
    recommendations.push("Consider alternative payment structures");
  }
  
  if (riskFactors.includes("Long-term commitment")) {
    recommendations.push("Include periodic review clauses");
    recommendations.push("Add early termination options");
  }
  
  return recommendations;
}
</file>

<file path="convex/agents/manager.ts">
import { query, mutation, internalMutation } from "../_generated/server";
import { v } from "convex/values";
import { Id } from "../_generated/dataModel"; // Keep for potential explicit Id type usage

// ============================================================================
// AGENT SYSTEM MANAGEMENT
// ============================================================================

const taskPriorityOptions = [
  "low",
  "medium",
  "high",
  "critical",
] as const;

const insightTypeOptions = [
    "contract_analysis",    // Contract content analysis
    "financial_risk",       // Financial risk assessment
    "expiration_warning",   // Contract expiration alerts
    "legal_review",         // Legal compliance issues
    "compliance_alert",     // Regulatory compliance warnings
    "performance_metric",   // Performance and KPI insights
    "cost_optimization",    // Cost-saving opportunities
    "vendor_risk",          // Vendor risk assessment
    "renewal_opportunity",  // Contract renewal suggestions
    "negotiation_insight",  // Contract negotiation recommendations
    "audit_finding",        // Audit-related discoveries
    "anomaly_detection",    // Unusual patterns or outliers
    "trend_analysis",       // Historical trend insights
    "recommendation",       // General recommendations
    "alert",                // General system alerts
    "report",               // Automated reports
] as const;


export const initializeAgentSystem = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Authentication required: No user identity found.");
    }

    // Check if system already exists
    const existingSystem = await ctx.db.query("agentSystem").first();
    if (existingSystem) {
      return { success: true, message: "Agent system already initialized.", systemId: existingSystem._id };
    }

    // Create the agent system record
    const systemId = await ctx.db.insert("agentSystem", {
      isRunning: false,
      status: "stopped",
      config: {
        maxConcurrentTasks: 10,
        taskTimeoutMinutes: 30,
        logRetentionDays: 30,
        // Add other AgentSystemConfig defaults as needed
      },
      metrics: {
        totalTasksProcessed: 0,
        totalInsightsGenerated: 0,
        systemUptime: 0,
        // Add other AgentSystemMetrics defaults as needed
      },
    });

    // Create the default manager agent
    const managerAgentConfig = { // Explicitly defining for clarity, matches ManagerAgentConfig
      runIntervalMinutes: 5, // Default for manager specific config
      retryAttempts: 3,
      timeoutMinutes: 10,
      healthCheckIntervalMinutes: 5,
      taskCleanupHours: 24,
      logCleanupDays: 30,
      agentRestartThreshold: 3,
      systemMetricsCollectionInterval: 15,
    };

    const managerAgentMetrics = { // Matches AgentMetrics with custom fields for manager
        totalRuns: 0,
        successfulRuns: 0,
        failedRuns: 0,
        averageRunTime: 0,
        // Manager-specific metrics below
        agentsManaged: 0, // This would be dynamically updated
        tasksCoordinated: 0,
        healthChecksPerformed: 0,
    };

    const managerId = await ctx.db.insert("agents", {
      name: "System Manager",
      type: "manager", // Make sure "manager" is in your agentTypeOptions in agent-schema.ts
      status: "inactive",
      description: "Coordinates and manages all other agents in the system.",
      isEnabled: true,
      runCount: 0,
      errorCount: 0,
      config: managerAgentConfig,
      metrics: managerAgentMetrics,
      createdAt: new Date().toISOString(), // Aligns with your schema defining createdAt: v.string()
    });

    // Log the initialization
    await ctx.db.insert("agentLogs", {
      agentId: managerId,
      level: "info", // Make sure "info" is in your logLevelOptions in agent-schema.ts
      message: "Agent system initialized successfully.",
      data: { systemId: systemId.toString(), newManagerId: managerId.toString() },
      timestamp: new Date().toISOString(),
      category: "system_lifecycle", // Ensure 'category' field exists in agentLogs schema
    });

    return {
      success: true,
      message: "Agent system initialized successfully.",
      systemId,
      managerId,
    };
  },
});

/**
 * Start the agent system.
 */
export const startAgentSystem = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Authentication required.");
    }

    const system = await ctx.db.query("agentSystem").first();
    if (!system) {
      throw new Error("Agent system not initialized. Please initialize first.");
    }

    if (system.isRunning && system.status === "running") {
      return { success: true, message: "Agent system is already running." };
    }

    await ctx.db.patch(system._id, {
      isRunning: true,
      status: "running",
      lastStarted: new Date().toISOString(),
      errorMessage: undefined,
    });

    const manager = await ctx.db
      .query("agents")
      .withIndex("by_type", (q) => q.eq("type", "manager"))
      .first();

    if (manager) {
      await ctx.db.patch(manager._id, {
        status: "active",
        lastRun: new Date().toISOString(),
        // updatedAt: new Date().toISOString(), // If you manually manage a string updatedAt field
      });

      await ctx.db.insert("agentLogs", {
        agentId: manager._id,
        level: "info",
        message: "Agent system started successfully.",
        timestamp: new Date().toISOString(),
        category: "system_lifecycle",
      });
    } else {
        console.warn("StartAgentSystem: Manager agent not found during startup.");
         await ctx.db.insert("agentLogs", {
            agentId: system._id as unknown as Id<"agents">, // This cast might be problematic if agentSystem._id can't be an agentId
                                                 // Consider a dedicated system/log agent ID or null if schema allows
            level: "warn",
            message: "Agent system started, but Manager agent not found.",
            timestamp: new Date().toISOString(),
            category: "system_lifecycle",
         });
    }

    return { success: true, message: "Agent system started successfully." };
  },
});

/**
 * Stop the agent system.
 */
export const stopAgentSystem = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Authentication required.");
    }

    const system = await ctx.db.query("agentSystem").first();
    if (!system) {
      return { success: true, message: "Agent system not found or not initialized." };
    }

    if (!system.isRunning && system.status === "stopped") {
        return { success: true, message: "Agent system is already stopped."};
    }

    await ctx.db.patch(system._id, {
      isRunning: false,
      status: "stopped",
      lastStopped: new Date().toISOString(),
    });

    const activeAgents = await ctx.db.query("agents").filter(q => q.eq(q.field("status"), "active")).collect();
    for (const agent of activeAgents) {
      await ctx.db.patch(agent._id, {
        status: "inactive",
      
      });
    }

    const manager = await ctx.db
      .query("agents")
      .withIndex("by_type", (q) => q.eq("type", "manager"))
      .first();

    if (manager) {
      await ctx.db.insert("agentLogs", {
        agentId: manager._id,
        level: "info",
        message: "Agent system stopped.",
        timestamp: new Date().toISOString(),
        category: "system_lifecycle",
      });
    } else {
         await ctx.db.insert("agentLogs", {
            agentId: system._id as unknown as Id<"agents">, 
            level: "info",
            message: "Agent system stopped. Manager agent not found for detailed logging.",
            timestamp: new Date().toISOString(),
            category: "system_lifecycle",
         });
    }

    return { success: true, message: "Agent system stopped successfully." };
  },
});

/**
 * Get the overall status of the agent system, all agents, and basic statistics.
 */
export const getAgentSystemStatus = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) { throw new Error("Authentication required."); }

    const system = await ctx.db.query("agentSystem").first();
    const allAgents = await ctx.db.query("agents").collect();

    const twentyFourHoursAgoISO = new Date(Date.now() - 24 * 60 * 60 * 1000).toISOString();
    const recentInsights = await ctx.db
      .query("agentInsights")
      // Ensure "by_createdAt" index exists on agentInsights for "createdAt" (string) field
      .withIndex("by_createdAt", q => q.gt("createdAt", twentyFourHoursAgoISO))
      .collect();

    const pendingTasks = await ctx.db
      .query("agentTasks")
      .withIndex("by_status", (q) => q.eq("status", "pending"))
      .collect();

    const inProgressTasks = await ctx.db
      .query("agentTasks")
      .withIndex("by_status", (q) => q.eq("status", "in_progress"))
      .collect();

       return {
      system: system || null,
      agents: allAgents || [],
      stats: {
        totalAgents: allAgents.length,
        activeAgents: allAgents.filter(a => a.status === "active").length,
        recentInsights: recentInsights.length,
        pendingTasks: pendingTasks.length,
        activeTasks: inProgressTasks.length,
      },
    };
  },
});

/**
 * Get recent agent insights, optionally enriched with agent information.
 */
export const getRecentInsights = query({
  args: {
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity(); // Added auth check for consistency
    if (!identity) { throw new Error("Authentication required."); }

    // Orders by _creationTime descending by default.
    // If you need to order by your string `createdAt` field, ensure it's indexed
    // and use .withIndex("by_createdAt").order("desc") if "by_createdAt" is just ["createdAt"]
    // or simply .order("desc") if relying on _creationTime.
    const insights = await ctx.db
      .query("agentInsights")
      .order("desc")
      .take(args.limit || 10);

    const enrichedInsights = await Promise.all(
      insights.map(async (insight) => {
        const agent = await ctx.db.get(insight.agentId);
        return {
          ...insight,
          agentName: agent?.name || "Unknown Agent",
          agentType: agent?.type,
        };
      })
    );
    return enrichedInsights;
  },
});

/**
 * Get agent logs with optional filtering by agent ID and log level.
 */
export const getAgentLogs = query({
  args: {
    agentId: v.optional(v.id("agents")),
    level: v.optional(
      v.union( // This union should match logLevelOptions in your agent-schema.ts
        v.literal("debug"),
        v.literal("info"),
        v.literal("warn"),
        v.literal("error"),
        v.literal("critical")
      )
    ),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity(); // Added auth check
    if (!identity) { throw new Error("Authentication required."); }

    const limit = args.limit || 50;
    let queryChain = ctx.db.query("agentLogs");

    if (args.agentId && args.level) {
      //@ts-ignore
      queryChain = queryChain.withIndex("by_agent_and_level", (q) =>
        q.eq("agentId", args.agentId!).eq("level", args.level!)
      );
    } else if (args.agentId) {
       //@ts-ignore
      queryChain = queryChain.withIndex("by_agent", (q) =>
        q.eq("agentId", args.agentId!)
      );
    } else if (args.level) {
       //@ts-ignore
      queryChain = queryChain.withIndex("by_level", (q) =>
        q.eq("level", args.level!)
      );
    }
    // Orders by _creationTime descending if no other order on index specified
    const logs = await queryChain.order("desc").take(limit);

    const enrichedLogs = await Promise.all(
      logs.map(async (log) => {
        const agent = log.agentId ? await ctx.db.get(log.agentId) : null;
        return {
          ...log,
          agentName: agent?.name || "System Log",
          agentType: agent?.type,
        };
      })
    );
    return enrichedLogs;
  },
});

/**
 * Enable or disable a specific agent.
 */
export const toggleAgent = mutation({
  args: {
    agentId: v.id("agents"),
    enabled: v.boolean(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Authentication required.");
    }

    const agent = await ctx.db.get(args.agentId);
    if (!agent) {
      throw new Error("Agent not found.");
    }

    await ctx.db.patch(args.agentId, {
      isEnabled: args.enabled,
      status: args.enabled ? "inactive" : "disabled",
      // updatedAt: new Date().toISOString(), // If you manually manage a string updatedAt field
    });

    await ctx.db.insert("agentLogs", {
      agentId: args.agentId,
      level: "info",
      message: `Agent ${agent.name} ${args.enabled ? "enabled" : "disabled"} by user ${identity.nickname || identity.subject}.`,
      timestamp: new Date().toISOString(),
      data: { agentId: args.agentId.toString(), enabled: args.enabled, userId: identity.subject },
      category: "agent_management", // Ensure 'category' field exists in agentLogs schema
    });

    return { success: true, message: `Agent ${args.enabled ? "enabled" : "disabled"}.` };
  },
});

/**
 * Create a test insight (for development/testing purposes).
 */
export const createTestInsight = mutation({
  args: {
    title: v.optional(v.string()),
    description: v.optional(v.string()),
    // Uses the options arrays defined at the top of this file
    priority: v.optional(v.union(...taskPriorityOptions.map(o => v.literal(o)))),
    type: v.optional(v.union(...insightTypeOptions.map(o => v.literal(o)))),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Authentication required.");
    }

    const manager = await ctx.db
      .query("agents")
      .withIndex("by_type", (q) => q.eq("type", "manager"))
      .first();

    if (!manager) {
      throw new Error("Manager agent not found. Cannot create test insight.");
    }

    const insightTypeToUse = args.type || "performance_metric";
    if (!insightTypeOptions.includes(insightTypeToUse as any)) { // Type assertion needed due to v.optional
        throw new Error(`Invalid insight type: ${insightTypeToUse}. Must be one of: ${insightTypeOptions.join(", ")}`);
    }

    const priorityToUse = args.priority || "low";
     if (!taskPriorityOptions.includes(priorityToUse as any)) { // Type assertion needed
        throw new Error(`Invalid priority: ${priorityToUse}. Must be one of: ${taskPriorityOptions.join(", ")}`);
    }

    const insightId = await ctx.db.insert("agentInsights", {
      agentId: manager._id,
      type: insightTypeToUse,
      title: args.title || "System Health Check (Test)",
      description: args.description || "All systems are operating normally. No critical issues detected. (Test Insight)",
      priority: priorityToUse,
      actionRequired: false,
      actionTaken: false,
      isRead: false,
      createdAt: new Date().toISOString(), // This aligns with your schema
      // data: { ... } // Populate based on insightTypeToUse if needed
    });

    await ctx.db.insert("agentLogs", {
        agentId: manager._id,
        level: "debug", // Ensure "debug" is in logLevelOptions in agent-schema.ts
        message: `Test insight created by ${identity.nickname || identity.subject}.`,
        timestamp: new Date().toISOString(),
        data: { insightId: insightId.toString(), userId: identity.subject },
        category: "test_data", // Ensure 'category' field exists in agentLogs schema
    });

    return { success: true, insightId };
  },
});

/**
 * Mark a specific insight as read.
 */
export const markInsightAsRead = mutation({
  args: {
    insightId: v.id("agentInsights"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new Error("Authentication required.");
    }

    const insight = await ctx.db.get(args.insightId);
    if (!insight) {
        throw new Error("Insight not found.");
    }

    if (insight.isRead) {
        return { success: true, message: "Insight was already marked as read."};
    }

    await ctx.db.patch(args.insightId, {
      isRead: true,
      readAt: new Date().toISOString(),
    });

    return { success: true, message: "Insight marked as read." };
  },
});
</file>

<file path="convex/agents/secretary.ts">
// convex/agents/secretary.ts
import { internalMutation, internalQuery } from "../_generated/server";
import { v } from "convex/values";
import { Id } from "../_generated/dataModel";
// Removed: import { internal } from "../_generated/api"; // Not used in the provided snippet

/**
 * Secretary Agent
 * * Responsibilities:
 * - Monitor new contract uploads and trigger analysis
 * - Create tasks for other agents based on contract data
 * - Coordinate initial contract processing workflow
 * - Generate insights about contract intake patterns
 * - Manage task distribution based on agent availability
 */

// ============================================================================
// CONFIGURATION
// ============================================================================

const SECRETARY_CONFIG = {
  // Processing intervals
  checkIntervalMinutes: 2,
  batchSize: 10,
  
  // Task creation rules
  taskPriority: {
    expiringSoon: "high" as const,
    highValue: "medium" as const,
    standard: "low" as const,
  },
  
  // Thresholds
  lowValueThreshold: 10000,
  mediumValueThreshold: 50000,
  highValueThreshold: 250000, 
  expirationWarningDays: 30,
  
  // Analysis triggers
  analysisRequiredStatuses: ["pending_analysis", "draft"] as const,
};

// Define an extended metrics type for the secretary agent
// This helps TypeScript understand the expected shape of metrics for this specific agent.
interface SecretaryAgentMetrics {
  totalRuns: number;
  successfulRuns: number;
  failedRuns: number;
  averageRunTime: number;
  lastRunDuration?: number;
  dataProcessed?: number;
  insightsGenerated?: number;
  // Secretary-specific metrics
  contractsProcessed?: number;
  expiringContractsFound?: number;
  // Allow other dynamic fields if your schema/logic relies on them
  // [key: string]: any; // Uncomment if you have other dynamic metric fields not listed
}

// ============================================================================
// MAIN EXECUTION
// ============================================================================

/**
 * Main run function for the Secretary Agent
 * Called periodically by the manager agent
 */
export const run = internalMutation({
  args: {
    agentId: v.id("agents"),
  },
  handler: async (ctx, args) => {
    const startTime = Date.now();
    
    try {
      // Log start
      await ctx.db.insert("agentLogs", {
        agentId: args.agentId,
        level: "info",
        message: "Secretary agent starting run",
        timestamp: new Date().toISOString(),
        category: "agent_execution",
      });

      // Update agent status
      await ctx.db.patch(args.agentId, {
        status: "busy",
        lastRun: new Date().toISOString(),
      });

      // Process new contracts
      const newContractsProcessed = await processNewContracts(ctx, args.agentId);
      
      // Check for expiring contracts
      const expiringContractsFound = await checkExpiringContracts(ctx, args.agentId);
      
      // Monitor task queue health
      const queueHealth = await monitorTaskQueue(ctx, args.agentId);
      
      // Generate intake insights
      await generateIntakeInsights(ctx, args.agentId);

      // Update agent metrics
      const agent = await ctx.db.get(args.agentId);
      if (agent) {
        const runTime = Date.now() - startTime;

        // Cast agent.metrics to our specific SecretaryAgentMetrics type,
        // or provide a default object that conforms to it, initializing specific fields.
        const existingMetrics: SecretaryAgentMetrics = (agent.metrics as SecretaryAgentMetrics) || {
          totalRuns: 0,
          successfulRuns: 0,
          failedRuns: 0,
          averageRunTime: 0,
          contractsProcessed: 0, // Initialize if not present
          expiringContractsFound: 0, // Initialize if not present
        };

        // Ensure all base metric fields are initialized if they were somehow missing from existingMetrics
        const newMetrics: SecretaryAgentMetrics = {
          ...existingMetrics, // Spread all fields from existingMetrics first
          totalRuns: (existingMetrics.totalRuns || 0) + 1,
          successfulRuns: (existingMetrics.successfulRuns || 0) + 1,
          failedRuns: existingMetrics.failedRuns || 0, 
          averageRunTime: 
            (((existingMetrics.averageRunTime || 0) * (existingMetrics.totalRuns || 0)) + runTime) / 
            ((existingMetrics.totalRuns || 0) + 1 || 1), // Avoid division by zero if totalRuns was 0
          lastRunDuration: runTime,
          // Now, safely access and update secretary-specific metrics
          contractsProcessed: (existingMetrics.contractsProcessed || 0) + newContractsProcessed,
          expiringContractsFound: (existingMetrics.expiringContractsFound || 0) + expiringContractsFound,
        };

        await ctx.db.patch(args.agentId, {
          status: "active",
          lastSuccess: new Date().toISOString(),
          runCount: (agent.runCount || 0) + 1, // Ensure agent.runCount is treated as a number
          // errorCount remains unchanged unless an error occurred in this run
          metrics: newMetrics, 
          // If you have an updatedAt field in your 'agents' schema, uncomment and set it:
          // updatedAt: new Date().toISOString(), 
        });
      }

      return { 
        success: true, 
        contractsProcessed: newContractsProcessed,
        expiringContractsFound,
        queueHealth,
      };

    } catch (error) {
      // Log error
      await ctx.db.insert("agentLogs", {
        agentId: args.agentId,
        level: "error",
        message: "Secretary agent failed",
        data: { error: error instanceof Error ? error.message : String(error) },
        timestamp: new Date().toISOString(),
        category: "agent_execution",
      });

      // Update agent with error
      const agent = await ctx.db.get(args.agentId);
      if (agent) {
        await ctx.db.patch(args.agentId, {
          status: "error",
          errorCount: (agent.errorCount || 0) + 1, // Ensure agent.errorCount is treated as a number
          lastError: error instanceof Error ? error.message : String(error),
        });
      }

      throw error;
    }
  },
});

// ============================================================================
// CORE FUNCTIONS (processNewContracts, checkExpiringContracts, etc.)
// ... (rest of your existing functions remain unchanged) ...
// ============================================================================
async function processNewContracts(
  ctx: any, // Consider using MutationCtx from "../_generated/server" for better typing
  agentId: Id<"agents">
): Promise<number> {
  // Get contracts pending analysis
  const contractsPending = await ctx.db
    .query("contracts")
    .withIndex("by_analysisStatus_and_enterpriseId") // Ensure this index exists and matches your query needs
    .filter((q: any) => 
      q.or(
        q.eq(q.field("analysisStatus"), "pending"),
        q.eq(q.field("analysisStatus"), undefined) // Include contracts where analysisStatus might not be set
      )
    )
    // Add enterpriseId filter if contracts are enterprise-specific
    // .filter((q: any) => q.eq(q.field("enterpriseId"), someEnterpriseId)) 
    .take(SECRETARY_CONFIG.batchSize);

  let processed = 0;

  for (const contract of contractsPending) {
    try {
      // Determine financial agent ID
      const financialAgent = await ctx.db
        .query("agents")
        .withIndex("by_type", (q: any) => q.eq("type", "financial"))
        .first();

      if (!financialAgent) {
        console.warn("Financial agent not found. Cannot create analysis task.");
        // Optionally, log this as a system warning or create a placeholder task
        continue; 
      }

      // Create analysis task for financial agent
      await ctx.db.insert("agentTasks", {
        assignedAgentId: financialAgent._id, // Use the fetched financial agent's ID
        createdByAgentId: agentId,
        taskType: "contract_analysis",
        status: "pending",
        priority: determineContractPriority(contract),
        title: `Analyze contract: ${contract.title || contract._id.toString()}`, // Fallback title
        description: `Perform financial analysis on contract ${contract._id}`,
        contractId: contract._id,
        vendorId: contract.vendorId,
        data: {
          contractType: contract.contractType,
          fileName: contract.fileName,
          storageId: contract.storageId,
        },
        createdAt: new Date().toISOString(),
      });

      // Update contract status
      await ctx.db.patch(contract._id, {
        analysisStatus: "processing",
      });

      processed++;

      // Log the task creation
      await ctx.db.insert("agentLogs", {
        agentId,
        level: "info",
        message: `Created analysis task for contract ${contract.title || contract._id.toString()}`,
        data: { contractId: contract._id.toString(), assignedAgentId: financialAgent._id.toString() },
        timestamp: new Date().toISOString(),
        category: "task_creation",
      });

    } catch (error) {
      await ctx.db.insert("agentLogs", {
        agentId,
        level: "error",
        message: `Failed to process contract ${contract._id}`,
        data: { contractId: contract._id.toString(), error: error instanceof Error ? error.message : String(error) },
        timestamp: new Date().toISOString(),
        category: "contract_processing",
      });
    }
  }

  return processed;
}

async function checkExpiringContracts(
  ctx: any, // Consider MutationCtx
  agentId: Id<"agents">
): Promise<number> {
  const warningDate = new Date();
  warningDate.setDate(warningDate.getDate() + SECRETARY_CONFIG.expirationWarningDays);
  const warningDateStr = warningDate.toISOString();

  // Query contracts expiring within warning period
  const expiringContracts = await ctx.db
    .query("contracts")
    // Add appropriate index if you filter by status and extractedEndDate frequently
    .filter((q: any) => 
      q.and(
        q.eq(q.field("status"), "active"), // Only active contracts
        q.lt(q.field("extractedEndDate"), warningDateStr), // Ends before warning date
        q.gt(q.field("extractedEndDate"), new Date().toISOString()) // But not already past
      )
    )
    // Add enterpriseId filter if applicable
    // .filter((q: any) => q.eq(q.field("enterpriseId"), someEnterpriseId))
    .collect();

  let newWarningsCreated = 0;

  for (const contract of expiringContracts) {
    // Check if we already have an active (non-actioned or unread) expiration insight
    const existingInsight = await ctx.db
      .query("agentInsights")
      .withIndex("by_contract", (q: any) => q.eq("contractId", contract._id)) // Ensure index exists
      .filter((q: any) => 
          q.and(
            q.eq(q.field("type"), "expiration_warning"),
            q.or(
                q.eq(q.field("actionTaken"), false), // If action not yet taken
                q.eq(q.field("isRead"), false)      // Or if it's unread (maybe action was taken but needs acknowledgement)
            )
          )
      )
      .first();

    if (!existingInsight) {
      newWarningsCreated++;
      // Create expiration warning insight
      await ctx.db.insert("agentInsights", {
        agentId, // Secretary agent ID
        type: "expiration_warning",
        title: `Contract Expiring Soon: ${contract.title || contract._id.toString()}`,
        description: `This contract expires on ${contract.extractedEndDate ? new Date(contract.extractedEndDate).toLocaleDateString() : 'N/A'}. Action may be required.`,
        priority: "high",
        contractId: contract._id,
        vendorId: contract.vendorId,
        actionRequired: true,
        actionTaken: false,
        isRead: false,
        createdAt: new Date().toISOString(),
        data: {
          expirationDate: contract.extractedEndDate,
          daysUntilExpiration: contract.extractedEndDate ? Math.ceil(
            (new Date(contract.extractedEndDate).getTime() - Date.now()) / 
            (1000 * 60 * 60 * 24)
          ) : undefined,
        },
      });

      // Create task for notifications agent
      const notificationsAgent = await ctx.db
        .query("agents")
        .withIndex("by_type", (q: any) => q.eq("type", "notifications"))
        .first();

      if (notificationsAgent) {
        await ctx.db.insert("agentTasks", {
          assignedAgentId: notificationsAgent._id,
          createdByAgentId: agentId,
          taskType: "send_notification",
          status: "pending",
          priority: "high",
          title: `Notify: Contract ${contract.title || contract._id.toString()} expiring`,
          contractId: contract._id,
          data: {
            notificationType: "contract_expiration",
            urgency: "high",
            recipient: "contract_owner_or_manager", // Define how recipient is determined
            message: `Contract '${contract.title || contract._id.toString()}' is expiring on ${contract.extractedEndDate ? new Date(contract.extractedEndDate).toLocaleDateString() : 'N/A'}.`,
          },
          createdAt: new Date().toISOString(),
        });
      } else {
        console.warn("Notifications agent not found. Cannot create notification task for expiring contract.");
      }
    }
  }
  // Return the count of *new* warnings created in this run, or total expiring if that's more relevant
  return newWarningsCreated; 
}

async function monitorTaskQueue(
  ctx: any, // Consider MutationCtx
  agentId: Id<"agents">
): Promise<any> {
  const pendingTasks = await ctx.db
    .query("agentTasks")
    .withIndex("by_status", (q: any) => q.eq(q.field("status"), "pending")) // Ensure index exists
    .collect();

  const inProgressTasks = await ctx.db
    .query("agentTasks")
    .withIndex("by_status", (q: any) => q.eq(q.field("status"), "in_progress")) // Ensure index exists
    .collect();
  
  const taskTimeoutMinutes = (SECRETARY_CONFIG as any).taskTimeoutMinutes || 30; // Fallback if not in config

  const stuckTasks = inProgressTasks.filter((task:any) => {
    if (!task.startedAt) return false;
    const runTimeMinutes = (Date.now() - new Date(task.startedAt).getTime()) / (1000 * 60);
    return runTimeMinutes > taskTimeoutMinutes; 
  });

  if (stuckTasks.length > 0) {
     // Check if a similar "Stuck Tasks" alert already exists and is recent/unactioned
    const existingAlert = await ctx.db.query("agentInsights")
      .filter((q:any) => q.and(
        q.eq(q.field("type"), "alert"),
        q.eq(q.field("title"), "Stuck Tasks Detected"),
        q.eq(q.field("actionTaken"), false), // Or based on createdAt time
        q.gt(q.field("createdAt"), new Date(Date.now() - 1 * 60 * 60 * 1000).toISOString()) // e.g., only one such alert per hour
      ))
      .first();

    if (!existingAlert) {
        await ctx.db.insert("agentInsights", {
            agentId, // Secretary agent ID
            type: "alert",
            title: "Stuck Tasks Detected",
            description: `${stuckTasks.length} task(s) appear to be stuck (running longer than ${taskTimeoutMinutes} minutes).`,
            priority: "high",
            actionRequired: true,
            actionTaken: false,
            isRead: false,
            createdAt: new Date().toISOString(),
            data: {
            stuckTaskIds: stuckTasks.map((t:any) => t._id.toString()),
            count: stuckTasks.length,
            timeoutThresholdMinutes: taskTimeoutMinutes
            },
        });
    }
  }

  return {
    pending: pendingTasks.length,
    inProgress: inProgressTasks.length,
    stuck: stuckTasks.length,
  };
}

async function generateIntakeInsights(
  ctx: any, 
  agentId: Id<"agents">
): Promise<void> {
  const thirtyDaysAgoTimestamp = Date.now() - (30 * 24 * 60 * 60 * 1000);
  
  const recentContracts = await ctx.db
    .query("contracts")
    // Assuming _creationTime is indexed or you have a createdAt string field that is indexed
    .filter((q: any) => 
      q.gte(q.field("_creationTime"), thirtyDaysAgoTimestamp)
    )
    // Add enterpriseId filter if applicable
    // .filter((q: any) => q.eq(q.field("enterpriseId"), someEnterpriseId))
    .collect();

  if (recentContracts.length >= 10) { // Only generate insight if there's a reasonable amount of data
    const byType = recentContracts.reduce((acc: { [key: string]: number }, contract: any) => {
      const type = contract.contractType || "other";
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {});

    const mostCommonTypeEntry = Object.entries(byType)
      .sort(([, a]:any, [, b]:any) => b - a)[0];
    
    const mostCommonType = mostCommonTypeEntry ? `${mostCommonTypeEntry[0]} (${mostCommonTypeEntry[1]} contracts)` : "N/A";

     // Avoid duplicate insights if one was generated recently
    const lastWeekTimestamp = new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString();
    const existingTrendInsight = await ctx.db.query("agentInsights")
        .filter((q:any) => q.and(
            q.eq(q.field("type"), "trend_analysis"),
            q.eq(q.field("title"), "Contract Intake Pattern (Last 30 Days)"),
            q.gt(q.field("createdAt"), lastWeekTimestamp) 
        )).first();

    if (!existingTrendInsight) {
        await ctx.db.insert("agentInsights", {
            agentId, // Secretary agent ID
            type: "trend_analysis",
            title: "Contract Intake Pattern (Last 30 Days)",
            description: `${recentContracts.length} contracts processed in the last 30 days. Most common type: ${mostCommonType}.`,
            priority: "low",
            actionRequired: false,
            actionTaken: false,
            isRead: false,
            createdAt: new Date().toISOString(),
            data: {
            totalContracts: recentContracts.length,
            contractsByType: byType,
            periodDays: 30,
            },
        });
    }
  }
}

function determineContractPriority(contract: any): "low" | "medium" | "high" | "critical" {
  if (contract.extractedPricing) {
    const valueString = String(contract.extractedPricing).replace(/[^0-9.-]+/g, "");
    const value = parseFloat(valueString);
    if (!isNaN(value) && value > SECRETARY_CONFIG.highValueThreshold) {
      return "high";
    }
  }

  if (contract.extractedEndDate) {
    try {
      const daysUntilExpiration = Math.ceil(
        (new Date(contract.extractedEndDate).getTime() - Date.now()) / 
        (1000 * 60 * 60 * 24)
      );
      if (daysUntilExpiration < SECRETARY_CONFIG.expirationWarningDays) {
        return "high";
      }
    } catch (e) {
      console.warn("Could not parse contract extractedEndDate:", contract.extractedEndDate);
    }
  }

  const highPriorityTypes = ["msa", "partnership", "saas"]; // Example
  if (contract.contractType && highPriorityTypes.includes(contract.contractType.toLowerCase())) {
    return "medium";
  }

  return "low";
}

async function getAgentId(ctx: any, type: string): Promise<Id<"agents">> {
  const agent = await ctx.db
    .query("agents")
    .withIndex("by_type", (q: any) => q.eq(q.field("type"), type)) // Ensure index exists
    .filter((q: any) => q.eq(q.field("isEnabled"), true)) // Prefer enabled agents
    .first();

  if (!agent) {
    // Fallback or specific error handling if no *enabled* agent of the type is found
    const anyAgentOfType = await ctx.db
        .query("agents")
        .withIndex("by_type", (q: any) => q.eq(q.field("type"), type))
        .first();
    if (anyAgentOfType) {
        console.warn(`Agent of type ${type} found but is not enabled. Using it anyway or consider erroring.`);
        return anyAgentOfType._id;
    }
    throw new Error(`No agent (enabled or otherwise) of type '${type}' found.`);
  }

  return agent._id;
}

export const getPendingContractsCount = internalQuery({
  args: {},
  handler: async (ctx) => {
    const pending = await ctx.db
      .query("contracts")
      .filter((q: any) => 
        q.or(
          q.eq(q.field("analysisStatus"), "pending"),
          q.eq(q.field("analysisStatus"), undefined)
        )
      )
      // Add enterpriseId filter if applicable
      // .filter((q: any) => q.eq(q.field("enterpriseId"), someEnterpriseId))
      .collect();
    
    return pending.length;
  },
});
</file>

<file path="convex/analytics.ts">
// convex/analytics.ts
import { query } from "./_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";

// ============================================================================
// DASHBOARD ANALYTICS
// ============================================================================

/**
 * Get dashboard summary for the current user's enterprise
 */
export const getDashboardSummary = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    // Get all contracts for the enterprise
    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .collect();

    // Get all vendors for the enterprise
    const vendors = await ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .collect();

    // Calculate contract statistics
    const now = new Date();
    const thirtyDaysFromNow = new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000);
    const ninetyDaysFromNow = new Date(now.getTime() + 90 * 24 * 60 * 60 * 1000);

    const contractStats = {
      total: contracts.length,
      active: contracts.filter(c => c.status === "active").length,
      draft: contracts.filter(c => c.status === "draft").length,
      pending: contracts.filter(c => c.status === "pending_analysis").length,
      expired: contracts.filter(c => c.status === "expired").length,
      expiringIn30Days: contracts.filter(c => 
        c.status === "active" && 
        c.endDate && 
        new Date(c.endDate) <= thirtyDaysFromNow &&
        new Date(c.endDate) > now
      ).length,
      expiringIn90Days: contracts.filter(c => 
        c.status === "active" && 
        c.endDate && 
        new Date(c.endDate) <= ninetyDaysFromNow &&
        new Date(c.endDate) > now
      ).length,
    };

    // Calculate vendor statistics
    const vendorStats = {
      total: vendors.length,
      active: vendors.filter(v => v.status === "active").length,
      inactive: vendors.filter(v => v.status === "inactive").length,
      byCategory: vendors.reduce((acc, vendor) => {
        acc[vendor?.category || ""] = (acc[vendor?.category || ""] || 0) + 1;
        return acc;
      }, {} as Record<string, number>),
    };

    // Calculate total contract value
    const totalValue = contracts.reduce((sum, contract) => {
      return sum + (contract.value || 0);
    }, 0);

    // Get recent activity (last 30 days)
    const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
    const recentContracts = contracts.filter(c => 
      new Date(c.createdAt) >= thirtyDaysAgo
    );

    return {
      contractStats,
      vendorStats,
      totalValue,
      recentActivity: {
        newContracts: recentContracts.length,
        contractsCreatedThisMonth: recentContracts.filter(c => 
          new Date(c.createdAt).getMonth() === now.getMonth() &&
          new Date(c.createdAt).getFullYear() === now.getFullYear()
        ).length,
      },
      alerts: {
        contractsExpiringSoon: contractStats.expiringIn30Days,
        pendingApprovals: contractStats.pending,
        overdueContracts: contracts.filter(c => 
          c.status === "active" && 
          c.endDate && 
          new Date(c.endDate) < now
        ).length,
      },
    };
  },
});

/**
 * Get recent activity for the dashboard
 */
export const getRecentActivity = query({
  args: {
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const limit = Math.min(args.limit || 10, 50);

     // Define the event type
     type ActivityEvent = {
      id: string;
      type: "contract" | "vendor";
      action: "created";
      title: string;
      timestamp: string;
      metadata: {
        contractId?: string;
        contractTitle?: string;
        status?: string;
        vendorId?: string;
        vendorName?: string;
        category?: string;
      };
    };

    // Get recent events from multiple sources
    const events: ActivityEvent[] = [];

    // Recent contracts
    const recentContracts = await ctx.db
      .query("contracts")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .order("desc")
      .take(limit);

    
    for (const contract of recentContracts) {      
      events.push({
        id: contract._id,
        type: "contract",
        action: "created",
        title: `Contract "${contract.title}" was created`,
        timestamp: contract.createdAt,
        metadata: {
          contractId: contract._id,
          contractTitle: contract.title,
          status: contract.status,
        },
      });
    }

    // Recent vendors
    const recentVendors = await ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .order("desc")
      .take(limit);

    for (const vendor of recentVendors) {
      events.push({
        id: vendor._id,
        type: "vendor",
        action: "created",
        title: `Vendor "${vendor.name}" was added`,
        timestamp: vendor.createdAt,
        metadata: {
          vendorId: vendor._id,
          vendorName: vendor.name,
          category: vendor.category,
        },
      });
    }

    // Sort by timestamp and limit
    events.sort((a:any, b:any) => new Date(b.timestamp).getTime() - new Date(a.timestamp).getTime());

    return events.slice(0, limit);
  },
});

/**
 * Get upcoming deadlines and alerts
 */
export const getUpcomingDeadlines = query({
  args: {
    days: v.optional(v.number()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const days = args.days || 30;
    const now = new Date();
    const futureDate = new Date(now.getTime() + days * 24 * 60 * 60 * 1000);

    // Get contracts expiring within the specified timeframe
    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .filter((q) => q.eq(q.field("status"), "active"))
      .collect();

    const upcomingDeadlines = contracts
      .filter(contract => {
        if (!contract.endDate) return false;
        const endDate = new Date(contract.endDate);
        return endDate > now && endDate <= futureDate;
      })
      .map(contract => ({
        id: contract._id,
        type: "contract_expiration",
        title: contract.title,
        deadline: contract.endDate,
        daysUntilDeadline: Math.ceil(
          (new Date(contract.endDate!).getTime() - now.getTime()) / (1000 * 60 * 60 * 24)
        ),
        priority: new Date(contract.endDate!).getTime() - now.getTime() <= 7 * 24 * 60 * 60 * 1000 
          ? "high" : "medium",
        vendor: contract.vendorId,
        value: contract.value,
      }))
      .sort((a, b) => new Date(a.deadline!).getTime() - new Date(b.deadline!).getTime());

    return upcomingDeadlines;
  },
});

/**
 * Get contract analytics by status
 */
export const getContractAnalytics = query({
  args: {
    timeRange: v.optional(v.union(
      v.literal("7days"),
      v.literal("30days"),
      v.literal("90days"),
      v.literal("1year"),
    )),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    // Calculate date range
    const now = new Date();
    const timeRange = args.timeRange || "30days";
    const daysMap = { "7days": 7, "30days": 30, "90days": 90, "1year": 365 };
    const cutoffDate = new Date(now.getTime() - daysMap[timeRange] * 24 * 60 * 60 * 1000);

    // Get contracts within the time range
    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .filter((q) => q.gte(q.field("createdAt"), cutoffDate.toISOString()))
      .collect();

    // Group by status
    const byStatus = contracts.reduce((acc, contract) => {
      acc[contract.status] = (acc[contract.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Group by month for trend analysis
    const byMonth = contracts.reduce((acc, contract) => {
      const month = new Date(contract.createdAt).toISOString().substring(0, 7); // YYYY-MM
      acc[month] = (acc[month] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    // Calculate total value
    const totalValue = contracts.reduce((sum, contract) => sum + (contract.value || 0), 0);
    const averageValue = contracts.length > 0 ? totalValue / contracts.length : 0;

    return {
      summary: {
        total: contracts.length,
        totalValue,
        averageValue,
      },
      byStatus,
      byMonth,
      timeRange,
    };
  },
});

/**
 * Get vendor performance analytics
 */
export const getVendorAnalytics = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    // Get all vendors and contracts for analysis
    const vendors = await ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .collect();

    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .collect();

    // Calculate vendor performance metrics
    const vendorMetrics = vendors.map(vendor => {
      const vendorContracts = contracts.filter(c => c.vendorId === vendor._id);
      const totalValue = vendorContracts.reduce((sum, c) => sum + (c.value || 0), 0);
      const activeContracts = vendorContracts.filter(c => c.status === "active").length;

      return {
        vendorId: vendor._id,
        name: vendor.name,
        category: vendor.category,
        contractCount: vendorContracts.length,
        totalValue,
        activeContracts,
        averageContractValue: vendorContracts.length > 0 ? totalValue / vendorContracts.length : 0,
      };
    });

    // Sort by total value
    vendorMetrics.sort((a, b) => b.totalValue - a.totalValue);

    // Group by category
    const byCategory = vendors.reduce((acc, vendor) => {
      acc[vendor?.category || ""] = (acc[vendor?.category || ""] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      topVendors: vendorMetrics.slice(0, 10),
      byCategory,
      summary: {
        totalVendors: vendors.length,
        activeVendors: vendors.filter(v => v.status === "active").length,
        totalContractValue: vendorMetrics.reduce((sum, v) => sum + v.totalValue, 0),
      },
    };
  },
});
</file>

<file path="convex/notifications.ts">
// convex/notifications.ts
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { NotificationChannel, NotificationData } from "./types";

// ============================================================================
// USER NOTIFICATIONS
// ============================================================================

/**
 * Create a new notification
 */
export const createNotification = mutation({
  args: {
    recipientId: v.id("users"),
    type: v.union(
      v.literal("contract_expiration"),
      v.literal("contract_created"), 
      v.literal("approval_required"),
      v.literal("payment_reminder"),
      v.literal("vendor_risk_alert"),
      v.literal("compliance_issue"),
      v.literal("task_assigned"),
      v.literal("system_alert"),
      v.literal("digest"),
    ),
    title: v.string(),
    message: v.string(),
    priority: v.union(v.literal("low"), v.literal("medium"), v.literal("high"), v.literal("critical")),
    channels: v.optional(v.array(v.union(v.literal("in_app"), v.literal("email"), v.literal("sms")))),
    contractId: v.optional(v.id("contracts")),
    vendorId: v.optional(v.id("vendors")),
    taskId: v.optional(v.id("agentTasks")),
    actionUrl: v.optional(v.string()),
    metadata: v.optional(v.any()),
    scheduledFor: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    // Verify recipient exists
    const recipient = await ctx.db.get(args.recipientId);
    if (!recipient) {
      throw new ConvexError("Recipient not found");
    }

    // Get recipient's notification preferences
    const preferences = await ctx.db
      .query("userNotificationPreferences")
      .withIndex("by_user", (q) => q.eq("userId", args.recipientId))
      .first();

    // Determine delivery channels based on preferences
    let channels: NotificationChannel[] = args.channels || ["in_app"];
    if (preferences) {
      const finalChannels: NotificationChannel[] = [];
      
      if (preferences.inAppEnabled && channels.includes("in_app")) {
        finalChannels.push("in_app");
      }
      
      if (preferences.emailEnabled && channels.includes("email")) {
        // Check type-specific preferences
        const typeEnabled = (
          (args.type === "contract_expiration" || args.type === "contract_created") && preferences.contractNotifications ||
          args.type === "approval_required" && preferences.approvalNotifications ||
          args.type === "payment_reminder" && preferences.paymentNotifications ||
          (args.type === "vendor_risk_alert") && preferences.vendorNotifications ||
          args.type === "compliance_issue" && preferences.complianceNotifications ||
          args.type === "system_alert" && preferences.systemNotifications ||
          args.type === "task_assigned" || // Always enabled for task assignments
          args.type === "digest"
        );
        
        if (typeEnabled) {
          finalChannels.push("email");
        }
      }
      
      if (preferences.smsEnabled && channels.includes("sms")) {
        finalChannels.push("sms");
      }
      
      channels = finalChannels.length > 0 ? finalChannels : ["in_app"];
    }

    // Create the notification
    const notificationId = await ctx.db.insert("notifications", {
      recipientId: args.recipientId,
      type: args.type,
      title: args.title,
      message: args.message,
      priority: args.priority,
      channels: channels,
      status: args.scheduledFor ? "scheduled" : "pending",
      isRead: false,
      scheduledFor: args.scheduledFor,
      retryCount: 0,
      contractId: args.contractId,
      vendorId: args.vendorId,
      taskId: args.taskId,
      actionUrl: args.actionUrl,
      metadata: args.metadata,
      createdAt: new Date().toISOString(),
    });

    // Log creation event
    await ctx.db.insert("notificationEvents", {
      notificationId,
      eventType: "created",
      timestamp: new Date().toISOString(),
      metadata: {
        createdBy: identity.subject,
        channels,
      },
    });

    // If not scheduled, mark as ready for delivery
    if (!args.scheduledFor) {
      await ctx.db.patch(notificationId, {
        status: "delivered", // In a real system, this would be handled by a background job
        deliveredAt: new Date().toISOString(),
      });

      await ctx.db.insert("notificationEvents", {
        notificationId,
        eventType: "delivered",
        timestamp: new Date().toISOString(),
      });
    }

    return { 
      success: true, 
      notificationId,
      channels,
    };
  },
});

/**
 * Get notifications for the current user
 */
export const getMyNotifications = query({
  args: {
    limit: v.optional(v.number()),
    offset: v.optional(v.number()),
    includeRead: v.optional(v.boolean()),
    type: v.optional(v.string()),
    priority: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const limit = Math.min(args.limit || 20, 100);
    const offset = args.offset || 0;

    // Build query
    let query = ctx.db
      .query("notifications")
      .withIndex("by_recipient", (q) => q.eq("recipientId", user._id));

    // Get all notifications first
    let notifications = await query.order("desc").collect();

    // Apply filters
    if (!args.includeRead) {
      notifications = notifications.filter(n => !n.isRead);
    }

    if (args.type) {
      notifications = notifications.filter(n => n.type === args.type);
    }

    if (args.priority) {
      notifications = notifications.filter(n => n.priority === args.priority);
    }

    // Exclude archived notifications
    notifications = notifications.filter(n => n.status !== "archived");

    // Apply pagination
    const paginatedNotifications = notifications.slice(offset, offset + limit);

    // Enrich with related data
    const enrichedNotifications = await Promise.all(
      paginatedNotifications.map(async (notification) => {
        const enriched: any = { ...notification };

        // Add contract info if available
        if (notification.contractId) {
          const contract = await ctx.db.get(notification.contractId);
          if (contract) {
            enriched.contract = {
              _id: contract._id,
              title: contract.title,
              status: contract.status,
            };
          }
        }

        // Add vendor info if available
        if (notification.vendorId) {
          const vendor = await ctx.db.get(notification.vendorId);
          if (vendor) {
            enriched.vendor = {
              _id: vendor._id,
              name: vendor.name,
              category: vendor.category,
            };
          }
        }

        return enriched;
      })
    );

    return {
      notifications: enrichedNotifications,
      total: notifications.length,
      unreadCount: notifications.filter(n => !n.isRead).length,
      hasMore: offset + limit < notifications.length,
    };
  },
});

/**
 * Get unread notification count for the current user
 */
export const getUnreadCount = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const unreadNotifications = await ctx.db
      .query("notifications")
      .withIndex("by_recipient_and_read", (q) => 
        q.eq("recipientId", user._id).eq("isRead", false)
      )
      .filter((q) => q.neq(q.field("status"), "archived"))
      .collect();

    return {
      total: unreadNotifications.length,
      byPriority: {
        critical: unreadNotifications.filter(n => n.priority === "critical").length,
        high: unreadNotifications.filter(n => n.priority === "high").length,
        medium: unreadNotifications.filter(n => n.priority === "medium").length,
        low: unreadNotifications.filter(n => n.priority === "low").length,
      },
    };
  },
});

/**
 * Mark a notification as read
 */
export const markAsRead = mutation({
  args: {
    notificationId: v.id("notifications"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const notification = await ctx.db.get(args.notificationId);
    if (!notification) {
      throw new ConvexError("Notification not found");
    }

    // Verify the notification belongs to the user
    if (notification.recipientId !== user._id) {
      throw new ConvexError("Access denied");
    }

    if (notification.isRead) {
      return { success: true, message: "Already marked as read" };
    }

    await ctx.db.patch(args.notificationId, {
      isRead: true,
      readAt: new Date().toISOString(),
    });

    // Log the event
    await ctx.db.insert("notificationEvents", {
      notificationId: args.notificationId,
      eventType: "read",
      timestamp: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Mark multiple notifications as read
 */
export const markMultipleAsRead = mutation({
  args: {
    notificationIds: v.array(v.id("notifications")),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    let successCount = 0;
    const errors: string[] = [];

    for (const notificationId of args.notificationIds) {
      try {
        const notification = await ctx.db.get(notificationId);
        
        if (!notification) {
          errors.push(`Notification ${notificationId} not found`);
          continue;
        }

        if (notification.recipientId !== user._id) {
          errors.push(`Access denied for notification ${notificationId}`);
          continue;
        }

        if (!notification.isRead) {
          await ctx.db.patch(notificationId, {
            isRead: true,
            readAt: new Date().toISOString(),
          });

          await ctx.db.insert("notificationEvents", {
            notificationId,
            eventType: "read",
            timestamp: new Date().toISOString(),
          });

          successCount++;
        }
      } catch (error) {
        errors.push(`Error processing ${notificationId}: ${error}`);
      }
    }

    return {
      success: true,
      successCount,
      totalCount: args.notificationIds.length,
      errors,
    };
  },
});

/**
 * Mark all notifications as read
 */
export const markAllAsRead = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const unreadNotifications = await ctx.db
      .query("notifications")
      .withIndex("by_recipient_and_read", (q) => 
        q.eq("recipientId", user._id).eq("isRead", false)
      )
      .filter((q) => q.neq(q.field("status"), "archived"))
      .collect();

    const readAt = new Date().toISOString();
    let count = 0;

    for (const notification of unreadNotifications) {
      await ctx.db.patch(notification._id, {
        isRead: true,
        readAt,
      });

      await ctx.db.insert("notificationEvents", {
        notificationId: notification._id,
        eventType: "read",
        timestamp: readAt,
      });

      count++;
    }

    return {
      success: true,
      count,
    };
  },
});

/**
 * Dismiss a notification
 */
export const dismissNotification = mutation({
  args: {
    notificationId: v.id("notifications"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const notification = await ctx.db.get(args.notificationId);
    if (!notification) {
      throw new ConvexError("Notification not found");
    }

    if (notification.recipientId !== user._id) {
      throw new ConvexError("Access denied");
    }

    // Archive the notification
    await ctx.db.patch(args.notificationId, {
      status: "archived",
      archivedAt: new Date().toISOString(),
    });

    await ctx.db.insert("notificationEvents", {
      notificationId: args.notificationId,
      eventType: "dismissed",
      timestamp: new Date().toISOString(),
    });

    return { success: true };
  },
});

// ============================================================================
// NOTIFICATION PREFERENCES
// ============================================================================

/**
 * Get notification preferences for the current user
 */
export const getMyPreferences = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const preferences = await ctx.db
      .query("userNotificationPreferences")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .first();

    // Return defaults if no preferences exist
    if (!preferences) {
      return {
        userId: user._id,
        inAppEnabled: true,
        emailEnabled: true,
        smsEnabled: false,
        contractNotifications: true,
        approvalNotifications: true,
        paymentNotifications: true,
        vendorNotifications: true,
        complianceNotifications: true,
        systemNotifications: true,
        batchNotifications: false,
        quietHoursEnabled: false,
        quietHoursStart: 22,
        quietHoursEnd: 7,
        emailFrequency: "immediate",
        emailDigestTime: 9,
      };
    }

    return preferences;
  },
});

/**
 * Update notification preferences
 */
export const updatePreferences = mutation({
  args: {
    preferences: v.object({
      inAppEnabled: v.optional(v.boolean()),
      emailEnabled: v.optional(v.boolean()),
      smsEnabled: v.optional(v.boolean()),
      contractNotifications: v.optional(v.boolean()),
      approvalNotifications: v.optional(v.boolean()),
      paymentNotifications: v.optional(v.boolean()),
      vendorNotifications: v.optional(v.boolean()),
      complianceNotifications: v.optional(v.boolean()),
      systemNotifications: v.optional(v.boolean()),
      batchNotifications: v.optional(v.boolean()),
      quietHoursEnabled: v.optional(v.boolean()),
      quietHoursStart: v.optional(v.number()),
      quietHoursEnd: v.optional(v.number()),
      timezone: v.optional(v.string()),
      emailFrequency: v.optional(v.union(
        v.literal("immediate"),
        v.literal("hourly"),
        v.literal("daily"),
        v.literal("weekly"),
      )),
      emailDigestTime: v.optional(v.number()),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const existingPreferences = await ctx.db
      .query("userNotificationPreferences")
      .withIndex("by_user", (q) => q.eq("userId", user._id))
      .first();

    if (existingPreferences) {
      // Update existing preferences
      await ctx.db.patch(existingPreferences._id, {
        ...args.preferences,
        updatedAt: new Date().toISOString(),
      });
    } else {
      // Create new preferences
      await ctx.db.insert("userNotificationPreferences", {
        userId: user._id,
        inAppEnabled: args.preferences.inAppEnabled ?? true,
        emailEnabled: args.preferences.emailEnabled ?? true,
        smsEnabled: args.preferences.smsEnabled ?? false,
        contractNotifications: args.preferences.contractNotifications ?? true,
        approvalNotifications: args.preferences.approvalNotifications ?? true,
        paymentNotifications: args.preferences.paymentNotifications ?? true,
        vendorNotifications: args.preferences.vendorNotifications ?? true,
        complianceNotifications: args.preferences.complianceNotifications ?? true,
        systemNotifications: args.preferences.systemNotifications ?? true,
        batchNotifications: args.preferences.batchNotifications ?? false,
        quietHoursEnabled: args.preferences.quietHoursEnabled ?? false,
        quietHoursStart: args.preferences.quietHoursStart ?? 22,
        quietHoursEnd: args.preferences.quietHoursEnd ?? 7,
        timezone: args.preferences.timezone,
        emailFrequency: args.preferences.emailFrequency ?? "immediate",
        emailDigestTime: args.preferences.emailDigestTime ?? 9,
        createdAt: new Date().toISOString(),
      });
    }

    return { success: true };
  },
});

// ============================================================================
// NOTIFICATION ANALYTICS
// ============================================================================

/**
 * Get notification statistics for the current user
 */
export const getMyNotificationStats = query({
  args: {
    timeRange: v.optional(v.union(
      v.literal("7days"),
      v.literal("30days"),
      v.literal("90days"),
    )),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    // Calculate date range
    const now = new Date();
    const timeRange = args.timeRange || "30days";
    const daysMap = { "7days": 7, "30days": 30, "90days": 90 };
    const cutoffDate = new Date(now.getTime() - daysMap[timeRange] * 24 * 60 * 60 * 1000);

    // Get all notifications in the time range
    const notifications = await ctx.db
      .query("notifications")
      .withIndex("by_recipient", (q) => q.eq("recipientId", user._id))
      .filter((q) => q.gte(q.field("createdAt"), cutoffDate.toISOString()))
      .collect();

    // Calculate statistics
    const stats = {
      total: notifications.length,
      read: notifications.filter(n => n.isRead).length,
      unread: notifications.filter(n => !n.isRead).length,
      byType: {} as Record<string, number>,
      byPriority: {} as Record<string, number>,
      byChannel: {} as Record<string, number>,
      deliveryRate: 0,
      readRate: 0,
    };

    // Group by type
    notifications.forEach(n => {
      stats.byType[n.type] = (stats.byType[n.type] || 0) + 1;
      stats.byPriority[n.priority] = (stats.byPriority[n.priority] || 0) + 1;
      
      n.channels.forEach(channel => {
        stats.byChannel[channel] = (stats.byChannel[channel] || 0) + 1;
      });
    });

    // Calculate rates
    if (stats.total > 0) {
      const delivered = notifications.filter(n => n.status === "delivered").length;
      stats.deliveryRate = delivered / stats.total;
      stats.readRate = stats.read / stats.total;
    }

    return stats;
  },
});

// ============================================================================
// TEST NOTIFICATIONS (for development)
// ============================================================================

/**
 * Create a test notification (only in development)
 */
export const createTestNotification = mutation({
  args: {
    type: v.optional(v.string()),
    title: v.optional(v.string()),
    message: v.optional(v.string()),
    priority: v.optional(v.union(
      v.literal("low"),
      v.literal("medium"),
      v.literal("high"),
      v.literal("critical"),
    )),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const notificationId = await ctx.db.insert("notifications", {
      recipientId: user._id,
      type: (args.type || "system_alert") as any,
      title: args.title || "Test Notification",
      message: args.message || "This is a test notification to verify the system is working.",
      priority: args.priority || "medium",
      channels: ["in_app"],
      status: "delivered",
      isRead: false,
      createdAt: new Date().toISOString(),
      retryCount: 0,
      metadata: {
        isTest: true,
        createdBy: user._id,
      },
    });

    return { success: true, notificationId };
  },
});
</file>

<file path="convex/onboarding.ts">
import { query, mutation, action } from "./_generated/server";
import { v, ConvexError } from "convex/values";
import { api } from "./_generated/api";
import { Id } from "./_generated/dataModel";

// ============================================================================
// ONBOARDING STATE MANAGEMENT
// ============================================================================

/**
 * Onboarding steps that users go through
 */
export const ONBOARDING_STEPS = {
  ACCOUNT_TYPE: 'account_type',      // Choose between creating or joining
  CREATE_ENTERPRISE: 'create_enterprise',
  JOIN_ENTERPRISE: 'join_enterprise',
  PROFILE_SETUP: 'profile_setup',
  ENTERPRISE_CONFIG: 'enterprise_config', // Only for owners/admins
  INVITE_TEAM: 'invite_team',        // Optional
  FIRST_CONTRACT: 'first_contract',   // Optional tutorial
  COMPLETE: 'complete'
} as const;

export type OnboardingStep = typeof ONBOARDING_STEPS[keyof typeof ONBOARDING_STEPS];

/**
 * Check user's onboarding status and determine next step
 */
export const getOnboardingStatus = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return {
        isOnboarded: false,
        currentStep: ONBOARDING_STEPS.ACCOUNT_TYPE,
        requiresOnboarding: true,
      };
    }

    // Check if user exists
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      // New user - needs to choose account type
      return {
        isOnboarded: false,
        currentStep: ONBOARDING_STEPS.ACCOUNT_TYPE,
        requiresOnboarding: true,
        userEmail: identity.email,
      };
    }

    // Get enterprise details
    const enterprise = await ctx.db.get(user.enterpriseId);
    
    // Get onboarding record
    const onboarding = await ctx.db
      .query("userOnboarding")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();

    // Check various completion states
    const hasProfile = !!(user.firstName && user.lastName);
    const hasEnterprise = !!enterprise;
    const isOwnerOrAdmin = user.role === 'owner' || user.role === 'admin';
    
    // Determine current step
    let currentStep: OnboardingStep = ONBOARDING_STEPS.COMPLETE;
    let requiresOnboarding = false;

    if (!hasEnterprise) {
      currentStep = ONBOARDING_STEPS.CREATE_ENTERPRISE;
      requiresOnboarding = true;
    } else if (!hasProfile) {
      currentStep = ONBOARDING_STEPS.PROFILE_SETUP;
      requiresOnboarding = true;
    } else if (isOwnerOrAdmin && !enterprise.industry) {
      currentStep = ONBOARDING_STEPS.ENTERPRISE_CONFIG;
      requiresOnboarding = true;
    } else if (onboarding && !onboarding.completedAt) {
      currentStep = (Object.values(ONBOARDING_STEPS) as OnboardingStep[]).includes(onboarding.currentStep as OnboardingStep)
        ? onboarding.currentStep as OnboardingStep
        : ONBOARDING_STEPS.INVITE_TEAM;
      requiresOnboarding = true;
    }

    // Check if they've created any contracts
    const hasContracts = await ctx.db
      .query("contracts")
      .withIndex("by_status_and_enterpriseId", (q) => 
        q.eq("enterpriseId", user.enterpriseId)
      )
      .first();

    return {
      isOnboarded: !requiresOnboarding,
      currentStep,
      requiresOnboarding,
      user: {
        id: user._id,
        email: user.email,
        role: user.role,
        hasProfile,
      },
      enterprise: enterprise ? {
        id: enterprise._id,
        name: enterprise.name,
        hasConfig: !!enterprise.industry,
      } : null,
      progress: {
        hasProfile,
        hasEnterprise,
        hasEnterpriseConfig: enterprise?.industry ? true : false,
        hasContracts: !!hasContracts,
      },
      onboarding: onboarding || null,
    };
  },
});

/**
 * Start or update onboarding process
 */
export const updateOnboardingStep = mutation({
  args: {
    step: v.string(),
    completed: v.optional(v.boolean()),
    metadata: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new ConvexError("User not found");

    // Find or create onboarding record
    let onboarding = await ctx.db
      .query("userOnboarding")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();

    if (!onboarding) {
      // Create new onboarding record
      const onboardingId = await ctx.db.insert("userOnboarding", {
        userId: user._id,
        enterpriseId: user.enterpriseId,
        currentStep: args.step as OnboardingStep,
        completedSteps: args.completed ? [args.step] : [],
        startedAt: new Date().toISOString(),
        metadata: args.metadata || {},
      });
      return { onboardingId, isNew: true };
    }

    // Update existing record
    const completedSteps = [...(onboarding.completedSteps || [])];
    if (args.completed && !completedSteps.includes(args.step)) {
      completedSteps.push(args.step);
    }

    const updates: any = {
      currentStep: args.step as OnboardingStep,
      completedSteps,
      updatedAt: new Date().toISOString(),
    };

    if (args.metadata) {
      updates.metadata = { ...onboarding.metadata, ...args.metadata };
    }

    // Check if onboarding is complete
    const requiredSteps = [
      ONBOARDING_STEPS.PROFILE_SETUP,
      user.role === 'owner' || user.role === 'admin' 
        ? ONBOARDING_STEPS.ENTERPRISE_CONFIG 
        : null,
    ].filter(Boolean);

    const isComplete = requiredSteps.every(step => 
      completedSteps.includes(step as string)
    );

    if (isComplete && !onboarding.completedAt) {
      updates.completedAt = new Date().toISOString();
    }

    await ctx.db.patch(onboarding._id, updates);
    
    return { 
      onboardingId: onboarding._id, 
      isComplete,
      completedSteps,
    };
  },
});

// ============================================================================
// ACCOUNT TYPE SELECTION
// ============================================================================

/**
 * Check if user can join an enterprise via email domain
 */
export const checkEmailDomain = query({
  args: {
    email: v.string(),
  },
  handler: async (ctx, args) => {
    const domain = args.email.split('@')[1];
    if (!domain) return null;

    const enterprise = await ctx.db
      .query("enterprises")
      .withIndex("by_domain", (q) => q.eq("domain", domain))
      .first();

    if (!enterprise) return null;

    // Check if auto-join is enabled (you might want to add this field)
    return {
      enterpriseId: enterprise._id,
      enterpriseName: enterprise.name,
      canAutoJoin: true, // You might want to add settings for this
    };
  },
});

/**
 * Check for pending invitations
 */
export const checkPendingInvitations = query({
  args: {
    email: v.string(),
  },
  handler: async (ctx, args) => {
    const invitations = await ctx.db
      .query("invitations")
      .withIndex("by_email", (q) => q.eq("email", args.email.toLowerCase()))
      .filter(q => q.eq(q.field("acceptedAt"), undefined))
      .collect();

    const validInvitations = await Promise.all(
      invitations
        .filter(inv => new Date(inv.expiresAt) > new Date())
        .map(async (inv) => {
          const enterprise = await ctx.db.get(inv.enterpriseId);
          const inviter = await ctx.db.get(inv.invitedBy);
          return {
            id: inv._id,
            token: inv.token,
            role: inv.role,
            enterpriseName: enterprise?.name || 'Unknown',
            enterpriseId: inv.enterpriseId, // <<< --- ADD THIS LINE
            inviterName: inviter 
              ? `${inviter.firstName || ''} ${inviter.lastName || ''}`.trim() || inviter.email
              : 'Unknown',
            expiresAt: inv.expiresAt,
          };
        })
    );

    return validInvitations;
  },
});

// ============================================================================
// PROFILE SETUP
// ============================================================================

/**
 * Complete user profile setup
 */
export const completeProfileSetup = mutation({
  args: {
    firstName: v.string(),
    lastName: v.string(),
    phoneNumber: v.optional(v.string()),
    department: v.optional(v.string()),
    title: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new ConvexError("User not found");

    // Validate inputs
    if (!args.firstName || args.firstName.trim().length < 1) {
      throw new ConvexError("First name is required");
    }
    if (!args.lastName || args.lastName.trim().length < 1) {
      throw new ConvexError("Last name is required");
    }

    // Update user profile
    await ctx.db.patch(user._id, {
      firstName: args.firstName.trim(),
      lastName: args.lastName.trim(),
      phoneNumber: args.phoneNumber?.trim(),
      department: args.department?.trim(),
      title: args.title?.trim(),
      updatedAt: new Date().toISOString(),
    });

    // Update onboarding step
    await ctx.runMutation(api.onboarding.updateOnboardingStep, {
      step: ONBOARDING_STEPS.PROFILE_SETUP,
      completed: true,
    });

    return { success: true };
  },
});

// ============================================================================
// ENTERPRISE CONFIGURATION
// ============================================================================

/**
 * Complete enterprise configuration (for owners/admins)
 */
export const completeEnterpriseConfig = mutation({
  args: {
    industry: v.string(),
    size: v.union(
      v.literal("1-10"),
      v.literal("11-50"),
      v.literal("51-200"),
      v.literal("201-500"),
      v.literal("501-1000"),
      v.literal("1000+")
    ),
    contractVolume: v.optional(v.union(
      v.literal("low"),      // < 10 contracts
      v.literal("medium"),   // 10-50 contracts
      v.literal("high"),     // 50-200 contracts
      v.literal("enterprise") // 200+ contracts
    )),
    primaryUseCase: v.optional(v.array(v.string())), // e.g., ["vendor", "customer", "partner", "employee"]
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new ConvexError("User not found");

    // Only owners and admins can configure enterprise
    if (user.role !== "owner" && user.role !== "admin") {
      throw new ConvexError("Only owners and admins can configure enterprise settings");
    }

    const enterprise = await ctx.db.get(user.enterpriseId);
    if (!enterprise) throw new ConvexError("Enterprise not found");

    // Update enterprise with configuration
    await ctx.db.patch(user.enterpriseId, {
      industry: args.industry,
      size: args.size,
      contractVolume: args.contractVolume,
      primaryUseCase: args.primaryUseCase,
    });

    // Update onboarding step
    await ctx.runMutation(api.onboarding.updateOnboardingStep, {
      step: ONBOARDING_STEPS.ENTERPRISE_CONFIG,
      completed: true,
      metadata: {
        configuredBy: user._id,
        configuredAt: new Date().toISOString(),
      },
    });

    return { success: true };
  },
});

// ============================================================================
// ONBOARDING COMPLETION
// ============================================================================

/**
 * Complete onboarding process
 */
export const completeOnboarding = action({
  args: {
    skippedSteps: v.optional(v.array(v.string())),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Authentication required");

    // Get current onboarding status
    const status = await ctx.runQuery(api.onboarding.getOnboardingStatus);
    
    if (!status.user) {
      throw new Error("User not found");
    }

    // Mark as complete
    await ctx.runMutation(api.onboarding.updateOnboardingStep, {
      step: ONBOARDING_STEPS.COMPLETE,
      completed: true,
      metadata: {
        skippedSteps: args.skippedSteps || [],
        completedAt: new Date().toISOString(),
      },
    });

    // Optional: Create sample data for demo purposes
    if (status.user.role === 'owner' && !status.progress.hasContracts) {
      // You could create a sample contract here if desired
    }

    // Optional: Schedule welcome email
    // await ctx.scheduler.runAfter(0, api.emails.sendWelcomeEmail, {
    //   userId: status.user.id,
    // });

    return { 
      success: true,
      redirectTo: '/dashboard', // Or wherever you want to send them
    };
  },
});

// ============================================================================
// UTILITIES
// ============================================================================

/**
 * Skip onboarding (for returning users or special cases)
 */
export const skipOnboarding = mutation({
  args: {
    reason: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) throw new ConvexError("User not found");

    const onboarding = await ctx.db
      .query("userOnboarding")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .first();

    if (onboarding) {
      await ctx.db.patch(onboarding._id, {
        skippedAt: new Date().toISOString(),
        skipReason: args.reason,
        completedAt: new Date().toISOString(),
      });
    } else {
      await ctx.db.insert("userOnboarding", {
        userId: user._id,
        enterpriseId: user.enterpriseId,
        currentStep: ONBOARDING_STEPS.COMPLETE,
        completedSteps: [],
        startedAt: new Date().toISOString(),
        completedAt: new Date().toISOString(),
        skippedAt: new Date().toISOString(),
        skipReason: args.reason,
        metadata: {},
      });
    }

    return { success: true };
  },
});

/**
 * Get onboarding analytics (for admins)
 */
export const getOnboardingAnalytics = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user || (user.role !== "owner" && user.role !== "admin")) {
      throw new ConvexError("Access denied");
    }

    const onboardings = await ctx.db
      .query("userOnboarding")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .collect();

    const analytics = {
      total: onboardings.length,
      completed: onboardings.filter(o => o.completedAt).length,
      inProgress: onboardings.filter(o => !o.completedAt && !o.skippedAt).length,
      skipped: onboardings.filter(o => o.skippedAt).length,
      averageCompletionTime: 0,
      stepCompletion: {} as Record<string, number>,
      dropoffPoints: {} as Record<string, number>,
    };

    // Calculate average completion time
    const completedWithTime = onboardings.filter(o => o.completedAt && o.startedAt);
    if (completedWithTime.length > 0) {
      const totalTime = completedWithTime.reduce((sum, o) => {
        const start = new Date(o.startedAt).getTime();
        const end = new Date(o.completedAt!).getTime();
        return sum + (end - start);
      }, 0);
      analytics.averageCompletionTime = totalTime / completedWithTime.length;
    }

    // Calculate step completion rates
    Object.values(ONBOARDING_STEPS).forEach(step => {
      const completed = onboardings.filter(o => 
        o.completedSteps?.includes(step)
      ).length;
      analytics.stepCompletion[step] = completed;
    });

    // Find dropout points
    const incomplete = onboardings.filter(o => !o.completedAt && !o.skippedAt);
    incomplete.forEach(o => {
      const lastStep = o.currentStep || 'unknown';
      analytics.dropoffPoints[lastStep] = (analytics.dropoffPoints[lastStep] || 0) + 1;
    });

    return analytics;
  },
});
</file>

<file path="src/app/_components/contracts/ContractDetails.tsx">
'use client';

import React from 'react';
import { useRouter } from 'next/navigation';
import { format } from 'date-fns';
import { useConvexQuery } from '@/lib/api-client';
import { api } from '../../../../convex/_generated/api';
import { Id } from '../../../../convex/_generated/dataModel';
import type { ContractStatus, AnalysisStatus, ContractTypeEnum } from '@/types/contract.types'; // Added ContractTypeEnum
import type { VendorCategory } from '@/types/vendor.types'; // Added VendorCategory for vendor display

// Clerk hook to get user information
import { useUser } from '@clerk/nextjs';

// UI Components
import { Card, CardContent, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Separator } from "@/components/ui/separator";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip"; // Added Tooltip

// Icons
import {
  Building,
  Calendar,
  Edit,
  FileText,
  Download,
  AlertCircle,
  Trash2,
  Archive,
  Info,
  ExternalLink,
  BarChart2,
  CreditCard, // PenTool was not used, CreditCard is used
  Users,
  Clock,
  FileBadge, // Using FileBadge for contract type
  Briefcase // Using Briefcase for vendor category
} from 'lucide-react';
import { cn } from '@/lib/utils';

interface ContractDetailsProps {
  contractId: Id<"contracts">;
  onEdit?: () => void;
  // enterpriseId should ideally be fetched within the component or passed if readily available higher up
}

// Contract status color mapper
const statusColors: Record<ContractStatus, string> = {
  draft: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300',
  pending_analysis: 'bg-yellow-100 text-yellow-800 dark:bg-yellow-900/70 dark:text-yellow-300',
  active: 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300',
  expired: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300',
  terminated: 'bg-orange-100 text-orange-800 dark:bg-orange-900/70 dark:text-orange-300',
  archived: 'bg-slate-100 text-slate-800 dark:bg-slate-700 dark:text-slate-300',
};

// Analysis status color mapper
const analysisColors: Record<AnalysisStatus, string> = {
  pending: 'bg-slate-100 text-slate-800 dark:bg-slate-700 dark:text-slate-300',
  processing: 'bg-blue-100 text-blue-800 dark:bg-blue-900/70 dark:text-blue-300',
  completed: 'bg-green-100 text-green-800 dark:bg-green-900/70 dark:text-green-300',
  failed: 'bg-red-100 text-red-800 dark:bg-red-900/70 dark:text-red-300',
};

// Contract type color mapper (example)
const contractTypeColors: Record<string, string> = {
    default: 'bg-purple-100 text-purple-800 dark:bg-purple-900/70 dark:text-purple-300',
    nda: 'bg-indigo-100 text-indigo-800 dark:bg-indigo-900/70 dark:text-indigo-300',
    msa: 'bg-sky-100 text-sky-800 dark:bg-sky-900/70 dark:text-sky-300',
    saas: 'bg-teal-100 text-teal-800 dark:bg-teal-900/70 dark:text-teal-300',
};

export const ContractDetails = ({ contractId, onEdit }: ContractDetailsProps) => {
  const router = useRouter();
  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();

  // --- Get enterpriseId from Clerk user's public metadata ---
  // Ensure this is correctly set in your Clerk dashboard for users.
  const enterpriseId = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;

  // Fetch contract data - now passing enterpriseId
  const { data: contract, isLoading: isLoadingContract, error: contractError } = useConvexQuery(
    api.contracts.getContractById,
    // Skip query if contractId or enterpriseId is not available yet
    (contractId && enterpriseId) ? { contractId, enterpriseId } : "skip"
  );

  // Fetch vendor data - now passing enterpriseId
  // The `getVendorById` query in `convex/vendors.ts` should also expect `enterpriseId`
  const { data: vendor, isLoading: isLoadingVendor } = useConvexQuery(
    api.vendors.getVendorById,
    (contract?.vendorId && enterpriseId) ? { vendorId: contract.vendorId, enterpriseId } : "skip"
  );

  const { data: fileUrl, isLoading: isLoadingFileUrl } = useConvexQuery(
    api.contracts.getContractFileUrl,
    contract?.storageId ? { storageId: contract.storageId } : "skip"
    // Consider adding enterpriseId to getContractFileUrl args if strict permission is needed for file URLs
  );

  const isLoading = isLoadingContract || isLoadingVendor || isLoadingFileUrl || !isClerkLoaded;

  const formatDate = (dateString?: string): string => {
    if (!dateString) return 'N/A';
    try {
      // Check if dateString is a valid ISO string or timestamp number
      const date = new Date(isNaN(Number(dateString)) ? dateString : Number(dateString));
      if (isNaN(date.getTime())) return dateString; // Return original if invalid
      return format(date, 'PPP'); // e.g., Jun 20, 2023
    } catch (e) {
      console.warn("Error formatting date:", dateString, e);
      return dateString; // Fallback to original string if formatting fails
    }
  };

  const handleEdit = () => {
    if (onEdit) {
      onEdit();
    } else {
      router.push(`/dashboard/contracts/edit/${contractId}`);
    }
  };

  const handleDownload = () => {
    if (fileUrl) {
      window.open(fileUrl, '_blank');
    }
  };

   if (isLoading) {
    return (
      <div className="p-8 flex justify-center items-center min-h-[300px]">
        <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"></div>
        <p className="ml-3 text-muted-foreground">Loading contract details...</p>
      </div>
    );
  }

  if (!enterpriseId && isClerkLoaded) {
    return (
      <Alert variant="destructive" className="mb-6">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Configuration Error</AlertTitle>
        <AlertDescription>
          Enterprise information is missing for your user account. Please contact support.
        </AlertDescription>
      </Alert>
    );
  }

  if (contractError || !contract) {
    return (
      <Alert variant="destructive" className="mb-6">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>
          {contractError ? `Failed to load contract: ${contractError.message}` : 'Contract not found or access denied.'}
        </AlertDescription>
      </Alert>
    );
  }

  // Use the vendor data directly from the contract object if it's already populated by getContractById
  const vendorInfo = contract.vendor || vendor || { name: 'Unknown Vendor', category: undefined };

  const statusColor = statusColors[contract.status as ContractStatus] || 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
  const analysisColor = contract.analysisStatus
    ? (analysisColors[contract.analysisStatus as AnalysisStatus] || 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300')
    : 'bg-gray-100 text-gray-800 dark:bg-gray-700 dark:text-gray-300';
  const currentContractTypeColor = contract.contractType
    ? (contractTypeColors[contract.contractType] || contractTypeColors.default)
    : contractTypeColors.default;


  const formatStatusLabel = (status?: string): string => {
    if (!status) return 'N/A';
    return status.replace(/_/g, ' ').replace(/\b\w/g, c => c.toUpperCase());
  };

  return (
    <TooltipProvider>
      <div className="space-y-6 p-1"> {/* Added p-1 for slight padding */}
        {/* Contract Header */}
        <Card className="border-border dark:border-border/50 bg-card shadow-sm">
          <CardHeader className="flex flex-col md:flex-row items-start justify-between gap-4">
            <div className="flex-grow">
              <div className="flex flex-wrap items-center gap-2 mb-2">
                <FileText className="h-7 w-7 text-primary mr-2 flex-shrink-0" />
                <CardTitle className="text-2xl font-serif text-primary dark:text-primary-foreground break-all">
                  {contract.title}
                </CardTitle>
                <Badge className={`${statusColor} font-medium`}>
                  {formatStatusLabel(contract.status)}
                </Badge>
                {contract.analysisStatus && (
                  <Badge className={`${analysisColor} font-medium`}>
                    Analysis: {formatStatusLabel(contract.analysisStatus)}
                  </Badge>
                )}
                 {contract.contractType && (
                  <Badge className={`${currentContractTypeColor} font-medium`}>
                    Type: {formatStatusLabel(contract.contractType)}
                  </Badge>
                )}
              </div>
              <p className="text-sm text-muted-foreground ml-9">
                File: {contract.fileName || 'N/A'} ({contract.fileType || 'N/A'})
              </p>
            </div>
            <div className="flex gap-2 flex-shrink-0 self-start md:self-center">
              {fileUrl && (
                <Button variant="outline" size="sm" onClick={handleDownload}>
                  <Download className="h-4 w-4 md:mr-2" /> <span className="hidden md:inline">Document</span>
                </Button>
              )}
              <Button variant="default" size="sm" onClick={handleEdit}> {/* Changed to default */}
                <Edit className="h-4 w-4 md:mr-2" /> <span className="hidden md:inline">Edit</span>
              </Button>
            </div>
          </CardHeader>
        </Card>

        {/* Contract Details Grid */}
        <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
          {/* Main Contract Information (Spans 2 cols on lg) */}
          <Card className="border-border dark:border-border/50 bg-card shadow-sm lg:col-span-2">
            <CardHeader>
              <CardTitle className="text-lg font-medium text-primary dark:text-primary-foreground">
                <Info className="inline h-5 w-5 mr-2" />
                Contract Details
              </CardTitle>
            </CardHeader>
            <CardContent className="space-y-5">
              {/* Section for Key Dates & Financials */}
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                <DetailItem icon={Calendar} label="Start Date" value={formatDate(contract.extractedStartDate)} />
                <DetailItem icon={Calendar} label="End Date" value={formatDate(contract.extractedEndDate)} />
                <DetailItem icon={CreditCard} label="Pricing / Value" value={contract.extractedPricing || 'N/A'} />
                <DetailItem icon={Clock} label="Payment Schedule" value={contract.extractedPaymentSchedule || 'N/A'} />
              </div>
              <Separator />
               {/* Contract Type and Analysis */}
              <div className="grid grid-cols-1 sm:grid-cols-2 gap-x-6 gap-y-5">
                <DetailItem icon={FileBadge} label="Contract Type" value={contract.contractType ? formatStatusLabel(contract.contractType) : 'N/A'} />
                <DetailItem icon={BarChart2} label="Analysis Status" value={contract.analysisStatus ? formatStatusLabel(contract.analysisStatus) : 'N/A'} />
                {contract.analysisStatus === 'failed' && contract.analysisError && (
                    <div className="sm:col-span-2">
                        <DetailItem icon={AlertCircle} label="Analysis Error" value={contract.analysisError} valueClassName="text-red-600 dark:text-red-400" />
                    </div>
                )}
              </div>

              {contract.extractedParties && contract.extractedParties.length > 0 && (
                <>
                  <Separator />
                  <div>
                    <DetailItem icon={Users} label="Parties Involved" />
                    <ul className="mt-1 space-y-1 pl-8">
                      {contract.extractedParties.map((party:any, index:number) => (
                        <li key={index} className="text-sm text-muted-foreground list-disc list-inside">
                          {party}
                        </li>
                      ))}
                    </ul>
                  </div>
                </>
              )}

              {contract.extractedScope && (
                <>
                  <Separator />
                  <div>
                    <DetailItem icon={FileText} label="Scope of Work" />
                    <p className="mt-1 text-sm text-muted-foreground whitespace-pre-line pl-8">
                      {contract.extractedScope}
                    </p>
                  </div>
                </>
              )}

              {contract.notes && (
                <>
                  <Separator />
                  <div>
                    <DetailItem icon={Edit} label="Internal Notes" />
                    <p className="mt-1 text-sm text-muted-foreground whitespace-pre-line pl-8">
                      {contract.notes}
                    </p>
                  </div>
                </>
              )}
            </CardContent>
          </Card>

          {/* Sidebar Information (Vendor & System Info) */}
          <div className="space-y-6">
            <Card className="border-border dark:border-border/50 bg-card shadow-sm h-fit">
              <CardHeader>
                <CardTitle className="text-lg font-medium text-primary dark:text-primary-foreground">
                  <Building className="inline h-5 w-5 mr-2" />
                  Vendor Information
                </CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <DetailItem label="Name" value={vendorInfo.name} />
                {vendorInfo.category && (
                  <DetailItem icon={Briefcase} label="Category" value={formatStatusLabel(vendorInfo.category)} />
                )}
                {vendorInfo.contactEmail && (
                    <DetailItem label="Email" value={vendorInfo.contactEmail} isLink={`mailto:${vendorInfo.contactEmail}`} />
                )}
                {vendorInfo.contactPhone && (
                  <DetailItem label="Phone" value={vendorInfo.contactPhone} />
                )}
                {vendorInfo.website && (
                  <DetailItem label="Website" value={vendorInfo.website} isLink={vendorInfo.website.startsWith('http') ? vendorInfo.website : `https://${vendorInfo.website}`} />
                )}
              </CardContent>
            </Card>

            <Card className="border-border dark:border-border/50 bg-card shadow-sm h-fit">
                <CardHeader>
                    <CardTitle className="text-lg font-medium text-primary dark:text-primary-foreground">
                        <Info className="inline h-5 w-5 mr-2" />
                        System Information
                    </CardTitle>
                </CardHeader>
                <CardContent className="space-y-4">
                    <DetailItem icon={Calendar} label="Date Created" value={formatDate(contract._creationTime?.toString())} />
                    <DetailItem icon={FileText} label="File Name" value={contract.fileName || "N/A"} />
                    <DetailItem icon={FileBadge} label="File Type" value={contract.fileType || "N/A"} />
                    <DetailItem icon={Edit} label="Contract ID" value={contract._id} isMonospace={true} />
                    <DetailItem icon={Edit} label="Storage ID" value={contract.storageId} isMonospace={true}/>
                </CardContent>
            </Card>
          </div>
        </div>

        {/* Contract Actions - simplified, can be expanded */}
        <Card className="border-border dark:border-border/50 bg-card shadow-sm">
          <CardHeader>
            <CardTitle className="text-lg font-medium text-primary dark:text-primary-foreground">Contract Actions</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="flex flex-wrap gap-3">
              {/* Add other actions like archive, terminate, delete etc. based on backend capabilities */}
               <Button variant="outline" size="sm" disabled>
                <Archive className="h-4 w-4 mr-2" /> Archive (Coming Soon)
              </Button>
              <Button variant="outline" size="sm" className="text-destructive hover:bg-destructive/10 hover:text-destructive-foreground" disabled>
                <Trash2 className="h-4 w-4 mr-2" /> Delete (Coming Soon)
              </Button>
            </div>
          </CardContent>
        </Card>
      </div>
    </TooltipProvider>
  );
};

// Helper component for detail items
const DetailItem = ({ icon: Icon, label, value, isLink, isMonospace, valueClassName }: { icon?: React.ElementType, label: string, value?: string | number | null, isLink?: string, isMonospace?: boolean, valueClassName?: string}) => (
    <div>
        <p className="text-sm font-medium text-foreground dark:text-gray-300 flex items-center">
            {Icon && <Icon className="h-4 w-4 text-muted-foreground mr-2 flex-shrink-0" />}
            {label}
        </p>
        {value && (
            isLink ? (
                <a
                    href={isLink}
                    target="_blank"
                    rel="noopener noreferrer"
                    className={cn("text-sm text-primary hover:underline dark:text-blue-400 break-all", valueClassName)}
                >
                    {value} <ExternalLink className="inline h-3 w-3 ml-1" />
                </a>
            ) : (
                <p className={cn("text-sm text-muted-foreground dark:text-gray-400 break-all", isMonospace && "font-mono text-xs", valueClassName)}>
                    {value}
                </p>
            )
        )}
         {!value && <p className="text-sm text-muted-foreground dark:text-gray-500">N/A</p>}
    </div>
);

export default ContractDetails;
</file>

<file path="src/app/_components/dashboard/Header.tsx">
import React from "react";
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { Menu } from "lucide-react";
import { GlobalSearch } from "./GlobalSearch";
import { Avatar, AvatarFallback, AvatarImage } from "@/components/ui/avatar";
import { useClerk, useUser } from "@clerk/nextjs";
import { useRouter } from "next/navigation";
import {
  DropdownMenu,
  DropdownMenuContent,
  DropdownMenuItem,
  DropdownMenuLabel,
  DropdownMenuSeparator,
  DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Logo } from "@/app/_components/common/Logo"

interface HeaderProps {
  isSearchOpen: boolean;
  onSearchOpen: () => void;
  onSearchClose: () => void;
  enterpriseName?: string;
  userName?: string;
}

const MobileNavigation = () => {
  const navigationLinks = [
    { label: "Dashboard", href: "/dashboard" },
    { label: "Contracts", href: "/contracts" },
    { label: "Vendors", href: "/vendors" },
    { label: "Analytics", href: "/analytics" },
    { label: "Settings", href: "/settings" },
  ];

  return (
    <nav className="flex flex-col space-y-1 mt-2">
      {navigationLinks.map((link) => (
        <Button
          key={link.label}
          variant="ghost"
          className="justify-start w-full text-primary hover:bg-primary/5 hover:text-primary/90 px-4"
          onClick={() => (window.location.href = link.href)}
        >
          {link.label}
        </Button>
      ))}
    </nav>
  );
};

const UserMenu = () => {
  const { user } = useUser();
  const { signOut } = useClerk();
  const router = useRouter();
  
  const userName = user?.firstName || "User";
  
  return (
    <DropdownMenu>
      <DropdownMenuTrigger asChild>
        <Button variant="ghost" className="h-9 w-9 rounded-full p-0 hover:bg-primary/5">
          <Avatar className="h-8 w-8 border border-gold/20 cursor-pointer">
            <AvatarImage src={user?.imageUrl || ""} alt={userName} />
            <AvatarFallback className="bg-primary/5 text-primary font-medium">{userName.charAt(0)}</AvatarFallback>
          </Avatar>
        </Button>
      </DropdownMenuTrigger>
      <DropdownMenuContent align="end" className="w-56 bg-white dark:bg-card border border-border shadow-md" sideOffset={5}>
        <DropdownMenuLabel className="cursor-pointer font-normal bg-white dark:bg-card">
          <div className="flex flex-col space-y-1">
            <p className="font-medium text-primary">{userName}</p>
            <p className="text-xs text-muted-foreground">Enterprise Admin</p>
          </div>
        </DropdownMenuLabel>
        <DropdownMenuSeparator className="bg-border/50" />
        <DropdownMenuItem className="cursor-pointer focus:bg-primary/5 bg-white dark:bg-card hover:bg-muted" onClick={() => router.push('/profile')}>Profile</DropdownMenuItem>
        <DropdownMenuItem className="cursor-pointer focus:bg-primary/5 bg-white dark:bg-card hover:bg-muted" onClick={() => router.push('/settings')}>Settings</DropdownMenuItem>
        <DropdownMenuSeparator className="bg-border/50" />
        <DropdownMenuItem 
          className="text-red-600 focus:bg-red-50 focus:text-red-600 cursor-pointer bg-white dark:bg-card hover:bg-red-50"
          onClick={() => signOut(() => router.push('/'))}
        >
          Log out
        </DropdownMenuItem>
      </DropdownMenuContent>
    </DropdownMenu>
  );
};

export const Header: React.FC<HeaderProps> = ({
  isSearchOpen,
  onSearchOpen,
  onSearchClose,
}) => {
  const { user } = useUser();
  const userName = user?.firstName ? `${user.firstName} ${user.lastName || ''}` : "User";


  return (
    <header className="h-16 border-b border-border/50 bg-white dark:bg-card px-4 md:px-6 flex items-center justify-between sticky top-0 z-10 shadow-sm">
      {/* Mobile Navigation Trigger & Logo */}
      <div className="flex items-center gap-4">
        <Sheet>
          <SheetTrigger asChild>
            <Button variant="ghost" size="icon" className="md:hidden text-primary hover:bg-primary/5">
              <Menu className="h-5 w-5" />
            </Button>
          </SheetTrigger>
          <SheetContent side="left" className="w-64 border-r border-border/50">
            <div className="mb-4 mt-2 px-2">
              <Logo size="sm" />
            </div>
            <MobileNavigation />
          </SheetContent>
        </Sheet>

        {/* Enterprise Logo/Name for Desktop */}
        <div className="hidden md:block">
          <Logo size="md" />
        </div>
      </div>

      {/* Global Search */}
      <div className="flex-1 max-w-2xl mx-4">
        <GlobalSearch
          isOpen={isSearchOpen}
          onOpen={onSearchOpen}
          onClose={onSearchClose}
        />
      </div>

      {/* Right Section: User Menu */}
      <div className="flex items-center gap-3">
        <div className="hidden md:block text-right mr-1">
          <p className="text-sm font-medium text-primary">{userName}</p>
          <p className="text-xs text-muted-foreground">USER ROLE WILL BE HERE FOR LATER</p>
        </div>
        <UserMenu />
      </div>
    </header>
  );
};
</file>

<file path="src/app/_components/dashboard/SideNavigation.tsx">
'use client'

import React, { useCallback } from "react";
import { useRouter } from "next/navigation";
import { Button } from "@/components/ui/button";
import { ScrollArea } from "@/components/ui/scroll-area";
import { Separator } from "@/components/ui/separator";
import { cn } from "@/lib/utils";
import {
  Home,
  Files,
  Building2,
  BarChart3,
  Settings,
  FileText,
  FileSignature,
  Clock,
  ChevronDown,
  Users,
} from "lucide-react";
import { useDashboardStore } from "@/stores/dashboard-store"
import type { NavSection } from "@/types/homedashboard.types"

const NavItem = React.memo(
  ({
    item,
    isActive,
    isExpanded,
    onExpand,
    onClick,
  }: {
    item: NavSection["items"][0];
    isActive: boolean;
    isExpanded: boolean;
    onExpand: () => void;
    onClick: (href: string, label: string) => void;
  }) => {
    const { setSelectedType } = useDashboardStore();
    

    const handleClick = useCallback(() => {
      if (item.subItems) {
        onExpand();
      } else {
        setSelectedType(item.label);
        onClick(item.href, item.label);
      }
    }, [item, onExpand, onClick, setSelectedType]);

    return (
      <div className="space-y-1">
        <Button
          variant={isActive ? "secondary" : "ghost"}
          className={cn("w-full justify-start", isActive && "bg-muted", "cursor-pointer")}
          onClick={handleClick}
        >
          <item.icon className="mr-2 h-4 w-4 text-gold" />
          <span className="flex-1 text-left">{item.label}</span>
          {item.subItems && (
            <ChevronDown
              className={cn(
                "h-4 w-4 transition-transform",
                isExpanded && "rotate-180"
              )}
            />
          )}
        </Button>

        {isExpanded && item.subItems && (
          <div className="ml-6 space-y-1">
            {item.subItems.map((subItem) => (
              <Button
                key={subItem.href}
                variant="ghost"
                className={cn(
                  "w-full justify-start h-9 cursor-pointer",
                  location.pathname === subItem.href && "bg-muted" // This line changes
                )}
                onClick={() => onClick(subItem.href, subItem.label)}
              >
                <subItem.icon className="mr-2 h-4 w-4 text-muted-foreground" />
                <span className="text-sm">{subItem.label}</span>
              </Button>
            ))}
          </div>
        )}
      </div>
    );
  }
);

export const SideNavigation = ({ className }: { className?: string }) => {
 
  const router = useRouter();

  const { expandedItems, setExpandedItems, setSelectedType } =
    useDashboardStore();

  const navigationSections: NavSection[] = [
    {
      items: [
        {
          label: "Dashboard",
          href: "/dashboard",
          icon: Home,
        },
      ],
    },
    {
      label: "Contract Management",
      items: [
        {
          label: "Contracts",
          icon: Files,
          href: "/dashboard/contracts",
          subItems: [
            {
              label: "All Contracts",
              href: "/dashboard/contracts",
              icon: FileText,
            },
            {
              label: "Pending Signature",
              href: "/dashboard/contracts/pending",
              icon: FileSignature,
            },
            {
              label: "Drafts",
              href: "/dashboard/contracts/drafts",
              icon: Clock,
            },
            {
              label: "Expired",
              href: "/dashboard/contracts/expired",
              icon: Clock,
            },
            {
              label: "Archived",
              href: "/dashboard/contracts/archived",
              icon: Clock,
            },
          ],
        },
        {
          label: "Vendors",
          href: "/dashboard/vendors",
          icon: Building2,
          subItems: [
            {
              label: "All Vendors",
              href: "/dashboard/vendors",
              icon: Building2,
            },
            {
              label: "Active Vendors",
              href: "/dashboard/vendors/active",
              icon: Users,
            },
            {
              label: "Inactive Vendors",
              href: "/dashboard/vendors/inactive",
              icon: Users,
            },
          ],
        },
      ],
    },
    {
      label: "Analytics & Settings",
      items: [
        {
          label: "Analytics",
          href: "/dashboard/analytics",
          icon: BarChart3,
        },
        {
          label: "Settings",
          href: "/dashboard/settings",
          icon: Settings,
        },
      ],
    },
  ];

  const toggleExpanded = useCallback(
    (label: string) => {
      setExpandedItems((prev: string[]) =>
        prev.includes(label)
          ? prev.filter((item: string) => item !== label)
          : [...prev, label]
      );
    },
    [setExpandedItems]
  );

  const handleNavigate = useCallback(
    (href: string, label: string) => {
      router.push(href);
      setSelectedType(label);
    },
    [ setSelectedType]
  );

  const isItemActive = useCallback(
    (href: string, subItems?: NavSection["items"][0]["subItems"]) => {
      // If this item has subitems and matches the base path
      if (subItems && location.pathname.startsWith(href)) {
        // Check if we're on the exact base path
        if (location.pathname === href) {
          return true;
        }
        // Check if any subitem paths match
        return subItems.some((subItem: { href: string }) =>
          location.pathname.startsWith(subItem.href)
        );
      }
      // Regular path matching for items without subitems
      return (
        location.pathname === href || location.pathname.startsWith(`${href}/`)
      );
    },
    [location]
  );

  return (
    <aside className={cn("flex flex-col border-r bg-card", className)}>
      

      <ScrollArea className="flex-1">
        <div className="space-y-6 p-4">
          {navigationSections.map((section, idx) => (
            <div key={idx}>
              {section.label && (
                <>
                  <div className="flex items-center px-2">
                    <span className="text-xs font-medium text-muted-foreground">
                      {section.label}
                    </span>
                    <Separator className="ml-2 flex-1" />
                  </div>
                  <div className="mt-2" />
                </>
              )}
              <div className="space-y-1">
                {section.items.map((item) => (
                  <NavItem
                    key={item.href}
                    item={item}
                    isActive={isItemActive(item.href, item.subItems)}
                    isExpanded={expandedItems.includes(item.label)}
                    onExpand={() => toggleExpanded(item.label)}
                    onClick={handleNavigate}
                  />
                ))}
              </div>
            </div>
          ))}
        </div>
      </ScrollArea>
    </aside>
  );
};

export default SideNavigation;
</file>

<file path="src/app/dashboard/agents/page.tsx">
'use client';

import React, { useState } from "react";
import { useConvexQuery, useConvexMutation } from "@/lib/api-client";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Bot,
  AlertCircle,
  Loader2,
  Brain,
  Activity,
  FileText,
} from "lucide-react";
import { Agent } from "@/types/agents.types";
import AgentSystemStatus from "@/app/_components/agents/AgentSystemStatus";
import AgentCard from "@/app/_components/agents/AgentCard";
import InsightCard from "@/app/_components/agents/InsightCard";
import AgentLogViewer from "@/app/_components/agents/AgentLogViewer";

const AgentDashboard = () => {
  const [message, setMessage] = useState<{ type: 'success' | 'error'; text: string } | null>(null);

  // Fetch agent system status
  const { data: systemStatus, isLoading, error } = useConvexQuery(
    api.agents.manager.getAgentSystemStatus,
    {}
  );

  // Fetch recent insights
  const { data: recentInsights } = useConvexQuery(
    api.agents.manager.getRecentInsights,
    { limit: 5 }
  );

  // Fetch recent logs
  const { data: recentLogs } = useConvexQuery(
    api.agents.manager.getAgentLogs,
    { limit: 10 }
  );

  // Mutations
  const initializeSystem = useConvexMutation(api.agents.manager.initializeAgentSystem);
  const startSystem = useConvexMutation(api.agents.manager.startAgentSystem);
  const stopSystem = useConvexMutation(api.agents.manager.stopAgentSystem);
  const toggleAgent = useConvexMutation(api.agents.manager.toggleAgent);
  const createTestInsight = useConvexMutation(api.agents.manager.createTestInsight);
  const markInsightAsRead = useConvexMutation(api.agents.manager.markInsightAsRead);

  const handleInitialize = async () => {
    setMessage(null);
    try {
      const result = await initializeSystem.execute({});
      if (result?.success) {
        setMessage({ type: 'success', text: result.message });
      }
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to initialize' });
    }
  };

  const handleStartSystem = async () => {
    try {
      const result = await startSystem.execute({});
      if (result?.success) {
        setMessage({ type: 'success', text: result.message });
      }
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to start system' });
    }
  };

  const handleStopSystem = async () => {
    try {
      const result = await stopSystem.execute({});
      if (result?.success) {
        setMessage({ type: 'success', text: result.message });
      }
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to stop system' });
    }
  };

  const handleToggleAgent = async (agentId: string, enabled: boolean) => {
    try {
      await toggleAgent.execute({ agentId: agentId as any, enabled });
      setMessage({ type: 'success', text: `Agent ${enabled ? 'enabled' : 'disabled'} successfully` });
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to toggle agent' });
    }
  };

  const handleCreateTestInsight = async () => {
    try {
      await createTestInsight.execute({});
      setMessage({ type: 'success', text: 'Test insight created successfully' });
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to create test insight' });
    }
  };

  const handleMarkAsRead = async (insightId: string) => {
    try {
      await markInsightAsRead.execute({ insightId: insightId as any });
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to mark insight as read' });
    }
  };

  const handleRefreshStatus = () => {
    // Trigger a re-fetch of the system status
    window.location.reload();
  };

  const handleCreateTestInsight = async () => {
    try {
      await createTestInsight.execute({});
      setMessage({ type: 'success', text: 'Test insight created successfully' });
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to create test insight' });
    }
  };

  const handleMarkAsRead = async (insightId: string) => {
    try {
      await markInsightAsRead.execute({ insightId: insightId as any });
    } catch (err: any) {
      setMessage({ type: 'error', text: err.message || 'Failed to mark insight as read' });
    }
  };

  const handleExportLogs = () => {
    // Export logs functionality
    setMessage({ type: 'success', text: 'Log export feature coming soon' });
  };

  if (isLoading) {
    return (
      <div className="flex items-center justify-center p-8">
        <Loader2 className="h-8 w-8 animate-spin" />
        <p className="ml-2">Loading agent system...</p>
      </div>
    );
  }

  if (error) {
    return (
      <Alert variant="destructive">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Error</AlertTitle>
        <AlertDescription>{error.message}</AlertDescription>
      </Alert>
    );
  }

  return (
    <div className="space-y-6 p-6">
      {/* Header */}
      <div className="flex items-center space-x-3">
        <Bot className="h-8 w-8 text-primary" />
        <h1 className="text-3xl font-bold">AI Agent Management</h1>
      </div>

      {/* Message Display */}
      {message && (
        <Alert variant={message.type === 'error' ? 'destructive' : 'default'}>
          <AlertCircle className="h-4 w-4" />
          <AlertTitle>{message.type === 'error' ? 'Error' : 'Success'}</AlertTitle>
          <AlertDescription>{message.text}</AlertDescription>
        </Alert>
      )}

      {/* System Status */}
      <AgentSystemStatus
        systemStatus={systemStatus}
        onStartSystem={handleStartSystem}
        onStopSystem={handleStopSystem}
        onInitializeSystem={handleInitialize}
        onRefreshStatus={handleRefreshStatus}
        loading={isLoading}
        startLoading={startSystem.isLoading}
        stopLoading={stopSystem.isLoading}
        initLoading={initializeSystem.isLoading}
      />

      {/* Tabs for different views */}
      <Tabs defaultValue="overview" className="w-full">
        <TabsList className="grid w-full grid-cols-4">
          <TabsTrigger value="overview" className="flex items-center space-x-2">
            <Activity className="h-4 w-4" />
            <span>Overview</span>
          </TabsTrigger>
          <TabsTrigger value="agents" className="flex items-center space-x-2">
            <Bot className="h-4 w-4" />
            <span>Agents</span>
          </TabsTrigger>
          <TabsTrigger value="insights" className="flex items-center space-x-2">
            <Brain className="h-4 w-4" />
            <span>Insights</span>
          </TabsTrigger>
          <TabsTrigger value="logs" className="flex items-center space-x-2">
            <FileText className="h-4 w-4" />
            <span>Logs</span>
          </TabsTrigger>
        </TabsList>

        {/* Overview Tab */}
        <TabsContent value="overview" className="space-y-6">
          <div className="grid grid-cols-1 lg:grid-cols-2 gap-6">
            {/* Recent Agents */}
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Recent Agent Activity</h3>
              {systemStatus?.agents && systemStatus.agents.length > 0 ? (
                <div className="space-y-3">
                  {systemStatus.agents.slice(0, 3).map((agent: Agent) => (
                    <AgentCard
                      key={agent._id}
                      agent={agent}
                      onToggleAgent={handleToggleAgent}
                      loading={toggleAgent.isLoading}
                    />
                  ))}
                </div>
              ) : (
                <p className="text-muted-foreground">No agents available</p>
              )}
            </div>

            {/* Recent Insights */}
            <div className="space-y-4">
              <h3 className="text-lg font-semibold">Latest Insights</h3>
              {recentInsights && recentInsights.length > 0 ? (
                <div className="space-y-3">
                  {recentInsights.slice(0, 3).map((insight: any) => (
                    <InsightCard
                      key={insight._id}
                      insight={insight}
                      onMarkAsRead={handleMarkAsRead}
                      loading={markInsightAsRead.isLoading}
                    />
                  ))}
                </div>
              ) : (
                <p className="text-muted-foreground">No insights generated yet</p>
              )}
            </div>
          </div>
        </TabsContent>

        {/* Agents Tab */}
        <TabsContent value="agents" className="space-y-4">
          <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
            {systemStatus?.agents && systemStatus.agents.length > 0 ? (
              systemStatus.agents.map((agent: Agent) => (
                <AgentCard
                  key={agent._id}
                  agent={agent}
                  onToggleAgent={handleToggleAgent}
                  loading={toggleAgent.isLoading}
                />
              ))
            ) : (
              <div className="col-span-full text-center py-12">
                <Bot className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
                <p className="text-muted-foreground">No agents found. Initialize the system to get started.</p>
              </div>
            )}
          </div>
        </TabsContent>

        {/* Insights Tab */}
        <TabsContent value="insights" className="space-y-4">
          {recentInsights && recentInsights.length > 0 ? (
            <div className="space-y-4">
              {recentInsights.map((insight: any) => (
                <InsightCard
                  key={insight._id}
                  insight={insight}
                  onMarkAsRead={handleMarkAsRead}
                  loading={markInsightAsRead.isLoading}
                />
              ))}
            </div>
          ) : (
            <div className="text-center py-12">
              <Brain className="h-12 w-12 text-muted-foreground mx-auto mb-4" />
              <p className="text-muted-foreground">No insights generated yet.</p>
              <p className="text-sm text-muted-foreground mt-2">
                Insights will appear here once the agent system is running.
              </p>
            </div>
          )}
        </TabsContent>

        {/* Logs Tab */}
        <TabsContent value="logs">
          <AgentLogViewer
            logs={recentLogs || []}
            onRefresh={handleRefreshStatus}
            onExportLogs={handleExportLogs}
            loading={isLoading}
          />
        </TabsContent>
      </Tabs>
    </div>
  );
};

export default AgentDashboard;
</file>

<file path="src/app/dashboard/analytics/page.tsx">
'use client'

import React from "react";
import dynamic from "next/dynamic";
import LoadingSpinner from "@/app/_components/common/LoadingSpinner";

const AnalyticsDashboard = dynamic(
  () => import("@/app/_components/analytics/AnalyticsDashboard"),
  {
    loading: () => <LoadingSpinner />,
    ssr: false
  }
);

const Analytics = () => {
  return (
    <div className="p-6">
      <AnalyticsDashboard />
    </div>
  );
};

export default Analytics;
</file>

<file path="src/app/dashboard/layout.tsx">
'use client'

import React, { useState } from "react";
import { Header } from "@/app/_components/dashboard/Header";
import { SideNavigation } from "@/app/_components/dashboard/SideNavigation";
import { useAuth, RedirectToSignIn } from "@clerk/nextjs";

interface DashboardLayoutProps {
  children?: React.ReactNode;
}

export const DashboardLayout: React.FC<DashboardLayoutProps> = ({
  children,
}) => {
  const [isSearchOpen, setIsSearchOpen] = useState(false);
  const { isSignedIn, isLoaded } = useAuth();
  
  // Show loading state while checking auth
  if (!isLoaded) {
    return <div className="flex h-screen items-center justify-center">Loading...</div>;
  }
  
  // Redirect to sign in if not authenticated
  if (!isSignedIn) {
    return <RedirectToSignIn />;
  }

  return (
    <div className="flex h-screen bg-background">
      <SideNavigation className="hidden md:flex w-64" />
      <div className="flex-1 flex flex-col">
        <Header
          isSearchOpen={isSearchOpen}
          onSearchOpen={() => setIsSearchOpen(true)}
          onSearchClose={() => setIsSearchOpen(false)}
        />
        <main className="flex-1 overflow-auto p-6">{children}</main>
      </div>
    </div>
  );
};

export default DashboardLayout;
</file>

<file path="src/stores/contract-store.ts">
import { create } from "zustand";
import { devtools } from "zustand/middleware";
import { ContractType } from "@/types/contract.types";

interface ContractModalState {
  // Modal state
  isModalOpen: boolean;
  openModal: () => void;
  closeModal: () => void;
  
  // Vendor verification state
  vendorName: string;
  vendorExists: boolean | null;
  vendorSearchPerformed: boolean;
  setVendorName: (name: string) => void;
  checkVendorExists: () => void;
  
  // Vendor creation dialog
  showVendorDialog: boolean;
  openVendorDialog: () => void;
  closeVendorDialog: () => void;
  createVendor: () => void;
  
  // Form data
  startDate: Date | null;
  endDate: Date | null;
  setStartDate: (date: Date | null) => void;
  setEndDate: (date: Date | null) => void;
  
  formData: {
    contractName: string;
    contractType: string;
    contractValue: string;
    contractCategory: string;
    contractOwner: string;
    contractDescription: string;
  };
  
  // Form operations
  updateFormData: (field: string, value: string) => void;
  isSubmitting: boolean;
  isFormValid: () => boolean;
  submitContract: () => Promise<any>;
  
  // Search functionality
  searchQuery: string;
  setSearchQuery: (query: string) => void;
  getFilteredContracts: () => ContractType[];
}

interface ContractStoreState extends ContractModalState {
  // Original contract store state
  contracts: ContractType[];
  loading: boolean;
  error: string | null;

  // Contract CRUD operations
  setContracts: (contracts: ContractType[]) => void;
  addContract: (contract: ContractType) => void;
  updateContract: (id: number, contract: Partial<ContractType>) => void;
  deleteContract: (id: number) => void;
  fetchMoreContracts: (page: number) => Promise<void>;

  // Loading and error states
  setLoading: (loading: boolean) => void;
  setError: (error: string | null) => void;
}

const useContractStore = create<ContractStoreState>()(
  devtools(
    (set, get) => ({
      // Initial state from original contract store
      contracts: [],
      loading: false,
      error: null,

      // Core actions from original store
      setContracts: (contracts) => set({ contracts }),
      setLoading: (loading) => set({ loading }),
      setError: (error) => set({ error }),

      // CRUD operations from original store
      addContract: (contract) => {
        set((state) => ({
          contracts: [...state.contracts, contract],
        }));
      },

      updateContract: (id, updatedContract) => {
        set((state) => ({
          contracts: state.contracts.map((contract) =>
            contract.id === id ? { ...contract, ...updatedContract } : contract
          ),
        }));
      },

      deleteContract: (id) => {
        set((state) => ({
          contracts: state.contracts.filter((contract) => contract.id !== id),
        }));
      },

      fetchMoreContracts: async (page: number) => {
        try {
          set({ loading: true });
          const response = await fetch(`/api/contracts?page=${page}`);
          const newContracts = await response.json();
          set((state) => ({
            contracts: [...state.contracts, ...newContracts],
            loading: false,
          }));
        } catch (error) {
          set({ error: (error as Error).message, loading: false });
        }
      },

      // Modal state from new implementation
      isModalOpen: false,
      openModal: () => set({ isModalOpen: true }),
      closeModal: () => {
        // Reset form data when closing modal
        set({
          isModalOpen: false,
          vendorName: "",
          vendorExists: null,
          vendorSearchPerformed: false,
          startDate: null,
          endDate: null,
          formData: {
            contractName: "",
            contractType: "",
            contractValue: "",
            contractCategory: "",
            contractOwner: "",
            contractDescription: "",
          },
        });
      },
      
      // Vendor verification state
      vendorName: "",
      vendorExists: null,
      vendorSearchPerformed: false,
      setVendorName: (name) => set({ vendorName: name }),
      
      // Check if vendor exists (simulated API call)
      checkVendorExists: () => {
        const vendorName = get().vendorName;
        if (!vendorName.trim()) return;
        
        set({ vendorSearchPerformed: true });
        
        // In a real app, this would be an API call to check the vendor
        setTimeout(() => {
          // Simulate vendor check - in this case we'll say a vendor named "Acme" exists
          const exists = vendorName.toLowerCase() === "acme";
          set({ vendorExists: exists });
        }, 600);
      },
      
      // Vendor creation dialog
      showVendorDialog: false,
      openVendorDialog: () => set({ showVendorDialog: true }),
      closeVendorDialog: () => set({ showVendorDialog: false }),
      
      // Handle create vendor action
      createVendor: () => {
        // In a real app, this would make an API call to create the vendor
        set({ 
          showVendorDialog: false,
          vendorExists: true 
        });
      },
      
      // Form data
      startDate: null,
      endDate: null,
      setStartDate: (date) => set({ startDate: date }),
      setEndDate: (date) => set({ endDate: date }),
      
      formData: {
        contractName: "",
        contractType: "",
        contractValue: "",
        contractCategory: "",
        contractOwner: "",
        contractDescription: "",
      },
      
      // Update form data
      updateFormData: (field, value) => {
        set((state) => ({
          formData: {
            ...state.formData,
            [field]: value
          }
        }));
      },
      
      // Form submission
      isSubmitting: false,
      
      // Check if form is valid
      isFormValid: () => {
        const state = get();
        return (
          state.vendorExists && 
          state.formData.contractName && 
          state.formData.contractType && 
          state.formData.contractValue && 
          state.formData.contractCategory && 
          state.formData.contractOwner && 
          state.startDate && 
          state.endDate
        );
      },
      
      // Submit contract
      submitContract: async () => {
        const state = get();
        if (!state.isFormValid()) return;
        
        set({ isSubmitting: true });
        
        try {
          // Generate a random contract number
          const contractNumber = `CNT-${new Date().getFullYear()}-${Math.floor(Math.random() * 10000).toString().padStart(4, '0')}`;
          
          // Format dates consistently
          const formatDate = (date: Date | null): string => {
            return date ? date.toISOString() : new Date().toISOString();
          };
          
          // Convert form data to the specific ContractType format
          const contractData: ContractType = {
            id: Math.floor(Math.random() * 10000), // Temporary ID (server would generate real one)
            title: state.formData.contractName,
            type: state.formData.contractType,
            contract_number: contractNumber,
            status: "draft", // Initial status
            value: parseFloat(state.formData.contractValue) || 0,
            created_at: new Date().toISOString(),
            start_date: formatDate(state.startDate),
            expires_at: formatDate(state.endDate),
            updated_at: new Date().toISOString(),
            assignee: state.formData.contractOwner, // Assuming owner and assignee are the same initially
            description: state.formData.contractDescription,
            is_renewable:  true, // Default value of true
            auto_renewal: true, // Default value since autoRenewal doesn't exist in formData
            archived_at: "",
            signature_due_date: new Date(Date.now() + 14 * 24 * 60 * 60 * 1000), // Default 14 days
            sent_for_signature_at: new Date(),
            awaiting_counterparty: true,
            pending_signers: [], // Default empty array since pendingSigners doesn't exist in formData
            vendor: {
              id: 1, // This would come from your vendor selection/lookup
              name: state.vendorName,
              location: "Unknown", // This would come from vendor data
              email: "vendor@example.com", // This would come from vendor data
              rating: 0, // Default value
              tier: "Standard" // Default value
            },
            owner: state.formData.contractOwner
          };
          
          // In a real app, this would be an API call
          // const response = await fetch('/api/contracts', {
          //   method: 'POST',
          //   headers: { 'Content-Type': 'application/json' },
          //   body: JSON.stringify(contractData)
          // });
          // const savedContract = await response.json();
          
          // Simulate API delay
          await new Promise(resolve => setTimeout(resolve, 1000));
          
          // Add the contract to state
          get().addContract(contractData);
          
          // Reset submission state and close modal
          set({ isSubmitting: false });
          get().closeModal();
          
          return contractData;
        } catch (error) {
          // Handle error
          set({ 
            isSubmitting: false,
            error: (error as Error).message
          });
        }
      },
      
      // Search functionality
      searchQuery: "",
      setSearchQuery: (query) => set({ searchQuery: query }),
      getFilteredContracts: () => {
        const { contracts, searchQuery } = get();
        if (!searchQuery.trim()) return contracts;
        
        const query = searchQuery.toLowerCase();
        return contracts.filter(contract => 
          contract.title.toLowerCase().includes(query) ||
          contract.vendor.name?.toLowerCase().includes(query) ||
          contract.type?.toLowerCase().includes(query)
        );
      }
    }),
    {
      name: "contract-store",
    }
  )
);

export default useContractStore;
</file>

<file path="postcss.config.mjs">
const config = {
  plugins: {
    "@tailwindcss/postcss": {},

  },
};
export default config;
</file>

<file path="README.md">
An application that will serve as a central contract repository but will also be able to be a centralized database for vendors
</file>

<file path="tailwind.config.js">
/** @type {import('tailwindcss').Config} */
module.exports = {
  darkMode: ["class"],
  content: [
    "./pages/**/*.{ts,tsx}",
    "./components/**/*.{ts,tsx}",
    "./app/**/*.{ts,tsx}",
    "./src/**/*.{ts,tsx}",
  ],
  theme: {
    container: {
      center: true,
      padding: "2rem",
      screens: {
        "2xl": "1400px",
      },
    },
    extend: {
      colors: {
        border: "hsl(var(--border))",
        input: "hsl(var(--input))",
        ring: "hsl(var(--ring))",
        background: "hsl(var(--background))",
        foreground: "hsl(var(--foreground))",
        primary: {
          DEFAULT: "hsl(var(--primary))",
          foreground: "hsl(var(--primary-foreground))",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary))",
          foreground: "hsl(var(--secondary-foreground))",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive))",
          foreground: "hsl(var(--destructive-foreground))",
        },
        muted: {
          DEFAULT: "hsl(var(--muted))",
          foreground: "hsl(var(--muted-foreground))",
        },
        accent: {
          DEFAULT: "hsl(var(--accent))",
          foreground: "hsl(var(--accent-foreground))",
        },
        popover: {
          DEFAULT: "hsl(var(--popover))",
          foreground: "hsl(var(--popover-foreground))",
        },
        card: {
          DEFAULT: "hsl(var(--card))",
          foreground: "hsl(var(--card-foreground))",
        },
        gold: {
          light: "hsl(var(--elegant-gold-light))",
          DEFAULT: "hsl(var(--elegant-gold))",
          dark: "hsl(var(--elegant-gold-dark))",
        },
        navy: {
          light: "#1E3A8A",
          DEFAULT: "#0A192F",
          dark: "#050C17",
        },
        metallic: {
          silver: "#C0C0C0",
          platinum: "#E5E4E2",
          bronze: "#CD7F32",
        },
        chart: {
          1: "hsl(var(--chart-1))",
          2: "hsl(var(--chart-2))",
          3: "hsl(var(--chart-3))",
          4: "hsl(var(--chart-4))",
          5: "hsl(var(--chart-5))",
        },
      },
      borderRadius: {
        lg: "var(--radius)",
        md: "calc(var(--radius) - 2px)",
        sm: "calc(var(--radius) - 4px)",
      },
      boxShadow: {
        "luxury-sm":
          "0 2px 4px rgba(0, 0, 0, 0.05), 0 1px 2px rgba(197, 165, 114, 0.15)",
        luxury:
          "0 4px 6px rgba(0, 0, 0, 0.05), 0 2px 4px rgba(197, 165, 114, 0.15)",
        "luxury-lg":
          "0 10px 15px rgba(0, 0, 0, 0.05), 0 4px 6px rgba(197, 165, 114, 0.15)",
        "glass": "0 4px 30px rgba(0, 0, 0, 0.05)",
        "elegant": "0 10px 30px -5px rgba(0, 0, 0, 0.05), 0 1px 3px rgba(0, 0, 0, 0.03)",
        "card-hover-gold": "0 12px 28px -8px hsla(var(--elegant-gold), 0.3), 0 4px 10px -5px hsla(var(--elegant-gold), 0.2)",
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" }, // Ensure 0 is a string if Radix expects it
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" }, // Ensure 0 is a string
        },
        "fade-in": {
          from: { opacity: "0" },
          to: { opacity: "1" },
        },
        "fade-in-up": {
          from: { opacity: "0", transform: "translateY(20px)" },
          to: { opacity: "1", transform: "translateY(0)" },
        },
        "gentle-pulse": {
          "0%, 100%": { transform: "scale(1)", opacity: "1" },
          "50%": { transform: "scale(1.03)", opacity: "0.9" },
        },
        'delicate-sweep-in': {
          '0%': {
            opacity: '0',
            transform: 'translateY(35px) rotateX(-15deg) scale(0.97)',
            filter: 'blur(2px)',
          },
          '100%': {
            opacity: '1',
            transform: 'translateY(0) rotateX(0deg) scale(1)',
            filter: 'blur(0px)',
          },
        },
        'icon-subtle-bob': {
          '0%, 100%': { transform: 'translateY(0) scale(1)' },
          '50%': { transform: 'translateY(-3px) scale(1.05)' },
        },
        float: { 
          "0%, 100%": {
            transform: "translate(0px, 0px) rotate(0deg) scale(1)",
          },
          "33%": {
            transform: "translate(10px, -10px) rotate(2deg) scale(1.01)",
          },
          "66%": {
            transform: "translate(-5px, 5px) rotate(-1deg) scale(0.99)",
          },
        },
        gradient: { 
          "0%, 100%": {
            "background-size": "200% 200%",
            "background-position": "left center",
          },
          "50%": {
            "background-size": "200% 200%",
            "background-position": "right center",
          },
        },
        shimmer: {
          "0%": { backgroundPosition: "-200% 0" },
          "100%": { backgroundPosition: "200% 0" },
        },
        pulse: {
          "0%, 100%": { opacity: "1" },
          "50%": { opacity: "0.5" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
        "fade-in": "fade-in 0.5s ease-out",
        "fade-in-up": "fade-in-up 0.7s ease-out forwards",
        "gentle-pulse": "gentle-pulse 2.5s ease-in-out infinite",
        'delicate-sweep-in': 'delicate-sweep-in 0.8s cubic-bezier(0.23, 1, 0.32, 1) forwards',
        'icon-subtle-bob': 'icon-subtle-bob 0.6s ease-in-out',
        float: "float 20s ease-in-out infinite", 
        gradient: "gradient 8s ease infinite",
        shimmer: "shimmer 8s ease-in-out infinite", 
        pulse: "pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite",
      },
      fontFamily: {
        serif: ["Playfair Display", "serif"],
        sans: ["Inter", "sans-serif"],
      },
      backdropBlur: {
        xs: "2px",
        sm: "4px",
        md: "8px",
        lg: "16px",
        xl: "24px",
        "2xl": "40px",
        "3xl": "64px",
      },
      backgroundImage: {
       
        "text-gradient-gold": "linear-gradient(to right, hsl(var(--elegant-gold-light)), hsl(var(--elegant-gold)), hsl(var(--elegant-gold-dark)))",
       
        "gold-gradient": "linear-gradient(135deg, hsl(var(--gold)) 0%, hsl(var(--gold-dark)) 100%)",
        "gold-shine": "linear-gradient(90deg, transparent, rgba(255,255,255,0.3), transparent)",
        "luxury-gradient": "linear-gradient(to right, hsl(var(--primary)), hsl(var(--gold)), hsl(var(--primary)))",
      },
    },
  },
  plugins: [
    require("tailwindcss-animate"),
    function ({ addUtilities, theme }) {
      addUtilities({
        ".animation-delay-2000": { "animation-delay": "2s" },
        ".animation-delay-4000": { "animation-delay": "4s" },
        ".text-balance": { "text-wrap": "balance" },
        ".text-shadow-sm": { "text-shadow": "0 1px 2px rgba(0, 0, 0, 0.1)" },
        ".text-shadow-md": { "text-shadow": "0 2px 4px rgba(0, 0, 0, 0.1)" },
        ".backdrop-blur-xs": { "backdrop-filter": "blur(2px)" },
        ".bg-clip-text": {
          "-webkit-background-clip": "text",
          "background-clip": "text",
        },
        ".subtle-shadow": {
          "box-shadow": "0 4px 20px -2px rgba(0, 0, 0, 0.05)",
        },
        ".text-gradient-gold": {
          "background-image": theme('backgroundImage.text-gradient-gold'),
          "-webkit-background-clip": "text",
          "background-clip": "text",
          color: "transparent",
        },
        ".perspective": { "perspective": "1000px" },
      });
    },
  ],
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "ES2017",
    "lib": ["dom", "dom.iterable", "esnext"],
    "allowJs": true,
    "skipLibCheck": true,
    "strict": true,
    "noEmit": true,
    "esModuleInterop": true,
    "module": "esnext",
    "moduleResolution": "bundler",
    "resolveJsonModule": true,
    "isolatedModules": true,
    "jsx": "preserve",
    "incremental": true,
    // Enhanced type checking
    "noImplicitAny": true,
    "strictNullChecks": true,
    "strictFunctionTypes": true,
    "strictBindCallApply": true,
    "strictPropertyInitialization": true,
    "noImplicitReturns": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedIndexedAccess": true,
    "noImplicitOverride": true,
    "exactOptionalPropertyTypes": true,
    "plugins": [
      {
        "name": "next"
      }
    ],
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["next-env.d.ts", "**/*.ts", "**/*.tsx", ".next/types/**/*.ts", "convex/_generated/contracts.js", "convex/_generated/vendors.js", "convex/_generated/users.js"],
  "exclude": ["node_modules"]
}
</file>

<file path="convex/enterprises.ts">
// convex/enterprises.ts
import { query, mutation } from "./_generated/server";
import { v, ConvexError } from "convex/values";
import { UserRole, userRoleOptions } from "./schema";

// ============================================================================
// ENTERPRISE CREATION & ONBOARDING
// ============================================================================

/**
 * Create a new enterprise with the current user as owner
 */
export const createEnterpriseWithOwner = mutation({
  args: {
    enterpriseName: v.string(),
    domain: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    // Check if user already belongs to an enterprise
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (existingUser) {
      throw new ConvexError("You already belong to an enterprise");
    }

    // Validate enterprise name
    if (!args.enterpriseName || args.enterpriseName.trim().length < 2) {
      throw new ConvexError("Enterprise name must be at least 2 characters long");
    }

    // Create enterprise
    const enterpriseId = await ctx.db.insert("enterprises", {
      name: args.enterpriseName.trim(),
      domain: args.domain,
    });

    // Create user as owner
    await ctx.db.insert("users", {
      clerkId: String(identity.subject),
      email: typeof identity.email === "string" ? identity.email : "",
      firstName: typeof identity.given_name === "string" ? identity.given_name : undefined,
      lastName: typeof identity.family_name === "string" ? identity.family_name : undefined,
      enterpriseId,
      role: "owner",
      isActive: true,
      lastLoginAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
    });

    return enterpriseId;
  },
});

/**
 * Check if the current user can create an enterprise
 */
export const canCreateEnterprise = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return false;

    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    return !existingUser; // Can create if no existing user record
  },
});

// ============================================================================
// ENTERPRISE QUERIES
// ============================================================================

/**
 * Get enterprise details for the current user
 */
export const getMyEnterprise = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) return null;

    const enterprise = await ctx.db.get(user.enterpriseId);
    if (!enterprise) return null;

    // Get member count
    const members = await ctx.db
      .query("users")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", user.enterpriseId))
      .collect();

    // Get basic stats
    const [contracts, vendors] = await Promise.all([
      ctx.db
        .query("contracts")
        .withIndex("by_status_and_enterpriseId", (q) => 
          q.eq("enterpriseId", user.enterpriseId)
        )
        .collect(),
      ctx.db
        .query("vendors")
        .withIndex("by_enterprise", (q) => 
          q.eq("enterpriseId", user.enterpriseId)
        )
        .collect(),
    ]);

    return {
      ...enterprise,
      memberCount: members.length,
      contractCount: contracts.length,
      vendorCount: vendors.length,
      currentUserRole: user.role,
    };
  },
});

/**
 * Get enterprise by ID (with permission check)
 */
export const getEnterpriseById = query({
  args: { 
    enterpriseId: v.id("enterprises") 
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user || user.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied");
    }

    return await ctx.db.get(args.enterpriseId);
  },
});

/**
 * Get enterprise by email domain
 */
export const getEnterpriseByDomain = query({
  args: { 
    domain: v.string() 
  },
  handler: async (ctx, args) => {
    return await ctx.db
      .query("enterprises")
      .withIndex("by_domain", (q) => q.eq("domain", args.domain))
      .first();
  },
});

// ============================================================================
// ENTERPRISE MANAGEMENT
// ============================================================================

/**
 * Update enterprise settings
 */
export const updateEnterprise = mutation({
  args: {
    enterpriseId: v.id("enterprises"),
    name: v.optional(v.string()),
    domain: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    // Get current user
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied");
    }

    // Only owners and admins can update enterprise
    if (currentUser.role !== "owner" && currentUser.role !== "admin") {
      throw new ConvexError("Only owners and admins can update enterprise settings");
    }

    const updates: any = {};
    
    if (args.name !== undefined) {
      if (args.name.trim().length < 2) {
        throw new ConvexError("Enterprise name must be at least 2 characters long");
      }
      updates.name = args.name.trim();
    }

    if (args.domain !== undefined) {
      updates.domain = args.domain;
    }

    if (Object.keys(updates).length === 0) {
      return { success: false, message: "No updates provided" };
    }

    await ctx.db.patch(args.enterpriseId, updates);
    return { success: true };
  },
});

// ============================================================================
// TEAM MANAGEMENT - INVITATIONS
// ============================================================================

/**
 * Create invitation for new user
 */
export const createInvitation = mutation({
  args: {
    email: v.string(),
    role: v.union(
      v.literal("owner"),
      v.literal("admin"),
      v.literal("manager"),
      v.literal("user"),
      v.literal("viewer")
    ),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    // Get current user
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    // Check permissions (only owner and admin can invite)
    if (currentUser.role !== "owner" && currentUser.role !== "admin") {
      throw new ConvexError("Only owners and admins can invite users");
    }

    // Admins cannot invite owners
    if (currentUser.role === "admin" && args.role === "owner") {
      throw new ConvexError("Admins cannot invite users with owner role");
    }

    // Check if user already exists
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_email", (q) => q.eq("email", args.email))
      .first();

    if (existingUser && existingUser.enterpriseId === currentUser.enterpriseId) {
      throw new ConvexError("User already exists in this enterprise");
    }

    // Check for pending invitation
    const pendingInvitation = await ctx.db
      .query("invitations")
      .withIndex("by_email", (q) => q.eq("email", args.email))
      .filter(q => 
        q.and(
          q.eq(q.field("enterpriseId"), currentUser.enterpriseId),
          q.eq(q.field("acceptedAt"), undefined)
        )
      )
      .first();

    if (pendingInvitation) {
      throw new ConvexError("An invitation for this email already exists");
    }

    // Generate unique token
    const token = Math.random().toString(36).substring(2) + Date.now().toString(36);
    
    // Create invitation (expires in 7 days)
    const expiresAt = new Date();
    expiresAt.setDate(expiresAt.getDate() + 7);

    const invitationId = await ctx.db.insert("invitations", {
      enterpriseId: currentUser.enterpriseId,
      email: args.email.toLowerCase(),
      role: args.role,
      invitedBy: currentUser._id,
      token,
      expiresAt: expiresAt.toISOString(),
    });

    return { 
      invitationId,
      token, 
      invitationUrl: `/invite/${token}`,
      email: args.email 
    };
  },
});

/**
 * Get pending invitations for the enterprise
 */
export const getPendingInvitations = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    // Only owners and admins can view invitations
    if (currentUser.role !== "owner" && currentUser.role !== "admin") {
      throw new ConvexError("Access denied");
    }

    const invitations = await ctx.db
      .query("invitations")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", currentUser.enterpriseId))
      .filter(q => q.eq(q.field("acceptedAt"), undefined))
      .collect();

    // Filter out expired invitations and enrich with inviter info
    const now = new Date();
    const validInvitations = await Promise.all(
      invitations
        .filter(inv => new Date(inv.expiresAt) > now)
        .map(async (inv) => {
          const inviter = await ctx.db.get(inv.invitedBy);
          return {
            ...inv,
            inviterName: inviter 
              ? `${inviter.firstName || ''} ${inviter.lastName || ''}`.trim() || inviter.email
              : 'Unknown',
          };
        })
    );

    return validInvitations;
  },
});

/**
 * Cancel/revoke an invitation
 */
export const cancelInvitation = mutation({
  args: {
    invitationId: v.id("invitations"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    const invitation = await ctx.db.get(args.invitationId);
    if (!invitation) {
      throw new ConvexError("Invitation not found");
    }

    if (invitation.enterpriseId !== currentUser.enterpriseId) {
      throw new ConvexError("Access denied");
    }

    // Only owners, admins, or the original inviter can cancel
    if (
      currentUser.role !== "owner" && 
      currentUser.role !== "admin" && 
      invitation.invitedBy !== currentUser._id
    ) {
      throw new ConvexError("You don't have permission to cancel this invitation");
    }

    await ctx.db.delete(args.invitationId);
    return { success: true };
  },
});

/**
 * Get invitation by token (for preview before accepting)
 */
export const getInvitationByToken = query({
  args: {
    token: v.string(),
  },
  handler: async (ctx, args) => {
    const invitation = await ctx.db
      .query("invitations")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();

    if (!invitation) {
      return null;
    }

    // Check if expired
    if (new Date(invitation.expiresAt) < new Date()) {
      return { error: "Invitation has expired" };
    }

    // Check if already accepted
    if (invitation.acceptedAt) {
      return { error: "Invitation has already been accepted" };
    }

    const enterprise = await ctx.db.get(invitation.enterpriseId);
    const inviter = await ctx.db.get(invitation.invitedBy);

    return {
      invitation: {
        email: invitation.email,
        role: invitation.role,
        expiresAt: invitation.expiresAt,
      },
      enterprise: enterprise ? {
        name: enterprise.name,
      } : null,
      inviter: inviter ? {
        name: `${inviter.firstName || ''} ${inviter.lastName || ''}`.trim() || inviter.email,
        email: inviter.email,
      } : null,
    };
  },
});

/**
 * Accept invitation
 */
export const acceptInvitation = mutation({
  args: {
    token: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const invitation = await ctx.db
      .query("invitations")
      .withIndex("by_token", (q) => q.eq("token", args.token))
      .first();

    if (!invitation) {
      throw new ConvexError("Invalid invitation");
    }

    if (invitation.acceptedAt) {
      throw new ConvexError("Invitation already accepted");
    }

    if (new Date(invitation.expiresAt) < new Date()) {
      throw new ConvexError("Invitation expired");
    }

    if (invitation.email.toLowerCase() !== identity.email?.toLowerCase()) {
      throw new ConvexError("Invitation is for a different email address");
    }

    // Mark invitation as accepted
    await ctx.db.patch(invitation._id, {
      acceptedAt: new Date().toISOString(),
    });

    // Create or update user
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (existingUser) {
      // User exists, update their enterprise and role
      await ctx.db.patch(existingUser._id, {
        enterpriseId: invitation.enterpriseId,
        role: invitation.role,
        updatedAt: new Date().toISOString(),
      });
      return existingUser._id;
    } else {
      // Create new user
      return await ctx.db.insert("users", {
        clerkId: identity.subject,
        email: identity.email || "",
        firstName: typeof identity.given_name === "string" ? identity.given_name : undefined,
        lastName: typeof identity.family_name === "string" ? identity.family_name : undefined,
        enterpriseId: invitation.enterpriseId,
        role: invitation.role,
        isActive: true,
        lastLoginAt: new Date().toISOString(),
        createdAt: new Date().toISOString(),
      });
    }
  },
});

// ============================================================================
// TEAM MANAGEMENT - USERS
// ============================================================================

/**
 * Remove a user from the enterprise
 */
export const removeUser = mutation({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("User not found");
    }

    const targetUser = await ctx.db.get(args.userId);
    if (!targetUser) {
      throw new ConvexError("Target user not found");
    }

    // Ensure same enterprise
    if (targetUser.enterpriseId !== currentUser.enterpriseId) {
      throw new ConvexError("Cannot remove user from different enterprise");
    }

    // Permission checks
    if (currentUser.role !== "owner" && currentUser.role !== "admin") {
      throw new ConvexError("Only owners and admins can remove users");
    }

    // Cannot remove yourself
    if (currentUser._id === targetUser._id) {
      throw new ConvexError("Cannot remove yourself from the enterprise");
    }

    // Admins cannot remove owners
    if (currentUser.role === "admin" && targetUser.role === "owner") {
      throw new ConvexError("Admins cannot remove owners");
    }

    // Check if this is the last owner
    if (targetUser.role === "owner") {
      const owners = await ctx.db
        .query("users")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", currentUser.enterpriseId))
        .filter(q => q.eq(q.field("role"), "owner"))
        .collect();

      if (owners.length <= 1) {
        throw new ConvexError("Cannot remove the last owner. Transfer ownership first.");
      }
    }

    // Instead of deleting, mark as inactive
    await ctx.db.patch(args.userId, {
      isActive: false,
      updatedAt: new Date().toISOString(),
    });

    return { success: true };
  },
});

/**
 * Get enterprise statistics/overview
 */
export const getEnterpriseStats = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new ConvexError("Authentication required");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const enterpriseId = user.enterpriseId;

    // Get all stats in parallel
    const [
      totalUsers,
      activeUsers,
      totalContracts,
      activeContracts,
      totalVendors,
      pendingInvitations,
    ] = await Promise.all([
      // Total users
      ctx.db
        .query("users")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", enterpriseId))
        .collect()
        .then(users => users.length),
      
      // Active users
      ctx.db
        .query("users")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", enterpriseId))
        .filter(q => q.eq(q.field("isActive"), true))
        .collect()
        .then(users => users.length),
      
      // Total contracts
      ctx.db
        .query("contracts")
        .withIndex("by_status_and_enterpriseId", (q) => 
          q.eq("enterpriseId", enterpriseId)
        )
        .collect()
        .then(contracts => contracts.length),
      
      // Active contracts
      ctx.db
        .query("contracts")
        .withIndex("by_status_and_enterpriseId", (q) => 
          q.eq("enterpriseId", enterpriseId).eq("status", "active")
        )
        .collect()
        .then(contracts => contracts.length),
      
      // Total vendors
      ctx.db
        .query("vendors")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", enterpriseId))
        .collect()
        .then(vendors => vendors.length),
      
      // Pending invitations
      ctx.db
        .query("invitations")
        .withIndex("by_enterprise", (q) => q.eq("enterpriseId", enterpriseId))
        .filter(q => q.eq(q.field("acceptedAt"), undefined))
        .collect()
        .then(invitations => 
          invitations.filter(inv => new Date(inv.expiresAt) > new Date()).length
        ),
    ]);

    // Get user breakdown by role
    const users = await ctx.db
      .query("users")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", enterpriseId))
      .filter(q => q.eq(q.field("isActive"), true))
      .collect();

    const usersByRole = users.reduce((acc, user) => {
      acc[user.role] = (acc[user.role] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return {
      users: {
        total: totalUsers,
        active: activeUsers,
        byRole: usersByRole,
      },
      contracts: {
        total: totalContracts,
        active: activeContracts,
      },
      vendors: {
        total: totalVendors,
      },
      invitations: {
        pending: pendingInvitations,
      },
    };
  },
});
</file>

<file path="src/app/_components/homepage/Footer.tsx">
"use client";

import React from "react";
import {
  Mail,
  Phone,
  MapPin,
  Github,
  Twitter,
  Linkedin,
  ChevronRight,
  Globe,
} from "lucide-react";
import { Separator } from "@/components/ui/separator";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Alert, AlertDescription } from "@/components/ui/alert";

export const Footer = () => {
  const currentYear = new Date().getFullYear();
  // const [email, setEmail] = React.useState("");
  // const [subscriptionStatus, setSubscriptionStatus] = React.useState("");

  // const handleSubscribe = (e: React.FormEvent) => {
  //   e.preventDefault();
  //   setSubscriptionStatus("Thank you for subscribing!");
  //   setEmail("");
  // };

  return (
    <footer className="bg-background border-t">
      <div className="container px-4 py-8 mx-auto">
        {/* Newsletter Section */}
        <div className="mb-8 pb-8 border-b">
          {/* <div className="max-w-xl mx-auto text-center">
            <h3 className="text-xl font-semibold mb-3">Stay Updated</h3>
            <p className="text-sm text-muted-foreground mb-4">
              Subscribe to our newsletter for the latest updates on contract
              management.
            </p>
            <form
              onSubmit={handleSubscribe}
              className="flex flex-col sm:flex-row gap-3 justify-center"
            >
              <Input
                type="email"
                placeholder="Enter your email"
                className="max-w-xs"
                value={email}
                onChange={(e) => setEmail(e.target.value)}
              />
              <Button type="submit" size="sm">
                Subscribe
                <ChevronRight className="ml-2 h-4 w-4" />
              </Button>
            </form>
            {subscriptionStatus && (
              <Alert className="mt-3 max-w-sm mx-auto">
                <AlertDescription>{subscriptionStatus}</AlertDescription>
              </Alert>
            )}
          </div> */}
        </div>

        {/* Main Categories */}
        <div className="grid grid-cols-3 gap-8 mb-6 text-center">
          <div>
            <h3 className="text-sm font-semibold">Solutions</h3>
          </div>
          <div>
            <h3 className="text-sm font-semibold">Resources</h3>
          </div>
          <div>
            <h3 className="text-sm font-semibold">Contact</h3>
          </div>
        </div>

    
        <div className="grid grid-cols-3 gap-8 mb-8">
        
          <div className="flex justify-center">
            <ul className="space-y-1.5 text-center">
              <li>
                <a
                  // href="#"
                  className="text-xs text-muted-foreground hover:text-primary transition-colors"
                >
                  Contract Management
                </a>
              </li>
              <li>
                <a
                  href="#"
                  className="text-xs text-muted-foreground hover:text-primary transition-colors"
                >
                  Document Analytics
                </a>
              </li>
              <li>
                <a
                  // href="#"
                  className="text-xs text-muted-foreground hover:text-primary transition-colors"
                >
                  E-Signature Platform
                </a>
              </li>
              <li>
                <a
                  // href="#"
                  className="text-xs text-muted-foreground hover:text-primary transition-colors"
                >
                  Template Library
                </a>
              </li>
            </ul>
          </div>

          {/* Resources Subcategories */}
          <div className="flex justify-center">
            <ul className="space-y-1.5 text-center">
              <li>
                <a
                  href="#"
                  className="text-xs text-muted-foreground hover:text-primary transition-colors"
                >
                  Documentation
                </a>
              </li>
             
              {/* <li>
                <a
                  href="#"
                  className="text-xs text-muted-foreground hover:text-primary transition-colors"
                >
                  Customer Stories
                </a>
              </li> */}
              <li>
                <a
                  href="#"
                  className="text-xs text-muted-foreground hover:text-primary transition-colors"
                >
                  Support Center
                </a>
              </li>
            </ul>
          </div>

          {/* Contact Information */}
          <div className="flex justify-center">
            <ul className="space-y-1.5 text-center">
              <li className="flex items-center justify-center space-x-2">
                <Mail className="h-3 w-3 text-muted-foreground" />
                <span className="text-xs text-muted-foreground">
                  danielpark0503@gmail.com
                </span>
              </li>
              <li className="flex items-center justify-center space-x-2">
                <Phone className="h-3 w-3 text-muted-foreground" />
                <span className="text-xs text-muted-foreground">
                  +1 (908) 239 4019
                </span>
              </li>
              <li className="flex items-center justify-center space-x-2">
                <MapPin className="h-3 w-3 text-muted-foreground" />
                <span className="text-xs text-muted-foreground">
                  New York
                </span>
              </li>
            </ul>
          </div>
        </div>

        <Separator className="my-6" />

        {/* Company Info and Social */}
        {/* <div className="flex flex-col items-center mb-6 space-y-4">
          <div className="text-center">
            <h3 className="text-sm font-semibold mb-2">ContractFlow</h3>
            <p className="text-xs text-muted-foreground mb-3 max-w-md">
              Enterprise-grade contract management platform with advanced
              analytics and secure collaboration.
            </p>
          </div>
          <div className="flex space-x-4">
            <a
              href="#"
              className="text-muted-foreground hover:text-primary transition-colors"
            >
              <Github className="h-4 w-4" />
            </a>
            <a
              href="#"
              className="text-muted-foreground hover:text-primary transition-colors"
            >
              <Twitter className="h-4 w-4" />
            </a>
            <a
              href="#"
              className="text-muted-foreground hover:text-primary transition-colors"
            >
              <Linkedin className="h-4 w-4" />
            </a>
          </div>
        </div> */}

        {/* Footer Bottom */}
        <div className="flex flex-col-reverse md:flex-row md:justify-between items-center space-y-4 md:space-y-0 text-xs text-muted-foreground">
          <div className="flex items-center space-x-4 mt-4 md:mt-0">
            <span> {currentYear} PactWise</span>
            <Separator orientation="vertical" className="h-3" />
            <div className="flex items-center space-x-1">
              <Globe className="h-3 w-3" />
              <select className="bg-transparent border-none cursor-pointer hover:text-primary transition-colors focus:outline-none text-xs">
                <option value="en">English</option>
                <option value="es">Espaol</option>
                <option value="fr">Franais</option>
              </select>
            </div>
          </div>
          <div className="flex flex-wrap justify-center gap-4">
            <a href="#" className="hover:text-primary transition-colors">
              Privacy
            </a>
            <a href="#" className="hover:text-primary transition-colors">
              Terms
            </a>
            <a href="#" className="hover:text-primary transition-colors">
              Cookies
            </a>
          </div>
        </div>
      </div>
    </footer>
  );
};
</file>

<file path="src/app/dashboard/contracts/page.tsx">
'use client'

import React, { useMemo, useState, useCallback } from "react";
import { useRouter } from "next/navigation";

import { NewContractButton } from "@/app/_components/contracts/NewContractButton";
import { Badge } from "@/components/ui/badge";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Search, Eye, FileText, Calendar } from "lucide-react";
import { Input } from "@/components/ui/input";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
} from "@/components/ui/select";
import { Button } from "@/components/ui/button";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { AlertCircle } from "lucide-react";

// Import simplified hooks
import { useConvexQuery } from "@/lib/api-client";
import { api } from "../../../../convex/_generated/api";

import { useDashboardStore } from "@/stores/dashboard-store";
import { ContractType } from "@/types/contract.types";
import { Id } from "../../../../convex/_generated/dataModel";

const AllContracts = () => {
  const router = useRouter();
  const { searchQuery, setSearchQuery } = useDashboardStore();
  const [statusFilter, setStatusFilter] = useState<string>("all");

  // We'll add a new function to contracts.ts instead
  // Let's modify this file so it calls that new function

  /*
   * Now we'll use the new getContracts function we created in convex/contracts.ts
   */
  const { data: contracts = [], isLoading: isLoadingContracts, error: contractsError } = useConvexQuery(
    api.contracts.getContracts,
    {}
  );

  // Use a combined loading state
  const isLoading = isLoadingContracts;

  // Filter contracts based on search and status
  const filteredContracts = useMemo(() => {
    // Ensure contracts is an array before filtering
    if (!Array.isArray(contracts)) return [];

    return contracts.filter((contract) => {
      // Filter by status if not "all"
      const matchesStatus = statusFilter === "all" || contract.status === statusFilter;
      if (!matchesStatus) return false;
      
      // Apply search filter
      if (!searchQuery) return true;

      const query = searchQuery.toLowerCase();
      return (
        contract.title?.toLowerCase().includes(query) ||
        contract.fileName?.toLowerCase().includes(query) ||
        (contract.extractedParties && 
          contract.extractedParties.some(party => 
            party.toLowerCase().includes(query)
          ))
      );
    });
  }, [contracts, searchQuery, statusFilter]);

  // Calculate contract statistics
  const stats = useMemo(() => {
    // Ensure contracts is an array
    if (!Array.isArray(contracts)) return {
      total: 0, 
      activeCount: 0, 
      pendingCount: 0, 
      draftCount: 0,
    };

    return {
      total: contracts.length,
      activeCount: contracts.filter((c) => c.status === "active").length,
      pendingCount: contracts.filter((c) => c.status === "pending_analysis").length,
      draftCount: contracts.filter((c) => c.status === "draft").length,
    };
  }, [contracts]);

  const viewContractDetails = useCallback((contractId: Id<"contracts">) => {
    router.push(`/dashboard/contracts/${contractId}`);
  }, [router]);

  // Render loading state
  if (isLoading) {
    return (
      <div className="space-y-6 p-6">
        <div className="flex justify-between items-center">
          <h2 className="text-2xl font-semibold">All Contracts</h2>
          <NewContractButton />
        </div>
        <div className="flex items-center justify-center py-12">
          <div className="animate-spin rounded-full h-12 w-12 border-t-2 border-b-2 border-primary"></div>
        </div>
      </div>
    );
  }

  // Handle error state
  if (contractsError) {
    return (
      <Alert variant="destructive" className="m-4">
        <AlertCircle className="h-4 w-4" />
        <AlertTitle>Error Loading Contracts</AlertTitle>
        <AlertDescription>
          {contractsError.message}
          <pre className="mt-2 text-xs">Please try refreshing the page.</pre>
        </AlertDescription>
      </Alert>
    );
  }

  // Map status to badge style
  const getStatusBadgeClass = useCallback((status: string): string => {
    switch (status) {
      case "active": return "bg-green-100 text-green-800";
      case "pending_analysis": return "bg-yellow-100 text-yellow-800";
      case "draft": return "bg-blue-100 text-blue-800";
      case "expired": return "bg-red-100 text-red-800";
      case "terminated": return "bg-orange-100 text-orange-800";
      case "archived": return "bg-gray-100 text-gray-800";
      default: return "bg-slate-100 text-slate-800";
    }
  }, []);

  // Format date for display
  const formatDate = useCallback((dateString?: string): string => {
    if (!dateString) return "Not available";
    try {
      return new Date(dateString).toLocaleDateString();
    } catch (e) {
      return "Invalid date";
    }
  }, []);

  // Format status label
  const formatStatusLabel = useCallback((status: string): string => {
    if (!status) return "Unknown";
    return status.replace(/_/g, " ").replace(/\b\w/g, l => l.toUpperCase());
  }, []);

  return (
    <div className="space-y-6 p-6">
      {/* Header with Stats */}
      <div className="flex justify-between items-center">
        <h2 className="text-2xl font-semibold">All Contracts</h2>
        <NewContractButton />
      </div>

      {/* Contract Statistics */}
      <div className="grid grid-cols-1 md:grid-cols-4 gap-4">
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Total Contracts</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.total}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Active Contracts</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.activeCount}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Pending Analysis</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.pendingCount}</div>
          </CardContent>
        </Card>
        <Card>
          <CardHeader>
            <CardTitle className="text-sm font-medium">Drafts</CardTitle>
          </CardHeader>
          <CardContent>
            <div className="text-2xl font-bold">{stats.draftCount}</div>
          </CardContent>
        </Card>
      </div>

      {/* Filters */}
      <div className="flex items-center space-x-4">
        <div className="relative flex-1">
          <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
          <Input
            placeholder="Search contracts..."
            value={searchQuery}
            onChange={(e) => setSearchQuery(e.target.value)}
            className="pl-8"
          />
        </div>
        <Select value={statusFilter} onValueChange={setStatusFilter}>
          <SelectTrigger className="w-[180px]">
            <SelectValue placeholder="Filter by status" />
          </SelectTrigger>
          <SelectContent>
            <SelectItem value="all">All Statuses</SelectItem>
            <SelectItem value="draft">Draft</SelectItem>
            <SelectItem value="pending_analysis">Pending Analysis</SelectItem>
            <SelectItem value="active">Active</SelectItem>
            <SelectItem value="expired">Expired</SelectItem>
            <SelectItem value="terminated">Terminated</SelectItem>
            <SelectItem value="archived">Archived</SelectItem>
          </SelectContent>
        </Select>
      </div>

      {/* Contracts Table */}
      <div className="bg-white rounded-lg border shadow-sm overflow-hidden">
        <div className="overflow-x-auto">
          <table className="w-full">
            <thead>
              <tr className="bg-muted/50">
                <th className="px-4 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">Contract</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">Vendor</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">Status</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">Analysis Status</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">Start Date</th>
                <th className="px-4 py-3 text-left text-xs font-medium text-muted-foreground uppercase tracking-wider">End Date</th>
                <th className="px-4 py-3 text-right text-xs font-medium text-muted-foreground uppercase tracking-wider">Actions</th>
              </tr>
            </thead>
            <tbody className="divide-y divide-gray-200">
              {filteredContracts.length > 0 ? (
                filteredContracts.map((contract) => {
                  // Get vendor information (assuming we have loaded vendor data)
                  const vendor = contract.vendor || { name: 'N/A' };
                  
                  return (
                    <tr
                      key={contract._id}
                      className="hover:bg-muted/20 cursor-pointer"
                      onClick={() => viewContractDetails(contract._id)}
                    >
                      <td className="px-4 py-4 whitespace-nowrap">
                        <div className="flex items-center">
                          <FileText className="h-5 w-5 text-muted-foreground mr-2 flex-shrink-0" />
                          <div>
                            <div className="font-medium text-primary truncate" title={contract.title}>{contract.title || 'Untitled'}</div>
                            <div className="text-xs text-muted-foreground">{contract.fileName || 'No file'}</div>
                          </div>
                        </div>
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap">
                        {vendor.name}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap">
                        <Badge className={`${getStatusBadgeClass(contract.status)} font-medium`}>
                          {formatStatusLabel(contract.status)}
                        </Badge>
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap">
                        {contract.analysisStatus ? (
                          <Badge className={
                            contract.analysisStatus === 'completed' ? 'bg-green-100 text-green-800' :
                            contract.analysisStatus === 'processing' ? 'bg-blue-100 text-blue-800' :
                            contract.analysisStatus === 'failed' ? 'bg-red-100 text-red-800' :
                            'bg-yellow-100 text-yellow-800'
                          }>
                            {formatStatusLabel(contract.analysisStatus)}
                          </Badge>
                        ) : 'Not analyzed'}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap">
                        {formatDate(contract.extractedStartDate)}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap">
                        {formatDate(contract.extractedEndDate)}
                      </td>
                      <td className="px-4 py-4 whitespace-nowrap text-right">
                        <Button
                          variant="ghost"
                          size="sm"
                          onClick={(e) => {
                            e.stopPropagation(); // Prevent row click when clicking button
                            viewContractDetails(contract._id);
                          }}
                        >
                          <Eye className="h-4 w-4 mr-1" />
                          View
                        </Button>
                      </td>
                    </tr>
                  );
                })
              ) : (
                <tr>
                  <td colSpan={7} className="px-4 py-8 text-center text-muted-foreground">
                    {searchQuery || statusFilter !== 'all' ? "No contracts found matching your criteria" : "No contracts found"}
                  </td>
                </tr>
              )}
            </tbody>
          </table>
        </div>
      </div>
    </div>
  );
};

export default AllContracts;
</file>

<file path="src/app/dashboard/page.tsx">
'use client'

import React from "react";
import DashboardContent from "@/app/_components/dashboard/DashboardContent";
import { useQuery } from 'convex/react';
import { api } from "../../../convex/_generated/api";

interface HomeDashboardProps {
  children?: React.ReactNode;
}

export const HomeDashboard: React.FC<HomeDashboardProps> = () => {
  const currentUser = useQuery(api.users.getCurrentUser, {});
  
  // Handle loading state
  if (currentUser === undefined) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <div className="animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4"></div>
          <p className="text-gray-600">Loading dashboard...</p>
        </div>
      </div>
    );
  }

  // Handle unauthenticated state
  if (currentUser === null) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-gray-900 mb-2">Authentication Required</h2>
          <p className="text-gray-600">Please sign in to access the dashboard.</p>
        </div>
      </div>
    );
  }

  // Handle case where user doesn't have an enterprise
  if (!currentUser.enterpriseId) {
    return (
      <div className="flex items-center justify-center min-h-screen">
        <div className="text-center">
          <h2 className="text-xl font-semibold text-gray-900 mb-2">No Enterprise Found</h2>
          <p className="text-gray-600">Please contact your administrator to be assigned to an enterprise.</p>
        </div>
      </div>
    );
  }

  return (
    <>
      <DashboardContent enterpriseId={currentUser.enterpriseId} />
    </>    
  );
};

export default HomeDashboard;
</file>

<file path="src/app/page.tsx">
import React, { Suspense } from "react";
import { Navigation } from "@/app/_components/homepage/Navigation";
import { Hero } from "@/app/_components/homepage/Hero";
const Features = React.lazy(() => import("@/app/_components/homepage/Features"));
import { Benefits } from "@/app/_components/homepage/Benefits";
import { Footer } from "@/app/_components/homepage/Footer";
import  LoadingSpinner  from "@/app/_components/common/LoadingSpinner"
import "@/app/globals.css"


import AuthRedirectHandler from "../app/../lib/AuthRedirectHandler"

const LandingPage = () => {
  return (
    <div className="relative min-h-screen bg-background/50 overflow-hidden">
   
    <AuthRedirectHandler />
      <div className="relative z-10 flex flex-col min-h-screen">
        <Navigation />

        <main className="flex-grow">
          <Hero />

          <Suspense fallback={<LoadingSpinner />}>
            <Features />
          </Suspense>

          <Benefits />
        </main>

        <Footer />
      </div>
    </div>
  );
};

export default LandingPage;
</file>

<file path="src/types/vendor.types.ts">
// src/types/vendor.types.ts
import { Id } from "../../convex/_generated/dataModel";

// --- DEFINE VENDOR CATEGORY OPTIONS AND TYPE (mirrors schema.ts) ---
export const vendorCategoryOptions = [
  "technology", "marketing", "legal", "finance", "hr",
  "facilities", "logistics", "manufacturing", "consulting", "other"
] as const;
export type VendorCategory = typeof vendorCategoryOptions[number];

export type VendorType = {
  _id: Id<"vendors">;
  _creationTime?: number;
  enterpriseId: Id<"enterprises">;
  name: string;
  contactEmail?: string;
  contactPhone?: string;
  address?: string;
  notes?: string;
  website?: string;
  

  // --- NEW: Vendor category ---
  category?: VendorCategory;

  // --- Optional: Fields from your vendor-store that might be part of the VendorType ---
  // These were in your vendor-store.ts but not explicitly in the VendorType
  // Add them if they are indeed part of the core vendor data fetched from Convex.
  // If they are derived or client-side only, they might belong in a different type or interface.
  vendor_number?: string; // Was in vendor page component
  status?: "active" | "inactive" | "pending"; // Was in vendor page component & store
  total_spend?: number; // Was in vendor page component & store
  risk_level?: "low" | "medium" | "high"; // Was in vendor page component & store
  active_contracts?: number; // Was in vendor page component & store
  compliance_score?: number; // Was in vendor store
  updated_at?: string; // Used in inactive vendors page
  metadata?: { // Used in inactive vendors page
    reviewed?: boolean;
  };
  // contractCount is likely a derived field, added in getVendors query
  contractCount?: number;
};
</file>

<file path="src/app/_components/contracts/ContractForm.tsx">
'use client';

import React, { useState, useEffect, useRef } from 'react';
import { useRouter } from 'next/navigation';
import { format } from 'date-fns';
import { VendorType } from '@/types/vendor.types'; // Assuming this has _id
import { contractValidationSchema, validateFileUpload, sanitizeInput } from '@/lib/validation-utils';

// UI Components
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardFooter, CardHeader, CardTitle } from "@/components/ui/card";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Textarea } from "@/components/ui/textarea";
import {
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue
} from "@/components/ui/select";
import {
  Popover,
  PopoverContent,
  PopoverTrigger
} from "@/components/ui/popover";
import { Calendar } from "@/components/ui/calendar";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogFooter,
  DialogHeader,
  DialogTitle
} from "@/components/ui/dialog";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Switch } from "@/components/ui/switch";
import { Separator } from "@/components/ui/separator";

// Icons
import {
  Calendar as CalendarIcon,
  DollarSign,
  FileText,
  Check,
  X,
  Building,
  Tag,
  AlertCircle,
  Search,
  Plus,
  Save,
  ArrowLeft,
  Upload,
  File as FileIcon,
  Paperclip,
  Loader2
} from "lucide-react";

// Clerk
import { useUser } from '@clerk/nextjs';

// API Client and types
// Removed useCurrentUser, ensure useVendors and useContract hooks are correctly defined
// and don't rely on a Convex-based useCurrentUser for enterpriseId if not intended.
import { useConvexMutation, useVendors, useContract } from '@/lib/api-client';
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";

interface ContractFormProps {
  contractId?: Id<"contracts">;
  isModal?: boolean;
  onClose?: () => void;
  onSuccess?: (contractId: Id<"contracts">) => void;
}

interface FormState {
  title: string;
  description: string; // Mapped to 'notes' in Convex
  contractType: string; // Could be mapped to a custom field or part of description
  vendorId: string;
  effectiveDate?: Date; // Mapped to 'extractedStartDate' for display, 'startDate' for save
  expiresAt?: Date;     // Mapped to 'extractedEndDate' for display, 'endDate' for save
  autoRenewal: boolean;  // Not in simplified schema, might be part of 'notes' or future field
  currency: string;      // Not in simplified schema, might be part of 'notes' or 'extractedPricing'
  value?: number;       // Mapped to 'contractValue' or part of 'extractedPricing'
  documents: File[];
}

function formatBytes(bytes: number, decimals = 2): string {
    if (bytes === 0) return '0 Bytes';
    const k = 1024;
    const dm = decimals < 0 ? 0 : decimals;
    const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];
    const i = Math.floor(Math.log(bytes) / Math.log(k));
    return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
}

export const ContractForm = ({ contractId, isModal = false, onClose, onSuccess }: ContractFormProps) => {
  const router = useRouter();
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [showVendorSearch, setShowVendorSearch] = useState(false);
  const [vendorSearchQuery, setVendorSearchQuery] = useState('');
  const fileInputRef = useRef<HTMLInputElement>(null);

  const { user: clerkUser, isLoaded: isClerkLoaded } = useUser();

  // IMPORTANT: How enterpriseId is determined:
  // Option A: From Clerk's public metadata (shown here)
  const enterpriseIdFromClerk = clerkUser?.publicMetadata?.enterpriseId as Id<"enterprises"> | undefined;
  // Option B: If you create a Convex 'users' table linked to Clerk users and enterprises,
  // you'd fetch that record here using a new Convex query.
  // For now, we rely on enterpriseIdFromClerk.

  // Adjust useVendors hook if it needs enterpriseId for filtering.
  // Assuming useVendors is designed to fetch all or you'll filter client-side for now.
  // If useVendors *requires* enterpriseId, this query will be skipped until enterpriseIdFromClerk is available.
  const { data: vendors = [], isLoading: isLoadingVendors } = useVendors(
    enterpriseIdFromClerk ? { enterpriseId: enterpriseIdFromClerk, category: "all" } : "skip"
  );


  const { data: contractData, isLoading: isLoadingContract, error: contractError } = useContract(
    contractId && enterpriseIdFromClerk ? { contractId, enterpriseId: enterpriseIdFromClerk } : "skip"
  );

  const createContractMutation = useConvexMutation(api.contracts.createContract);
  const updateContractMutation = useConvexMutation(api.contracts.updateContract);
  const generateUploadUrlMutation = useConvexMutation(api.contracts.generateUploadUrl);

  const [formState, setFormState] = useState<FormState>({
    title: '', description: '', contractType: '', vendorId: '',
    effectiveDate: undefined, expiresAt: undefined,
    autoRenewal: false, currency: 'USD', value: undefined,
    documents: [],
  });

  const contractTypes = [
    { value: "sales", label: "Sales Agreement" },
    { value: "service", label: "Service Agreement" },
    { value: "nda", label: "Non-Disclosure Agreement" },
    // ... other types
  ];
  const currencies = [ { value: "USD", label: "US Dollar (USD)" }, /* ... */];


  useEffect(() => {
    if (contractData && contractId && contractData._id === contractId) {
      setFormState({
        title: contractData.title || '',
        description: contractData.notes || '', // Map to notes
        contractType: (contractData as any).contractType || '', // Add missing field
        vendorId: contractData.vendorId?.toString() || '',
        effectiveDate: contractData.extractedStartDate ? new Date(contractData.extractedStartDate) : undefined,
        expiresAt: contractData.extractedEndDate ? new Date(contractData.extractedEndDate) : undefined,
        // These fields are not in the simplified schema
        autoRenewal: (contractData as any).autoRenewal || false,
        currency: (contractData as any).currency || 'USD',
        value: (contractData as any).extractedPricing ? parseFloat((contractData as any).extractedPricing.replace(/[^0-9.-]+/g,"")) : undefined, // Basic parsing attempt
        documents: [],
      });
    } else if (!contractId) { // Reset for new contract
      setFormState({
        title: '', description: '', contractType: '', vendorId: '',
        effectiveDate: undefined, expiresAt: undefined,
        autoRenewal: false, currency: 'USD', value: undefined,
        documents: [],
      });
    }
  }, [contractData, contractId]);

  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement | HTMLTextAreaElement>) => {
    const { name, value } = e.target;
    setFormState(prev => ({ ...prev, [name]: name === 'value' ? parseFloat(value) || undefined : value }));
  };
  const handleSelectChange = (name: string, value: string) => setFormState(prev => ({ ...prev, [name]: value }));
  const handleDateChange = (name: string, date?: Date) => setFormState(prev => ({ ...prev, [name]: date }));
  const handleToggleChange = (name: string, checked: boolean) => setFormState(prev => ({ ...prev, [name]: checked }));

  const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      setFormState(prev => ({ ...prev, documents: Array.from(e.target.files!) }));
      if (e.target) e.target.value = ''; // Allow re-selecting the same file
    }
  };
  const removeDocument = (indexToRemove: number) => setFormState(prev => ({ ...prev, documents: prev.documents.filter((_, index) => index !== indexToRemove) }));
  const selectVendor = (vendorId: string) => { setFormState(prev => ({ ...prev, vendorId })); setShowVendorSearch(false); };

  const filteredVendors = vendors && vendors.filter((vendor: VendorType) => {
    if (!vendorSearchQuery) return true;
    return vendor.name?.toLowerCase().includes(vendorSearchQuery.toLowerCase());
  });

  const formatDateDisplay = (date?: Date): React.ReactNode => date ? format(date, 'PPP') : <span className="text-muted-foreground">Select date</span>;

  const isFormValid = (): boolean => {
    // For new contracts, enterpriseIdFromClerk and a document are now essential.
    if (!contractId) {
      return !!(formState.title && formState.vendorId && enterpriseIdFromClerk && formState.documents.length > 0);
    }
    // For existing contracts, these might not be changed.
    return !!(formState.title && formState.vendorId);
  };

  const handleSubmit = async (e: React.FormEvent) => {
    e.preventDefault();
    setError(null); setSuccess(null);

    if (!isClerkLoaded) { setError('User data is loading. Please wait.'); return; }

    // Check enterpriseId specifically for new contracts
    if (!contractId && !enterpriseIdFromClerk) {
      setError('Enterprise information is missing. Unable to create contract.');
      return;
    }
    if (!isFormValid()) {
      setError('Please fill all required fields: Title, Vendor, and Attachment (for new contracts).');
      return;
    }
    setIsLoading(true);

    try {
      let uploadedStorageId: Id<"_storage"> | null = null;
      let uploadedFileName = '';
      let uploadedFileType = '';

      if (formState.documents.length > 0) {
        const fileToUpload = formState.documents[0]; // Process first file
        uploadedFileName = fileToUpload.name;
        uploadedFileType = fileToUpload.type;

        const postUrlResult = await generateUploadUrlMutation.execute(fileToUpload.type);
        if (!postUrlResult) throw new Error("Could not get an upload URL.");
        
        const uploadResponse = await fetch(postUrlResult.toString(), {
            method: "POST", headers: { "Content-Type": fileToUpload.type }, body: fileToUpload,
        });
        const { storageId } = await uploadResponse.json();
        if (!storageId) throw new Error(`Upload failed for ${fileToUpload.name}`);
        uploadedStorageId = storageId;
      } else if (!contractId) { // File required for new contracts
        throw new Error("A document is required to create a new contract.");
      }

      if (contractId) { // Update existing contract
        const updatePayload: any = { id: contractId };
        // Only include fields if they've changed and are part of the schema
        if (formState.title !== contractData?.title) updatePayload.title = formState.title;
        if (formState.description !== contractData?.notes) updatePayload.notes = formState.description;
        // Note: Updating vendorId, status, or file (storageId) for an existing contract
        // would require specific logic and potentially different mutations or checks.
        // The current `updateContract` in `convex/contracts.ts` is simple.
        if (formState.vendorId !== contractData?.vendorId.toString()) {
            // You might want to add a specific check or disallow vendor change here
            // or ensure backend handles implications of vendor change.
            // For now, let's assume it's not directly updatable via this form post-creation
            // to keep it simple with the current backend `updateContract`.
        }
        await updateContractMutation.execute({
            ...updatePayload,
            // Pass enterpriseId for permission check if your updateContract mutation expects it
            ...(enterpriseIdFromClerk && { enterpriseId: enterpriseIdFromClerk }),
        });
        setSuccess('Contract updated successfully!');
        if (onSuccess) onSuccess(contractId);
        if (!isModal) setTimeout(() => router.push(`/dashboard/contracts/${contractId}`), 1500);

      } else { // Create new contract
        if (!uploadedStorageId) throw new Error("File upload is required for new contract.");
        if (!enterpriseIdFromClerk) throw new Error("Enterprise ID is required to create a new contract."); // Should be caught by isFormValid

        const newContractArgs = {
          enterpriseId: enterpriseIdFromClerk, // Pass the enterpriseId
          vendorId: formState.vendorId as Id<"vendors">,
          title: formState.title,
          storageId: uploadedStorageId,
          fileName: uploadedFileName,
          fileType: uploadedFileType,
          notes: formState.description,
          status: 'pending_analysis' as const,
        };
        const newContractResult = await createContractMutation.execute(newContractArgs);

        if (newContractResult) {
          setSuccess('Contract created successfully!');
          if (onSuccess) onSuccess(newContractResult);
          if (!isModal) setTimeout(() => router.push(`/dashboard/contracts/${newContractResult}`), 1500);
        } else {
           setError(createContractMutation.error?.message || 'Failed to create contract.');
        }
      }

      if (!error && !createContractMutation.error && !updateContractMutation.error) {
         setFormState(prev => ({ ...prev, documents: [] })); // Clear documents on success
      }

    } catch (err: any) {
      console.error("Error saving contract:", err);
      setError(`Submission failed: ${err.message || String(err)}`);
    } finally {
      setIsLoading(false);
    }
  };

  const initialDataLoading = !isClerkLoaded || isLoadingVendors || (contractId && isLoadingContract);

  // --- Form JSX ---
  const formContent = (
    <form onSubmit={handleSubmit} className="space-y-6">
      {error && (
        <Alert variant="destructive">
          <AlertCircle className="h-4 w-4" /> <AlertTitle>Error</AlertTitle> <AlertDescription>{error}</AlertDescription>
        </Alert>
      )}
      {success && (
        <Alert variant="default">
          <Check className="h-4 w-4" /> <AlertTitle>Success</AlertTitle> <AlertDescription>{success}</AlertDescription>
        </Alert>
      )}

      <div className="space-y-4">
        <h3 className="text-lg font-medium text-foreground">Contract Details</h3>
        <Separator />
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div className="space-y-1.5">
            <Label htmlFor="title">Contract Title <span className="text-destructive">*</span></Label>
            <div className="relative">
              <FileText className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
              <Input id="title" name="title" placeholder="e.g., Annual SaaS Subscription" className="pl-8" value={formState.title} onChange={handleInputChange} required />
            </div>
          </div>
          <div className="space-y-1.5">
            <Label htmlFor="contractType">Category/Type <span className="text-destructive">*</span></Label>
            <div className="relative">
               <Tag className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
               <Select value={formState.contractType} onValueChange={(value) => handleSelectChange('contractType', value)} required>
                 <SelectTrigger className="pl-8"><SelectValue placeholder="Select type..." /></SelectTrigger>
                 <SelectContent>{contractTypes.map((type) => ( <SelectItem key={type.value} value={type.value}>{type.label}</SelectItem> ))}</SelectContent>
               </Select>
            </div>
          </div>
        </div>
        <div className="space-y-1.5">
          <Label>Vendor <span className="text-destructive">*</span></Label>
          <div className="flex items-center gap-2">
            <div className="relative flex-grow">
               <Building className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
               <Button type="button" variant="outline" className="w-full justify-start text-left font-normal pl-8" onClick={() => setShowVendorSearch(true)} disabled={isLoadingVendors || (!enterpriseIdFromClerk && !contractId) }>
                 {isLoadingVendors ? 'Loading vendors...' : ( formState.vendorId && vendors&& vendors.length > 0 ? vendors.find((v:VendorType) => v._id.toString() === formState.vendorId)?.name ?? 'Select vendor...' : 'Select vendor...' )}
               </Button>
            </div>
            <Button type="button" variant="outline" size="icon" onClick={() => setShowVendorSearch(true)} disabled={isLoadingVendors || (!enterpriseIdFromClerk && !contractId) }><Search className="h-4 w-4" /></Button>
          </div>
           {!enterpriseIdFromClerk && isClerkLoaded && !contractId && <p className="text-xs text-amber-600 mt-1">Enterprise information is missing. Vendor selection is disabled.</p>}
           <input type="text" value={formState.vendorId} required style={{ display: 'none' }} readOnly/>
        </div>
      </div>


      <div className="space-y-4">
        <h3 className="text-lg font-medium text-foreground">Optional Details</h3>
        <Separator />
        {/* Description / Notes */}
        <div className="space-y-1.5">
           <Label htmlFor="description">Description / Notes</Label>
           <Textarea id="description" name="description" placeholder="Add key terms, notes, or summary..." className="min-h-[100px]" value={formState.description} onChange={handleInputChange} />
        </div>
      </div>


      {/* Attachment Section */}
      <div className="space-y-4">
        <h3 className="text-lg font-medium text-foreground">Attachment</h3>
        <Separator />
        <div className="space-y-1.5">
            <Label htmlFor="document-upload">
              Document <span className="text-destructive">{!contractId ? '*' : '(Optional if not changing)'}</span>
            </Label>
            <input type="file" id="document-upload" ref={fileInputRef} className="hidden" onChange={handleFileChange} accept=".pdf,.doc,.docx,.xls,.xlsx,.ppt,.pptx,.txt,.csv,.jpg,.jpeg,.png" required={!contractId} />
            <label htmlFor="document-upload" className="flex flex-col items-center justify-center w-full h-32 px-4 text-center border-2 border-dashed rounded-lg cursor-pointer bg-card hover:border-primary/50 hover:bg-muted/50 transition-colors" >
                <Upload className="w-8 h-8 text-muted-foreground mb-2" />
                <p className="text-sm text-muted-foreground"> <span className="font-semibold text-primary">Click to upload</span> or drag and drop </p>
                <p className="text-xs text-muted-foreground">PDF, DOCX, etc. (Single file)</p>
            </label>
            {formState.documents.length > 0 && (
            <div className="mt-4 space-y-2">
                <p className="text-sm font-medium text-foreground">Selected file:</p>
                <ul className="space-y-1 max-h-40 overflow-y-auto rounded-md border p-2">
                {formState.documents.slice(0, 1).map((file, index) => ( /* Show only first file if multiple selected */
                    <li key={index} className="flex items-center justify-between text-sm p-1.5 bg-muted/30 rounded">
                    <div className="flex items-center gap-2 truncate">
                        <FileIcon className="h-4 w-4 flex-shrink-0 text-muted-foreground" />
                        <span className="truncate flex-grow">{file.name}</span>
                        <span className="text-xs text-muted-foreground flex-shrink-0">({formatBytes(file.size)})</span>
                    </div>
                    <Button type="button" variant="ghost" size="icon" className="h-6 w-6 text-destructive hover:bg-destructive/10" onClick={() => removeDocument(index)} aria-label={`Remove ${file.name}`} >
                        <X className="h-4 w-4" />
                    </Button>
                    </li>
                ))}
                </ul>
                {formState.documents.length > 1 && ( <p className="text-xs text-amber-600">Note: Only the first selected file will be uploaded.</p> )}
            </div>
            )}
        </div>
      </div>

      <Separator className="mt-8"/>
      <div className="flex justify-between items-center pt-4 gap-4 flex-wrap">
         <Button type="button" variant="outline" onClick={isModal ? onClose : () => router.back()} disabled={isLoading}>
            <ArrowLeft className="mr-2 h-4 w-4" /> {isModal ? 'Cancel' : 'Back'}
         </Button>
         <Button type="submit" disabled={!isFormValid() || isLoading || !isClerkLoaded} className="min-w-[120px]">
            {isLoading ? ( <Loader2 className="mr-2 h-4 w-4 animate-spin" /> ) : ( <Save className="mr-2 h-4 w-4" /> )}
            {isLoading ? (contractId ? 'Updating...' : 'Creating...') : (contractId ? 'Update Contract' : 'Create Contract')}
         </Button>
      </div>
    </form>
  );

  const vendorSearchDialog = (
    <Dialog open={showVendorSearch} onOpenChange={setShowVendorSearch}>
      <DialogContent className="sm:max-w-[425px] bg-background">
        <DialogHeader> <DialogTitle>Select Vendor</DialogTitle> <DialogDescription>Search for an existing vendor.</DialogDescription> </DialogHeader>
        <div className="space-y-4 py-4">
          <div className="relative">
            <Search className="absolute left-2.5 top-2.5 h-4 w-4 text-muted-foreground" />
            <Input placeholder="Search by name..." value={vendorSearchQuery} onChange={(e) => setVendorSearchQuery(e.target.value)} className="pl-8" />
          </div>
          <div className="max-h-60 overflow-y-auto border rounded-md bg-card">
            {isLoadingVendors ? ( <div className="p-4 text-center text-muted-foreground">Loading vendors...</div> )
             : (filteredVendors && filteredVendors.length > 0) ? (
              filteredVendors.map((vendor: VendorType) => ( 
                <button type="button" key={vendor._id.toString()} className="flex items-center justify-between w-full p-3 text-left hover:bg-muted/50 cursor-pointer border-b last:border-0" onClick={() => selectVendor(vendor._id.toString())} >
                  <div> <p className="font-medium text-sm">{vendor.name}</p> </div>
                  {formState.vendorId === vendor._id.toString() && ( <Check className="ml-auto h-4 w-4 text-green-600 flex-shrink-0" /> )}
                </button>
              ))
            ) : ( <div className="p-4 text-center text-muted-foreground"> {vendorSearchQuery ? 'No vendors found.' : 'No vendors available.'} </div> )}
          </div>
        </div>
        <DialogFooter className="flex-col sm:flex-row sm:justify-between gap-2">
          <Button variant="outline" onClick={() => { console.log("TODO: Implement New Vendor Form/Modal"); setShowVendorSearch(false); }}>
            <Plus className="mr-2 h-4 w-4" /> New Vendor (Not Implemented)
          </Button>
          <Button variant="ghost" onClick={() => setShowVendorSearch(false)}>Close</Button>
        </DialogFooter>
      </DialogContent>
    </Dialog>
  );

  // --- Final Render Logic ---
  if (initialDataLoading && !isModal) {
    return (
      <div className="flex items-center justify-center p-10 min-h-[300px] bg-background rounded-lg">
        <Loader2 className="h-8 w-8 animate-spin text-primary" />
        <p className="ml-3 text-muted-foreground">Loading form data...</p>
      </div>
    );
  }

  if (contractId && contractError) {
    return (
      <Alert variant="destructive" className="m-4">
        <AlertCircle className="h-4 w-4" /> <AlertTitle>Error Loading Contract Data</AlertTitle> <AlertDescription>{contractError.message}</AlertDescription>
      </Alert>
    );
  }
  if (isModal) {
    return (
      <>
        {initialDataLoading && (
             <div className="flex items-center justify-center p-10 min-h-[200px]">
                <Loader2 className="h-6 w-6 animate-spin text-primary" /> <p className="ml-2 text-muted-foreground">Loading...</p>
            </div>
        )}
        {!initialDataLoading && formContent}
        {vendorSearchDialog}
      </>
    );
  }

  return (
    <div className="max-w-4xl mx-auto py-8 px-4">
      <Card className="bg-card shadow-md">
        <CardHeader>
          <CardTitle className="text-2xl"> {contractId ? 'Edit Contract' : 'Create New Contract'} </CardTitle>
          <CardDescription> {contractId ? 'Update the details of the existing contract.' : 'Fill in the details to create a new contract.'} </CardDescription>
        </CardHeader>
        <CardContent className="p-6">
          {!isClerkLoaded && <div className="flex items-center justify-center p-4"><Loader2 className="h-5 w-5 animate-spin text-muted-foreground mr-2"/>Loading user data...</div>}
          {isClerkLoaded && !enterpriseIdFromClerk && !contractId && ( // Show warning if enterpriseId is missing for new contracts
            <Alert variant="destructive" className="mb-4">
              <AlertCircle className="h-4 w-4" />
              <AlertTitle>Enterprise Information Missing</AlertTitle>
              <AlertDescription>
                Your enterprise ID could not be determined from your user profile.
                Please ensure this is set up correctly in your Clerk user public metadata.
                You will not be able to create new contracts without it.
              </AlertDescription>
            </Alert>
          )}
          {formContent}
        </CardContent>
      </Card>
      {vendorSearchDialog}
    </div>
  );
};

export default ContractForm;
</file>

<file path="src/app/_components/homepage/Features.tsx">
"use client";

import { Shield, FileText, Users, BarChart2, Bot, Brain, Zap, Eye } from "lucide-react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Container } from "@/app/_components/common/Container";
import React from 'react';
import { cn } from "@/lib/utils";

const features = [
  {
    icon: <Bot className="h-10 w-10" />,
    title: "AI Agent Automation",
    description:
      "Deploy autonomous AI agents for contract analysis, risk assessment, compliance monitoring, and workflow orchestration.",
  },
  {
    icon: <Brain className="h-10 w-10" />,
    title: "Intelligent Contract Analysis",
    description:
      "Advanced AI analyzes contract content, extracts key terms, identifies risks, and provides actionable insights in real-time.",
  },
  {
    icon: <Shield className="h-10 w-10" />,
    title: "Enterprise-Grade Security",
    description:
      "Secure document management with role-based access control, encryption, and comprehensive audit trails.",
  },
  {
    icon: <FileText className="h-10 w-10" />,
    title: "Smart Contract Management",
    description:
      "Create, upload, and manage contracts with AI-powered templating, automated redlining, and intelligent categorization.",
  },
  {
    icon: <Users className="h-10 w-10" />,
    title: "Vendor Intelligence",
    description:
      "AI-driven vendor risk assessment, performance monitoring, and relationship optimization for better partnerships.",
  },
  {
    icon: <BarChart2 className="h-10 w-10" />,
    title: "Advanced Analytics",
    description:
      "Real-time dashboards, predictive insights, and automated reporting powered by AI agents working around the clock.",
  },
  {
    icon: <Zap className="h-10 w-10" />,
    title: "Workflow Automation",
    description:
      "Intelligent automation of approval processes, notifications, renewals, and compliance checks with minimal human intervention.",
  },
  {
    icon: <Eye className="h-10 w-10" />,
    title: "Risk Monitoring",
    description:
      "Continuous AI monitoring for contract compliance, regulatory changes, and potential risks with automated alerts.",
  },
];

export const Features = () => {
  return (
    <section className="relative bg-gradient-to-t from-slate-50/50 to-transparent">
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        <div className="absolute bottom-0 right-1/4 w-1/3 h-1/3 bg-gradient-to-tl from-gold/5 to-transparent animate-gentle-pulse" />
        <div className="absolute top-1/3 left-0 w-1/4 h-1/4 bg-gradient-to-tr from-primary/5 to-transparent animate-gentle-pulse animation-delay-2000" />
      </div>

      <Container className="py-16 sm:py-24 relative z-10">
        <div className="mb-20 flex flex-col items-center">
          <div className="mb-8 flex items-center justify-center">
            <span className="h-px w-8 bg-gold mx-4"></span>
            <span className="text-sm uppercase tracking-widest font-medium text-gradient-gold">AI-Powered Capabilities</span>
            <span className="h-px w-8 bg-gold mx-4"></span>
          </div>
          
          <h2 className="text-4xl font-bold tracking-tight text-primary font-serif sm:text-5xl md:text-6xl text-center max-w-3xl">
            Revolutionize Your Workflow with{" "}
            <span className="relative inline-block ml-2 text-gold text-gradient-gold">
              Intelligent Automation
              <span className="absolute -bottom-2.5 left-0 right-0 h-1 bg-gradient-to-r from-transparent via-gold/60 to-transparent"></span>
            </span>
          </h2>
          
          <p className="mt-8 max-w-2xl text-center text-muted-foreground font-light text-lg">
            Experience next-generation contract management powered by autonomous AI agents that work 24/7 
            to analyze, monitor, and optimize your contracts.
          </p>
        </div>

        <div className="mb-20 p-10 bg-gradient-to-br from-primary/5 via-transparent to-gold/5 rounded-xl border border-gold/15 shadow-elegant">
          <div className="text-center mb-10">
            <h3 className="text-3xl font-bold text-primary mb-3">Meet Your AI Agents</h3>
            <p className="text-muted-foreground text-base">Autonomous agents synergizing to elevate your contract management.</p>
          </div>
          <div className="grid grid-cols-1 md:grid-cols-3 gap-8">
            {[
              { icon: <Bot className="w-10 h-10 text-gradient-gold" />, title: "Financial Agent", desc: "Analyzes costs, identifies savings, and monitors financial compliance with precision." },
              { icon: <Shield className="w-10 h-10 text-primary" />, title: "Legal Agent", desc: "Reviews contracts for legal compliance, risk assessment, and regulatory alignment meticulously." },
              { icon: <BarChart2 className="w-10 h-10 text-gradient-gold" />, title: "Analytics Agent", desc: "Generates insights, tracks KPIs, and provides predictive analytics for strategic decision making." }
            ].map((agent, idx) => (
              <div key={idx} className="text-center">
                <div className="w-20 h-20 bg-card/50 border border-gold/20 rounded-full flex items-center justify-center mx-auto mb-5 shadow-luxury-sm group hover:bg-gold/10 transition-all duration-300 transform group-hover:scale-105">
                  {React.cloneElement(agent.icon, { className: cn(agent.icon.props.className, "transform transition-transform duration-300 group-hover:scale-110") })}
                </div>
                <h4 className="font-semibold text-xl text-primary mb-2">{agent.title}</h4>
                <p className="text-sm text-muted-foreground px-2">{agent.desc}</p>
              </div>
            ))}
          </div>
        </div>

        <div className="grid grid-cols-1 gap-8 md:gap-10 sm:grid-cols-2 lg:grid-cols-4">
          {features.map((feature, index) => (
            <Card
              key={index}
              className={cn(
                "transition-all duration-300 border border-gold/10 bg-card shadow-elegant group relative overflow-hidden",
                "transform hover:-translate-y-2 hover:shadow-card-hover-gold" 
              )}
              style={{ transformStyle: "preserve-3d" }}
            >
              <CardHeader className="pb-4">
                <div className="mb-4 p-3 bg-primary/5 rounded-lg inline-block group-hover:bg-gold/10 transition-colors duration-300 transform group-hover:scale-105">
                  {React.cloneElement(feature.icon, { className: "h-10 w-10 text-gradient-gold transition-transform duration-300 group-hover:scale-110" })}
                </div>
                <CardTitle className="text-xl font-serif text-primary group-hover:text-gradient-gold transition-colors duration-300">
                  {feature.title}
                </CardTitle>
              </CardHeader>
              <CardContent>
                <p className="text-sm text-muted-foreground leading-relaxed">
                  {feature.description}
                </p>
                <div className="mt-6 h-px w-12 bg-gradient-to-r from-gold/40 to-transparent group-hover:w-full transition-all duration-500 ease-out"></div>
              </CardContent>
            </Card>
          ))}
        </div>

        <div className="mt-20 text-center">
          <p className="text-base text-muted-foreground mb-6">Powered by cutting-edge AI technology</p>
          <div className="flex flex-wrap justify-center gap-x-6 gap-y-3 text-sm">
            {["Machine Learning", "Natural Language Processing", "Autonomous Agents", "Predictive Analytics"].map((tech, idx) => (
                <span key={idx} className="px-4 py-2 bg-background/60 backdrop-blur-sm rounded-full border border-gold/20 text-primary/80 hover:shadow-luxury-sm transition-all duration-300 transform hover:scale-105 cursor-default">
                    {tech}
                </span>
            ))}
          </div>
        </div>
      </Container>
    </section>
  );
};

export default Features;
</file>

<file path="src/app/_components/homepage/Hero.tsx">
"use client";

import { ArrowRight, Bot, Zap, Shield } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Container } from "@/app/_components/common/Container";

export const Hero = () => {
  return (
    <div className="relative pt-24 pb-20 md:pt-32 md:pb-28 bg-gradient-to-b from-slate-50 to-transparent overflow-hidden">
      <div className="absolute inset-0 overflow-hidden pointer-events-none">
        {/* Kept subtle background animations for "life" */}
        <div className="absolute top-0 right-0 w-1/3 h-1/3 bg-gradient-to-br from-gold/10 to-transparent animate-gentle-pulse" />
        <div className="absolute bottom-0 left-0 w-1/4 h-1/4 bg-gradient-to-tr from-primary/5 to-transparent animate-gentle-pulse animation-delay-2000" />
        <div className="absolute top-1/4 left-1/3 w-1 h-16 bg-gold/30 animate-float" />
        <div className="absolute top-1/2 right-1/4 w-24 h-1 bg-gold/20 animate-float animation-delay-2000" />
      </div>

      <Container className="relative z-10">
        <div className="flex flex-col items-center text-center">
          <div className="mb-6 flex items-center justify-center">
            <span className="h-px w-8 bg-gold mx-3"></span>
            <span className="text-sm uppercase tracking-widest font-medium text-gradient-gold">AI-Powered Solutions</span>
            <span className="h-px w-8 bg-gold mx-3"></span>
          </div>

          <h1 className="max-w-5xl text-4xl font-bold tracking-tight text-primary sm:text-6xl md:text-7xl font-serif">
            Transform Your{" "}
            <span className="relative inline-block text-gold text-gradient-gold">
              Contract Management
              <span className="absolute -bottom-2 left-0 right-0 h-px bg-gradient-to-r from-transparent via-gold/70 to-transparent"></span>
            </span>
            {" "}<br className="hidden sm:inline" />
            with AI Agents{" "}
          </h1>

          <p className="mt-8 max-w-3xl text-lg leading-8 text-muted-foreground md:text-xl font-light">
            Experience the future of contract management with autonomous AI agents that handle analysis, 
            compliance monitoring, risk assessment, and workflow automationwhile you focus on strategy.
          </p>

          <div className="mt-10 flex flex-wrap justify-center gap-4 text-sm">
            <div className="flex items-center gap-2 bg-white/50 backdrop-blur-sm rounded-full px-4 py-2 border border-gold/20 hover:shadow-luxury-sm transition-shadow duration-300">
              <Bot className="w-4 h-4 text-gold" /> {/* text-gold will be standard, not gradient here unless you add text-gradient-gold */}
              <span className="text-primary/80">Autonomous AI Agents</span>
            </div>
            <div className="flex items-center gap-2 bg-white/50 backdrop-blur-sm rounded-full px-4 py-2 border border-gold/20 hover:shadow-luxury-sm transition-shadow duration-300">
              <Zap className="w-4 h-4 text-gold" />
              <span className="text-primary/80">Real-time Analysis</span>
            </div>
            <div className="flex items-center gap-2 bg-white/50 backdrop-blur-sm rounded-full px-4 py-2 border border-gold/20 hover:shadow-luxury-sm transition-shadow duration-300">
              <Shield className="w-4 h-4 text-gold" />
              <span className="text-primary/80">Risk Monitoring</span>
            </div>
          </div>

          <div className="mt-8 flex flex-col sm:flex-row items-center gap-y-4 gap-x-8">
            <Button 
              variant="outline"
              size="lg" 
              className="group bg-primary hover:bg-primary/90 text-gold px-8 py-6 rounded-sm cursor-pointer shadow-luxury hover:shadow-luxury-lg transition-all duration-300 transform hover:scale-105"
            >
              Get Started
              <ArrowRight className="ml-2 h-4 w-4 transition-transform group-hover:translate-x-1" />
            </Button>           
          </div>
        </div>
      </Container>
    </div>
  );
};
</file>

<file path="src/app/ConvexClientProvider.tsx">
"use client";

import { ReactNode, useEffect } from "react";
import { ConvexReactClient } from "convex/react";
import { ClerkProvider, useAuth } from "@clerk/nextjs";
import { ConvexProviderWithClerk } from "convex/react-clerk";
import { performanceTracker, userAnalytics, errorTracker, healthMonitor } from "@/lib/monitoring";

// Initialize the Convex client
const convexUrl = process.env.NEXT_PUBLIC_CONVEX_URL;
if (!convexUrl) {
  throw new Error("Missing NEXT_PUBLIC_CONVEX_URL environment variable");
}

const convex = new ConvexReactClient(convexUrl);

// Monitoring wrapper component
function MonitoringProvider({ children }: { children: ReactNode }) {
  useEffect(() => {
    // Initialize monitoring when the app starts
    if (typeof window !== 'undefined') {
      // Set up global convex analytics object for monitoring integration
      (window as any).convexAnalytics = {
        logEvent: (event: string, properties: Record<string, any>) => {
          userAnalytics.track(event, properties);
        },
        logEventBatch: (events: Array<{ event: string; properties: Record<string, any> }>) => {
          events.forEach(({ event, properties }) => {
            userAnalytics.track(event, properties);
          });
        },
        reportError: (errorData: Record<string, any>) => {
          errorTracker.captureError(new Error(errorData.message), errorData);
        },
        getHealthStatus: () => {
          return {
            status: healthMonitor.isHealthy() ? 'healthy' : 'unhealthy',
            checks: healthMonitor.getHealthStatus(),
          };
        },
      };

      // Track initial page load
      userAnalytics.track('app_loaded', {
        url: window.location.href,
        timestamp: Date.now(),
      });

      // Clean up on unmount
      return () => {
        healthMonitor.destroy();
        userAnalytics.flush();
      };
    }
  }, []);

  return <>{children}</>;
}

export function ConvexClientProvider({
  children,
}: {
  children: ReactNode;
}) {
  return (
    <ClerkProvider
      publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}
    >
      <ConvexProviderWithClerk client={convex} useAuth={useAuth}>
        <MonitoringProvider>
          {children}
        </MonitoringProvider>
      </ConvexProviderWithClerk>
    </ClerkProvider>
  );
}
</file>

<file path="src/types/contract.types.ts">
// src/types/contract.types.ts
import { Id } from "../../convex/_generated/dataModel";
// --- IMPORT VendorType AND VendorCategory from vendor.types.ts ---
import { VendorType, VendorCategory, vendorCategoryOptions } from "./vendor.types";

// Contract status options from the schema (already defined)
export type ContractStatus =
  | "draft"
  | "pending_analysis"
  | "active"
  | "expired"
  | "terminated"
  | "archived";

// Analysis status options from the schema (already defined)
export type AnalysisStatus =
  | "pending"
  | "processing"
  | "completed"
  | "failed";

// --- Define Contract Type Options (mirroring schema.ts for frontend use) ---
export const contractTypeOptions = [
  "nda", "msa", "sow", "saas", "lease", "employment", "partnership", "other"
] as const;
export type ContractTypeEnum = typeof contractTypeOptions[number];

// Main contract type aligned with the Convex schema
export type ContractType = {
  _id: Id<"contracts">; // Convex ID
  _creationTime?: number; // Convex automatic timestamp

  // Link to an enterprise
  enterpriseId: Id<"enterprises">; // This should be in your schema

  // Core Contract Info
  title: string;
  vendorId: Id<"vendors">;
  status: ContractStatus;

  // Contract Type field
  contractType?: ContractTypeEnum;

  // File Information
  storageId: Id<"_storage">;
  fileName: string;
  fileType: string;

  // Extracted Information (all optional since they might not be available)
  extractedParties?: string[];
  extractedStartDate?: string;
  extractedEndDate?: string;
  extractedPaymentSchedule?: string;
  extractedPricing?: string;
  extractedScope?: string;

  // Analysis Process Tracking
  analysisStatus?: AnalysisStatus;
  analysisError?: string;

  // Optional user notes
  notes?: string;

  // Not in the schema but added by the getContracts query for UI display
  // VendorType itself might now contain its category.
  vendor?: VendorType; // VendorType is imported and should include its category

  // Review and reconcile these fields with your actual Convex schema for 'contracts'
  // contract_number?: string;
  // value?: number;
  // ... (other commented-out fields from your previous version)
};


// Form data for contract creation/editing
export interface ContractFormData {
  title: string;
  vendorId: string; // String representation of the Id (usually from a select input)
  contractType?: ContractTypeEnum;
  notes?: string;
  file?: File; // For uploading the contract document
  // Optional: if you allow manual setting of these during form submission
  extractedStartDate?: Date | null;
  extractedEndDate?: Date | null;
}

// Vendor form data
export interface VendorFormData {
  name: string;
  contactEmail?: string;
  contactPhone?: string;
  address?: string;
  notes?: string;
  website?: string;
  // Use the imported VendorCategory type
  category?: VendorCategory;
}
</file>

<file path="PACTWISE.md">
# PACTWISE - Enterprise Contract & Vendor Management Platform

> **AI-Powered Contract Intelligence for Modern Enterprises**

##  Executive Summary

**PactWise** is a comprehensive enterprise-grade contract and vendor management platform that transforms how organizations handle their contractual relationships. By combining traditional document repository functionality with advanced AI-powered insights, real-time collaboration, and automated workflows, PactWise addresses the critical challenges faced by legal, procurement, and operations teams in today's fast-paced business environment.

### The Problem We Solve

Modern enterprises struggle with:
- **Contract Chaos**: Scattered documents across emails, shared drives, and legacy systems
- **Manual Processing**: Time-intensive contract review, analysis, and compliance monitoring
- **Risk Blindness**: Missed renewal dates, compliance violations, and hidden liabilities
- **Vendor Fragmentation**: Disconnected vendor relationships and performance tracking
- **Security Concerns**: Inadequate access controls and audit trails for sensitive documents

### Our Solution

PactWise provides:
- **Centralized Intelligence Hub**: AI-powered contract repository with automated analysis
- **Proactive Risk Management**: Real-time alerts, compliance monitoring, and predictive insights
- **Streamlined Workflows**: Automated approval processes and collaborative review tools
- **Vendor Ecosystem Management**: Comprehensive relationship tracking and performance analytics
- **Enterprise Security**: Multi-layered security with audit trails and role-based access

---

##  Technical Architecture

### System Overview

```

                        PACTWISE PLATFORM                        

  Frontend Layer (Next.js 15 + React 19 + TypeScript)          
     
   Dashboard     Contracts     Vendors       Analytics   
   Components    Management    Management    & Reports   
     

  API Layer (Convex Real-time Backend)                          
     
   GraphQL-      Real-time     File          Security    
   style API     Subscriptions  Management    Framework   
     

  AI Agent System (Autonomous Contract Intelligence)            
     
   Analytics     Legal         Financial     Manager     
   Agent         Agent         Agent         Agent       
     

  Data Layer (Convex Database + File Storage)                   
     
   Multi-tenant  Real-time     File          Audit &     
   Database      Events        Storage       Security    
     

```

### Technology Stack

**Frontend:**
- **Framework**: Next.js 15 with App Router
- **UI Library**: React 19 with TypeScript
- **Styling**: Tailwind CSS + shadcn/ui components
- **State Management**: Convex real-time hooks
- **Charts**: Recharts for analytics visualization
- **File Upload**: Custom drag-and-drop with progress tracking

**Backend:**
- **Database**: Convex (Real-time serverless database)
- **Authentication**: Clerk (Multi-tenant auth with RBAC)
- **File Storage**: Convex native file storage
- **Real-time**: Native Convex subscriptions
- **Security**: Custom row-level security framework

**Infrastructure:**
- **Deployment**: Vercel (Frontend) + Convex Cloud (Backend)
- **Monitoring**: Built-in Convex dashboard + custom metrics
- **CDN**: Global edge network for file delivery

---

##  Frontend Architecture

### Component Structure

```
src/app/
 _components/                 # Reusable UI components
    agents/                 # AI Agent system components
       AgentCard.tsx
       AgentLogViewer.tsx
       AgentSystemStatus.tsx
       InsightCard.tsx
    analytics/              # Dashboard analytics widgets
       AdvancedKPICard.tsx
       AnalyticsDashboard.tsx
       ContractAnalyticsSection.tsx
       DateRangePicker.tsx
       DepartmentPerformanceSection.tsx
       DrillDownModal.tsx
       InteractiveChart.tsx
       KPISection.tsx
       RiskAndComplianceSection.tsx
    auth/                   # Authentication & authorization
       PermissionGate.tsx
       UnauthorizedPage.tsx
    common/                 # Shared utilities & core components
       BulkActions.tsx
       Container.tsx
       CustomToolTip.tsx
       DocumentViewer.tsx
       DynamicCharts.tsx
       EmptyStates.tsx
       ErrorBoundary.tsx
       ExportOptions.tsx
       GlobalErrorHandler.tsx
       LoadingSpinner.tsx
       LoadingStates.tsx
       Logo.tsx
       MetricCard.tsx
       NotificationCenter.tsx
       ToastNotifications.tsx
    contracts/              # Contract management
       ContractDetails.tsx
       ContractForm.tsx
       ContractFormModal.tsx
       ContractTable.tsx
       NewContractButton.tsx
    dashboard/              # Dashboard layout
       DashboardContent.tsx
       GlobalSearch.tsx
       Header.tsx
       SideNavigation.tsx
    homepage/               # Landing page
       Benefits.tsx
       Features.tsx
       Footer.tsx
       Hero.tsx
       Navigation.tsx
    mobile/                 # Mobile-optimized components
       MobileCard.tsx
       MobileNavigation.tsx
    onboarding/             # User onboarding flow
       AccountTypeStep.tsx
       CompleteOnboardingStep.tsx
       CreateEnterpriseStep.tsx
       EnterpriseConfigStep.tsx
       FirstContractStep.tsx
       InviteTeamStep.tsx
       OnboardingFlowManager.tsx
       ProfileSetupStep.tsx
    search/                 # Advanced search & discovery
       AdvancedFilters.tsx
       GlobalSearch.tsx
       SearchResults.tsx
    vendor/                 # Vendor management
       VendorTable.tsx
    workflow/               # Workflow automation & approvals
        ApprovalQueue.tsx
        WorkflowDesigner.tsx
        WorkflowStatus.tsx
 dashboard/                  # Main application routes
    analytics/page.tsx
    contracts/
       active/page.tsx
       archived/page.tsx
       drafts/page.tsx
       edit/[id]/page.tsx
       expired/page.tsx
       new/page.tsx
       pending/page.tsx
       page.tsx
    profile/page.tsx
    vendors/
       active/page.tsx
       inactive/page.tsx
       page.tsx
    page.tsx               # Main dashboard
 auth/                      # Authentication pages
    sign-in/page.tsx
    sign-up/page.tsx
 invite/[token]/page.tsx    # Team invitation handling
```

### Key Frontend Features

** Advanced Dashboard:**
- Real-time contract status monitoring with live updates
- Interactive analytics charts with Recharts and drill-down capabilities
- Advanced KPI tracking and department performance metrics
- Responsive design optimized for all device sizes

** Intelligent Search & Discovery:**
- Global search with command bar interface (Cmd/Ctrl+K)
- Advanced filtering with saved filters and quick presets
- Real-time search suggestions and recent searches
- Unified search results with multiple view modes (grid/list/compact)
- Faceted search across contracts, vendors, users, and documents

** Contract & Document Management:**
- Professional data tables with sorting, filtering, and pagination
- Multi-format document viewer (PDF, images, text) with zoom and controls
- Drag-and-drop file upload with progress tracking
- Export functionality (PDF, Excel, CSV) with bulk operations
- Version control and collaborative editing capabilities

** Workflow Automation:**
- Visual workflow designer with drag-and-drop interface
- Approval queue dashboard with filtering and bulk actions
- Real-time workflow status tracking with progress indicators
- Multi-stage approval processes with escalation rules
- Automated notifications and deadline management

** Mobile Experience:**
- Touch-optimized navigation with bottom tab bar
- Mobile-responsive data cards for all entity types
- Slide-out menu with user profile and quick actions
- Floating action buttons for common tasks
- Optimized layouts for contract, vendor, and workflow management

** Production-Ready Components:**
- Comprehensive error handling with error boundaries
- Centralized error management and reporting
- Toast notifications for user feedback
- Loading states and empty state handling
- Role-based permission gates and access control

** User Experience:**
- Guided onboarding flow for new users and enterprises
- Role-based UI customization and feature access
- Real-time notifications and alert center
- Keyboard shortcuts and accessibility features
- Bulk operations and selection management

---

##  Backend Architecture

### Database Schema

```typescript
// Core Entities
interface Enterprise {
  _id: Id<"enterprises">;
  name: string;
  domain?: string;
  industry?: string;
  size?: "1-10" | "11-50" | "51-200" | "201-500" | "501-1000" | "1000+";
  contractVolume?: "low" | "medium" | "high" | "enterprise";
  primaryUseCase?: string[];
}

interface User {
  _id: Id<"users">;
  clerkId: string;
  email: string;
  firstName?: string;
  lastName?: string;
  enterpriseId: Id<"enterprises">;
  role: "owner" | "admin" | "manager" | "user" | "viewer";
  isActive?: boolean;
  lastLoginAt?: string;
  department?: string;
  title?: string;
  createdAt: string;
}

interface Contract {
  _id: Id<"contracts">;
  enterpriseId: Id<"enterprises">;
  vendorId: Id<"vendors">;
  title: string;
  status: "draft" | "pending_approval" | "active" | "expired" | "terminated";
  contractType?: "service" | "software" | "consulting" | "maintenance" | "other";
  
  // File management
  storageId: Id<"_storage">;
  fileName: string;
  fileType: string;
  
  // User-provided details
  value?: number;
  startDate?: string;
  endDate?: string;
  
  // AI-extracted data
  extractedParties?: string[];
  extractedStartDate?: string;
  extractedEndDate?: string;
  extractedPaymentSchedule?: string;
  extractedPricing?: string;
  extractedScope?: string;
  
  // Analysis status
  analysisStatus?: "pending" | "processing" | "completed" | "failed";
  analysisError?: string;
  notes?: string;
  createdAt: string;
}

interface Vendor {
  _id: Id<"vendors">;
  enterpriseId: Id<"enterprises">;
  name: string;
  contactEmail?: string;
  contactPhone?: string;
  address?: string;
  website?: string;
  category?: "technology" | "consulting" | "manufacturing" | "services" | "other";
  status?: "active" | "inactive";
  notes?: string;
  createdAt: string;
}
```

### API Architecture

**Query Pattern:**
```typescript
// Real-time dashboard data
api.analytics.getDashboardSummary()      // Contract/vendor overview
api.analytics.getRecentActivity()        // Timeline of recent changes
api.analytics.getUpcomingDeadlines()     // Expiring contracts alerts

// Contract operations
api.contracts.getContracts()             // Filtered contract lists
api.contracts.getContractById()          // Individual contract details
api.contracts.createContract()           // New contract creation
api.contracts.updateContract()           // Contract modifications
api.contracts.triggerContractAnalysis()  // Manual AI analysis

// Vendor management
api.vendors.getVendors()                 // Vendor directory
api.vendors.createVendor()               // New vendor onboarding
api.vendors.updateVendor()               // Vendor information updates

// User & enterprise management
api.users.getCurrentUser()               // Current user profile
api.users.getEnterpriseUsers()           // Team member list
api.enterprises.getEnterpriseByDomain()  // Enterprise lookup
```

**Real-time Subscriptions:**
```typescript
// Live dashboard updates
const dashboardData = useQuery(api.analytics.getDashboardSummary);
const recentActivity = useQuery(api.analytics.getRecentActivity);

// Notification system
const notifications = useQuery(api.notifications.getMyNotifications);
const unreadCount = useQuery(api.notifications.getUnreadCount);

// Collaborative features
const presence = useQuery(api.presence.getActiveUsers);
const typingIndicators = useQuery(api.realtime.getTypingIndicators);
```

### Performance Optimizations

**Database Indexes (12 critical indexes added):**
```typescript
// Contracts table - optimized for enterprise-scale queries
.index("by_enterprise_created_desc", ["enterpriseId", "_creationTime"])
.index("by_enterprise_status_endDate", ["enterpriseId", "status", "extractedEndDate"])
.index("by_enterprise_title_status", ["enterpriseId", "title", "status"])
.index("by_enterprise_vendor_status", ["enterpriseId", "vendorId", "status"])

// Expected performance improvements:
// - Dashboard queries: 99.6% faster (5000ms  20ms)
// - Search operations: 99.3% faster (2000ms  15ms)
// - Real-time notifications: 98.4% faster (500ms  8ms)
```

---

##  Security Implementation

### Multi-Layered Security Architecture

```

                     SECURITY LAYERS                             

 1. Authentication Layer (Clerk)                                 
     Multi-tenant user management                             
     SSO and OAuth providers                                  
     Session management and tokens                            

 2. Authorization Layer (RBAC)                                   
     Role-based permissions (5 levels)                        
     Resource-level access control                            
     Enterprise data isolation                                

 3. Data Layer Security                                          
     Row-level security filters                               
     Encrypted data transmission                              
     Secure file storage                                      

 4. API Security                                                 
     Rate limiting and DDoS protection                        
     Input validation and sanitization                        
     Secure mutation wrappers                                 

 5. Audit & Monitoring                                           
     Comprehensive audit logging                              
     Real-time security monitoring                            
     Compliance reporting                                     

```

### Role-Based Access Control

| Role | Level | Permissions | Use Case |
|------|-------|-------------|----------|
| **Owner** | 5 | Full system access, billing, enterprise settings | C-Suite, IT Directors |
| **Admin** | 4 | User management, all CRUD operations, settings | Legal Directors, Operations Managers |
| **Manager** | 3 | Team oversight, contract/vendor management | Department Heads, Senior Staff |
| **User** | 2 | Create and edit own content, view team data | Contract Analysts, Procurement Staff |
| **Viewer** | 1 | Read-only access to assigned content | Auditors, External Consultants |

### Security Framework

**Secure Wrappers:**
```typescript
// All mutations wrapped with security checks
export const createContract = createSecureMutation(
  { /* args schema */ },
  {
    rateLimit: { operation: "contract.create", cost: 2 },
    audit: { operation: "createContract", resourceType: "contracts", action: "create" },
    permission: "contracts.create"
  },
  async (ctx, args, security, secure) => {
    // Enterprise-isolated operations with automatic audit logging
  }
);
```

**Row-Level Security:**
```typescript
// Automatic enterprise data isolation
export class SecureQuery<T> {
  async all(): Promise<T[]> {
    return await this.ctx.db
      .query(this.table)
      .filter(q => q.eq(q.field("enterpriseId"), this.securityContext.enterpriseId))
      .collect();
  }
}
```

---

##  AI Agent System

### Agent Architecture

```

                        AI AGENT ECOSYSTEM                       

  Manager Agent (Orchestration & Coordination)                   
   
    Task prioritization and scheduling                        
    Resource allocation across agents                         
    Cross-agent communication and data sharing              
    Quality assurance and validation                         
   

  Specialized Agents                                             
      
   Analytics     Legal         Financial     Notification 
   Agent         Agent         Agent         Agent        
                                                          
    KPI calc     Risk         Cost         Alert      
    Trends        analysis      analysis      generation 
    Reports      Compliance   Budget       Escalation 
    Insights     Legal         tracking     Scheduling 
                   review       Forecasts                
      

```

### Agent Capabilities

**Analytics Agent:**
- Contract performance metrics and KPI calculations
- Vendor relationship analysis and scoring
- Usage pattern detection and optimization recommendations
- Custom report generation and data visualization

**Legal Agent:**
- Contract risk assessment and compliance checking
- Legal clause analysis and standard compliance
- Renewal and termination deadline tracking
- Regulatory compliance monitoring

**Financial Agent:**
- Cost analysis and budget impact assessment
- Payment schedule optimization
- ROI calculations and financial forecasting
- Vendor spend analysis and cost reduction opportunities

**Notification Agent:**
- Intelligent alert prioritization and scheduling
- Multi-channel notification delivery
- Escalation rule management
- Personalized notification preferences

---

##  User Management & Permissions

### Enterprise Onboarding Flow

```
1. Account Creation
    Email verification
    Initial role assignment
    Enterprise association

2. Enterprise Setup
    Company profile creation
    Industry and size configuration
    Use case identification
    Initial team invitations

3. Configuration
    Role and permission setup
    Notification preferences
    Integration configuration
    Security policy definition

4. Initial Content
    First contract upload
    Vendor directory setup
    Team member onboarding
    Workflow customization
```

### Team Management

**Invitation System:**
- Secure token-based invitations with expiration
- Role-based access assignment during invitation
- Bulk team member invitations
- External collaborator temporary access

**User Lifecycle:**
- Automated onboarding with role-specific guidance
- Progressive feature introduction
- Activity tracking and engagement metrics
- Graceful offboarding with data retention policies

---

##  Analytics & Reporting

### Dashboard Metrics

**Contract Analytics:**
- Total contract value and distribution
- Contract status breakdown and trends
- Average contract lifecycle duration
- Renewal success rates and patterns

**Vendor Performance:**
- Vendor relationship scores and ratings
- Spend analysis by category and time period
- Vendor risk assessment and compliance status
- Performance benchmarking and comparisons

**Risk Management:**
- Upcoming contract expirations and renewals
- Compliance violations and risk indicators
- Financial exposure and budget variance
- Legal risk assessment and mitigation status

**Operational Efficiency:**
- Contract processing time metrics
- User productivity and engagement stats
- System utilization and performance indicators
- Process bottleneck identification

### Real-time Insights

**Proactive Alerts:**
- Contract expiration warnings (30/60/90 day notices)
- Budget threshold exceeded notifications
- Compliance violation alerts
- Vendor performance degradation warnings

**Trend Analysis:**
- Contract volume and value trends over time
- Vendor relationship evolution patterns
- Cost optimization opportunities
- Risk profile changes and implications

---

##  Development Status

###  Completed Features

**Core Platform:**
-  Multi-tenant enterprise architecture
-  Complete user authentication and authorization
-  Role-based access control (5 permission levels)
-  Enterprise data isolation and security
-  Comprehensive error handling framework
-  Production-ready component library

**Contract Management:**
-  Professional contract data tables with advanced features
-  File upload and storage system
-  Multi-format document viewer (PDF, images, text)
-  Contract metadata management
-  Status tracking and workflow management
-  Export functionality (PDF, Excel, CSV)
-  Bulk operations and selection management

**Vendor Management:**
-  Advanced vendor data tables with performance metrics
-  Vendor directory and profile management
-  Category-based organization and risk assessment
-  Contact information and relationship tracking
-  Integration with contract management
-  Compliance scoring and performance analytics

**Dashboard & Analytics:**
-  Real-time dashboard with advanced KPI cards
-  Interactive charts and visualizations with drill-down
-  Department performance tracking
-  Recent activity tracking
-  Upcoming deadline alerts
-  Risk and compliance monitoring

**Search & Discovery:**
-  Global search with command bar interface (Cmd/Ctrl+K)
-  Advanced filtering with saved filters and quick presets
-  Unified search results with multiple view modes
-  Real-time search suggestions and recent searches
-  Faceted search across all entity types

**Workflow Automation:**
-  Visual workflow designer with drag-and-drop interface
-  Approval queue dashboard with advanced filtering
-  Real-time workflow status tracking
-  Multi-stage approval processes
-  Progress indicators and timeline visualization
-  Automated notifications and escalation

**Mobile Experience:**
-  Touch-optimized navigation with bottom tab bar
-  Mobile-responsive data cards for all entity types
-  Slide-out menu with user profile and quick actions
-  Floating action buttons for common tasks
-  Mobile header components and navigation

**Security & Infrastructure:**
-  Comprehensive audit logging
-  Rate limiting and DDoS protection
-  Secure API wrappers and validation
-  Performance-optimized database indexes
-  Role-based permission gates
-  Centralized error management

**User Experience:**
-  Responsive design with shadcn/ui components
-  Guided onboarding flow for enterprises
-  Global search and advanced filtering
-  Real-time notifications center
-  Toast notifications for user feedback
-  Loading states and empty state handling
-  Bulk operations across all data types

###  In Progress

**AI Integration:**
-  Contract analysis framework (structure complete, AI models needed)
-  Agent system coordination (architecture ready, integration pending)
-  Intelligent insights generation (data pipeline established)

**Advanced Features:**
-  Integration with existing pages and components
-  Performance optimization and code splitting
-  Advanced testing framework implementation

###  Planned Features

**Q1 2025 - AI Implementation:**
-  Real AI contract analysis with GPT-4 integration
-  OCR and document text extraction
-  Intelligent contract clause identification
-  Automated compliance checking

**Q2 2025 - Enhanced Functionality:**
-  Advanced workflow automation
-  Third-party integrations (DocuSign, Salesforce, etc.)
-  Mobile applications (iOS/Android)
-  Advanced reporting and business intelligence

**Q3 2025 - Enterprise Features:**
-  AI-powered contract drafting assistance
-  Predictive risk modeling
-  Advanced vendor performance analytics
-  Custom workflow designer

**Q4 2025 - Platform Evolution:**
-  API marketplace for third-party integrations
-  White-label solutions for resellers
-  Advanced AI insights and recommendations
-  Industry-specific compliance modules

---

##  Deployment & Infrastructure

### Current Architecture

**Frontend Deployment:**
- **Platform**: Vercel with global CDN
- **Environment**: Production, staging, and development
- **Performance**: Edge caching and optimization
- **Monitoring**: Real-time performance metrics

**Backend Infrastructure:**
- **Database**: Convex Cloud with automatic scaling
- **File Storage**: Convex native storage with CDN
- **Authentication**: Clerk with multi-tenant support
- **Real-time**: Native Convex subscriptions

**Security & Compliance:**
- **Data Encryption**: End-to-end encryption in transit and at rest
- **Backup Strategy**: Automated daily backups with point-in-time recovery
- **Compliance**: SOC 2 Type II ready architecture
- **Monitoring**: Comprehensive logging and alerting

### Scaling Considerations

**Performance Targets:**
- **Query Response Time**: < 100ms for 95% of requests
- **File Upload Speed**: < 5 seconds for 10MB files
- **Real-time Updates**: < 200ms latency
- **Concurrent Users**: 10,000+ per enterprise

**Scaling Strategy:**
- **Database**: Convex auto-scaling with optimized indexes
- **File Storage**: Global CDN with edge caching
- **Compute**: Serverless functions with automatic scaling
- **Monitoring**: Proactive performance monitoring and alerting

---

##  Business Model & Market Position

### Target Market

**Primary Users:**
- **Legal Teams**: Contract review, compliance, and risk management
- **Procurement Departments**: Vendor management and cost optimization
- **Operations Teams**: Process automation and efficiency improvement
- **C-Suite Executives**: Strategic insights and risk visibility

**Enterprise Segments:**
- **Mid-Market (50-500 employees)**: Streamlined contract management
- **Enterprise (500+ employees)**: Advanced analytics and automation
- **Legal Firms**: Multi-client contract management
- **Consulting Companies**: Project-based contract tracking

### Competitive Advantages

**Technical Differentiators:**
- Real-time collaborative platform with instant updates
- AI-powered insights and automation capabilities
- Comprehensive security with enterprise-grade compliance
- Modern, intuitive user experience with mobile support

**Business Differentiators:**
- Rapid deployment and onboarding (< 24 hours)
- Flexible pricing model with transparent costs
- Industry-specific templates and workflows
- Dedicated customer success and support teams

### Market Opportunity

**Addressable Market:**
- **TAM**: $50B+ global contract management market
- **SAM**: $15B+ enterprise software solutions
- **SOM**: $2B+ AI-powered legal tech solutions

**Growth Drivers:**
- Increasing regulatory compliance requirements
- Digital transformation in legal and procurement
- Rising demand for AI-powered automation
- Remote work driving need for collaborative tools

---

##  Contributing & Development

### Development Environment Setup

**Prerequisites:**
```bash
# Required software
node >= 18.0.0
npm >= 9.0.0
git >= 2.30.0

# Optional but recommended
vscode with extensions:
  - TypeScript and JavaScript
  - Tailwind CSS IntelliSense
  - Convex extension
```

**Setup Instructions:**
```bash
# 1. Clone repository
git clone https://github.com/your-org/pactwise-fork.git
cd pactwise-fork

# 2. Install dependencies
npm install

# 3. Setup Convex backend
npx convex dev

# 4. Configure environment variables
cp .env.example .env.local
# Update with your Clerk and Convex credentials

# 5. Start development server
npm run dev
```

### Code Architecture Guidelines

**TypeScript Standards:**
- Strict type checking enabled
- Interface definitions for all data structures
- Generic types for reusable components
- Comprehensive error handling

**Component Patterns:**
- Functional components with hooks
- Custom hooks for business logic
- Compound component patterns for complex UI
- Consistent prop interface definitions

**State Management:**
- Convex for server state and real-time data
- React Context for app-wide client state
- Local state for component-specific data
- Optimistic updates for better UX

### Testing Strategy

**Current Testing:**
- Build-time TypeScript validation
- ESLint code quality checks
- Manual testing with staging environment

**Planned Testing:**
- Unit tests with Jest and React Testing Library
- Integration tests for API endpoints
- End-to-end tests with Playwright
- Performance testing with load simulation

---

##  Support & Contact

### Development Team

**Architecture & Backend**: Claude (AI Assistant)
**Product Direction**: Development Team
**UI/UX Design**: Design Team
**DevOps & Infrastructure**: Platform Team

### Documentation

- **API Documentation**: Available at `/docs/api`
- **Component Library**: Storybook documentation
- **User Guides**: In-app help system
- **Developer Docs**: This PACTWISE.md file

### Issue Reporting

**Bug Reports:**
- Use GitHub Issues with bug template
- Include reproduction steps and environment details
- Attach relevant screenshots or error logs

**Feature Requests:**
- Use GitHub Discussions for new ideas
- Include business justification and user stories
- Consider technical feasibility and architecture impact

---

##  License & Legal

### Software License
- **Type**: Proprietary Software
- **Usage**: Commercial use with appropriate licensing
- **Distribution**: Restricted to authorized parties

### Data Privacy
- **GDPR Compliant**: User data protection and right to deletion
- **CCPA Compliant**: California consumer privacy rights
- **Enterprise Privacy**: Customer data isolation and security

### Security Compliance
- **SOC 2 Type II**: Security and availability controls
- **ISO 27001**: Information security management
- **HIPAA Ready**: Healthcare data protection capabilities

---

##  Recent Development Updates

### Latest Component Development (June 2025)

**High-Priority Component Suite Completed:**

1. ** Enhanced UI Components:**
   - Advanced data tables (ContractTable, VendorTable) with professional features
   - Multi-format document viewer with zoom, rotation, and download controls
   - Export functionality supporting PDF, Excel, and CSV formats
   - Comprehensive notification center with real-time updates

2. ** Search & Discovery System:**
   - Global search with command bar interface (Cmd/Ctrl+K shortcut)
   - Advanced filtering with saved filters, quick presets, and complex field types
   - Unified search results with grid, list, and compact view modes
   - Real-time search suggestions and recent search history

3. ** Workflow Automation Platform:**
   - Visual workflow designer with drag-and-drop node-based interface
   - Approval queue dashboard with advanced filtering and bulk operations
   - Real-time workflow status tracking with progress indicators and timelines
   - Multi-stage approval processes with escalation rules and notifications

4. ** Mobile-First Experience:**
   - Touch-optimized navigation with bottom tab bar and slide-out menu
   - Mobile-responsive data cards for contracts, vendors, workflows, users, and documents
   - Mobile header components with quick actions and notifications
   - Floating action buttons for common tasks

5. ** Production Infrastructure:**
   - Comprehensive error boundary system with fallback UI
   - Centralized error handling with automatic categorization and reporting
   - Toast notification system for user feedback
   - Loading states and empty state handling across all components
   - Role-based permission gates with resource ownership checks
   - Bulk operations with selection management

**Technical Achievements:**
- 30+ production-ready components built following existing project patterns
- TypeScript with comprehensive type safety and interfaces
- Integration with shadcn/ui components and Tailwind CSS
- Clerk authentication and Convex backend compatibility
- Mobile-responsive design with touch-optimized interactions
- Consistent error handling and loading states throughout

**Architecture Highlights:**
- Modular component structure with clear separation of concerns
- Reusable patterns for data tables, forms, and modals
- Consistent prop interfaces and component APIs
- Performance optimizations with proper state management
- Accessibility features and keyboard navigation support

---

*This document serves as the definitive reference for PactWise development, architecture, and business strategy. Last updated: June 2025*
</file>

<file path="src/app/globals.css">
@import "tailwindcss";

@layer base {
  :root {
    /* Luxury light theme */
    --background: 210 50% 98%; /* Soft ivory white */
    --foreground: 215 25% 15%; /* Deep charcoal with blue undertone */

    --card: 0 0% 100%;
    --card-foreground: 215 25% 15%;

    --popover: 0 0% 100%;
    --popover-foreground: 215 25% 15%;

    --primary: 215 30% 20%; /* Rich navy blue */
    --primary-foreground: 210 40% 98%;

    --secondary: 210 40% 96.1%;
    --secondary-foreground: 215 30% 20%;

    --muted: 210 40% 96.1%;
    --muted-foreground: 215 25% 40%;

    --accent: 210 40% 96.1%;
    --accent-foreground: 215 30% 20%;

    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 210 40% 98%;

    --border: 214 20% 90%;
    --input: 214 20% 90%;
    --ring: 215 30% 20%;

    --radius: 0.25rem; /* Reduced radius for more refined look */

    /* Gold accent color for luxury feel */
    --elegant-gold: 38 55% 58%;
    --elegant-gold-light: 38 50% 70%;
    --elegant-gold-dark: 38 50% 45%; 

    /* Chart colors */
    --chart-1: 215 70% 35%;
    --chart-2: 173 58% 39%;
    --chart-3: 40 80% 60%; /* Gold */
    --chart-4: 200 70% 45%;
    --chart-5: 235 60% 50%;

    /* Background opacity control */
    --background-light: 210 50% 98% / 0.8;
    --background-glass: 210 50% 98% / 0.5;
  }

  .dark {
    /* Luxury dark theme */
    --background: 215 30% 10%; /* Deep navy charcoal */
    --foreground: 210 40% 98%; /* Soft white with cool undertone */

    --card: 215 35% 12%; 
    --card-foreground: 210 40% 98%;

    --popover: 215 35% 12%;
    --popover-foreground: 210 40% 98%;

    --primary: 210 40% 98%; 
    --primary-foreground: 215 30% 10%;

    --secondary: 215 25% 18%;
    --secondary-foreground: 210 40% 98%;

    --muted: 215 25% 18%;
    --muted-foreground: 215 20% 70%;

    --accent: 215 25% 18%;
    --accent-foreground: 210 40% 98%;

    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 210 40% 98%;

    --border: 215 25% 18%;
    --input: 215 25% 18%;
    --ring: 210 40% 90%;

    /* Gold accent color for luxury dark theme */
    --elegant-gold: 38 55% 58%; /* More muted, sophisticated gold */
    --elegant-gold-light: 38 50% 70%; /* Lighter, subtle version */  
    --elegant-gold-dark: 38 50% 45%; /* Deeper, richer version */

    --navy: 215 30% 20%;

    /* Chart colors for dark theme */
    --chart-1: 215 70% 60%;
    --chart-2: 173 58% 50%;
    --chart-3: 40 70% 55%; /* Gold */
    --chart-4: 200 70% 60%;
    --chart-5: 235 60% 65%;

    /* Background opacity control for dark theme */
    --background-light: 215 30% 10% / 0.8;
    --background-glass: 215 30% 10% / 0.5;
  }
}

/* Typography enhancements */
@layer base {
  body {
    @apply antialiased;
  }
  
  h1, h2, h3, h4, h5, h6 {
    @apply tracking-tight;
  }
}

/* Additional classes for luxury UI elements */
@layer utilities {
  .gold-gradient {
    background: linear-gradient(135deg, hsl(var(--gold)) 0%, hsl(var(--gold-dark)) 100%);
  }
  
  .text-shadow-sm {
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }
  
  .border-gold {
    border-color: hsl(var(--gold) / 0.2);
  }
  
  .backdrop-blur-xs {
    backdrop-filter: blur(2px);
  }
  
  .subtle-shadow {
    box-shadow: 0 4px 20px -2px rgba(0, 0, 0, 0.05);
  }

  .cursor-pointer-important {
    cursor: pointer !important;
  }

  
   .animate-fade-in-up {
    animation: fade-in-up 0.7s ease-out forwards;
  }
  .animation-delay-200 { animation-delay: 200ms; }
  .animation-delay-400 { animation-delay: 400ms; }
  .animation-delay-600 { animation-delay: 600ms; }
}


.text-gold {
  color: hsl(var(--elegant-gold));
}

.bg-gold {
  background-color: hsl(var(--elegant-gold));

  
}



.from-gold {
  --tw-gradient-from: hsl(var(--elegant-gold)) var(--tw-gradient-from-position);
  --tw-gradient-to: hsl(var(--elegant-gold) / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.via-gold {
  --tw-gradient-to: hsl(var(--elegant-gold) / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), hsl(var(--elegant-gold)) var(--tw-gradient-via-position), var(--tw-gradient-to);
}

.to-gold {
  --tw-gradient-to: hsl(var(--elegant-gold)) var(--tw-gradient-to-position);
}

.from-navy {
  --tw-gradient-from: hsl(var(--navy)) var(--tw-gradient-from-position);
  --tw-gradient-to: hsl(var(--navy) / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), var(--tw-gradient-to);
}

.via-navy {
  --tw-gradient-to: hsl(var(--navy) / 0) var(--tw-gradient-to-position);
  --tw-gradient-stops: var(--tw-gradient-from), hsl(var(--navy)) var(--tw-gradient-via-position), var(--tw-gradient-to);
}

.to-navy {
  --tw-gradient-to: hsl(var(--navy)) var(--tw-gradient-to-position);
}



@keyframes gradient {
  0%, 100% {
    background-size: 200% 200%;
    background-position: left center;
  }
  50% {
    background-size: 200% 200%;
    background-position: right center;
  }
}

/* Keyframes for fade-in-up */
@keyframes fade-in-up {
  from {
    opacity: 0;
    transform: translateY(20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}


.animate-gradient {
  animation: gradient 8s ease infinite;
}

.animation-delay-2000 {
  animation-delay: 2s;
}

button, 
.button,
[role="button"],
select,
[role="combobox"],
.select-trigger,
.select-item,  
.dropdown-item, 
[role="option"], 
.checkbox,
.radio,
.switch {
  cursor: pointer;
}

.stagger-children > * {
  opacity: 0; 
}
@layer utilities {
  .gold-gradient {
    background: linear-gradient(135deg, hsl(var(--gold)) 0%, hsl(var(--gold-dark)) 100%);
  }
  
  .text-shadow-sm {
    text-shadow: 0 1px 2px rgba(0, 0, 0, 0.1);
  }
  
  .border-gold {
    border-color: hsl(var(--gold) / 0.2);
  }
  
  .backdrop-blur-xs {
    backdrop-filter: blur(2px);
  }
  
  .subtle-shadow {
    box-shadow: 0 4px 20px -2px rgba(0, 0, 0, 0.05);
  }

  .cursor-pointer-important {
    cursor: pointer !important;
  }
  
   .animate-delicate-sweep-in { /* Ensure this class is available if not using Tailwind's animate-* directly */
    animation: delicate-sweep-in 0.8s cubic-bezier(0.23, 1, 0.32, 1) forwards;
  }
  .animation-delay-200 { animation-delay: 200ms; }
  .animation-delay-400 { animation-delay: 400ms; }
  .animation-delay-600 { animation-delay: 600ms; }
  .animation-delay-800 { animation-delay: 800ms; } /* Added more delays */
  .animation-delay-1000 { animation-delay: 1000ms; }
}
</file>

<file path="src/middleware.ts">
// src/middleware.ts

import {
  clerkMiddleware,
  createRouteMatcher,
} from "@clerk/nextjs/server";
import { NextResponse } from "next/server";
import type { NextRequest } from "next/server";

// Rate limiting store (in production, use Redis)
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

// Rate limiting configuration
const RATE_LIMIT_WINDOW = 15 * 60 * 1000; // 15 minutes
const RATE_LIMIT_MAX_REQUESTS = 100; // requests per window
const RATE_LIMIT_MAX_AUTH_ATTEMPTS = 5; // auth attempts per window

// Helper function to get client IP
function getClientIP(request: NextRequest): string {
  const forwarded = request.headers.get('x-forwarded-for');
  const realIP = request.headers.get('x-real-ip');
  
  if (forwarded) {
    return forwarded.split(',')[0].trim();
  }
  
  if (realIP) {
    return realIP;
  }
  
  return request.ip || 'unknown';
}

// Rate limiting function
function isRateLimited(ip: string, key: string, maxRequests: number): boolean {
  const now = Date.now();
  const limitKey = `${ip}:${key}`;
  const record = rateLimitStore.get(limitKey);

  if (!record || now > record.resetTime) {
    rateLimitStore.set(limitKey, { count: 1, resetTime: now + RATE_LIMIT_WINDOW });
    return false;
  }

  if (record.count >= maxRequests) {
    return true;
  }

  record.count++;
  return false;
}

// --- Route Matchers ---
const isProtectedRoute = createRouteMatcher([
  '/dashboard(.*)',
  '/forum(.*)',
  "/product(.*)",
  "/contracts(.*)",
  "/vendors(.*)",
  "/settings(.*)",
  "/profile(.*)",
  "/agents(.*)",
]);

// Match sign-in/sign-up pages
const isSignInOrSignUpPage = createRouteMatcher([
  '/auth/sign-in(.*)',
  '/auth/sign-up(.*)',
]);

// Match public pages that authenticated users should still be able to access
const isPublicPage = createRouteMatcher([
  '/',
  '/contact',
  '/about',
  '/features',
  '/pricing',
]);

// --- Clerk Middleware ---
export default clerkMiddleware(async (auth, req) => {
  const authResult = await auth();
  const { userId } = authResult;

  const { pathname, search, origin } = req.nextUrl;
  const pathWithQuery = pathname + search;
  const clientIP = getClientIP(req);

  console.log(`Processing path: ${pathWithQuery}, User ID: ${userId || 'Not logged in'}, IP: ${clientIP}`);

  // Rate limiting check
  const isAuthRoute = isSignInOrSignUpPage(req);
  const maxRequests = isAuthRoute ? RATE_LIMIT_MAX_AUTH_ATTEMPTS : RATE_LIMIT_MAX_REQUESTS;
  const rateLimitKey = isAuthRoute ? 'auth' : 'general';
  
  if (isRateLimited(clientIP, rateLimitKey, maxRequests)) {
    console.log(`Rate limit exceeded for IP: ${clientIP} on route: ${pathname}`);
    return new NextResponse('Too Many Requests', { 
      status: 429,
      headers: {
        'Retry-After': '900', // 15 minutes
        'X-RateLimit-Limit': maxRequests.toString(),
        'X-RateLimit-Remaining': '0',
        'X-RateLimit-Reset': (Date.now() + RATE_LIMIT_WINDOW).toString(),
      },
    });
  }

  // --- Logic for Protected Routes ---
  if (!userId && isProtectedRoute(req)) {
    console.log(`Unauthenticated access attempt to protected route: ${pathname}. Redirecting to sign-in.`);
    // Create a return URL that will redirect to dashboard after sign-in
    const signInUrl = new URL('/auth/sign-in', origin);
    signInUrl.searchParams.set('redirect_url', '/dashboard');
    return NextResponse.redirect(signInUrl);
  }

  // --- Logic for Auth Pages (Sign-in/Sign-up) ---
  if (userId && isSignInOrSignUpPage(req)) {
    console.log(`Authenticated user accessing auth page: ${pathname}. Redirecting to dashboard.`);
    
    // Always redirect authenticated users to dashboard from auth pages
    const dashboardUrl = new URL('/dashboard', origin);
    return NextResponse.redirect(dashboardUrl);
  }

  // --- Handle root path redirect for authenticated users ---
  if (userId && pathname === '/') {
    console.log(`Authenticated user on homepage. Redirecting to dashboard.`);
    const dashboardUrl = new URL('/dashboard', origin);
    return NextResponse.redirect(dashboardUrl);
  }

  // --- Allow Request ---
  console.log(`Allowing request to proceed for path: ${pathname}`);
  return NextResponse.next();
});

// --- Middleware Configuration ---
export const config = {
  matcher: [
    /*
     * Match all request paths except for the ones starting with:
     * - _next/static (static files)
     * - _next/image (image optimization files)
     * - favicon.ico (favicon file)
     * - Any files with extensions (e.g., .png, .jpg, .svg)
     */
    '/((?!_next/static|_next/image|favicon.ico|.*\\.\\w+).*)',
  ],
};
</file>

<file path="convex/vendors.ts">
// convex/vendors.ts
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { Id } from "./_generated/dataModel"; 
import { ConvexError } from "convex/values";
import { api } from "./_generated/api";
import { VendorFilters, VendorCategory, CreateVendorArgs, UpdateVendorArgs } from "./types"; 


const vendorCategoryOptions = [
  "technology", "marketing", "legal", "finance", "hr",
  "facilities", "logistics", "manufacturing", "consulting", "other"
] as const;

// ============================================================================
// CREATE
// ============================================================================
export const createVendor = mutation({
  args: {
    enterpriseId: v.id("enterprises"),
    name: v.string(),   
    contactEmail: v.optional(v.string()),
    contactPhone: v.optional(v.string()),
    address: v.optional(v.string()),
    notes: v.optional(v.string()),
    website: v.optional(v.string()),
    category: v.optional(
      v.union(
        ...vendorCategoryOptions.map(option => v.literal(option))
      )
    ),
    createdAt: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in to create a vendor.");
    }
    
    // Get current user to check permissions
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied: You can only create vendors for your enterprise.");
    }

    // Check role permissions (viewers cannot create)
    if (currentUser.role === "viewer") {
      throw new ConvexError("Permission denied: Viewers cannot create vendors.");
    }

    if (!args.name || args.name.trim() === "") {
        throw new ConvexError("Validation Error: Vendor name cannot be empty.");
    }
    
    // Check for duplicate vendor names
    const existingVendor = await ctx.db
      .query("vendors")
      .withIndex("by_name", (q) => q.eq("name", args.name.trim()))
      .filter((q) => q.eq(q.field("enterpriseId"), args.enterpriseId))
      .first();

    if (existingVendor) {
      throw new ConvexError("A vendor with this name already exists in your enterprise.");
    }

    // Validate email format if provided
    if (args.contactEmail && !isValidEmail(args.contactEmail)) {
      throw new ConvexError("Invalid email format.");
    }

    const vendorId = await ctx.db.insert("vendors", {
      enterpriseId: args.enterpriseId,
      name: args.name.trim(),
      contactEmail: args.contactEmail?.toLowerCase() || undefined,
      contactPhone: args.contactPhone || undefined,
      address: args.address || undefined,
      notes: args.notes || undefined,
      website: args.website || undefined,
      category: args.category || undefined,
      createdAt: args.createdAt,
    });

    console.log(`Vendor created with ID: ${vendorId} for enterprise ${args.enterpriseId}`);
    return vendorId;
  },
});

// ============================================================================
// READ
// ============================================================================
export const getVendors = query({
  args: {
    // --- REQUIRED: enterpriseId to fetch vendors for a specific enterprise ---
    enterpriseId: v.id("enterprises"),
    // --- NEW: Optional filter by category ---
    category: v.optional(
      v.union(
        ...vendorCategoryOptions.map(option => v.literal(option)),
        v.literal("all") // Special value to fetch all categories for the enterprise
      )
    ),
    // Search query
    searchQuery: v.optional(v.string()),
    // Pagination
    limit: v.optional(v.number()),
    offset: v.optional(v.number()),
    // Sorting
    sortBy: v.optional(v.union(
      v.literal("name"),
      v.literal("contractCount"),
      v.literal("totalValue"),
      v.literal("lastActivity")
    )),
    sortOrder: v.optional(v.union(v.literal("asc"), v.literal("desc"))),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to view vendors.");
    }
    
    // Verify user has access to this enterprise
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied: You can only view vendors from your enterprise.");
    }

    // Base query for the enterprise
    let queryBuilder = ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", args.enterpriseId));

    // Apply category filter if provided and not "all"
    if (args.category && args.category !== "all") {
        queryBuilder = ctx.db
          .query("vendors")
          .withIndex("by_category_and_enterpriseId", (q) =>
            q.eq("enterpriseId", args.enterpriseId).eq("category", args.category as Exclude<typeof args.category, "all">)
          );
    }

    let vendors = await queryBuilder.order("asc").collect();

    // Apply search filter if provided
    if (args.searchQuery && args.searchQuery.trim().length > 0) {
      const searchLower = args.searchQuery.toLowerCase().trim();
      vendors = vendors.filter(vendor => 
        vendor.name.toLowerCase().includes(searchLower) ||
        vendor.contactEmail?.toLowerCase().includes(searchLower) ||
        vendor.website?.toLowerCase().includes(searchLower) ||
        vendor.notes?.toLowerCase().includes(searchLower)
      );
    }

    // Optimize: Fetch all contracts for the enterprise once, then group by vendor
    const allContracts = await ctx.db
      .query("contracts")
      .withIndex("by_enterprise", q => q.eq("enterpriseId", args.enterpriseId))
      .collect();

    // Group contracts by vendor ID for efficient lookup
    const contractsByVendor = new Map<string, typeof allContracts>();
    allContracts.forEach(contract => {
      const vendorId = contract.vendorId;
      if (!contractsByVendor.has(vendorId)) {
        contractsByVendor.set(vendorId, []);
      }
      contractsByVendor.get(vendorId)!.push(contract);
    });

    // Enrich vendors with contract data and calculate metrics
    const vendorsWithDetails = vendors.map(vendor => {
      const contracts = contractsByVendor.get(vendor._id) || [];
      const activeContracts = contracts.filter(c => c.status === "active");
      
      const totalValue = contracts.reduce((sum, contract) => {
        const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
        return sum + value;
      }, 0);

      // Get last activity (most recent contract creation or update)
      const lastActivity = contracts.reduce((latest, contract) => {
        const contractTime = contract._creationTime || 0;
        return contractTime > latest ? contractTime : latest;
      }, 0);

      return { 
        ...vendor, 
        contractCount: contracts.length,
        activeContractCount: activeContracts.length,
        totalValue,
        lastActivity,
        hasActiveContracts: activeContracts.length > 0,
      };
    });

    // Sort vendors
    let sortedVendors = [...vendorsWithDetails];
    if (args.sortBy) {
      sortedVendors.sort((a, b) => {
        let aVal, bVal;
        switch (args.sortBy) {
          case "name":
            aVal = a.name.toLowerCase();
            bVal = b.name.toLowerCase();
            break;
          case "contractCount":
            aVal = a.contractCount;
            bVal = b.contractCount;
            break;
          case "totalValue":
            aVal = a.totalValue;
            bVal = b.totalValue;
            break;
          case "lastActivity":
            aVal = a.lastActivity;
            bVal = b.lastActivity;
            break;
          default:
            return 0;
        }

        if (args.sortOrder === "desc") {
          return aVal > bVal ? -1 : aVal < bVal ? 1 : 0;
        } else {
          return aVal < bVal ? -1 : aVal > bVal ? 1 : 0;
        }
      });
    }

    // Apply pagination
    const limit = args.limit || 50;
    const offset = args.offset || 0;
    const paginatedVendors = sortedVendors.slice(offset, offset + limit);

    return {
      vendors: paginatedVendors,
      total: sortedVendors.length,
      hasMore: offset + limit < sortedVendors.length,
    };
  },
});

export const getVendorById = query({
  args: {
    vendorId: v.id("vendors"),
    // --- REQUIRED: enterpriseId for access control and context ---
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
        throw new ConvexError("Authentication required to view vendor details.");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied.");
    }

    const vendor = await ctx.db.get(args.vendorId);

    if (!vendor) {
      return null;
    }

    // --- Security Check: Ensure the fetched vendor belongs to the specified enterprise ---
    if (vendor.enterpriseId !== args.enterpriseId) {
      console.warn(`User attempted to access vendor ${args.vendorId} not belonging to their enterprise ${args.enterpriseId}.`);
      return null;
    }

    // Fetch related data
    const contracts = await ctx.db
        .query("contracts")
        .withIndex("by_vendorId_and_enterpriseId", q => 
          q.eq("enterpriseId", args.enterpriseId).eq("vendorId", vendor._id)
        )
        .collect();

    // Calculate vendor metrics
    const activeContracts = contracts.filter(c => c.status === "active");
    const totalValue = contracts.reduce((sum, contract) => {
      const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
      return sum + value;
    }, 0);

    // Get contract value breakdown
    const contractsByStatus = contracts.reduce((acc, contract) => {
      acc[contract.status] = (acc[contract.status] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    const contractsByType = contracts.reduce((acc, contract) => {
      const type = contract.contractType || "other";
      acc[type] = (acc[type] || 0) + 1;
      return acc;
    }, {} as Record<string, number>);

    return { 
      ...vendor, 
      contracts,
      metrics: {
        totalContracts: contracts.length,
        activeContracts: activeContracts.length,
        totalValue,
        averageContractValue: contracts.length > 0 ? totalValue / contracts.length : 0,
        contractsByStatus,
        contractsByType,
      },
    };
  },
});

// ============================================================================
// UPDATE
// ============================================================================
export const updateVendor = mutation({
  args: {
    vendorId: v.id("vendors"),
    // --- REQUIRED: enterpriseId for permission check ---
    enterpriseId: v.id("enterprises"),
    // Optional fields to update (matching schema)
    name: v.optional(v.string()),
    contactEmail: v.optional(v.string()),
    contactPhone: v.optional(v.string()),
    address: v.optional(v.string()),
    notes: v.optional(v.string()),
    website: v.optional(v.string()),
    // --- NEW: Allow updating category ---
    category: v.optional(
      v.union(
        ...vendorCategoryOptions.map(option => v.literal(option))
      )
    ),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in to update a vendor.");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied.");
    }

    // Check role permissions
    if (currentUser.role === "viewer") {
      throw new ConvexError("Permission denied: Viewers cannot update vendors.");
    }

    const existingVendor = await ctx.db.get(args.vendorId);
    if (!existingVendor) {
        throw new ConvexError(`Vendor not found with ID: ${args.vendorId}`);
    }

    // --- Security Check: Ensure user is updating a vendor within their enterprise ---
    if (existingVendor.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Permission denied: You do not have permission to update this vendor.");
    }

    const { vendorId, enterpriseId: _enterpriseId, ...updates } = args;

    if (updates.name !== undefined && updates.name.trim() === "") {
        throw new ConvexError("Validation Error: Vendor name cannot be empty.");
    }
    if(updates.name) {
      updates.name = updates.name.trim();
      
      // Check for duplicate names
      const duplicateVendor = await ctx.db
        .query("vendors")
        .withIndex("by_name", (q) => q.eq("name", updates.name!))
        .filter((q) => 
          q.and(
            q.eq(q.field("enterpriseId"), existingVendor.enterpriseId),
            q.neq(q.field("_id"), args.vendorId)
          )
        )
        .first();

      if (duplicateVendor) {
        throw new ConvexError("A vendor with this name already exists.");
      }
    }

    // Validate email if provided
    if (updates.contactEmail !== undefined && updates.contactEmail && !isValidEmail(updates.contactEmail)) {
      throw new ConvexError("Invalid email format.");
    }
    if (updates.contactEmail) {
      updates.contactEmail = updates.contactEmail.toLowerCase();
    }

    // Remove undefined values so patch only applies provided fields
    (Object.keys(updates) as Array<keyof typeof updates>).forEach(key => {
      if (updates[key] === undefined) {
        delete updates[key];
      }
    });

    if (Object.keys(updates).length === 0) {
        console.log("No fields provided to update for vendor:", vendorId);
        return { success: true, message: "No fields provided to update." };
    }

    await ctx.db.patch(args.vendorId, updates);

    console.log(`Vendor updated with ID: ${args.vendorId}. Updates applied:`, updates);
    return { success: true };
  },
});

// ============================================================================
// DELETE
// ============================================================================
export const deleteVendor = mutation({
  args: {
    vendorId: v.id("vendors"),
    // --- REQUIRED: enterpriseId for permission check ---
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in to delete a vendor.");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied.");
    }

    // Check role permissions (only admins and owners can delete)
    if (currentUser.role !== "owner" && currentUser.role !== "admin") {
      throw new ConvexError("Permission denied: Only owners and admins can delete vendors.");
    }

    const existingVendor = await ctx.db.get(args.vendorId);
    if (!existingVendor) {
        throw new ConvexError(`Vendor not found with ID: ${args.vendorId}`);
    }

    // --- Security Check: Ensure user is deleting a vendor within their enterprise ---
    if (existingVendor.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Permission denied: You do not have permission to delete this vendor.");
    }

    // Check for Associated Contracts (Safety Check within the correct enterprise)
    const associatedContracts = await ctx.db
      .query("contracts")
      .withIndex("by_vendorId_and_enterpriseId", (q) =>
          q.eq("enterpriseId", args.enterpriseId).eq("vendorId", args.vendorId)
      )
      .collect();

    if (associatedContracts.length > 0) {
        throw new ConvexError(
            `Cannot delete vendor: This vendor has ${associatedContracts.length} associated contract(s). Please delete or reassign the contracts first.`
        );
    }

    await ctx.db.delete(args.vendorId);

    console.log(`Vendor deleted with ID: ${args.vendorId} from enterprise ${args.enterpriseId}`);
    return { success: true };
  },
});

// ============================================================================
// ANALYTICS
// ============================================================================

/**
 * Get vendor analytics and statistics
 */
export const getVendorAnalytics = query({
  args: {
    enterpriseId: v.id("enterprises"),
    timeRange: v.optional(v.union(
      v.literal("30days"),
      v.literal("90days"),
      v.literal("1year"),
      v.literal("all")
    )),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required.");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied.");
    }

    const vendors = await ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", args.enterpriseId))
      .collect();

    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_status_and_enterpriseId", (q) => 
        q.eq("enterpriseId", args.enterpriseId)
      )
      .collect();

    // Calculate time range filter
    let startDate: Date | null = null;
    if (args.timeRange && args.timeRange !== "all") {
      startDate = new Date();
      switch (args.timeRange) {
        case "30days":
          startDate.setDate(startDate.getDate() - 30);
          break;
        case "90days":
          startDate.setDate(startDate.getDate() - 90);
          break;
        case "1year":
          startDate.setFullYear(startDate.getFullYear() - 1);
          break;
      }
    }

    // Filter contracts by time range
    const filteredContracts = startDate 
      ? contracts.filter(c => c._creationTime && c._creationTime > startDate.getTime())
      : contracts;

    // Calculate analytics
    const analytics = {
      totalVendors: vendors.length,
      vendorsByCategory: {} as Record<string, number>,
      topVendorsByValue: [] as Array<{ vendor: any; totalValue: number; contractCount: number }>,
      topVendorsByContracts: [] as Array<{ vendor: any; contractCount: number; totalValue: number }>,
      vendorsWithActiveContracts: 0,
      vendorsWithoutContracts: 0,
      totalSpend: 0,
      averageContractValue: 0,
      categorySpend: {} as Record<string, number>,
    };

    // Group contracts by vendor
    const contractsByVendor = new Map<string, any[]>();
    filteredContracts.forEach(contract => {
      const vendorId = contract.vendorId.toString();
      if (!contractsByVendor.has(vendorId)) {
        contractsByVendor.set(vendorId, []);
      }
      contractsByVendor.get(vendorId)!.push(contract);
    });

    // Analyze each vendor
    vendors.forEach(vendor => {
      // Category breakdown
      const category = vendor.category || "other";
      analytics.vendorsByCategory[category] = (analytics.vendorsByCategory[category] || 0) + 1;

      // Get vendor contracts
      const vendorContracts = contractsByVendor.get(vendor._id.toString()) || [];
      const activeContracts = vendorContracts.filter(c => c.status === "active");
      
      if (activeContracts.length > 0) {
        analytics.vendorsWithActiveContracts++;
      }
      if (vendorContracts.length === 0) {
        analytics.vendorsWithoutContracts++;
      }

      // Calculate total value
      const totalValue = vendorContracts.reduce((sum, contract) => {
        const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
        return sum + value;
      }, 0);

      analytics.totalSpend += totalValue;
      analytics.categorySpend[category] = (analytics.categorySpend[category] || 0) + totalValue;

      // Add to top vendors lists
      if (vendorContracts.length > 0) {
        const vendorData = {
          vendor: {
            _id: vendor._id,
            name: vendor.name,
            category: vendor.category,
          },
          totalValue,
          contractCount: vendorContracts.length,
        };
        analytics.topVendorsByValue.push(vendorData);
        analytics.topVendorsByContracts.push(vendorData);
      }
    });

    // Sort and limit top vendors
    analytics.topVendorsByValue.sort((a, b) => b.totalValue - a.totalValue);
    analytics.topVendorsByValue = analytics.topVendorsByValue.slice(0, 10);

    analytics.topVendorsByContracts.sort((a, b) => b.contractCount - a.contractCount);
    analytics.topVendorsByContracts = analytics.topVendorsByContracts.slice(0, 10);

    // Calculate average contract value
    if (filteredContracts.length > 0) {
      analytics.averageContractValue = analytics.totalSpend / filteredContracts.length;
    }

    return analytics;
  },
});

/**
 * Get vendor categories with counts
 */
export const getVendorCategories = query({
  args: {
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required.");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied.");
    }

    const vendors = await ctx.db
      .query("vendors")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", args.enterpriseId))
      .collect();

    const categories = vendorCategoryOptions.map(category => {
      const count = vendors.filter(v => v.category === category).length;
      return { category, count };
    });

    // Add count for vendors without category
    const uncategorizedCount = vendors.filter(v => !v.category).length;
    if (uncategorizedCount > 0) {
      categories.push({ category: "other", count: uncategorizedCount });
    }

    return categories.filter(c => c.count > 0);
  },
});

// ============================================================================
// BULK OPERATIONS
// ============================================================================

/**
 * Bulk update vendor categories
 */
export const bulkUpdateCategories = mutation({
  args: {
    enterpriseId: v.id("enterprises"),
    updates: v.array(v.object({
      vendorId: v.id("vendors"),
      category: v.union(
        ...vendorCategoryOptions.map(option => v.literal(option))
      ),
    })),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required.");
    }

    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied.");
    }

    if (currentUser.role !== "owner" && currentUser.role !== "admin") {
      throw new ConvexError("Permission denied: Only owners and admins can bulk update vendors.");
    }

    let successCount = 0;
    const errors: Array<{ vendorId: string; error: string }> = [];

    for (const update of args.updates) {
      try {
        const vendor = await ctx.db.get(update.vendorId);
        if (!vendor) {
          errors.push({ vendorId: update.vendorId.toString(), error: "Vendor not found" });
          continue;
        }

        if (vendor.enterpriseId !== args.enterpriseId) {
          errors.push({ vendorId: update.vendorId.toString(), error: "Access denied" });
          continue;
        }

        await ctx.db.patch(update.vendorId, { category: update.category });
        successCount++;
      } catch (error) {
        errors.push({ 
          vendorId: update.vendorId.toString(), 
          error: error instanceof Error ? error.message : "Unknown error" 
        });
      }
    }

    return {
      success: true,
      successCount,
      totalCount: args.updates.length,
      errors,
    };
  },
});

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

function isValidEmail(email: string): boolean {
  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  return emailRegex.test(email);
}
</file>

<file path="src/app/_components/dashboard/DashboardContent.tsx">
// src/app/_components/dashboard/DashboardContent.tsx
'use client';

import React, { useState } from "react";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";
import {
  Activity,
  DollarSign,
  TrendingUp,
  Scale,
  Building,
  Target,
  ShieldCheck,
  AlertCircle,
  FileText,
  Users,
  Calendar
} from "lucide-react";
import { MetricCard } from "@/app/_components/common/MetricCard";
import DynamicChart from "@/app/_components/common/DynamicCharts";
import { Alert, AlertDescription, AlertTitle } from "@/components/ui/alert";
import { Button } from "@/components/ui/button";
import { useQuery } from "convex/react";
import { api } from "../../../../convex/_generated/api";
import { Id } from "../../../../convex/_generated/dataModel";

// Define chart colors for consistency
const CHART_COLORS = {
  primary: "hsl(var(--chart-1))",
  secondary: "hsl(var(--chart-2))",
  tertiary: "hsl(var(--chart-3))",
  quaternary: "hsl(var(--chart-4))",
  success: "#10b981", // emerald-500
  warning: "#f59e0b", // amber-500
  danger: "#ef4444", // red-500
};

interface DashboardContentProps {
  enterpriseId: Id<"enterprises">;
}

const DashboardContent: React.FC<DashboardContentProps> = ({ enterpriseId }) => {
  const [timeRange, setTimeRange] = useState("month");

  // Fetch data from Convex backend
  const contractStats = useQuery(api.contracts.getContractStats, { enterpriseId });
  const contracts = useQuery(api.contracts.getContracts, { 
    enterpriseId,
    status: "all",
    contractType: "all"
  });
  const vendors = useQuery(api.vendors.getVendors, { 
    enterpriseId,
    category: "all"
  });
  
  // Agent system data
  const agentSystemStatus = useQuery(api.agents.manager.getAgentSystemStatus, {});
  const recentInsights = useQuery(api.agents.manager.getRecentInsights, { limit: 10 });

  // Helper functions
  const formatCurrency = (value: number) => {
    if (isNaN(value) || typeof value !== 'number') return '$0';
    return new Intl.NumberFormat("en-US", {
      style: "currency",
      currency: "USD",
      minimumFractionDigits: 0,
      maximumFractionDigits: 0,
    }).format(value);
  };

  const formatYAxis = (value: number) => {
    if (isNaN(value) || typeof value !== 'number') return '0';
    if (value >= 1000000) {
      return `$${(value / 1000000).toFixed(1)}M`;
    } else if (value >= 1000) {
      return `$${(value / 1000).toFixed(0)}k`;
    }
    return value.toString();
  };

  // Calculate metrics from actual data
  const calculateTotalContractValue = () => {
    if (!contracts) return 0;
    return contracts.reduce((total, contract) => {
      const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
      return total + (isNaN(value) ? 0 : value);
    }, 0);
  };

  const calculateActiveContracts = () => {
    return contractStats?.byStatus?.active || 0;
  };

  const calculateExpiringContracts = () => {
    if (!contracts) return 0;
    const thirtyDaysFromNow = new Date();
    thirtyDaysFromNow.setDate(thirtyDaysFromNow.getDate() + 30);
    
    return contracts.filter(contract => {
      if (!contract.extractedEndDate) return false;
      const endDate = new Date(contract.extractedEndDate);
      return endDate <= thirtyDaysFromNow && endDate > new Date();
    }).length;
  };

  const getStatusDistributionData = () => {
    if (!contractStats?.byStatus) return [];
    
    const statusColors: Record<string, string> = {
      active: "#10b981",
      draft: "#60a5fa", 
      pending_analysis: "#f59e0b",
      expired: "#ef4444",
      terminated: "#8b5cf6",
      archived: "#6b7280"
    };

    return Object.entries(contractStats.byStatus).map(([status, count]) => ({
      name: status.charAt(0).toUpperCase() + status.slice(1).replace('_', ' '),
      value: count,
      color: statusColors[status] || "#6b7280"
    }));
  };

  const getContractTypeData = () => {
    if (!contractStats?.byType) return [];
    
    const typeColors: Record<string, string> = {
      nda: CHART_COLORS.primary,
      msa: CHART_COLORS.secondary,
      saas: CHART_COLORS.tertiary,
      sow: CHART_COLORS.quaternary,
      lease: "#8b5cf6",
      employment: "#06b6d4",
      partnership: "#84cc16",
      other: "#6b7280"
    };

    return Object.entries(contractStats.byType).map(([type, count]) => ({
      name: type.toUpperCase(),
      value: count,
      color: typeColors[type] || "#6b7280"
    }));
  };

  const getVendorCategoryData = () => {
    if (!vendors) return [];
    
    const categoryCount: Record<string, number> = {};
    vendors.forEach(vendor => {
      const category = vendor.category || 'other';
      categoryCount[category] = (categoryCount[category] || 0) + 1;
    });

    const categoryColors: Record<string, string> = {
      technology: CHART_COLORS.primary,
      marketing: CHART_COLORS.secondary,
      legal: CHART_COLORS.tertiary,
      finance: CHART_COLORS.quaternary,
      hr: "#8b5cf6",
      facilities: "#06b6d4",
      logistics: "#84cc16",
      manufacturing: "#f59e0b",
      consulting: "#ef4444",
      other: "#6b7280"
    };

    return Object.entries(categoryCount).map(([category, count]) => ({
      name: category.charAt(0).toUpperCase() + category.slice(1),
      value: count,
      color: categoryColors[category] || "#6b7280"
    }));
  };

  const getRiskDistributionData = () => {
    // Calculate risk based on contract values and types
    if (!contracts) return [];
    
    let lowRisk = 0, mediumRisk = 0, highRisk = 0;
    
    contracts.forEach(contract => {
      const value = parseFloat(contract.extractedPricing?.replace(/[^0-9.-]/g, '') || '0');
      const type = contract.contractType;
      
      // Simple risk calculation based on value and type
      if (value > 100000 || ['partnership', 'msa'].includes(type || '')) {
        highRisk++;
      } else if (value > 10000 || ['saas', 'employment'].includes(type || '')) {
        mediumRisk++;
      } else {
        lowRisk++;
      }
    });

    return [
      { name: "Low Risk", value: lowRisk, color: CHART_COLORS.success },
      { name: "Medium Risk", value: mediumRisk, color: CHART_COLORS.warning },
      { name: "High Risk", value: highRisk, color: CHART_COLORS.danger }
    ];
  };

  // Loading state
  const isLoading = contractStats === undefined || contracts === undefined || vendors === undefined;

  if (isLoading) {
    return (
      <div className="flex items-center justify-center h-full">
        <div className="text-center">
          <div className="mb-4 p-3 bg-primary/5 rounded-sm inline-block">
            <div className="w-10 h-10 border-t-2 border-primary animate-spin rounded-full"></div>
          </div>
          <p className="text-muted-foreground">Loading dashboard data...</p>
        </div>
      </div>
    );
  }

  const totalContractValue = calculateTotalContractValue();
  const activeContracts = calculateActiveContracts();
  const expiringCount = calculateExpiringContracts();
  const totalVendors = vendors?.length || 0;
  const agentInsights = recentInsights?.length || 0;

  return (
    <div className="w-full min-h-screen bg-background">
      <Tabs defaultValue="overview" className="w-full">
        <div className="flex flex-col space-y-4 px-4 py-6">
          <div className="flex justify-between items-center">
            <TabsList className="bg-background-light">
              <TabsTrigger value="overview">Executive Summary</TabsTrigger>
              <TabsTrigger value="contracts">Contract Analytics</TabsTrigger>
              <TabsTrigger value="vendors">Vendor Insights</TabsTrigger>
              <TabsTrigger value="agents">AI Agents</TabsTrigger>
            </TabsList>
          </div>

          {/* Alert for expiring contracts */}
          {expiringCount > 0 && (
            <Alert className="mb-4 border-amber-200 bg-amber-50 dark:bg-amber-900/20">
              <AlertCircle className="h-4 w-4 text-amber-600" />
              <AlertTitle className="text-amber-800">Attention Required</AlertTitle>
              <AlertDescription className="text-amber-700">
                {expiringCount} {expiringCount === 1 ? 'contract expires' : 'contracts expire'} in the next 30 days.
                <Button variant="link" className="p-0 h-auto text-amber-800 font-medium hover:text-amber-900 ml-1">
                  View Expiring Contracts
                </Button>
              </AlertDescription>
            </Alert>
          )}

          <TabsContent value="overview" className="space-y-6 mt-0">
            {/* Executive KPIs */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              <MetricCard
                title="Total Contract Value"
                value={formatCurrency(totalContractValue)}
                icon={DollarSign}
                trend={12.5}
                changeType="positive"
                description="Total portfolio value"
              />
              <MetricCard
                title="Active Contracts"
                value={activeContracts.toString()}
                icon={FileText}
                trend={8.2}
                changeType="positive"
                description="Currently active contracts"
              />
              <MetricCard
                title="Total Vendors"
                value={totalVendors.toString()}
                icon={Users}
                trend={15.3}
                changeType="positive"
                description="Vendor relationships"
              />
              <MetricCard
                title="Expiring Soon"
                value={expiringCount.toString()}
                icon={Calendar}
                trend={-5.7}
                changeType={expiringCount > 5 ? "negative" : "positive"}
                description="Contracts expiring in 30 days"
              />
            </div>

            {/* AI Insights Summary */}
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              <MetricCard 
                title="AI Insights Generated" 
                value={agentInsights.toString()} 
                icon={Activity} 
                trend={25.4} 
                changeType="positive" 
                description="Recent AI analysis insights"
              />
              <MetricCard 
                title="System Health" 
                value={agentSystemStatus?.system?.isRunning ? "Running" : "Stopped"} 
                icon={ShieldCheck} 
                trend={0} 
                changeType="neutral" 
                description="AI agent system status"
              />
              <MetricCard 
                title="Active Agents" 
                value={agentSystemStatus?.stats?.activeAgents?.toString() || "0"} 
                icon={Target} 
                trend={0} 
                changeType="neutral" 
                description="Currently running agents"
              />
            </div>

            {/* Contract Analysis Charts */}
            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
              <Card className="border border-gold/10 shadow-luxury">
                <CardHeader>
                  <CardTitle className="text-primary font-serif">Contract Status Distribution</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-[300px] w-full">
                    <DynamicChart 
                      type="pie" 
                      data={getStatusDistributionData()} 
                      series={[{ dataKey: "value" }]} 
                      height={300} 
                      useCustomTooltip={true} 
                      showLegend={false} 
                      colors={getStatusDistributionData().map(item => item.color)}
                      pieConfig={{ 
                        dataKey: "value", 
                        nameKey: "name", 
                        innerRadius: 60, 
                        outerRadius: 100, 
                        paddingAngle: 2 
                      }}
                    />
                    <div className="flex justify-center mt-2 flex-wrap gap-2">
                      {getStatusDistributionData().map((item, index) => (
                        <div key={index} className="flex items-center">
                          <div className="w-3 h-3 rounded-full mr-1" style={{ backgroundColor: item.color }} />
                          <span className="text-xs">{item.name} ({item.value})</span>
                        </div>
                      ))}
                    </div>
                  </div>
                </CardContent>
              </Card>

              <Card className="border border-gold/10 shadow-luxury">
                <CardHeader>
                  <CardTitle className="text-primary font-serif">Risk Distribution</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-[300px] w-full">
                    <DynamicChart 
                      type="pie" 
                      data={getRiskDistributionData()} 
                      series={[{ dataKey: "value" }]} 
                      height={300} 
                      useCustomTooltip={true} 
                      showLegend={false} 
                      colors={getRiskDistributionData().map(item => item.color)}
                      pieConfig={{ 
                        dataKey: "value", 
                        nameKey: "name", 
                        innerRadius: 60, 
                        outerRadius: 100, 
                        paddingAngle: 2 
                      }}
                    />
                    <div className="flex justify-center mt-2 space-x-4">
                      {getRiskDistributionData().map((item, index) => (
                        <div key={index} className="flex items-center">
                          <div className="w-3 h-3 rounded-full mr-1" style={{ backgroundColor: item.color }} />
                          <span className="text-xs">{item.name} ({item.value})</span>
                        </div>
                      ))}
                    </div>
                  </div>
                </CardContent>
              </Card>
            </div>
          </TabsContent>

          <TabsContent value="contracts" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              <MetricCard 
                title="Total Contracts" 
                value={contractStats?.total?.toString() || "0"} 
                icon={FileText} 
                description="All contracts in system"
              />
              <MetricCard 
                title="Active Contracts" 
                value={contractStats?.byStatus?.active?.toString() || "0"} 
                icon={Activity} 
                description="Currently active contracts"
              />
              <MetricCard 
                title="Draft Contracts" 
                value={contractStats?.byStatus?.draft?.toString() || "0"} 
                icon={Activity} 
                description="Contracts in draft status"
              />
              <MetricCard 
                title="Recently Created" 
                value={contractStats?.recentlyCreated?.toString() || "0"} 
                icon={Calendar} 
                description="Created in last 7 days"
              />
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
              <Card>
                <CardHeader>
                  <CardTitle>Contract Types Distribution</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-80">
                    <DynamicChart 
                      type="bar" 
                      data={getContractTypeData()} 
                      series={[{ dataKey: "value", name: "Count", fill: CHART_COLORS.primary }]} 
                      xAxisKey="name" 
                      height={320} 
                      showGrid={true} 
                      showLegend={false} 
                      useCustomTooltip={true}
                    />
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Analysis Status</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-80">
                    <DynamicChart 
                      type="pie" 
                      data={Object.entries(contractStats?.byAnalysisStatus || {}).map(([status, count]) => ({
                        name: status.charAt(0).toUpperCase() + status.slice(1),
                        value: count,
                        color: status === 'completed' ? CHART_COLORS.success : 
                               status === 'failed' ? CHART_COLORS.danger : 
                               status === 'processing' ? CHART_COLORS.warning : CHART_COLORS.primary
                      }))} 
                      series={[{ dataKey: "value" }]} 
                      height={320} 
                      showLegend={true} 
                      useCustomTooltip={true}
                      pieConfig={{ 
                        dataKey: "value", 
                        nameKey: "name", 
                        innerRadius: 60, 
                        outerRadius: 120 
                      }}
                    />
                  </div>
                </CardContent>
              </Card>
            </div>
          </TabsContent>

          <TabsContent value="vendors" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-4">
              <MetricCard 
                title="Total Vendors" 
                value={totalVendors.toString()} 
                icon={Building} 
                description="Registered vendor relationships"
              />
              <MetricCard 
                title="Active Relationships" 
                value={vendors?.filter(v => v.contractCount > 0).length.toString() || "0"} 
                icon={Activity} 
                description="Vendors with active contracts"
              />
              <MetricCard 
                title="Avg Contracts per Vendor" 
                value={(totalVendors > 0 ? ((contractStats?.total || 0) / totalVendors).toFixed(1) : "0")} 
                icon={Target} 
                description="Average contracts per vendor"
              />
            </div>

            <div className="grid grid-cols-1 lg:grid-cols-2 gap-4">
              <Card>
                <CardHeader>
                  <CardTitle>Vendor Categories</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-80">
                    <DynamicChart 
                      type="bar" 
                      data={getVendorCategoryData()} 
                      series={[{ dataKey: "value", name: "Vendors", fill: CHART_COLORS.secondary }]} 
                      xAxisKey="name" 
                      height={320} 
                      showGrid={true} 
                      showLegend={false} 
                      useCustomTooltip={true}
                    />
                  </div>
                </CardContent>
              </Card>

              <Card>
                <CardHeader>
                  <CardTitle>Top Vendors by Contract Count</CardTitle>
                </CardHeader>
                <CardContent>
                  <div className="h-80">
                    <DynamicChart 
                      type="bar" 
                      data={vendors?.sort((a, b) => (b.contractCount || 0) - (a.contractCount || 0))
                        .slice(0, 5)
                        .map(vendor => ({
                          name: vendor.name.length > 15 ? vendor.name.substring(0, 15) + '...' : vendor.name,
                          value: vendor.contractCount || 0
                        })) || []
                      } 
                      series={[{ dataKey: "value", name: "Contracts", fill: CHART_COLORS.tertiary }]} 
                      xAxisKey="name" 
                      height={320} 
                      showGrid={true} 
                      showLegend={false} 
                      useCustomTooltip={true}
                    />
                  </div>
                </CardContent>
              </Card>
            </div>
          </TabsContent>

          <TabsContent value="agents" className="space-y-6">
            <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-4 gap-4">
              <MetricCard 
                title="System Status" 
                value={agentSystemStatus?.system?.isRunning ? "Running" : "Stopped"} 
                icon={Activity} 
                description="AI agent system status"
              />
              <MetricCard 
                title="Active Agents" 
                value={agentSystemStatus?.stats?.activeAgents?.toString() || "0"} 
                icon={Users} 
                description="Currently running agents"
              />
              <MetricCard 
                title="Recent Insights" 
                value={agentSystemStatus?.stats?.recentInsights?.toString() || "0"} 
                icon={TrendingUp} 
                description="Insights generated (24h)"
              />
              <MetricCard 
                title="Active Tasks" 
                value={agentSystemStatus?.stats?.activeTasks?.toString() || "0"} 
                icon={Calendar} 
                description="Tasks being processed"
              />
            </div>

            {/* Recent AI Insights */}
            <Card>
              <CardHeader>
                <CardTitle>Recent AI Insights</CardTitle>
              </CardHeader>
              <CardContent>
                <div className="space-y-3">
                  {recentInsights && recentInsights.length > 0 ? (
                    recentInsights.slice(0, 5).map((insight, index) => (
                      <div key={index} className="flex items-start space-x-3 p-3 border rounded-lg">
                        <div className={`w-2 h-2 rounded-full mt-2 ${
                          insight.priority === 'critical' ? 'bg-red-500' :
                          insight.priority === 'high' ? 'bg-orange-500' :
                          insight.priority === 'medium' ? 'bg-yellow-500' : 'bg-green-500'
                        }`} />
                        <div className="flex-1">
                          <h4 className="font-medium text-sm">{insight.title}</h4>
                          <p className="text-xs text-muted-foreground mt-1">{insight.description}</p>
                          <div className="flex items-center space-x-2 mt-2 text-xs text-muted-foreground">
                            <span>{insight.agentName}</span>
                            <span></span>
                            <span>{new Date(insight.createdAt).toLocaleDateString()}</span>
                          </div>
                        </div>
                      </div>
                    ))
                  ) : (
                    <p className="text-muted-foreground text-center py-8">
                      No recent AI insights available.
                    </p>
                  )}
                </div>
              </CardContent>
            </Card>
          </TabsContent>
        </div>
      </Tabs>
    </div>
  );
};

export default DashboardContent;
</file>

<file path="src/lib/api-client.ts">
// src/lib/api-client.ts
import { useState, useMemo } from 'react';
import { api } from "../../convex/_generated/api"; // Correct path to generated API
import { useQuery, useMutation, useAction } from "convex/react";
import type {
    FunctionReference,
    FunctionArgs,
    FunctionReturnType
} from "convex/server";
import { Id } from '../../convex/_generated/dataModel'; // Correct path to generated dataModel
import type { VendorCategory } from '@/types/vendor.types'; // Import VendorCategory
import type { ContractTypeEnum } from '@/types/contract.types'; // Import ContractTypeEnum

// Define a constant for skipping queries cleanly
const SKIP_TOKEN = 'skip' as const;

/**
 * Custom hook for Convex queries with simplified loading/error handling.
 * Handles undefined state during loading and returns data, loading state, and error.
 * Supports skipping the query by passing SKIP_TOKEN as args.
 */
export function useConvexQuery<
    Query extends FunctionReference<"query">
>(
  queryFn: Query,
  args: FunctionArgs<Query> | typeof SKIP_TOKEN
) {
    const stableArgs = useMemo(() => args, [JSON.stringify(args)]);

    const result = useQuery(
        queryFn,
        stableArgs === SKIP_TOKEN ? SKIP_TOKEN : stableArgs
    );

    const isLoading = result === undefined && stableArgs !== SKIP_TOKEN;
    const error = result && typeof result === 'object' && 'message' in result ? result as Error : null;
    const data = (!isLoading && !error && stableArgs !== SKIP_TOKEN && result !== undefined)
                 ? result as FunctionReturnType<Query>
                 : null;

    return { data, isLoading, error };
}

/**
 * Custom hook for Convex mutations with loading state and error handling.
 */
export function useConvexMutation<
    Mutation extends FunctionReference<"mutation">
>(
  mutationFn: Mutation
) {
  const mutationRunner = useMutation(mutationFn);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = async (
      args: FunctionArgs<Mutation>
  ): Promise<FunctionReturnType<Mutation> | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await mutationRunner(args);
      return result as FunctionReturnType<Mutation>;
    } catch (err) {
      const caughtError = err instanceof Error ? err : new Error(String(err));
      console.error(`Mutation failed:`, caughtError);
      setError(caughtError);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { execute, isLoading, error };
}


export function useConvexAction<Action extends FunctionReference<"action">> (
  actionFn: Action
) {
  const actionRunner = useAction(actionFn);
  const [isLoading, setIsLoading] = useState(false);
  const [error, setError] = useState<Error | null>(null);

  const execute = async (
    args: FunctionArgs<Action>
  ): Promise<FunctionReturnType<Action> | null> => {
    setIsLoading(true);
    setError(null);
    try {
      const result = await actionRunner(args);
      return result as FunctionReturnType<Action>;
    } catch (err) {
      const caughtError = err instanceof Error ? err : new Error(String(err));
      console.error(`Action failed:`, caughtError);
      setError(caughtError);
      return null;
    } finally {
      setIsLoading(false);
    }
  };

  return { execute, isLoading, error };
}

// ============================================================================
// Vendor API Hooks
// ============================================================================

/**
 * Args type for fetching vendors.
 * Includes enterpriseId (required) and optional category filter.
 */
interface UseVendorsArgs {
  enterpriseId: Id<"enterprises">;
  category?: VendorCategory | "all"; // Use the imported VendorCategory type
}

/**
 * Hook to fetch vendors for a specific enterprise, with optional category filter.
 * @param args - Object containing enterpriseId and optional category.
 * Pass null/undefined or use SKIP_TOKEN to skip the query.
 */
export const useVendors = (args: UseVendorsArgs | null | undefined | typeof SKIP_TOKEN) => {
  return useConvexQuery(
      api.vendors.getVendors,
      args === SKIP_TOKEN || !args || !args.enterpriseId ? SKIP_TOKEN : args
  );
};

/**
 * Args type for fetching a single vendor.
 */
interface UseVendorArgs {
    vendorId: Id<"vendors">;
    enterpriseId: Id<"enterprises">; // For access control
}

/**
 * Hook to fetch a single vendor by its ID, ensuring it belongs to the enterprise.
 * @param args - Object containing vendorId and enterpriseId.
 * Pass null/undefined or use SKIP_TOKEN to skip.
 */
export const useVendor = (args: UseVendorArgs | null | undefined | typeof SKIP_TOKEN) => {
   return useConvexQuery(
       api.vendors.getVendorById,
       args === SKIP_TOKEN || !args || !args.vendorId || !args.enterpriseId ? SKIP_TOKEN : args
   );
};

export const useCreateVendor = () => {
  return useConvexMutation(api.vendors.createVendor);
};

export const useUpdateVendor = () => {
  return useConvexMutation(api.vendors.updateVendor);
};

export const useDeleteVendor = () => {
  return useConvexMutation(api.vendors.deleteVendor);
};


// ============================================================================
// Contract API Hooks
// ============================================================================

export const useGenerateUploadUrl = () => {
    return useConvexMutation(api.contracts.generateUploadUrl);
};

export const useCreateContract = () => {
  return useConvexMutation(api.contracts.createContract);
};

/**
 * Args type for fetching contracts for an enterprise.
 */
interface UseContractsArgs {
    enterpriseId: Id<"enterprises">;
    contractType?: ContractTypeEnum | "all"; // Use imported ContractTypeEnum
    // Add other filters if your getContracts query supports them (e.g., status)
    status?: string; // Example
}

/**
 * Hook to fetch contracts for a specific enterprise, with optional filters.
 * @param args - Object containing enterpriseId and optional filters like contractType.
 * Pass null/undefined or use SKIP_TOKEN to skip.
 */
export const useContracts = (args: UseContractsArgs | null | undefined | typeof SKIP_TOKEN) => {
    return useConvexQuery(
        api.contracts.getContracts,
        args === SKIP_TOKEN || !args || !args.enterpriseId
            ? SKIP_TOKEN
            : {
                  ...args,
                  // Explicitly narrow status to allowed values if present
                  status: args.status as
                      | "draft"
                      | "pending_analysis"
                      | "active"
                      | "expired"
                      | "terminated"
                      | "archived"
                      | "all"
                      | undefined,
                  contractType: args.contractType as
                      | "other"
                      | "nda"
                      | "msa"
                      | "sow"
                      | "saas"
                      | "lease"
                      | "employment"
                      | "partnership"
                      | "all"
                      | undefined,
              }
    );
  }

/**
 * Args type for fetching contracts by vendor.
 */
interface UseContractsByVendorArgs {
    vendorId: Id<"vendors">;
    enterpriseId: Id<"enterprises">; // To scope contracts to the enterprise
}
/**
 * Hook to fetch contracts associated with a specific vendor within an enterprise.
 * @param args - Object containing vendorId and enterpriseId.
 * Pass null/undefined or use SKIP_TOKEN to skip.
 */
export const useContractsByVendor = (args: UseContractsByVendorArgs | null | undefined | typeof SKIP_TOKEN) => {
  return useConvexQuery(
    api.contracts.getContractsByVendor,
    args === SKIP_TOKEN || !args || !args.vendorId || !args.enterpriseId ? SKIP_TOKEN : args
  );
};

/**
 * Args type for fetching a single contract.
 */
interface UseContractArgs {
    contractId: Id<"contracts">;
    enterpriseId: Id<"enterprises">; // For access control
}

/**
 * Hook to fetch a single contract by its ID, ensuring it belongs to the enterprise.
 * @param args - Object containing contractId and enterpriseId.
 * Pass null/undefined or use SKIP_TOKEN to skip.
 */
export const useContract = (args: UseContractArgs | null | undefined | typeof SKIP_TOKEN) => {
   return useConvexQuery(
       api.contracts.getContractById,
       args === SKIP_TOKEN || !args || !args.contractId || !args.enterpriseId ? SKIP_TOKEN : args
   );
};

export const useUpdateContract = () => {
  return useConvexMutation(api.contracts.updateContract);
};

export const useDeleteContract = () => {
  return useConvexMutation(api.contracts.deleteContract);
};

export const useContractFileUrl = (storageId: Id<"_storage"> | null | undefined | typeof SKIP_TOKEN) => {
    return useConvexQuery(
        api.contracts.getContractFileUrl,
        storageId === SKIP_TOKEN || !storageId ? SKIP_TOKEN : { storageId }
    );
};


// ============================================================================
// Direct API Client Export (Optional)
// ============================================================================
export const apiClient = {
  vendors: {
    create: api.vendors.createVendor,
    list: api.vendors.getVendors,
    get: api.vendors.getVendorById,
    update: api.vendors.updateVendor,
    delete: api.vendors.deleteVendor,
  },
  contracts: {
    generateUploadUrl: api.contracts.generateUploadUrl,
    create: api.contracts.createContract,
    list: api.contracts.getContracts, // Changed from listByVendor to general list
    listByVendor: api.contracts.getContractsByVendor,
    get: api.contracts.getContractById,
    getFileUrl: api.contracts.getContractFileUrl,
    update: api.contracts.updateContract,
    delete: api.contracts.deleteContract,
    // analysis functions are internal
  },
  // enterprises: { // Example if you add enterprise functions
  //   get: api.enterprises.getEnterpriseById,
  // }
};
</file>

<file path="src/app/_components/homepage/Navigation.tsx">
"use client";

import { Menu } from "lucide-react";
import { Button } from "@/components/ui/button";
import { Sheet, SheetContent, SheetTrigger } from "@/components/ui/sheet";
import { Container } from "@/app/_components/common/Container";
import { Logo } from "@/app/_components/common/Logo";
import { useRouter } from "next/navigation";
import { useAuth, SignInButton, SignUpButton, UserButton } from "@clerk/nextjs";

const navItems = [
  { href: "#contact", label: "Contact" },
];

export const Navigation = () => {
  const { isSignedIn } = useAuth();
  const router = useRouter();
  
  return (
    <nav className="sticky top-0 z-50 w-full border-b bg-background/95 backdrop-blur supports-[backdrop-filter]:bg-background/60">
      <Container>
        <div className="flex h-16 items-center justify-between">
          <div className="flex items-center">
            <Logo size="md" />
          </div>

          {/* Desktop Navigation */}
          <div className="hidden md:flex md:items-center md:space-x-6">
            {navItems.map((item) => (    
              <a
              key={item.href}          
                href={item.href}
                className="text-sm font-medium text-muted-foreground hover:text-primary transition-colors"
              >
                {item.label}
              </a>
            ))}
            
            {isSignedIn ? (
              <div className="flex items-center space-x-4">
                <Button 
                  variant="outline"
                  className="border-gold/50 text-primary hover:bg-gold/5" 
                  onClick={() => router.push('/dashboard')}
                >
                  Dashboard
                </Button>
                <UserButton afterSignOutUrl="/" />
              </div>
            ) : (
              <div className="flex items-center space-x-4">
                <SignInButton 
                  mode="modal"
                  forceRedirectUrl="/dashboard"
                  fallbackRedirectUrl="/dashboard"
                >
                  <Button variant="outline" className="border-gold/50 text-primary hover:bg-gold/5">
                    Sign In
                  </Button>
                </SignInButton>
                <SignUpButton 
                  mode="modal"
                  forceRedirectUrl="/dashboard"
                  fallbackRedirectUrl="/dashboard"
                >
                  <Button variant="outline" className="border-gold/50 text-primary hover:bg-gold/5 w-half">
                    Sign Up
                  </Button>
                </SignUpButton>
              </div>
            )}
          </div>

          {/* Mobile Navigation */}
          <div className="md:hidden">
            <Sheet>
              <SheetTrigger asChild>
                <Button variant="ghost" size="icon">
                  <Menu className="h-6 w-6" />
                </Button>
              </SheetTrigger>
              <SheetContent side="right" className="w-[300px] sm:w-[400px]">
                <nav className="flex flex-col gap-4 mt-8">
                  {navItems.map((item) => (
                    <a
                      key={item.href}
                      href={item.href}
                      className="text-sm font-medium text-muted-foreground hover:text-primary transition-colors"
                    >
                      {item.label}
                    </a>
                  ))}
                  
                  <div className="border-t border-gold/10 my-4 pt-4">
                    {isSignedIn ? (
                      <div className="flex flex-col gap-4">
                        <Button 
                          variant="outline"
                          className="border-gold/50 text-primary hover:bg-gold/5 w-full" 
                          onClick={() => router.push('/dashboard')}
                        >
                          Dashboard
                        </Button>
                        <div className="flex items-center justify-between">
                          <span className="text-sm font-medium text-muted-foreground">Your Account</span>
                          <UserButton afterSignOutUrl="/" />
                        </div>
                      </div>
                    ) : (
                      <div className="flex flex-col gap-4">
                        <SignInButton 
                          mode="modal"
                          forceRedirectUrl="/dashboard"
                          fallbackRedirectUrl="/dashboard"
                        >
                          <Button variant="outline" className="border-gold/50 text-primary hover:bg-gold/5 w-full">
                            Sign In
                          </Button>
                        </SignInButton>
                        <SignUpButton 
                          mode="modal"
                          forceRedirectUrl="/dashboard"
                          fallbackRedirectUrl="/dashboard"
                        >
                          <Button variant="outline" className="border-gold/50 text-primary hover:bg-gold/5 w-full">
                            Sign Up
                          </Button>
                        </SignUpButton>
                      </div>
                    )}
                  </div>
                </nav>
              </SheetContent>
            </Sheet>
          </div>
        </div>
      </Container>
    </nav>
  );
};
</file>

<file path="src/app/layout.tsx">
import type { Metadata } from "next";
import "./globals.css";
import { ConvexClientProvider } from "./ConvexClientProvider";
import { ClerkProvider } from '@clerk/nextjs'; // Import ClerkProvider
import { ErrorBoundary } from './_components/common/ErrorBoundary';
import { SessionWrapper } from './_components/auth/SessionWrapper';
import { MonitoringProvider, HealthIndicator } from './_components/common/MonitoringProvider';

export const metadata: Metadata = {
  title: "Pactwise",
  description: "An application to help manage your contracts and vendors",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <ClerkProvider publishableKey={process.env.NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY}>
      <html lang="en">
        <body>
          <ErrorBoundary>
            <MonitoringProvider>
              <SessionWrapper>
                <ConvexClientProvider>
                  {children}
                  <HealthIndicator />
                </ConvexClientProvider>
              </SessionWrapper>
            </MonitoringProvider>
          </ErrorBoundary>
        </body>
      </html>
    </ClerkProvider>
  );
}
</file>

<file path="convex/contracts.ts">
import { query, mutation, action, internalMutation } from "./_generated/server";
import { v } from "convex/values";
import { Id } from "./_generated/dataModel";
import { ConvexError } from "convex/values";
import { internal, api } from "./_generated/api";
import { triggerContractEvents } from "./realtimeHelpers";
import { ContractFilters, CreateContractArgs, UpdateContractArgs } from "./types";
import { rateLimitHelpers } from "./security/applyRateLimit";

// Contract type options (matching schema.ts)
const contractTypeOptions = [
  "nda", "msa", "sow", "saas", "lease", "employment", "partnership", "other"
] as const;

// Contract status options (matching schema.ts)
const contractStatusOptions = [
  "draft", "pending_analysis", "active", "expired", "terminated", "archived",
] as const;

// Analysis status options (matching schema.ts)
const analysisStatusOptions = [
  "pending", "processing", "completed", "failed"
] as const;

// ============================================================================
// FILE UPLOAD
// ============================================================================

/**
 * Generate upload URL for contract files
 */
export const generateUploadUrl = mutation({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in to upload files.");
    }
    
    // Generate upload URL for file storage
    return await ctx.storage.generateUploadUrl();
  },
});

/**
 * Get contract file URL from storage
 */
export const getContractFileUrl = query({
  args: {
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to access contract files.");
    }
    
    return await ctx.storage.getUrl(args.storageId);
  },
});

// ============================================================================
// CREATE
// ============================================================================

/**
 * Create a new contract
 */
export const createContract = mutation({
  args: {
    enterpriseId: v.id("enterprises"),
    vendorId: v.id("vendors"),
    title: v.string(),
    storageId: v.id("_storage"),
    fileName: v.string(),
    fileType: v.string(),
    contractType: v.optional(
      v.union(...contractTypeOptions.map(option => v.literal(option)))
    ),
    notes: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    // Apply rate limiting for contract creation
    await rateLimitHelpers.forContractMutation("create", "create")(ctx);
    
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in to create a contract.");
    }

    // Validate required fields
    if (!args.title || args.title.trim() === "") {
      throw new ConvexError("Validation Error: Contract title cannot be empty.");
    }

    // Validate that vendor belongs to the enterprise
    const vendor = await ctx.db.get(args.vendorId);
    if (!vendor) {
      throw new ConvexError("Vendor not found.");
    }
    if (vendor.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Vendor does not belong to the specified enterprise.");
    }

    // Get current user for events
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (!user) {
      throw new ConvexError("User not found.");
    }

    // Create the contract
    const contractId = await ctx.db.insert("contracts", {
      enterpriseId: args.enterpriseId,
      vendorId: args.vendorId,
      title: args.title.trim(),
      status: "draft",
      contractType: args.contractType,
      storageId: args.storageId,
      fileName: args.fileName,
      fileType: args.fileType,
      analysisStatus: "pending",
      notes: args.notes?.trim() || undefined,
      createdAt: ""
    });

    // Trigger real-time event
    await triggerContractEvents(
      ctx,
      "create",
      contractId,
      user._id,
      args.enterpriseId,
      {
        title: args.title.trim(),
        contractType: args.contractType,
        vendorId: args.vendorId,
      }
    );

    // Trigger contract analysis (optional - can be done manually or via agent system)
    // For now, we'll leave the contract in draft status until analysis is manually triggered

    console.log(`Contract created with ID: ${contractId} for enterprise ${args.enterpriseId}`);
    return contractId;
  },
});

// ============================================================================
// READ
// ============================================================================

/**
 * Get contracts for an enterprise with optional filters
 */
export const getContracts = query({
  args: {
    enterpriseId: v.id("enterprises"),
    contractType: v.optional(
      v.union(
        ...contractTypeOptions.map(option => v.literal(option)),
        v.literal("all")
      )
    ),
    status: v.optional(
      v.union(
        ...contractStatusOptions.map(option => v.literal(option)),
        v.literal("all")
      )
    ),
    limit: v.optional(v.number()),
    cursor: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to view contracts.");
    }

    const limit = args.limit || 50; // Default page size

    let queryBuilder = ctx.db
      .query("contracts")
      .withIndex("by_status_and_enterpriseId", (q) => 
        q.eq("enterpriseId", args.enterpriseId)
      );

    // Apply status filter if provided and not "all"
    if (args.status && args.status !== "all") {
      queryBuilder = ctx.db
        .query("contracts")
        .withIndex("by_status_and_enterpriseId", (q) =>
          q.eq("enterpriseId", args.enterpriseId).eq("status", args.status as Exclude<typeof args.status, "all">)
        );
    }

    // Apply pagination
    const paginationBuilder = queryBuilder.order("desc");
    
    let contracts;
    let nextCursor: string | null = null;
    
    if (args.cursor) {
      // Continue from cursor
      const result = await paginationBuilder.paginate({ cursor: args.cursor, numItems: limit });
      contracts = result.page;
      nextCursor = result.continueCursor;
    } else {
      // First page
      const result = await paginationBuilder.paginate({ numItems: limit });
      contracts = result.page;
      nextCursor = result.continueCursor;
    }

    // Apply contract type filter if provided and not "all"
    if (args.contractType && args.contractType !== "all") {
      contracts = contracts.filter(contract => contract.contractType === args.contractType);
    }

    // Optimize: Fetch vendor information in parallel for all contracts
    const vendorIds = [...new Set(contracts.map(contract => contract.vendorId))];
    const vendorsMap = new Map();
    
    if (vendorIds.length > 0) {
      const vendors = await Promise.all(
        vendorIds.map(vendorId => ctx.db.get(vendorId))
      );
      
      vendors.forEach(vendor => {
        if (vendor) {
          vendorsMap.set(vendor._id, {
            _id: vendor._id,
            name: vendor.name,
            category: vendor.category,
          });
        }
      });
    }

    // Enrich contracts with vendor information
    const contractsWithVendors = contracts.map(contract => ({
      ...contract,
      vendor: vendorsMap.get(contract.vendorId) || null,
    }));

    return {
      contracts: contractsWithVendors,
      nextCursor,
      hasMore: nextCursor !== null,
    };
  },
});

/**
 * Get contracts for an enterprise (simple version for backward compatibility)
 */
export const getContractsSimple = query({
  args: {
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const result = await ctx.runQuery(api.contracts.getContracts, {
      enterpriseId: args.enterpriseId,
      limit: 100, // Get first 100 contracts
    });
    return result.contracts;
  },
});

/**
 * Get contracts by vendor
 */
export const getContractsByVendor = query({
  args: {
    vendorId: v.id("vendors"),
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to view contracts.");
    }

    // Verify vendor belongs to enterprise
    const vendor = await ctx.db.get(args.vendorId);
    if (!vendor || vendor.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Vendor not found or access denied.");
    }

    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_vendorId_and_enterpriseId", (q) =>
        q.eq("enterpriseId", args.enterpriseId).eq("vendorId", args.vendorId)
      )
      .order("desc")
      .collect();

    // Enrich with vendor information
    const contractsWithVendor = contracts.map(contract => ({
      ...contract,
      vendor: {
        _id: vendor._id,
        name: vendor.name,
        category: vendor.category,
      },
    }));

    return contractsWithVendor;
  },
});

/**
 * Get a single contract by ID
 */
export const getContractById = query({
  args: {
    contractId: v.id("contracts"),
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to view contract details.");
    }

    const contract = await ctx.db.get(args.contractId);
    if (!contract) {
      return null;
    }

    // Security check: ensure contract belongs to the enterprise
    if (contract.enterpriseId !== args.enterpriseId) {
      console.warn(`User attempted to access contract ${args.contractId} not belonging to their enterprise ${args.enterpriseId}.`);
      return null;
    }

    // Get vendor information
    const vendor = await ctx.db.get(contract.vendorId);

    return {
      ...contract,
      vendor: vendor ? {
        _id: vendor._id,
        name: vendor.name,
        category: vendor.category,
        contactEmail: vendor.contactEmail,
        contactPhone: vendor.contactPhone,
      } : null,
    };
  },
});

// ============================================================================
// UPDATE
// ============================================================================

/**
 * Update contract details
 */
export const updateContract = mutation({
  args: {
    contractId: v.id("contracts"),
    enterpriseId: v.id("enterprises"),
    title: v.optional(v.string()),
    status: v.optional(
      v.union(...contractStatusOptions.map(option => v.literal(option)))
    ),
    contractType: v.optional(
      v.union(...contractTypeOptions.map(option => v.literal(option)))
    ),
    notes: v.optional(v.string()),
    // Allow updating extracted fields if needed
    extractedParties: v.optional(v.array(v.string())),
    extractedStartDate: v.optional(v.string()),
    extractedEndDate: v.optional(v.string()),
    extractedPaymentSchedule: v.optional(v.string()),
    extractedPricing: v.optional(v.string()),
    extractedScope: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in to update a contract.");
    }

    const existingContract = await ctx.db.get(args.contractId);
    if (!existingContract) {
      throw new ConvexError(`Contract not found with ID: ${args.contractId}`);
    }

    // Security check: ensure user is updating a contract within their enterprise
    if (existingContract.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Permission denied: You do not have permission to update this contract.");
    }

    const { contractId, enterpriseId, ...updates } = args;

    // Validate title if provided
    if (updates.title !== undefined && updates.title.trim() === "") {
      throw new ConvexError("Validation Error: Contract title cannot be empty.");
    }
    if (updates.title) {
      updates.title = updates.title.trim();
    }

    // Trim notes if provided
    if (updates.notes) {
      updates.notes = updates.notes.trim();
    }

    // Remove undefined values
    (Object.keys(updates) as Array<keyof typeof updates>).forEach(key => {
      if (updates[key] === undefined) {
        delete updates[key];
      }
    });

    if (Object.keys(updates).length === 0) {
      console.log("No fields provided to update for contract:", contractId);
      return { success: true, message: "No fields provided to update." };
    }

    await ctx.db.patch(args.contractId, updates);

    console.log(`Contract updated with ID: ${args.contractId}. Updates applied:`, updates);
    return { success: true };
  },
});

// ============================================================================
// DELETE
// ============================================================================

/**
 * Delete a contract
 */
export const deleteContract = mutation({
  args: {
    contractId: v.id("contracts"),
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in to delete a contract.");
    }

    const existingContract = await ctx.db.get(args.contractId);
    if (!existingContract) {
      throw new ConvexError(`Contract not found with ID: ${args.contractId}`);
    }

    // Security check: ensure user is deleting a contract within their enterprise
    if (existingContract.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Permission denied: You do not have permission to delete this contract.");
    }

    // Delete the associated file from storage
    try {
      await ctx.storage.delete(existingContract.storageId);
    } catch (error) {
      console.warn(`Failed to delete file for contract ${args.contractId}:`, error);
      // Continue with contract deletion even if file deletion fails
    }

    // Delete the contract
    await ctx.db.delete(args.contractId);

    console.log(`Contract deleted with ID: ${args.contractId} from enterprise ${args.enterpriseId}`);
    return { success: true };
  },
});

// ============================================================================
// ANALYSIS (Internal Actions)
// ============================================================================

/**
 * Analyze contract content (can be called by agents or manually)
 */
export const analyzeContract = action({
  args: {
    contractId: v.id("contracts"),
  },
  handler: async (ctx, args) => {
    try {
      // Get the contract directly
      const contract = await ctx.runQuery(api.contracts.getContractForAnalysis, {
        contractId: args.contractId,
      });

      if (!contract) {
        throw new Error("Contract not found for analysis");
      }

      // Update status to processing
      await ctx.runMutation(api.contracts.updateAnalysisStatus, {
        contractId: args.contractId,
        status: "processing",
      });

      // Get file content
      const fileUrl = await ctx.storage.getUrl(contract.storageId);
      if (!fileUrl) {
        throw new Error("Could not get file URL for analysis");
      }

      // Simulate contract analysis (replace with actual AI/ML analysis)
      const analysisResult = await simulateContractAnalysis(fileUrl, contract);

      // Update contract with analysis results
      await ctx.runMutation(api.contracts.updateAnalysisResults, {
        contractId: args.contractId,
        analysisResult,
      });

      console.log(`Contract analysis completed for contract ${args.contractId}`);

    } catch (error) {
      console.error(`Contract analysis failed for contract ${args.contractId}:`, error);
      
      // Update status to failed
      await ctx.runMutation(api.contracts.updateAnalysisStatus, {
        contractId: args.contractId,
        status: "failed",
        error: error instanceof Error ? error.message : String(error),
      });
    }
  },
});

// ============================================================================
// INTERNAL HELPERS (for analysis workflow)
// ============================================================================

export const getContractForAnalysis = query({
  args: {
    contractId: v.id("contracts"),
  },
  handler: async (ctx, args) => {
    return await ctx.db.get(args.contractId);
  },
});

export const updateAnalysisStatus = mutation({
  args: {
    contractId: v.id("contracts"),
    status: v.union(...analysisStatusOptions.map(option => v.literal(option))),
    error: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const updates: any = {
      analysisStatus: args.status,
    };

    if (args.error) {
      updates.analysisError = args.error;
    } else if (args.status === "processing") {
      // Clear any previous error when starting processing
      updates.analysisError = undefined;
    }

    await ctx.db.patch(args.contractId, updates);
  },
});

export const updateAnalysisResults = mutation({
  args: {
    contractId: v.id("contracts"),
    analysisResult: v.object({
      extractedParties: v.optional(v.array(v.string())),
      extractedStartDate: v.optional(v.string()),
      extractedEndDate: v.optional(v.string()),
      extractedPaymentSchedule: v.optional(v.string()),
      extractedPricing: v.optional(v.string()),
      extractedScope: v.optional(v.string()),
    }),
  },
  handler: async (ctx, args) => {
    await ctx.db.patch(args.contractId, {
      analysisStatus: "completed",
      analysisError: undefined,
      status: "active", // Move to active status after successful analysis
      ...args.analysisResult,
    });
  },
});

// ============================================================================
// HELPER FUNCTIONS
// ============================================================================

/**
 * Simulate contract analysis (replace with actual AI/ML integration)
 */
async function simulateContractAnalysis(fileUrl: string, contract: any): Promise<{
  extractedParties?: string[];
  extractedStartDate?: string;
  extractedEndDate?: string;
  extractedPaymentSchedule?: string;
  extractedPricing?: string;
  extractedScope?: string;
}> {
  // Simulate processing delay
  await new Promise(resolve => setTimeout(resolve, 2000));

  // Mock analysis results based on contract type and filename
  const mockResults: any = {};

  // Extract parties (mock)
  mockResults.extractedParties = [
    "Acme Corp", // Your company
    contract.vendor?.name || "Vendor Name"
  ];

  // Mock dates based on current date
  const startDate = new Date();
  const endDate = new Date();
  endDate.setFullYear(endDate.getFullYear() + 1); // 1 year contract

  mockResults.extractedStartDate = startDate.toISOString().split('T')[0];
  mockResults.extractedEndDate = endDate.toISOString().split('T')[0];

  // Mock pricing based on contract type
  const pricingMap: Record<string, string> = {
    saas: "$500/month",
    nda: "No fees",
    msa: "$10,000",
    sow: "$25,000",
    lease: "$2,000/month",
    employment: "$75,000/year",
    partnership: "Revenue share: 30%",
    other: "$5,000"
  };

  mockResults.extractedPricing = pricingMap[contract.contractType] || "$1,000";

  // Mock payment schedule
  const paymentMap: Record<string, string> = {
    saas: "Monthly recurring payment due on the 1st of each month",
    msa: "Net 30 payment terms",
    sow: "50% upfront, 50% on completion",
    lease: "Monthly payment due on the 1st",
    employment: "Bi-weekly salary payments",
    partnership: "Quarterly revenue sharing",
    other: "Payment due within 30 days"
  };

  mockResults.extractedPaymentSchedule = paymentMap[contract.contractType] || "Net 30 payment terms";

  // Mock scope
  const scopeMap: Record<string, string> = {
    saas: "Software as a Service platform access and support",
    nda: "Confidentiality obligations for proprietary information",
    msa: "General terms for ongoing professional services",
    sow: "Specific project deliverables and milestones",
    lease: "Office space rental and facilities usage",
    employment: "Full-time employment terms and conditions",
    partnership: "Strategic partnership and collaboration terms",
    other: "General business agreement terms"
  };

  mockResults.extractedScope = scopeMap[contract.contractType] || "General business services";

  return mockResults;
}

// ============================================================================
// UTILITY QUERIES
// ============================================================================

/**
 * Get contract statistics for an enterprise
 */
export const getContractStats = query({
  args: {
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to view contract statistics.");
    }

    const contracts = await ctx.db
      .query("contracts")
      .withIndex("by_status_and_enterpriseId", (q) => 
        q.eq("enterpriseId", args.enterpriseId)
      )
      .collect();

    const stats = {
      total: contracts.length,
      byStatus: {} as Record<string, number>,
      byType: {} as Record<string, number>,
      byAnalysisStatus: {} as Record<string, number>,
      recentlyCreated: 0,
    };

    const oneWeekAgo = Date.now() - (7 * 24 * 60 * 60 * 1000);

    contracts.forEach(contract => {
      // Count by status
      stats.byStatus[contract.status] = (stats.byStatus[contract.status] || 0) + 1;

      // Count by type
      const type = contract.contractType || "other";
      stats.byType[type] = (stats.byType[type] || 0) + 1;

      // Count by analysis status
      const analysisStatus = contract.analysisStatus || "pending";
      stats.byAnalysisStatus[analysisStatus] = (stats.byAnalysisStatus[analysisStatus] || 0) + 1;

      // Count recently created
      if (contract._creationTime && contract._creationTime > oneWeekAgo) {
        stats.recentlyCreated++;
      }
    });

    return stats;
  },
});

/**
 * Manually trigger contract analysis
 */
export const triggerContractAnalysis = mutation({
  args: {
    contractId: v.id("contracts"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required");
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      throw new ConvexError("User not found");
    }

    const contract = await ctx.db.get(args.contractId);
    if (!contract) {
      throw new ConvexError("Contract not found");
    }

    // Verify user has access to this contract's enterprise
    if (contract.enterpriseId !== user.enterpriseId) {
      throw new ConvexError("Access denied");
    }

    // Update analysis status to pending
    await ctx.db.patch(args.contractId, {
      analysisStatus: "pending",
      analysisError: undefined,
    });

    // Schedule analysis action (in a real implementation, this would trigger the AI analysis)
    await ctx.scheduler.runAfter(0, internal.contracts.analyzeContractInternal, {
      contractId: args.contractId,
    });

    return { success: true };
  },
});

/**
 * Internal contract analysis function for scheduling
 */
export const analyzeContractInternal = internalMutation({
  args: {
    contractId: v.id("contracts"),
  },
  handler: async (ctx, args) => {
    try {
      // Update status to processing
      await ctx.db.patch(args.contractId, {
        analysisStatus: "processing",
        analysisError: undefined,
      });
      
      // In a real implementation, this would perform AI analysis
      // For now, we'll simulate completion
      await ctx.db.patch(args.contractId, {
        analysisStatus: "completed",
      });
      
    } catch (error) {
      // Update with error status
      await ctx.db.patch(args.contractId, {
        analysisStatus: "failed",
        analysisError: error instanceof Error ? error.message : "Analysis failed",
      });
    }
  },
});
</file>

<file path="convex/users.ts">
// convex/users.ts
import { query, mutation } from "./_generated/server";
import { v } from "convex/values";
import { ConvexError } from "convex/values";
import { UserRole, userRoleOptions } from "./schema"; // Import from schema

// ============================================================================
// USER MANAGEMENT
// ============================================================================

/**
 * Get user from Clerk authentication. Returns the user document or null if not found/not authenticated.
 */
export const getCurrentUser = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return null; // Not authenticated
    }

    // Look for existing user by Clerk ID
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    return existingUser; // Returns user document or null
  },
});

/**
 * Get user by ID
 */
export const getById = query({
  args: {
    userId: v.id("users"),
  },
  handler: async (ctx, args) => {
    const user = await ctx.db.get(args.userId);
    return user;
  },
});

/**
 * Get user by Clerk ID (for secure action authentication)
 */
export const getByClerkId = query({
  args: {
    clerkId: v.string(),
  },
  handler: async (ctx, args) => {
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", args.clerkId))
      .first();
    return user;
  },
});

/**
 * Get all users for an enterprise (admin only)
 */
export const getEnterpriseUsers = query({
  args: {
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to view users.");
    }

    // Check if current user is admin or owner of the enterprise
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied: You can only view users from your enterprise.");
    }

    if (!["owner", "admin"].includes(currentUser.role)) {
      throw new ConvexError("Access denied: Only owners and admins can view all users.");
    }

    // Get all users for the enterprise
    const users = await ctx.db
      .query("users")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", args.enterpriseId))
      .collect();

    // Return users with sensitive info filtered
    return users.map(user => ({
      _id: user._id,
      email: user.email,
      firstName: user.firstName,
      lastName: user.lastName,
      role: user.role,
      isActive: user.isActive,
      lastLoginAt: user.lastLoginAt,
      department: user.department,
      title: user.title,
      createdAt: user.createdAt,
      updatedAt: user.updatedAt,
    }));
  },
});

/**
 * Create or update user from Clerk data.
 * This function is typically called after a user signs in or signs up.
 */
export const upsertUser = mutation({
  args: {
    // enterpriseId might be passed if a user is joining a specific enterprise directly,
    // e.g. after creating it or if determined by another flow.
    enterpriseId: v.optional(v.id("enterprises")),
    invitationToken: v.optional(v.string()), // For joining via invitation
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: No user identity found.");
    }

    // Check for existing user by Clerk ID
    const existingUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (existingUser) {
      await ctx.db.patch(existingUser._id, {
        lastLoginAt: new Date().toISOString(),
        firstName: typeof identity.given_name === "string" ? identity.given_name : undefined,
        lastName: typeof identity.family_name === "string" ? identity.family_name : undefined,
        email: identity.email || existingUser.email, 
      });
      return existingUser._id;
    }

    // New user: Determine enterprise and role
    let resolvedEnterpriseId = args.enterpriseId;
    let resolvedRole: UserRole = "user"; // Default role as per ROLE_PERMISSIONS.md

    // 1. Process invitation token if provided
    if (args.invitationToken) {
      const invitationToken = args.invitationToken as string;
      const invitation = await ctx.db
        .query("invitations")
        .withIndex("by_token", (q) => q.eq("token", invitationToken))
        .filter(q => q.eq(q.field("email"), identity.email)) // Match email
        .filter(q => q.eq(q.field("acceptedAt"), undefined)) // Not yet accepted
        .filter(q => q.gt(q.field("expiresAt"), new Date().toISOString())) // Not expired
        .first();
      
      if (invitation) {
        resolvedEnterpriseId = invitation.enterpriseId;
        resolvedRole = invitation.role;
        
        // Mark invitation as accepted
        await ctx.db.patch(invitation._id, {
          acceptedAt: new Date().toISOString(),
        });
      } else {
        // Optional: Handle invalid/expired token explicitly, or let it fall through
        console.warn(`Invalid or expired invitation token: ${args.invitationToken} for email ${identity.email}`);
      }
    }

    // 2. If no enterprise from invitation or args, try domain matching
    if (!resolvedEnterpriseId && identity.email) {
      const domain = identity.email.split('@')[1];
      if (domain) {
        const enterpriseByDomain = await ctx.db
          .query("enterprises")
          .withIndex("by_domain", (q) => q.eq("domain", domain))
          .first();
        
        if (enterpriseByDomain) {
          resolvedEnterpriseId = enterpriseByDomain._id;
          // Users joining via domain match typically get 'user' role by default
          // unless specific logic dictates otherwise.
        }
      }
    }

    // 3. Enterprise ID is crucial. If still not resolved, it's an issue.
    // This scenario implies the user needs to create an enterprise or be explicitly added to one.
    // `createEnterpriseWithOwner` handles the first user/owner case.
    if (!resolvedEnterpriseId) {
      // This could happen if a user signs up without an invitation and their domain doesn't match an existing enterprise.
      // The frontend flow should guide them to create an enterprise or request access.
      throw new ConvexError(
        "Enterprise not found. Please create an enterprise or use a valid invitation."
      );
    }

    // Create the new user document
    const userId = await ctx.db.insert("users", {
      clerkId: identity.subject,
      email: identity.email || "", // Ensure email is always set
      firstName: typeof identity.given_name === "string" ? identity.given_name : undefined,
      lastName: typeof identity.family_name === "string" ? identity.family_name : undefined,
      enterpriseId: resolvedEnterpriseId,
      role: resolvedRole,
      isActive: true, // New users are active by default
      lastLoginAt: new Date().toISOString(),
      createdAt: new Date().toISOString(),
    });

    return userId;
  },
});

/**
 * Get all users for a specific enterprise.
 * Requires the current user to be part of that enterprise.
 */
export const getEnterpriseUsers = query({
  args: {
    enterpriseId: v.id("enterprises"),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required: User must be logged in.");
    }

    // Verify current user belongs to the target enterprise to view its users
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser || currentUser.enterpriseId !== args.enterpriseId) {
      throw new ConvexError("Access denied: You are not authorized to view users for this enterprise.");
    }

    // Fetch users for the specified enterprise
    const users = await ctx.db
      .query("users")
      .withIndex("by_enterprise", (q) => q.eq("enterpriseId", args.enterpriseId))
      .collect();

    return users;
  },
});


/**
 * Get enterprise details by email domain.
 * Useful for sign-up flows to suggest an enterprise.
 */
export const getEnterpriseByEmailDomain = query({ // Renamed for clarity
  args: { email: v.string() },
  handler: async (ctx, args) => {
    const domain = args.email.split('@')[1];
    if (!domain) {
        return null; // Or throw new ConvexError("Invalid email format: Domain missing.");
    }
    
    return await ctx.db
      .query("enterprises")
      .withIndex("by_domain", (q) => q.eq("domain", domain))
      .first();
  },
});

/**
 * Update a user's role within their enterprise.
 * Only callable by 'owner' or 'admin' of the same enterprise.
 * Admins cannot modify Owners.
 */
export const updateUserRole = mutation({
  args: {
    userIdToUpdate: v.id("users"), // ID of the user whose role is being changed
    newRole: v.union(...userRoleOptions.map(r => v.literal(r))), // Use the imported userRoleOptions
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required.");
    }

    // Get the current (acting) user
    const currentUser = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!currentUser) {
      throw new ConvexError("Current user not found.");
    }

    // Permission Check: Only 'owner' or 'admin' can update roles
    if (currentUser.role !== "owner" && currentUser.role !== "admin") {
      throw new ConvexError("Permission denied: Only Owners or Admins can update user roles.");
    }

    // Get the target user (the user whose role is to be updated)
    const targetUser = await ctx.db.get(args.userIdToUpdate);
    if (!targetUser) {
      throw new ConvexError("Target user not found.");
    }

    // Ensure both users are in the same enterprise
    if (targetUser.enterpriseId !== currentUser.enterpriseId) {
      throw new ConvexError("Cannot update user roles across different enterprises.");
    }

    // Role-specific restrictions from ROLE_PERMISSIONS.md
    // Admin cannot modify Owner roles
    if (targetUser.role === "owner" && currentUser.role === "admin") {
      throw new ConvexError("Admins cannot modify the roles of Owners.");
    }
    // Owners cannot be demoted by anyone but another Owner (implicitly handled if there's only one owner,
    // but good to be explicit if multiple owners were possible and had different levels)
    // If demoting an Owner, the current user must be an Owner.
    if (targetUser.role === "owner" && args.newRole !== "owner" && currentUser.role !== "owner") {
        throw new ConvexError("Only an Owner can change another Owner's role to a non-Owner role.");
    }


    // Perform the update
    await ctx.db.patch(args.userIdToUpdate, {
      role: args.newRole,
      updatedAt: new Date().toISOString(), // Update timestamp
    });

    return { success: true, message: `User role updated to ${args.newRole}.` };
  },
});

// ============================================================================
// HELPER QUERIES
// ============================================================================

/**
 * Check if the current authenticated user has a specific level of access to an enterprise.
 */
export const hasEnterpriseAccess = query({
  args: {
    enterpriseId: v.id("enterprises"),
    requiredRole: v.optional(v.union(...userRoleOptions.map(r => v.literal(r)))),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return false; // Not authenticated
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user || user.enterpriseId !== args.enterpriseId) {
      return false; // User not found or does not belong to the specified enterprise
    }

    // If no specific role is required, just belonging to the enterprise is enough
    if (!args.requiredRole) {
      return true;
    }

    // Role hierarchy based on ROLE_PERMISSIONS.md
    // Owner (Level 5), Admin (Level 4), Manager (Level 3), User (Level 2), Viewer (Level 1)
    const roleHierarchy: Record<UserRole, number> = {
      owner: 5,
      admin: 4,
      manager: 3,
      user: 2,
      viewer: 1,
    };

    const userLevel = roleHierarchy[user.role];
    const requiredLevel = roleHierarchy[args.requiredRole];

    return userLevel >= requiredLevel; // User's role level must be greater than or equal to required
  },
});

/**
 * Get the current user's context including their enterprise and role information.
 */
export const getUserContext = query({
  args: {},
  handler: async (ctx) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      return null; // User not authenticated
    }

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!user) {
      // This case implies the user is authenticated with Clerk but doesn't have a corresponding user record in Convex.
      // This might happen if upsertUser hasn't completed or failed.
      // Frontend should ideally handle this by prompting for enterprise creation/joining.
      return { user: null, enterprise: null, message: "User record not found in Convex. Please complete setup." };
    }

    const enterprise = await ctx.db.get(user.enterpriseId);

    return {
      user: {
        _id: user._id,
        clerkId: user.clerkId,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
        isActive: user.isActive,
      },
      enterprise: enterprise ? {
        _id: enterprise._id,
        name: enterprise.name,
        domain: enterprise.domain,
      } : null, // Enterprise might be null if ID is stale, though unlikely with proper data integrity.
    };
  },
});


/**
 *  Updating a user's profile
 */
export const updateUserProfile = mutation({
  args: {
    // userId: v.id("users"), // Clerk ID will be used from identity
    firstName: v.optional(v.string()),
    lastName: v.optional(v.string()),
    phoneNumber: v.optional(v.string()),
    department: v.optional(v.string()),
    title: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) {
      throw new ConvexError("Authentication required to update profile.");
    }

    const userToUpdate = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();

    if (!userToUpdate) {
      throw new ConvexError("User not found.");
    }

    const updates: Partial<typeof userToUpdate> = {};

    if (args.firstName !== undefined) {
      if (args.firstName.trim().length < 1 && userToUpdate.firstName === undefined) { // only error if it was undefined and now it is empty
         // Allow clearing if already set
      } else if (args.firstName.trim().length < 1 && userToUpdate.firstName !== undefined) {
         updates.firstName = undefined; // Set to undefined to clear
      }
      else if (args.firstName.trim().length > 0) {
        updates.firstName = args.firstName.trim();
      }
    }

    if (args.lastName !== undefined) {
      if (args.lastName.trim().length < 1 && userToUpdate.lastName === undefined) {
        // Allow clearing if already set
      } else if (args.lastName.trim().length < 1 && userToUpdate.lastName !== undefined) {
          updates.lastName = undefined; // Set to undefined to clear
      }
      else if (args.lastName.trim().length > 0) {
        updates.lastName = args.lastName.trim();
      }
    }


    if (args.phoneNumber !== undefined) {
      updates.phoneNumber = args.phoneNumber.trim() || undefined;
    }
    if (args.department !== undefined) {
      updates.department = args.department.trim() || undefined;
    }
    if (args.title !== undefined) {
      updates.title = args.title.trim() || undefined;
    }

    if (Object.keys(updates).length > 0) {
      updates.updatedAt = new Date().toISOString();
      await ctx.db.patch(userToUpdate._id, updates);
    }

    return { success: true, message: "Profile updated successfully." };
  },
});
</file>

<file path="package.json">
{
  "name": "pactwise-fork",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev --turbopack",
    "build": "next build",
    "start": "next start",
    "lint": "next lint"
  },
  "dependencies": {
    "@auth/core": "^0.37.0",
    "@clerk/clerk-react": "^5.25.6",
    "@clerk/nextjs": "^6.12.12",
    "@convex-dev/auth": "^0.0.80",
    "@radix-ui/react-avatar": "^1.1.3",
    "@radix-ui/react-dialog": "^1.1.6",
    "@radix-ui/react-dropdown-menu": "^2.1.6",
    "@radix-ui/react-label": "^2.1.2",
    "@radix-ui/react-popover": "^1.1.6",
    "@radix-ui/react-scroll-area": "^1.2.3",
    "@radix-ui/react-select": "^2.1.6",
    "@radix-ui/react-separator": "^1.1.2",
    "@radix-ui/react-slot": "^1.1.2",
    "@radix-ui/react-switch": "^1.1.3",
    "@radix-ui/react-tabs": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.6",
    "@sentry/nextjs": "^9.28.0",
    "@types/dompurify": "^3.0.5",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.0.0",
    "convex": "^1.19.4",
    "date-fns": "^4.1.0",
    "dompurify": "^3.2.6",
    "lucide-react": "^0.477.0",
    "next": "15.2.0",
    "postcss": "^8.5.3",
    "react": "^19.0.0",
    "react-day-picker": "^8.10.1",
    "react-dom": "^19.0.0",
    "react-smooth": "^4.0.4",
    "recharts": "^2.15.1",
    "sonner": "^2.0.5",
    "tailwind-merge": "^3.0.2",
    "tailwindcss-animate": "^1.0.7",
    "web-vitals": "^5.0.2",
    "zustand": "^5.0.3"
  },
  "devDependencies": {
    "@eslint/eslintrc": "^3",
    "@tailwindcss/postcss": "^4.0.9",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "eslint": "^9",
    "eslint-config-next": "15.2.0",
    "tailwindcss": "^4.0.9",
    "typescript": "^5"
  }
}
</file>

<file path="convex/_generated/api.d.ts">
/* eslint-disable */
/**
 * Generated `api` utility.
 *
 * THIS CODE IS AUTOMATICALLY GENERATED.
 *
 * To regenerate, run `npx convex dev`.
 * @module
 */

import type {
  ApiFromModules,
  FilterApi,
  FunctionReference,
} from "convex/server";
import type * as agent_schema from "../agent_schema.js";
import type * as agent_types from "../agent_types.js";
import type * as agents_analytics from "../agents/analytics.js";
import type * as agents_financial from "../agents/financial.js";
import type * as agents_legal from "../agents/legal.js";
import type * as agents_manager from "../agents/manager.js";
import type * as agents_notifications from "../agents/notifications.js";
import type * as agents_secretary from "../agents/secretary.js";
import type * as analytics from "../analytics.js";
import type * as contracts from "../contracts.js";
import type * as enterprises from "../enterprises.js";
import type * as events from "../events.js";
import type * as notification_schema from "../notification_schema.js";
import type * as notifications from "../notifications.js";
import type * as onboarding from "../onboarding.js";
import type * as presence from "../presence.js";
import type * as realtime from "../realtime.js";
import type * as realtimeHelpers from "../realtimeHelpers.js";
import type * as search from "../search.js";
import type * as security_auditLogging from "../security/auditLogging.js";
import type * as security_monitoring from "../security/monitoring.js";
import type * as security_rateLimiting from "../security/rateLimiting.js";
import type * as security_rowLevelSecurity from "../security/rowLevelSecurity.js";
import type * as security_secureContractOperations from "../security/secureContractOperations.js";
import type * as security_secureWrapper from "../security/secureWrapper.js";
import type * as server from "../server.js";
import type * as types from "../types.js";
import type * as users from "../users.js";
import type * as vendors from "../vendors.js";

/**
 * A utility for referencing Convex functions in your app's API.
 *
 * Usage:
 * ```js
 * const myFunctionReference = api.myModule.myFunction;
 * ```
 */
declare const fullApi: ApiFromModules<{
  agent_schema: typeof agent_schema;
  agent_types: typeof agent_types;
  "agents/analytics": typeof agents_analytics;
  "agents/financial": typeof agents_financial;
  "agents/legal": typeof agents_legal;
  "agents/manager": typeof agents_manager;
  "agents/notifications": typeof agents_notifications;
  "agents/secretary": typeof agents_secretary;
  analytics: typeof analytics;
  contracts: typeof contracts;
  enterprises: typeof enterprises;
  events: typeof events;
  notification_schema: typeof notification_schema;
  notifications: typeof notifications;
  onboarding: typeof onboarding;
  presence: typeof presence;
  realtime: typeof realtime;
  realtimeHelpers: typeof realtimeHelpers;
  search: typeof search;
  "security/auditLogging": typeof security_auditLogging;
  "security/monitoring": typeof security_monitoring;
  "security/rateLimiting": typeof security_rateLimiting;
  "security/rowLevelSecurity": typeof security_rowLevelSecurity;
  "security/secureContractOperations": typeof security_secureContractOperations;
  "security/secureWrapper": typeof security_secureWrapper;
  server: typeof server;
  types: typeof types;
  users: typeof users;
  vendors: typeof vendors;
}>;
export declare const api: FilterApi<
  typeof fullApi,
  FunctionReference<any, "public">
>;
export declare const internal: FilterApi<
  typeof fullApi,
  FunctionReference<any, "internal">
>;
</file>

<file path="convex/schema.ts">
// convex/schema.ts
import { defineSchema, defineTable } from "convex/server";
import { v } from "convex/values";
import { agentTables } from "./agent_schema";
import { notificationTables } from "./notification_schema";
import { rateLimitTables } from "./security/rateLimiting";
import { auditTables } from "./security/auditLogging";

// ============================================================================
// OPTIONS / ENUMS
// ============================================================================

const contractStatusOptions = [
  "draft", "pending_analysis", "active", "expired", "terminated", "archived",
] as const;


const analysisStatusOptions = [
    "pending", "processing", "completed", "failed",
] as const;

const vendorCategoryOptions = [
  "technology",    // e.g., Software providers, IT services
  "marketing",     // e.g., Advertising agencies, SEO services
  "legal",         // e.g., Law firms, legal consultants
  "finance",       // e.g., Accounting firms, financial advisors
  "hr",            // e.g., Recruitment agencies, payroll services
  "facilities",    // e.g., Office supplies, maintenance services
  "logistics",     // e.g., Shipping companies, warehousing
  "manufacturing", // e.g., Component suppliers, OEMs
  "consulting",    // e.g., Management consultants, strategy advisors
  "other"          // For any categories not explicitly listed
] as const;

export type VendorCategory = typeof vendorCategoryOptions[number];

const contractTypeOptions = [
  "nda",             // Non-Disclosure Agreement
  "msa",             // Master Service Agreement
  "sow",             // Statement of Work
  "saas",            // Software as a Service Agreement
  "lease",           // Lease Agreement
  "employment",      // Employment Agreement
  "partnership",     // Partnership Agreement
  "other"            // For any types not explicitly listed
] as const;

export type ContractTypeEnum = typeof contractTypeOptions[number];

// User role options - Aligned with ROLE_PERMISSIONS.md
export const userRoleOptions = [
  "owner",   // Level 5
  "admin",   // Level 4
  "manager", // Level 3
  "user",    // Level 2
  "viewer",  // Level 1
] as const;

export type UserRole = typeof userRoleOptions[number];


// ============================================================================
// SCHEMA DEFINITION
// ============================================================================
export default defineSchema({
  // ===== ENTERPRISES =====
  enterprises: defineTable({
    name: v.string(),
    domain: v.optional(v.string()),
    industry: v.optional(v.string()),
    size: v.optional(v.union(
      v.literal("1-10"),
      v.literal("11-50"),
      v.literal("51-200"),
      v.literal("201-500"),
      v.literal("501-1000"),
      v.literal("1000+")
    )),
    contractVolume: v.optional(v.union(
      v.literal("low"),
      v.literal("medium"),
      v.literal("high"),
      v.literal("enterprise")
    )),
    primaryUseCase: v.optional(v.array(v.string())),
  })
    .index("by_name", ["name"])
    .index("by_domain", ["domain"]),

 // ===== USERS =====
 users: defineTable({
  clerkId: v.string(),
  email: v.string(),
  firstName: v.optional(v.string()),
  lastName: v.optional(v.string()),
  enterpriseId: v.id("enterprises"),
  role: v.union(...userRoleOptions.map(option => v.literal(option))),
  isActive: v.optional(v.boolean()),
  lastLoginAt: v.optional(v.string()),
  createdAt: v.string(),
  updatedAt: v.optional(v.string()),
  phoneNumber: v.optional(v.string()),
  department: v.optional(v.string()),
  title: v.optional(v.string()),
})
.index("by_clerkId", ["clerkId"])
.index("by_enterprise", ["enterpriseId"])
.index("by_email", ["email"]),

  // ===== VENDORS =====
  vendors: defineTable({
    enterpriseId: v.id("enterprises"),
    name: v.string(),
    contactEmail: v.optional(v.string()),
    contactPhone: v.optional(v.string()),
    address: v.optional(v.string()),
    notes: v.optional(v.string()),
    website: v.optional(v.string()),
    category: v.optional(
      v.union(
        ...vendorCategoryOptions.map(option => v.literal(option))
      )
    ),
    status: v.optional(v.union(v.literal("active"), v.literal("inactive"))),
    createdAt: v.string(),
  })
  // Basic indexes
  .index("by_name", ["name"])
  .index("by_enterprise", ["enterpriseId"])
  .index("by_category_and_enterpriseId", ["enterpriseId", "category"])
  // Performance-optimized indexes
  .index("by_enterprise_name_category", ["enterpriseId", "name", "category"])
  .index("by_enterprise_status_created", ["enterpriseId", "status"])
  .index("by_enterprise_category_status", ["enterpriseId", "category", "status"]),

  // ===== CONTRACTS =====
  contracts: defineTable({
    enterpriseId: v.id("enterprises"),
    vendorId: v.id("vendors"),
    title: v.string(),
    status: v.union(
        ...contractStatusOptions.map(option => v.literal(option))
    ),
    contractType: v.optional(
      v.union(
        ...contractTypeOptions.map(option => v.literal(option))
      )
    ),
    storageId: v.id("_storage"),
    fileName: v.string(),
    fileType: v.string(),
    // User-provided contract details
    value: v.optional(v.number()),
    startDate: v.optional(v.string()),
    endDate: v.optional(v.string()),
    // AI-extracted data
    extractedParties: v.optional(v.array(v.string())),
    extractedStartDate: v.optional(v.string()),
    extractedEndDate: v.optional(v.string()),
    extractedPaymentSchedule: v.optional(v.string()),
    extractedPricing: v.optional(v.string()),
    extractedScope: v.optional(v.string()),
    analysisStatus: v.optional(v.union(
        ...analysisStatusOptions.map(option => v.literal(option))
    )),
    analysisError: v.optional(v.string()),
    notes: v.optional(v.string()),
    createdAt: v.string(),
  })
  // Basic indexes
  .index("by_enterprise", ["enterpriseId"])
  .index("by_vendorId_and_enterpriseId", ["enterpriseId", "vendorId"])
  .index("by_status_and_enterpriseId", ["enterpriseId", "status"])
  .index("by_analysisStatus_and_enterpriseId", ["enterpriseId", "analysisStatus"])
  .index("by_contractType_and_enterpriseId", ["enterpriseId", "contractType"])
  // Performance-critical indexes for analytics and time-based queries
  .index("by_enterprise_status_endDate", ["enterpriseId", "status", "extractedEndDate"])
  .index("by_enterprise_vendor_status", ["enterpriseId", "vendorId", "status"])
  .index("by_enterprise_title_status", ["enterpriseId", "title", "status"])
  // Search optimization indexes
  .index("by_enterprise_fileName", ["enterpriseId", "fileName"])
  .index("by_enterprise_contractType_status", ["enterpriseId", "contractType", "status"]),

  invitations: defineTable({
    enterpriseId: v.id("enterprises"),
    email: v.string(),
    role: v.union(...userRoleOptions.map(r => v.literal(r))),
    invitedBy: v.id("users"),
    token: v.string(),
    expiresAt: v.string(),
    acceptedAt: v.optional(v.string()),
  })
  .index("by_email", ["email"])
  .index("by_token", ["token"])
  .index("by_enterprise", ["enterpriseId"]),

  // ======USER ONBOARDING=========
  userOnboarding: defineTable({
    userId: v.id("users"),
    enterpriseId: v.id("enterprises"),
    currentStep: v.string(),
    completedSteps: v.optional(v.array(v.string())),
    startedAt: v.string(),
    completedAt: v.optional(v.string()),
    skippedAt: v.optional(v.string()),
    skipReason: v.optional(v.string()),
    updatedAt: v.optional(v.string()),
    metadata: v.optional(v.any()),
  })
    .index("by_userId", ["userId"])
    .index("by_enterprise", ["enterpriseId"]),

  // ===== PRESENCE SYSTEM =====
  userPresence: defineTable({
    userId: v.id("users"),
    enterpriseId: v.id("enterprises"),
    lastSeen: v.string(),
    isOnline: v.boolean(),
    activity: v.optional(v.object({
      type: v.union(
        v.literal("viewing_contract"),
        v.literal("editing_contract"), 
        v.literal("viewing_vendor"),
        v.literal("dashboard"),
        v.literal("idle")
      ),
      resourceId: v.optional(v.string()),
      resourceTitle: v.optional(v.string()),
    })),
  })
    .index("by_user", ["userId"])
    .index("by_enterprise", ["enterpriseId"])
    .index("by_last_seen", ["lastSeen"]),

  // ===== REAL-TIME EVENTS =====
  realtimeEvents: defineTable({
    enterpriseId: v.id("enterprises"),
    userId: v.id("users"),
    eventType: v.union(
      v.literal("contract_updated"),
      v.literal("contract_created"),
      v.literal("contract_deleted"),
      v.literal("vendor_updated"),
      v.literal("vendor_created"),
      v.literal("analysis_completed"),
      v.literal("notification_created"),
      v.literal("user_joined"),
      v.literal("user_left"),
      v.literal("system_alert")
    ),
    resourceId: v.optional(v.string()),
    resourceType: v.optional(v.string()),
    data: v.optional(v.any()),
    targetUsers: v.optional(v.array(v.id("users"))),
    timestamp: v.string(),
    processed: v.boolean(),
  })
    .index("by_enterprise_timestamp", ["enterpriseId", "timestamp"])
    .index("by_user", ["userId"])
    .index("by_processed", ["processed"]),

  // ===== TYPING INDICATORS =====
  typingIndicators: defineTable({
    userId: v.id("users"),
    enterpriseId: v.id("enterprises"),
    resourceId: v.string(),
    resourceType: v.string(),
    field: v.optional(v.string()),
    lastTyped: v.string(),
  })
    .index("by_resource", ["resourceId", "resourceType"])
    .index("by_user_resource", ["userId", "resourceId", "resourceType"])
    .index("by_enterprise", ["enterpriseId"]),

  // ===== MONITORING & ANALYTICS =====
  analytics_events: defineTable({
    event: v.string(),
    timestamp: v.number(),
    url: v.string(),
    userId: v.optional(v.string()),
    properties: v.optional(v.any()),
    sessionId: v.string(),
    userAgent: v.optional(v.string()),
    ip: v.optional(v.string()),
    authenticatedUserId: v.optional(v.id("users")),
    enterpriseId: v.optional(v.id("enterprises")),
    serverTimestamp: v.number(),
    createdAt: v.string(),
  })
    .index("by_enterprise", ["enterpriseId"])
    .index("by_user", ["authenticatedUserId"])
    .index("by_event", ["event"])
    .index("by_timestamp", ["timestamp"])
    .index("by_session", ["sessionId"])
    .index("by_enterprise_event", ["enterpriseId", "event"])
    .index("by_enterprise_timestamp", ["enterpriseId", "timestamp"]),

  error_reports: defineTable({
    message: v.string(),
    stack: v.optional(v.string()),
    timestamp: v.number(),
    url: v.string(),
    userId: v.optional(v.string()),
    sessionId: v.string(),
    userAgent: v.string(),
    context: v.optional(v.any()),
    authenticatedUserId: v.optional(v.id("users")),
    enterpriseId: v.optional(v.id("enterprises")),
    serverTimestamp: v.number(),
    createdAt: v.string(),
  })
    .index("by_enterprise", ["enterpriseId"])
    .index("by_user", ["authenticatedUserId"])
    .index("by_timestamp", ["timestamp"])
    .index("by_session", ["sessionId"])
    .index("by_enterprise_timestamp", ["enterpriseId", "timestamp"]),

  health_checks: defineTable({
    timestamp: v.number(),
    status: v.string(),
    createdAt: v.string(),
  })
    .index("by_timestamp", ["timestamp"]),

  ...agentTables,
  ...notificationTables,
  ...rateLimitTables,
  ...auditTables
});
</file>

</files>
