// convex/memory/memoryIntegration.ts
import { v } from "convex/values";
import { mutation, query, internalMutation } from "./_generated/server";
import { api, internal } from "./_generated/api";
import { Doc, Id } from "./_generated/dataModel";

// Type definitions
type MemoryType = "user_preference" | "interaction_pattern" | "domain_knowledge" | 
  "conversation_context" | "task_history" | "feedback" | "entity_relation" | "process_knowledge";

// Helper function to store memory that avoids type depth issues
async function storeMemoryHelper(
  ctx: any,
  args: {
    sessionId: string;
    memoryType: string;
    content: string;
    structuredData: any;
    context: any;
    importance: string;
    confidence: number;
    source: string;
  }
) {  
  //@ts-ignore
  await ctx.runMutation(api.memoryShortTerm.store, args);
}

type ShortTermMemory = Doc<"shortTermMemory">;
type LongTermMemory = Doc<"longTermMemory">;

type MemoryResult = {
  shortTerm: ShortTermMemory[];
  longTerm: LongTermMemory[];
};

// ============================================================================
// MEMORY INTEGRATION WITH MANAGER AGENT
// ============================================================================

// Store agent task context in memory
export const storeTaskContext = mutation({
  args: {
    taskId: v.id("agentTasks"),
    sessionId: v.string(),
    context: v.object({
      taskType: v.string(),
      status: v.string(),
      priority: v.string(),
      agentType: v.string(),
      result: v.optional(v.any()),
      error: v.optional(v.string()),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (!user) throw new Error("User not found");

    const task = await ctx.db.get(args.taskId);
    if (!task) throw new Error("Task not found");

    // Store task execution context
    const memoryContent = `Task ${task.taskType} executed by ${args.context.agentType} agent with ${args.context.status} status. Priority: ${args.context.priority}.`;
    
    const structuredData = {
      taskType: task.taskType,
      status: args.context.status,
      priority: args.context.priority,
      agentType: args.context.agentType,
      result: args.context.result,
      error: args.context.error,
    };

    // Determine importance based on task outcome
    let importance: "critical" | "high" | "medium" | "low" | "temporary" = "medium";
    if (args.context.error) {
      importance = "high";
    } else if (args.context.priority === "critical") {
      importance = "critical";
    } else if (args.context.status === "completed") {
      importance = "low";
    }

    // Store in short-term memory using helper to avoid type depth issues
    await storeMemoryHelper(ctx, {
      sessionId: args.sessionId,
      memoryType: "task_history",
      content: memoryContent,
      structuredData,
      context: {
        taskId: args.taskId,
        agentId: args.context.agentType,
      },
      importance,
      confidence: 1.0,
      source: "task_outcome",
    });
  },
});

// Store agent insights in memory
export const storeInsightMemory = mutation({
  args: {
    insightId: v.id("agentInsights"),
    sessionId: v.string(),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (!user) throw new Error("User not found");

    const insight = await ctx.db.get(args.insightId);
    if (!insight) throw new Error("Insight not found");

    const agent = await ctx.db.get(insight.agentId);
    const agentName = agent?.name || "Unknown Agent";

    // Create memory content from insight
    const memoryContent = `${insight.title}: ${insight.description}. Generated by ${agentName}.`;
    
    const structuredData = {
      insightType: insight.type,
      priority: insight.priority,
      actionRequired: insight.actionRequired,
      data: insight.data,
      agentType: agent?.type,
    };

    // Map insight priority to memory importance
    const importanceMap = {
      critical: "critical",
      high: "high",
      medium: "medium",
      low: "low",
    } as const;

    const importance = importanceMap[insight.priority as keyof typeof importanceMap] || "medium";

    // Store in short-term memory
    const relatedEntities: Array<{type: string; id: string; name?: string}> = [];
    if (insight.contractId) {
      relatedEntities.push({ type: "contract", id: insight.contractId as string });
    }
    if (insight.vendorId) {
      relatedEntities.push({ type: "vendor", id: insight.vendorId as string });
    }
    
    await storeMemoryHelper(ctx, {
      sessionId: args.sessionId,
      memoryType: "domain_knowledge",
      content: memoryContent,
      structuredData,
      context: {
        agentId: agentName,
        relatedEntities,
      },
      importance,
      confidence: 0.9,
      source: "system_observation",
    });

    // If critical or high priority, also store in long-term memory
    if (importance === "critical" || importance === "high") {
      await ctx.runMutation(api.memoryLongTerm.store, {
        memoryType: "domain_knowledge",
        content: memoryContent,
        structuredData,
        summary: insight.title,
        keywords: extractKeywordsFromInsight(insight),
        context: {
          domain: mapInsightTypeToDomain(insight.type),
          tags: [insight.type, agentName, insight.priority],
        },
        importance,
        confidence: 0.9,
        source: "system_observation",
      });
    }
  },
});

// Get relevant memories for agent decision making
export const getRelevantMemoriesForAgent = query({
  args: {
    agentType: v.string(),
    taskType: v.optional(v.string()),
    entityId: v.optional(v.string()),
    entityType: v.optional(v.string()),
    limit: v.optional(v.number()),
  },
  handler: async (ctx, args): Promise<MemoryResult> => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return { shortTerm: [], longTerm: [] };

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (!user) return { shortTerm: [], longTerm: [] };

    // Get relevant memory types for the agent
    const relevantMemoryTypes = getRelevantMemoryTypesForAgent(args.agentType);

    // Get recent short-term memories
    const shortTermMemories: ShortTermMemory[] = await ctx.runQuery(
      api.memoryShortTerm.getRecentMemories,
      {
        memoryTypes: relevantMemoryTypes,
        limit: args.limit || 20,
        minImportance: "low",
      }
    );

    // Get relevant long-term memories
    const longTermMemories: LongTermMemory[] = await ctx.runQuery(
      api.memoryLongTerm.getMemories,
      {
        memoryTypes: relevantMemoryTypes,
        minImportance: "medium",
        minStrength: 0.5,
        limit: args.limit || 10,
      }
    );

    // Filter by entity if provided
    let filteredShortTerm: ShortTermMemory[] = shortTermMemories;
    let filteredLongTerm: LongTermMemory[] = longTermMemories;

    if (args.entityId && args.entityType) {
      filteredShortTerm = shortTermMemories.filter((m: ShortTermMemory) => {
        const entities = m.context.relatedEntities || [];
        return entities.some((e: any) => e.id === args.entityId && e.type === args.entityType);
      });

      filteredLongTerm = longTermMemories.filter((m: LongTermMemory) => {
        if (args.entityType === "contract" && m.context.contractIds?.includes(args.entityId as Id<"contracts">)) {
          return true;
        }
        if (args.entityType === "vendor" && m.context.vendorIds?.includes(args.entityId as Id<"vendors">)) {
          return true;
        }
        return false;
      });
    }

    return {
      shortTerm: filteredShortTerm,
      longTerm: filteredLongTerm,
    };
  },
});

// Store user interaction patterns
export const storeInteractionPattern = mutation({
  args: {
    sessionId: v.string(),
    action: v.string(),
    entityType: v.string(),
    entityId: v.string(),
    metadata: v.optional(v.any()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (!user) throw new Error("User not found");

    const content = `User performed ${args.action} on ${args.entityType} (${args.entityId})`;
    
    await storeMemoryHelper(ctx, {
      sessionId: args.sessionId,
      memoryType: "interaction_pattern",
      content,
      structuredData: {
        action: args.action,
        entityType: args.entityType,
        entityId: args.entityId,
        timestamp: new Date().toISOString(),
        metadata: args.metadata,
      },
      context: {
        relatedEntities: [{
          type: args.entityType,
          id: args.entityId,
        }],
      },
      importance: "low",
      confidence: 1.0,
      source: "implicit_learning",
    });
  },
});

// Store user feedback
export const storeUserFeedback = mutation({
  args: {
    sessionId: v.string(),
    feedbackType: v.union(
      v.literal("positive"),
      v.literal("negative"),
      v.literal("correction"),
      v.literal("preference")
    ),
    content: v.string(),
    relatedEntityId: v.optional(v.string()),
    relatedEntityType: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) throw new Error("Not authenticated");

    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", identity.subject))
      .first();
    
    if (!user) throw new Error("User not found");

    const importance = args.feedbackType === "correction" ? "high" : 
                      args.feedbackType === "preference" ? "high" : "medium";

    // Store in short-term memory
    await storeMemoryHelper(ctx, {
      sessionId: args.sessionId,
      memoryType: "feedback",
      content: args.content,
      structuredData: {
        feedbackType: args.feedbackType,
        timestamp: new Date().toISOString(),
      },
      context: {
        relatedEntities: args.relatedEntityId && args.relatedEntityType ? [{
          type: args.relatedEntityType,
          id: args.relatedEntityId,
        }] : undefined,
      },
      importance,
      confidence: 1.0,
      source: "explicit_feedback",
    });

    // Store preferences and corrections in long-term memory
    if (args.feedbackType === "preference" || args.feedbackType === "correction") {
      await ctx.runMutation(api.memoryLongTerm.store, {
        memoryType: args.feedbackType === "preference" ? "user_preference" : "feedback",
        content: args.content,
        summary: `User ${args.feedbackType}: ${args.content.substring(0, 100)}`,
        keywords: extractKeywords(args.content),
        context: {
          tags: [args.feedbackType, "user_feedback"],
        },
        importance,
        confidence: 1.0,
        source: "explicit_feedback",
      });
    }
  },
});

// Enhanced manager agent decision with memory context
export const makeInformedDecision = query({
  args: {
    sessionId: v.string(),
    decisionContext: v.object({
      taskType: v.string(),
      entityType: v.optional(v.string()),
      entityId: v.optional(v.string()),
      currentState: v.any(),
    }),
  },
  handler: async (ctx, args) => {
    const identity = await ctx.auth.getUserIdentity();
    if (!identity) return null;

    // Get relevant memories
    const queryArgs: any = {
      agentType: "manager",
      taskType: args.decisionContext.taskType,
    };
    if (args.decisionContext.entityId !== undefined) {
      queryArgs.entityId = args.decisionContext.entityId;
    }
    if (args.decisionContext.entityType !== undefined) {
      queryArgs.entityType = args.decisionContext.entityType;
    }
    
    const memories = await ctx.runQuery(
      api.memoryIntegration.getRelevantMemoriesForAgent,
      queryArgs
    );

    // Get user preferences
    const preferences = await ctx.runQuery(
      api.memoryLongTerm.getMemories,
      {
        memoryTypes: ["user_preference"],
        minImportance: "medium",
        limit: 10,
      }
    );

    // Get recent task outcomes
    const taskHistory = memories.shortTerm.filter((m: ShortTermMemory) => 
      m.memoryType === "task_history" && 
      m.structuredData?.taskType === args.decisionContext.taskType
    );

    // Analyze patterns and make recommendations
    const recommendations = analyzeMemoriesForDecision(
      memories,
      preferences,
      taskHistory,
      args.decisionContext
    );

    return recommendations;
  },
});

// Helper functions
function getRelevantMemoryTypesForAgent(agentType: string): Array<
  "user_preference" | "interaction_pattern" | "domain_knowledge" | 
  "conversation_context" | "task_history" | "feedback" | 
  "entity_relation" | "process_knowledge"
> {
  const agentMemoryMap: Record<string, Array<
    "user_preference" | "interaction_pattern" | "domain_knowledge" | 
    "conversation_context" | "task_history" | "feedback" | 
    "entity_relation" | "process_knowledge"
  >> = {
    manager: ["task_history", "process_knowledge", "user_preference", "feedback"],
    financial: ["domain_knowledge", "entity_relation", "task_history"],
    legal: ["domain_knowledge", "entity_relation", "process_knowledge"],
    secretary: ["interaction_pattern", "user_preference", "task_history"],
    analytics: ["domain_knowledge", "interaction_pattern", "entity_relation"],
    notifications: ["user_preference", "feedback", "interaction_pattern"],
    chat: ["user_preference", "conversation_context", "feedback", "domain_knowledge", "interaction_pattern"],
    vendor: ["entity_relation", "domain_knowledge", "feedback"],
  };

  return agentMemoryMap[agentType] || ["domain_knowledge", "task_history"];
}

function mapInsightTypeToDomain(insightType: string): string {
  const domainMap: Record<string, string> = {
    contract_analysis: "contract_management",
    financial_risk: "financial_analysis",
    expiration_warning: "contract_lifecycle",
    legal_review: "legal_compliance",
    compliance_alert: "regulatory_compliance",
    performance_metric: "performance_management",
    cost_optimization: "financial_optimization",
    vendor_risk: "vendor_management",
    renewal_opportunity: "contract_lifecycle",
    negotiation_insight: "contract_negotiation",
    audit_finding: "audit_compliance",
    anomaly_detection: "risk_management",
    trend_analysis: "analytics",
    recommendation: "general",
    alert: "system",
    report: "reporting",
  };

  return domainMap[insightType] || "general";
}

function extractKeywordsFromInsight(insight: Doc<"agentInsights">): string[] {
  const text = `${insight.title} ${insight.description}`;
  return extractKeywords(text);
}

function extractKeywords(text: string): string[] {
  const stopWords = new Set([
    'the', 'a', 'an', 'and', 'or', 'but', 'in', 'on', 'at', 'to', 'for',
    'of', 'with', 'by', 'from', 'as', 'is', 'was', 'are', 'were'
  ]);
  
  const words = text.toLowerCase()
    .split(/\s+/)
    .filter(word => word.length > 3 && !stopWords.has(word));
  
  const wordFreq = new Map<string, number>();
  words.forEach(word => {
    wordFreq.set(word, (wordFreq.get(word) || 0) + 1);
  });
  
  return Array.from(wordFreq.entries())
    .sort((a, b) => b[1] - a[1])
    .slice(0, 10)
    .map(([word]) => word);
}

function analyzeMemoriesForDecision(
  memories: {
    shortTerm: Doc<"shortTermMemory">[];
    longTerm: Doc<"longTermMemory">[];
  },
  preferences: Doc<"longTermMemory">[],
  taskHistory: Doc<"shortTermMemory">[],
  context: any
): {
  recommendations: string[];
  confidence: number;
  reasoning: string[];
  relevantMemories: Array<{ type: string; content: string; importance: string }>;
} {
  const recommendations: string[] = [];
  const reasoning: string[] = [];
  const relevantMemories: Array<{ type: string; content: string; importance: string }> = [];

  // Analyze user preferences
  preferences.forEach(pref => {
    relevantMemories.push({
      type: "preference",
      content: pref.content,
      importance: pref.importance,
    });
    reasoning.push(`User preference: ${pref.summary || pref.content}`);
  });

  // Analyze task history for patterns
  const successfulTasks = taskHistory.filter(t => 
    t.structuredData?.status === "completed" && !t.structuredData?.error
  );
  const failedTasks = taskHistory.filter(t => 
    t.structuredData?.error || t.structuredData?.status === "failed"
  );

  if (successfulTasks.length > 0) {
    reasoning.push(`Found ${successfulTasks.length} successful similar tasks`);
  }
  if (failedTasks.length > 0) {
    reasoning.push(`Found ${failedTasks.length} failed similar tasks to avoid`);
    failedTasks.forEach(task => {
      if (task.structuredData?.error) {
        recommendations.push(`Avoid: ${task.structuredData.error}`);
      }
    });
  }

  // Calculate confidence based on available memories
  const totalRelevantMemories = memories.shortTerm.length + memories.longTerm.length;
  const confidence = Math.min(1, totalRelevantMemories / 20);

  // Add domain knowledge
  memories.longTerm.forEach(mem => {
    if (mem.memoryType === "domain_knowledge" && mem.strength > 0.7) {
      relevantMemories.push({
        type: "knowledge",
        content: mem.content,
        importance: mem.importance,
      });
    }
  });

  return {
    recommendations,
    confidence,
    reasoning,
    relevantMemories: relevantMemories.slice(0, 10),
  };
}